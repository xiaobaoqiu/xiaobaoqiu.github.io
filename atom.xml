<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[xiaobaoqiu Blog]]></title>
  <link href="http://xiaobaoqiu.github.io/atom.xml" rel="self"/>
  <link href="http://xiaobaoqiu.github.io/"/>
  <updated>2015-09-12T19:32:11+08:00</updated>
  <id>http://xiaobaoqiu.github.io/</id>
  <author>
    <name><![CDATA[xiaobaoqiu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Lunece整体架构]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/09/09/lunecezheng-ti-jia-gou/"/>
    <updated>2015-09-09T22:19:51+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/09/09/lunecezheng-ti-jia-gou</id>
    <content type="html"><![CDATA[<p>根据上篇文章,我们大致知道Lucene创建索引和搜索的一个过程:</p>

<p><img src="http://xiaobaoqiu.github.io/images/lucene/Lucene_index_and_search.jpg"></p>

<p>这里主要分析一下Lucene的代码结构,包括理由Lucene API实现一个简单建立索引和搜索的小例子.</p>

<p>由于我们的服务器上crate是基于Lucene 4.10.3版本.所以我这里采用的Lucene版本也是4.10版本,小版本是4.10.4,是Lucene 4的最后一个版本,大约2014年9月推出,还比较新鲜.目前已经到了5.3版本.</p>

<h2>1. 源码结构</h2>

<p>首先看一下Lucene的源码结构,Lucene-core主要代码包结构如下:</p>

<p><img src="http://xiaobaoqiu.github.io/images/lucene/Lucene_source_struct.png"></p>

<p>每个包下面都有package.html文件介绍包的作用.各个包的作用如下:</p>

<pre><code>1.analysis
分词模块,包含将文本转化为可索引化/可搜索化的词元(convert text into indexable/searchable tokens)的API和实现.包括org.apache.lucene.analysis.Analyzer和其相关类.
2.codecs
包含自定义底层索引的编码和索引结构的模块,还包括索引的压缩,索引版本管理等.
3.document
定义了被索引和搜索内容的用户层面的逻辑定义,就是我们熟悉的Document,各种类型的Filed及其属性定义等.同事也提供了一下org.apache.lucene.document.Document和org.apache.lucene.index.IndexableField相关的工具类.
4.index
包含了索引维护(创建,更新,删除)和访问(读)的逻辑.包括我们熟悉的IndexReader,IndexWriter等.
5.search
索引的搜索.包括相似度的定义(similarities包),权重计算,文档评分计算,布尔模型,搜索结果搜集等逻辑.
6.store
索引底层二进制数据的读写,包括索引文件的Buffered的流的实现等,还包括一些限流策略的实现(RateLimiter)等.
7.util
工具类,如排序器,数学工具类,优先级队列等工具的实现等.
</code></pre>

<p>包基本上和本文开头的图对应起来,其中的QueryParser再Lucene4中是一个单独的jar包:</p>

<p><img src="http://xiaobaoqiu.github.io/images/lucene/Lucene_code_package_usage.jpg"></p>

<h2>2. 主要类</h2>

<p>首先上一个Lucene的简单的Demo,基本上是参考官网提供的Demo,自己手动修改了点,作用就是索引一个目录下的文本文件,在此基础上提供搜索服务.其中Indexer用于创建索引,Searcher作为搜索入口,接受用户输入的Query词并执行搜索.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> * 创建索引
</span><span class='line'> *
</span><span class='line'> * @author: xiaobaoqiu  Date: 15-9-8 Time: 下午4:04
</span><span class='line'> */
</span><span class='line'>public final class Indexer {
</span><span class='line'>
</span><span class='line'>    public static void main(String[] args) {
</span><span class='line'>        indexDocs(CommonConfig.SOURCE_FILE_DIR, CommonConfig.INDEX_FILE_DIR, true);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 构建磁盘索引
</span><span class='line'>     *
</span><span class='line'>     * @param dirPath 原始文件
</span><span class='line'>     * @param indexPath 索引文件存放路径
</span><span class='line'>     * @param create    创建or更新
</span><span class='line'>     */
</span><span class='line'>    public static void indexDocs(String dirPath, String indexPath, boolean create) {
</span><span class='line'>        try {
</span><span class='line'>            Directory dir = FSDirectory.open(new File(indexPath));
</span><span class='line'>            Analyzer analyzer = new StandardAnalyzer(Version.LUCENE_4_10_0);
</span><span class='line'>            IndexWriterConfig iwc = new IndexWriterConfig(Version.LUCENE_4_10_0, analyzer);
</span><span class='line'>
</span><span class='line'>            if (create) {
</span><span class='line'>                iwc.setOpenMode(IndexWriterConfig.OpenMode.CREATE);
</span><span class='line'>            } else {
</span><span class='line'>                iwc.setOpenMode(IndexWriterConfig.OpenMode.CREATE_OR_APPEND);
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>            IndexWriter writer = new IndexWriter(dir, iwc);
</span><span class='line'>            doIndexDocs(writer, new File(dirPath));
</span><span class='line'>
</span><span class='line'>            System.out.println("Build index finished...");
</span><span class='line'>            writer.close();
</span><span class='line'>        }catch (IOException ioe) {
</span><span class='line'>            //do something...
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    static void doIndexDocs(IndexWriter writer, File file) throws IOException {
</span><span class='line'>        if (!file.canRead()) {
</span><span class='line'>            System.out.println("文件不可读:" + file.getAbsolutePath());
</span><span class='line'>            return;
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        //文件夹则索引文件夹下的索引文件
</span><span class='line'>        if (file.isDirectory()) {
</span><span class='line'>            String[] files = file.list();
</span><span class='line'>            if (files != null) {
</span><span class='line'>                for (int i = 0; i &lt; files.length; i++) {
</span><span class='line'>                    doIndexDocs(writer, new File(file, files[i]));
</span><span class='line'>                }
</span><span class='line'>            }
</span><span class='line'>        } else {
</span><span class='line'>            doIndexFile(writer, file);
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 索引一个文件
</span><span class='line'>     *
</span><span class='line'>     * @param writer
</span><span class='line'>     * @param file
</span><span class='line'>     */
</span><span class='line'>    private static void doIndexFile(IndexWriter writer, File file) throws IOException{
</span><span class='line'>        //单个文件
</span><span class='line'>        FileInputStream fis;
</span><span class='line'>        try {
</span><span class='line'>            fis = new FileInputStream(file);
</span><span class='line'>        } catch (FileNotFoundException fnfe) {
</span><span class='line'>            //do nothing
</span><span class='line'>            return;
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        try {
</span><span class='line'>            // 创建一个新的空的Document
</span><span class='line'>            Document doc = new Document();
</span><span class='line'>
</span><span class='line'>            //文件路径字段
</span><span class='line'>            doc.add(new StringField(CommonConfig.PATH_FIELD_NAME, file.getPath(), Field.Store.YES));
</span><span class='line'>            //文件最后修改时间字段
</span><span class='line'>            doc.add(new LongField(CommonConfig.MODIFIED_FIELD_NAME, file.lastModified(), Field.Store.NO));
</span><span class='line'>            //文件内容,不存储原始串
</span><span class='line'>            doc.add(new TextField(CommonConfig.CONTENTS_FIELD_NAME, new BufferedReader(new InputStreamReader(fis, StandardCharsets.UTF_8))));
</span><span class='line'>
</span><span class='line'>            //新建索引 or 更新索引
</span><span class='line'>            if (writer.getConfig().getOpenMode() == IndexWriterConfig.OpenMode.CREATE) {
</span><span class='line'>                writer.addDocument(doc);
</span><span class='line'>            } else {
</span><span class='line'>                writer.updateDocument(new Term("path", file.getPath()), doc);
</span><span class='line'>            }
</span><span class='line'>        } finally {
</span><span class='line'>            fis.close();
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/**
</span><span class='line'> * 查询索引
</span><span class='line'> * 接受用户输入作为Query词
</span><span class='line'> *
</span><span class='line'> * @author: xiaobaoqiu  Date: 15-9-8 Time: 下午4:09
</span><span class='line'> */
</span><span class='line'>public final class Searcher {
</span><span class='line'>
</span><span class='line'>    public static void main(String[] args) throws Exception {
</span><span class='line'>        search(CommonConfig.INDEX_FILE_DIR, CommonConfig.CONTENTS_FIELD_NAME);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public static void search(String indexPath, String field) throws Exception {
</span><span class='line'>        IndexReader reader = DirectoryReader.open(FSDirectory.open(new File(indexPath)));
</span><span class='line'>        IndexSearcher searcher = new IndexSearcher(reader);
</span><span class='line'>        Analyzer analyzer = new StandardAnalyzer(Version.LUCENE_4_10_0);
</span><span class='line'>        QueryParser parser = new QueryParser(Version.LUCENE_4_10_0, field, analyzer);
</span><span class='line'>
</span><span class='line'>        //接受用户输入
</span><span class='line'>        BufferedReader in = new BufferedReader(new InputStreamReader(System.in, StandardCharsets.UTF_8));
</span><span class='line'>        String queryString = null;
</span><span class='line'>        while (StringUtils.isNotEmpty(queryString = in.readLine())) {
</span><span class='line'>            Query query = parser.parse(queryString.trim());
</span><span class='line'>
</span><span class='line'>            doSearch(searcher, query);
</span><span class='line'>        }
</span><span class='line'>        reader.close();
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public static void doSearch(IndexSearcher searcher, Query query) throws IOException {
</span><span class='line'>        // 搜索 CommonConfig.SEARCH_MAX_ITEM_COUNT 个数据
</span><span class='line'>        TopDocs results = searcher.search(query, CommonConfig.SEARCH_MAX_ITEM_COUNT);
</span><span class='line'>        ScoreDoc[] hits = results.scoreDocs;
</span><span class='line'>        int numTotalHits = results.totalHits;
</span><span class='line'>        System.out.println(numTotalHits + " total matching documents");
</span><span class='line'>
</span><span class='line'>        if (ArrayUtils.isEmpty(hits)) return;
</span><span class='line'>
</span><span class='line'>        for (ScoreDoc hit : hits) {
</span><span class='line'>            System.out.println();
</span><span class='line'>            Document hitDoc = searcher.doc(hit.doc);
</span><span class='line'>            System.out.println(CommonConfig.PATH_FIELD_NAME + " = " + hitDoc.get(CommonConfig.PATH_FIELD_NAME) +
</span><span class='line'>                    "\n" + CommonConfig.MODIFIED_FIELD_NAME + " = " + hitDoc.get(CommonConfig.MODIFIED_FIELD_NAME) +
</span><span class='line'>                    "\n" + CommonConfig.CONTENTS_FIELD_NAME + " = " + hitDoc.get(CommonConfig.CONTENTS_FIELD_NAME));
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>输入的文件及生成的索引:</p>

<p><img src="http://xiaobaoqiu.github.io/images/lucene/Lucene_demo_input_output.png"></p>

<p>建立索引的基本过程如下:</p>

<pre><code>1.FSDirectory定义索引文件存放目录
2.选择分词使用的Analyzer.
3.选择索引文件版本信息Version,将其和Analyzer组成IndexWriterConfig.
4.利用IndexWriterConfig生成一个IndexWriter,用于索引文件的变更;
5.根据原始文件生成一些列的Document,每个文档中包含多个Field,设置每个Field是否分词,释放存储等属性;
6.使用IndexWriter将文档写入索引文件.
</code></pre>

<p>搜索的基本过程如下:</p>

<pre><code>1.根据索引文件的目录生成一个IndexReader,将索引文件读到内存中.
2.生成一个IndexSearcher用于搜索;
3.选择一个分词器;
4.定义用户输入Query的解析器QueryParser;
5.接受用户输入,执行搜索过程,得到搜索结果用TopDocs表示,其中包含了命中文档的数目以及命中文档的id集合;
6.根据文档id获取对应的文档,从文档中获取各个Field信息;
</code></pre>

<h4>2.1 主要类</h4>

<p>首先介绍一下其中涉及到的主要的类:</p>

<ul>
<li>FSDirectory</li>
<li>Analyzer,StandardAnalyzer</li>
<li>Version</li>
<li>IndexWriterConfig</li>
<li>IndexWriter</li>
<li>Document</li>
<li>StringField,LongField,TextField</li>
<li>IndexReader,DirectoryReader</li>
<li>IndexSearcher</li>
<li>QueryParser</li>
<li>Query</li>
<li>TopDocs</li>
<li>ScoreDoc</li>
</ul>


<h2>3. 建立索引流程</h2>

<h2>4. 搜索流程</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lucene入门]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/09/03/luceneru-men/"/>
    <updated>2015-09-03T14:13:54+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/09/03/luceneru-men</id>
    <content type="html"><![CDATA[<p>Crate再项目中扮演越来越重要的角色.但是很多时候我对Crate,包括其下层的ElasticSearch以及Lucene都是一知半解,甚至可以说是完全不懂.因为没看过源代码.所以这段时间会集中学习一下Lucene和ElasticSearch的源码.</p>

<p>从Lucene开始.会包含以下内容:</p>

<pre><code>1.Lucene简介;
2.Lunece整体架构;
3.Lucene的存储;
4.Lucene的搜索;
5.Lucene其他功能,如高亮等;
</code></pre>

<p>这里从Lucene简介开始.第一次使用Lucene已经是两年前入职的时候,写了个简单的爬虫,抓取999网的疾病信息并提供一个简单的搜索入口.这里主要弄懂以下几个问题:</p>

<pre><code>1.信息检索
2.Lucene是什么;
3.Lucene建立索引的大致过程;
4.Lucene搜索的大致过程;
</code></pre>

<p>Lucene官网: <a href="http://lucene.apache.org/">http://lucene.apache.org/</a></p>

<p>在Lucene基础上衍生出很多搜索框架,下面是这些框架的对比:<a href="http://stackoverflow.com/questions/2271600/elasticsearch-sphinx-lucene-solr-xapian-which-fits-for-which-usage">http://stackoverflow.com/questions/2271600/elasticsearch-sphinx-lucene-solr-xapian-which-fits-for-which-usage</a></p>

<h2>1.信息检索</h2>

<p>信息检索简单讲就是从一堆数据中找到你需要的数据,数据的来源可能是文本或者网络,甚至别人说的话或者声波等等.比如:</p>

<ul>
<li>从一个Excel表格中找到你的名字;</li>
<li>从学生成绩标表中找到不及格的学生;</li>
<li>从图书馆里面找Java编程相关的书籍;</li>
<li>从网络搜索Lucene相关知识;</li>
<li>老师点名时候喊到;</li>
</ul>


<p>人类信息检索也是一个不断发展的过程,下面这个例子简单的诠释了信息检索的改善过程:</p>

<ol>
<li>一个书生想从书屋(假设1000本书)里找一本书他能做的就是,从第一本书开始一本一本的往后找,直到找到他要的那本书.如果很不幸,书屋里面每这本书,那么他就必须翻遍所以的书,很可能他找一遍需要10个小时;</li>
<li>经历过几次这样痛苦的找书经历之后,书生开始想招了,将书分类(假设10个分类),文学类在第一个书架子,史学类再第二个书架子&hellip;从此以后,他找书比以前方便多了.找一本书最多只需要翻一个架子,时间缩短到1个小时;但是带来的成本是:必须将书正确的放在其正确的架子上;</li>
<li>每次翻遍一个架子,书生觉得还是比较麻烦,于是他给每本书加了一个编号,将书按照编号排列好,并将所以的书名和编号的对应关系记录到一个单独的册子上.下次他找书只需要在册子上找就可以了(只需要看册子上的1000个书名),找到书名对应的编号,然后就能快速的找到书,时间只需要10分钟.成本是书必须按照需要排列;</li>
<li>10分钟还是有点长,书生于是决定再改善,结合2和3的改进措施.书按照各种类型放在不同的架子,每个架子的书单独编号,比如文学1,文学2&hellip;.册子上也按照书种类进行分开登记.这样找一本书只需要看一个分类下的书名(100个),只需要1分钟.</li>
</ol>


<p>我们生活中的数据分为:结构化数据和非结构化数据.结构化数据指具有固定格式或有限长度的数据,如数据库或者Excel表等.非结构化数据指不定长或无固定格式的数据,如邮件,word文档等.</p>

<p>计算机的产生对信息检索产生了质的变化,帮我们做了很多简单却耗时的工作.在计算机检索的世界里面我们已知了很多技术:</p>

<pre><code>1.对链表的搜索,我们采用从头到位逐项比较,O(N)的时间复杂度;
2.对于有序数组,我们可以采用二分搜索(其实就是二叉树,通常称之为二叉查找树),能够达到O(logN),底数是2;
3.多叉数的查找比二叉树更快,参考Tire树,B树等数据结构,O(logN),底数大于2;
4.Hash表的查找理论上是O(1)的时间复杂度;
</code></pre>

<p>除了顺序查找,其他几种检索都非常的快,但是这种快都是有维护成本的,比如二分搜索需要保证数据有序,因此新来的数据的插入成本会很高,包括删除数据的成本也会很高.但是其带来的检索效率的提升是非常大的.针对结构化数据,我们往往很简单的实现数据的快速搜索,比如数据库就是使用B树来达到快速搜索的目的.</p>

<p>但是现实中99%以上的原始数据都是混乱无须的非结构化数据.当数据量很大的时候,检索成为一个极其困难的问题(量变导致质变),即使对于计算很快的计算机而言.比如一个简单的字符串查找,假设在1页书的内容(约1000字)中查找一个单词可能需要1毫秒,那么在一本书的内容中(约50W词)中查找一个名字可能需要0.5秒,在1W本书(约50亿个单词)中查找这个单词需要5000秒,也就是接近1个半小时;假设每分钟要找一次呢?不敢想象.</p>

<p>在当今网络及其发达的今天,已经很多的公司的数据量超过了1W本书的信息量.这时候无序信息的全文检索显得极其重要.因此也催生了诸如Google,Yahoo和Baidu这些搜索巨头.</p>

<p>索引是全文搜索的基础,也是现代搜索引擎的核心,建立索引的过程就是把源数据处理成非常方便查询的索引文件的过程.你可以把索引想象成这样一种数据结构,他能够使你快速的随机访问存储在索引中的关键词,进而找到该关键词所关联的文档.</p>

<p>还是以书的例子来说,假设书前三页的内容:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//page1:
</span><span class='line'>如何使用Lucene完善搜索
</span><span class='line'>
</span><span class='line'>//page2
</span><span class='line'>Lucene数据如何存储
</span><span class='line'>
</span><span class='line'>//page3
</span><span class='line'>Lucene如何实现搜索
</span><span class='line'>
</span><span class='line'>//page4
</span><span class='line'>作者:肖宝秋</span></code></pre></td></tr></table></div></figure>


<p>我们首先使用分词软件见这四页的内容分词,得到以下结果:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//page1:
</span><span class='line'>如何, 使用, Lucene, 完善, 搜索
</span><span class='line'>
</span><span class='line'>//page2
</span><span class='line'>Lucene, 数据, 如何, 存储
</span><span class='line'>
</span><span class='line'>//page3
</span><span class='line'>Lucene, 如何, 实现, 搜索
</span><span class='line'>作者, 肖宝秋</span></code></pre></td></tr></table></div></figure>


<p>建立词&ndash;>文档的映射关系:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>如何 --&gt; page1, page2, page3
</span><span class='line'>使用 --&gt; page1
</span><span class='line'>Lucene --&gt; page1, page2, page3
</span><span class='line'>完善 --&gt; page1
</span><span class='line'>搜索 --&gt; page1, page3
</span><span class='line'>数据 --&gt; page2
</span><span class='line'>存储 --&gt; page2
</span><span class='line'>实现 --&gt; page3
</span><span class='line'>作者 --&gt; page4
</span><span class='line'>肖宝秋 --&gt; page4</span></code></pre></td></tr></table></div></figure>


<p>现在搜索"Lucene"的时候,我知道在page1,page2,page3中出现了.搜索"作者"的时候,我知道在page4出现了.</p>

<p>另外一个支撑现代搜索理论的既定现实是:词的数量是有限的,而且非常有限.比如常用的中文词就几万个.</p>

<h2>2.Lucene是什么</h2>

<p>简单讲,Lucene是一个高效的,基于Java的全文检索工具包,它不是一个完整的搜索应用程序,而是为你的应用程序提供索引和搜索功能.Lucene是Apache家族中的一个开源项目.也是目前最为流行的基于 Java 开源全文检索工具包.</p>

<p>Lucene 能够为文本类型的数据建立索引,所以你只要能把你要索引的数据格式转化的文本的,Lucene 就能对你的文档进行索引和搜索.比如你要对一些 HTML 文档,PDF 文档进行索引的话你只需要把 HTML 文档和 PDF 文档转化成文本格式的,然后将转化后的内容交给Lucene进行索引,然后把创建好的索引文件保存到磁盘或者内存中,最后根据用户输入的查询条件在索引文件上进行查询.不指定要索引的文档的格式也使Lucene能够几乎适用于所有的搜索应用程序.</p>

<p>下图展示搜索应用程序和Lucene之间的关系,也描述了Lucene的两个核心过程:建立索引和通过索引检索</p>

<p><img src="http://xiaobaoqiu.github.io/images/lucene/lucene_and_application.jpg"></p>

<h4>2.1 Lucene优点</h4>

<p>Lucene作为一个全文搜索引擎,其具有如下突出的优点:</p>

<ul>
<li>1.索引文件格式独立于应用平台.Lucene定义了一套以八字节为基础的索引文件格式,使得兼容系统和不同平台的应用能够共享建立的索引文件.</li>
<li>2.在传统全文检索引擎的倒序索引的基础上实现了分块索引,能够针对新的文件建立小文件索引,提升索引速度.然后通过与原有的索引的合并,达到优化的目的.</li>
<li>3.优秀的面向对象的系统架构,使得对于Lucene扩展的学习难度降低,方便加入新功能.</li>
<li>4.设计了独立于语言和文件格式的文本分析接口,索引器通过接受token流完成索引文件的创立,用户扩展新的语言和文件格式,只需要实现文本分析的接口.</li>
<li>5.已经默认实现了一套强大的查询引擎,用户无须自己编写代码即可使系统获得强大的查询能力,Lucene的查询实现中默认实现了布尔操作、模糊查询、分组查询.</li>
</ul>


<p>参考: <a href="http://lucene.apache.org/core/index.html">http://lucene.apache.org/core/index.html</a></p>

<h4>2.2 倒排索引</h4>

<p>现代搜索引擎基本都是基于倒排索引(反向索引).因为搜索问题本质就是求解"哪文档包含搜索词"这个问题.</p>

<p>简单讲一下什么是倒排索引,简单讲就是字符串到文件的映射关系.假设我的文档集合里面有100篇文档,为了方便表示,我们为文档编号从1到100,得到下面的结构:</p>

<p><img src="http://xiaobaoqiu.github.io/images/lucene/inverted_index.jpg"></p>

<p>左边保存的是一系列字符串,称为词典.每个字符串都指向包含此字符串的文档(Document)链表,此文档链表称为倒排表.</p>

<p>有了索引,便使保存的信息和要搜索的信息一致,可以大大加快搜索的速度.比如说,我们要寻找既包含字符串“lucene”又包含字符串“solr”的文档,我们只需要以下几步:</p>

<ol>
<li>取出包含字符串lucene的文档链表.</li>
<li>取出包含字符串solr的文档链表.</li>
<li>通过合并链表,找出既包含lucene又包含solr的文件.</li>
</ol>


<p><img src="http://xiaobaoqiu.github.io/images/lucene/inverted_index_merge.jpg"></p>

<h2>3.Lucene建立索引</h2>

<p>Lucene的建立索引包括以下几个过程:</p>

<h4>3.1.原始文档</h4>

<p>一些要索引的原文档(Document).包括Html文档,PDF文档,MC Word文档等.而Lucene是只能处理文本文档.</p>

<p>庆幸的是现在很多工具帮我们处理这些问题.如Apache的Tika, 官网:<a href="http://tika.apache.org/">http://tika.apache.org/</a></p>

<h4>3.2.分词</h4>

<p>确定输入的文本之后首先将文本传递给分词组件,分词组件(Tokenizer)会做以下几件事情(此过程称为Tokenize):</p>

<pre><code>1. 将文档分成一个一个单独的单词;
2. 去除标点符号;
3. 去除停词(Stop word);
</code></pre>

<p>停词(Stop word)就是一种语言中最普通的一些单词,由于没有特别的意义,因而大多数情况下不能成为搜索的关键词,因而创建索引时,这种词会被去掉而减少索引的大小.英语中挺词(Stop word)如:the,a,this,is等.对于每一种语言的分词组件(Tokenizer),都有一个停词(stop word)集合.经过分词(Tokenizer)后得到的结果称为词元(Token).</p>

<h4>3.3 语言处理</h4>

<p>分词之后将词元传递给语言处理模块,语言处理组件(linguistic processor)主要是对得到的词元(Token)做一些同语言相关的处理.</p>

<p>比如对于英语,语言处理组件(Linguistic Processor)一般做以下几点:</p>

<pre><code>1. 变为小写(Lowercase).
2. 将单词缩减为词根形式,如cars到car等.这种操作称为:stemming.
3. 将单词转变为词根形式,如“drove”到“drive”等.这种操作称为:lemmatization.
</code></pre>

<p>语言处理组件(linguistic processor)的结果称为词(Term).</p>

<h4>3.4 索引</h4>

<p>语言处理之后将词给索引模块,索引模块主要做以下几个事情:</p>

<pre><code>1. 利用得到的词(Term)创建一个字典.
即Term1--&gt;doc1, Term2--&gt;doc1这种映射关系
2. 对字典按字母顺序进行排序.
3. 合并相同的词(Term)成为文档倒排链表.
</code></pre>

<p>倒排链表的格式如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Term1,Document Frequency  --&gt; Doc1,Frequency1 ; Doc2,Frequency2</span></code></pre></td></tr></table></div></figure>


<p>Document Frequency 即文档频次,表示总共有多少文件包含此词(Term),即链表中文档数目.
Frequency 即词频率,表示此文件中包含了几个此词(Term).</p>

<p>下面是一个建立索引的例子,输入文本如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>文件一:Students should be allowed to go out with their friends, but not allowed to drink beer.
</span><span class='line'>文件二:My friend Jerry went to school to see his students but found them drunk which is not allowed.</span></code></pre></td></tr></table></div></figure>


<p>经过分词(Tokenizer)后得到的结果称为词元(Token):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Students,allowed,go,their,friends,allowed,drink,beer,My,friend,Jerry,went,school,see,his,students,found,them,drunk,allowed</span></code></pre></td></tr></table></div></figure>


<p>经过语言处理,得到的词(Term)如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>student,allow,go,their,friend,allow,drink,beer,my,friend,jerry,go,school,see,his,student,find,them,drink,allow</span></code></pre></td></tr></table></div></figure>


<p>最后得到的倒排索引表如下:</p>

<p><img src="http://xiaobaoqiu.github.io/images/lucene/posting_list.jpg"></p>

<p>所以对词allow来讲,总共有两篇文档包含此词(Term),从而词(Term)后面的文档链表总共有两项,第一项表示包含allow的第一篇文档,即1号文档,此文档中,allow出现了2次,第二项表示包含allow的第二个文档,是2号文档,此文档中,allow出现了1次.</p>

<h2>4.Lucene搜索</h2>

<p>有了倒排索引,我们就可以做搜索了,但是事实上Lucene的搜索过程也不简单.</p>

<p>简单来讲,搜索解决的问题是:找到和搜索词相关性最好的文档.细分的这个问题:</p>

<pre><code>1.找到相关文档;
2.评价搜索词和文档的相关性;
</code></pre>

<p>Lucene的搜索包括以下几个过程.</p>

<h4>3.1.用户输入</h4>

<p>查询语句同我们普通的语言一样,也是有一定语法的.查询语句的语法根据全文检索系统的实现而不同.最基本的有比如:AND, OR, NOT等.举个例子,用户输入语句:lucene AND learned NOT hadoop.说明用户想找一个包含lucene和learned然而不包括hadoop的文档.</p>

<p>目前看来,Google和Baidu都不支出这种语法:</p>

<p><img src="http://xiaobaoqiu.github.io/images/lucene/Google_Search.png"></p>

<p><img src="http://xiaobaoqiu.github.io/images/lucene/Baidu_Search.png"></p>

<h4>3.2.词法分析,语法分析,语言处理</h4>

<p>由于查询语句有语法,因而也要进行语法分析,语法分析及语言处理.</p>

<ul>
<li><p>词法分析主要用来切词,识别单词和关键字.通常建立索引的切词组件和对搜索词的切词组件一致.</p></li>
<li><p>语法分析主要是根据查询语句的语法规则来形成一棵语法树.比如例子:lucene AND learned NOT hadoop形成的语法树如下:</p>

<p>  <img src="http://xiaobaoqiu.github.io/images/lucene/Token_tree.jpg"></p></li>
<li><p>语言处理同索引过程中的语言处理几乎相同.如learned变成learn等.经过第三步,我们得到一棵经过语言处理的语法树.</p>

<p> <img src="http://xiaobaoqiu.github.io/images/lucene/Term_Tree.jpg"></p></li>
</ul>


<h4>3.3 搜索索引</h4>

<p>此步骤有分几小步:</p>

<ul>
<li>在反向索引表中,分别找出包含lucene,learn,hadoop的文档链表.</li>
<li>对包含lucene,learn的链表进行合并操作,得到既包含lucene又包含learn的文档链表.</li>
<li>将此链表与hadoop的文档链表进行差操作,去除包含hadoop的文档,从而得到既包含lucene又包含learn而且不包含hadoop的文档链表.此文档链表就是我们要找的文档.</li>
</ul>


<h4>3.4 结果文档排序</h4>

<p>虽然在上一步,我们得到了想要的文档,然而对于查询结果应该按照与查询语句的相关性进行排序,越相关者越靠前.</p>

<p>通常会把查询语句看作一片短小的文档,对文档与文档之间的相关性(relevance)进行打分(scoring),分数高的相关性好,就应该排在前面.</p>

<p>对于文档之间的关系,不同的Term重要性不同,比如对于本篇文档,search, Lucene, full-text就相对重要一些,this, a , what可能相对不重要一些.所以如果两篇文档都包含search, Lucene,fulltext,这两篇文档的相关性好一些,然而就算一篇文档包含this, a, what,另一篇文档不包含this, a, what,也不能影响两篇文档的相关性.</p>

<p>找出词(Term)对文档的重要性的过程称为计算词的权重(Term weight)的过程.计算词的权重(term weight)有两个参数,第一个是词(Term),第二个是文档(Document).词的权重(Term weight)表示此词(Term)在此文档中的重要程度,越重要的词(Term)有越大的权重(Term weight),因而在计算文档之间的相关性中将发挥更大的作用.</p>

<p>下面分析这两个过程:</p>

<ul>
<li>计算权重(Term weight).</li>
</ul>


<p>影响一个词(Term)在一篇文档中的重要性主要有两个因素:</p>

<pre><code>1.Term Frequency (tf):即此Term在此文档中出现了多少次. tf越大说明越重要.
2.Document Frequency (df):即有多少文档包含次Term. df越大说明越不重要.
</code></pre>

<p>很容易理解,词(Term)在文档中出现的次数越多,说明此词(Term)对该文档越重要,如“搜索”这个词,在本文档中出现的次数很多,说明本文档主要就是讲这方面的事的.然而在一篇英语文档中,this出现的次数更多,就说明越重要吗？不是的,这是由第二个因素进行调整,第二个因素说明,有越多的文档包含此词(Term), 说明此词(Term)太普通,不足以区分这些文档,因而重要性越低.</p>

<p>简单公式如下:</p>

<p><img src="http://xiaobaoqiu.github.io/images/lucene/Term_Weight.png"></p>

<ul>
<li>根据Term之间的关系得到文档相关性.</li>
</ul>


<p>我们把文档看作一系列词(Term),每一个词(Term)都有一个权重(Term weight),不同的词(Term)根据自己在文档中的权重来影响文档相关性的打分计算.</p>

<p>于是我们把所有此文档中词(term)的权重(term weight) 看作一个向量.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Document = {term1, term2, …… ,term N}
</span><span class='line'>Document Vector = {weight1, weight2, …… ,weight N}</span></code></pre></td></tr></table></div></figure>


<p>同样我们把查询语句看作一个简单的文档,也用向量来表示.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Query = {term1, term 2, …… , term N}
</span><span class='line'>Query Vector = {weight1, weight2, …… , weight N}</span></code></pre></td></tr></table></div></figure>


<p>我们把所有搜索出的文档向量及查询向量放到一个N维空间中,每个词(term)是一维:</p>

<p><img src="http://xiaobaoqiu.github.io/images/lucene/document_relative_vsm.jpg"></p>

<p>我们认为两个向量之间的夹角越小,相关性越大.所以我们计算夹角的余弦值作为相关性的打分,夹角越小,余弦值越大,打分越高,相关性越大.</p>

<p>需要注意的是,查询语句一般是很短的,包含的词(Term)是很少的,因而查询向量的维数很小,而文档很长,包含词(Term)很多,文档向量维数很大, 但是需要放到相同的向量空间,因此要保证二者维数是相同的.处理方式很简单,维数不同时,取二者的并集,如果不含某个词(Term)时,则权重(Term Weight)为0.</p>

<p>相关性打分公式如下:</p>

<p><img src="http://xiaobaoqiu.github.io/images/lucene/documet_relative_caculate.png"></p>

<p>举个例子,查询语句有11个Term,共有三篇文档搜索出来.其中各自的权重(Term weight),如下:</p>

<p><img src="http://xiaobaoqiu.github.io/images/lucene/document_score.png"></p>

<p>于是计算,三篇文档同查询语句的相关性打分分别为:</p>

<p><img src="http://xiaobaoqiu.github.io/images/lucene/score_example.png"></p>

<p>于是文档二相关性最高,先返回,其次是文档一,最后是文档三.到此为止,我们可以找到我们最想要的文档了.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mysql Join]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/09/03/mysql-join/"/>
    <updated>2015-09-03T11:42:33+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/09/03/mysql-join</id>
    <content type="html"><![CDATA[<p>join 用于多表中字段之间的关联,语法如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>... FROM table1 INNER|LEFT|RIGHT JOIN table2 ON conditiona</span></code></pre></td></tr></table></div></figure>


<p>JOIN实际上是两个表的的乘积(即笛卡尔积).假设集合A={a,b}，集合B={0,1,2}，则两个集合的笛卡尔积为{(a,0),(a,1),(a,2),(b,0),(b,1), (b,2)}.</p>

<p>JOIN按照功能大致分为如下三类:</p>

<pre><code>INNER JOIN: 取得两个表中存在连接匹配关系的记录;
LEFT JOIN: 取得左表完全记录，即使右表并无对应匹配记录,如果没有匹配,右侧将包含null;
RIGHT JOIN: 与 LEFT JOIN 相反，取得右表完全记录，即使左表并无匹配对应记录;
</code></pre>

<h2>. 1.显示join和隐式join</h2>

<p>另外,写join语句有所谓的显示join和隐式join的写法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-- 显示join
</span><span class='line'>select * from
</span><span class='line'>table1 inner join table2
</span><span class='line'>on table1.name = table2.name;
</span><span class='line'>
</span><span class='line'>-- 隐式join
</span><span class='line'>select table1.*, table2.*
</span><span class='line'>from table1, table2
</span><span class='line'>where table1.name = table2.name;</span></code></pre></td></tr></table></div></figure>


<p>这两种写法性能上基本没有差异,参考stackoverflow: <a href="http://stackoverflow.com/questions/44917/explicit-vs-implicit-sql-joins">http://stackoverflow.com/questions/44917/explicit-vs-implicit-sql-joins</a></p>

<h2>. 2.ON条件和WHERE条件</h2>

<p>在执行顺序上需要注意的是on条件和where条件执行顺序: 首先使用on条件产生初始笛卡尔积集合,再在这个集合上使用where条件筛选.所以join的时候应该首先好的on条件保证笛卡尔积集合尽可能小,从而减少Where的执行.</p>

<p>比如下面两种写法,方案2写法保证产生的笛卡尔积集合很小,因而从执行性能来看第二个显然更加省时。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-- 方案1
</span><span class='line'>select * from A
</span><span class='line'>inner join B on B.name = A.name
</span><span class='line'>left join C on C.name = B.name
</span><span class='line'>left join D on D.id = C.id
</span><span class='line'>where C.status&gt;1 and D.status=1;
</span><span class='line'>
</span><span class='line'>-- 方案2
</span><span class='line'>select * from A
</span><span class='line'>inner join B on B.name = A.name
</span><span class='line'>left join C on C.name = B.name and C.status&gt;1
</span><span class='line'>left join D on D.id = C.id and D.status=1</span></code></pre></td></tr></table></div></figure>


<h2>. 3.STRAIGHT_JOIN和NATURAL JOIN</h2>

<h4>. 3.1 STRAIGHT_JOIN</h4>

<p>再Join的时候,MySQL优化器要确定以谁为驱动表，也就是说以哪个表为基准，在处理此类问题时，MySQL优化器采用了简单粗暴的解决方法：哪个表的结果集小，就以哪个表为驱动表，当然MySQL优化器实际的处理方式会复杂许多，具体可以参考：<a href="http://www.orczhou.com/index.php/2013/04/how-mysql-choose-index-in-a-join/">http://www.orczhou.com/index.php/2013/04/how-mysql-choose-index-in-a-join/</a></p>

<p>说明：在EXPLAIN结果中，第一行出现的表就是驱动表。</p>

<p>但是这个由的时候比较愚蠢,比如我们order by的字段在大结果集的表上,也就是说排序字段不在驱动表里，于是乎不可避免的出现了Using filesort和Using temporary.</p>

<p>上面这种场景,我们就可以通过使用STRAIGHT_JOIN显示的指定驱动表</p>

<p>参考: <a href="http://huoding.com/2013/06/04/261">http://huoding.com/2013/06/04/261</a></p>

<h4>. 3.2 NATURAL</h4>

<p>MySQL将表中具有相同名称的字段自动进行记录匹配，而这些同名字段类型可以不同。因此，NATURAL JOIN 不用指定匹配条件。</p>

<p>同样包含NATURAL LEFT JOIN和NATURAL RIGHT JOIN.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SELECT article.aid,article.title,user.username FROM article NATURAL JOIN user</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在线诊断工具]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/08/27/zai-xian-zhen-duan-gong-ju/"/>
    <updated>2015-08-27T19:54:38+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/08/27/zai-xian-zhen-duan-gong-ju</id>
    <content type="html"><![CDATA[<p>Java诊断我相信再日常开发中都十分需要.相信大家都使用过以下几种诊断方式:</p>

<pre><code>1.肉眼诊断
就是出现问题时候企图通过肉眼来发现代码问题.通常很明显的问题有效;
2.日志诊断
通过给出问题的代码入参或者上下游加上日志,或者出问题的时候加上日志来诊断;这种方式的问题就是出现问题你需要重新拉分支,加日志,本地测试再上限这一系列流程.另外一个问题是过多的日志会影响应用性能;
3.监控诊断
通过完善的监控,通常包括完善且精确的异常划分.对不同的异常情况有独立的监控.加上完善的报警机制.这是最理想的情况.其优势是能快速定位问题点,问题是建立这一套完善的机制需要很长时间.并且监控只能发现问题类型,比如监控发现是数据错误,但是到底那条数据错误还是需要日志等手段来定位.
4.在线诊断工具
在不需要重新发布的情况下,在线诊断应用的问题所在.通常还可以用于定位接口瓶颈等问题;
</code></pre>

<p>这里简单介绍一下最近找到的几个在线诊断工具.它们都是非侵入式的,即不需要修改原始应用的代码再重新发布上线这个过程.</p>

<p>常用包括几个诊断工具包括,这里做一个简单的介绍:</p>

<pre><code>1.BTrace
2.HouseMD
3.Greys-Anatomy
</code></pre>

<p>参考: <a href="http://www.infoq.com/cn/articles/java-profiling-with-open-source/">http://www.infoq.com/cn/articles/java-profiling-with-open-source/</a></p>

<h2>. 1.BTrace</h2>

<p>Btrace(bytecode trace)是Kenai在2009年开发的一个开源项目(<a href="https://kenai.com/projects/btrace/">https://kenai.com/projects/btrace/</a>)，是一个动态跟踪分析JAVA源代码的工具。
它可以用来帮我们做运行时的JAVA程序分析，追踪，监控等.</p>

<p>官网: <a href="https://kenai.com/projects/btrace/">https://kenai.com/projects/btrace/</a></p>

<p>用户手册: <a href="https://kenai.com/projects/btrace/pages/UserGuide">https://kenai.com/projects/btrace/pages/UserGuide</a></p>

<p>samples下有很多使用例子.参考网上的一个例子:
<a href="http://mgoann.iteye.com/blog/1409685">http://mgoann.iteye.com/blog/1409685</a></p>

<p>参考: <a href="http://wiki.corp.qunar.com/pages/viewpage.action?pageId=56198121">http://wiki.corp.qunar.com/pages/viewpage.action?pageId=56198121</a></p>

<h4>1.1使用场景:</h4>

<p>1.数据采样
比如我们要优化某块代码，就可以先写一个btrace脚本，丢到线上服务器上跑一段时间；
这样可以收集到最真实的数据，而且不用发布之类的；
然后根据收集到的数据，做有目的的优化，优化之后，还可以对比出优化的效果。
2.排查问题
3.性能监控</p>

<h4>1.2优点</h4>

<p>1.跟踪任何java代码的调用（包括第三方类库中的，甚至jdk中的），比如统计某方法的调用次数，耗时。
2.可以监控的维度有很多，比如异常，同步块，内存申请，数组声明，甚至可以精确到行
3.完全不侵入业务代码，不需要重启服务
4.安全，对于应用内的数据来说是只读的。</p>

<h4>1.3缺点</h4>

<ol>
<li>有较多的使用限制，如只能调用用BtraceUtils中的方法、不能写实例变量；
（见docs/usersguide.html中的BTrace Restrictions条目）
所以刚编写脚本的时候，可能会有各种不习惯，但其实大多会用到的方法，BtraceUtils里都有封装
（其实个人感觉这个不算缺点，只是这个工具定位在追踪和监控，所以出于安全考虑，做了这个限制）</li>
<li>监控基本上只能单点，集群环境没法玩</li>
<li>被监控的服务重启，btrace也需要跟着重启
4.有影响原始应用的风险,严重可能导致JVM Crash.</li>
</ol>


<h4>1.4使用方式</h4>

<ul>
<li><p>Boot方式启动
追踪已启动的jvm进程
命令：btrace/bin/btrace 12345 SomeScript.java
注意，下载下来后bin下的文件都不可执行，需要chmod u+x，并且需要和目标进程是同一个用户来启动</p></li>
<li><p>Agent方式启动
与目标jvm同时启动
配置jvm参数：-javaagent:btrace-agent.jar=script=SqlMapTracer.class
注意：agent方式启动只能使用编译过的脚本
使用btrace/bin/btracec SqlMapTracer.java 编译
agent方式启动的btrace的标准输出位于你的SqlMapTracer.class所在目录下的SqlMapTracer.class.btrace文件</p></li>
</ul>


<p>boot方式灵活，但是当要求追踪结果精确时，就不太好用了。因为不知道btrace启动之前，目标进程已经执行了多少代码。agent方式是和目标进程同时启动的，可以保证结果精确。</p>

<h4>1.5原理</h4>

<p>主要就是使用ASM来实现对类的修改,再使用Instumentation实现类的内存替换.</p>

<p>btrace原理: <a href="http://victorzhzh.iteye.com/blog/965789">http://victorzhzh.iteye.com/blog/965789</a></p>

<p>btrace源码分析: <a href="http://agapple.iteye.com/blog/1005918">http://agapple.iteye.com/blog/1005918</a></p>

<h2>. 2.HouseMD</h2>

<p>高负载服务器端Java程序 诊断工具的特性要求有:</p>

<pre><code>1.命令行接口, 能够方便在服务器环境中运行;
2.支持常用诊断调式手段, 能够在其中快速来回切换;
3.容易定位跟踪目标, 且不易出错;
4.弱侵入, 目标Java程序无需任何修改, 不用重新部署或重启;
5.有效控制给目标进程带来的资源消耗;
6.不遗留任何"代码垃圾"等后遗症.
</code></pre>

<p>使用手册: <a href="https://github.com/CSUG/HouseMD/wiki/UserGuideCN">https://github.com/CSUG/HouseMD/wiki/UserGuideCN</a></p>

<h4>. 2.1安装</h4>

<p>首先安装jenv:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xiaobaoqiu@xiaobaoqiu:~/Tools/HouseMD$ curl -L -s get.jenv.io | bash
</span><span class='line'>...
</span><span class='line'>xiaobaoqiu@xiaobaoqiu:~/Tools/HouseMD$ source /home/xiaobaoqiu/.jenv/bin/jenv-init.sh
</span><span class='line'>...
</span><span class='line'>xiaobaoqiu@xiaobaoqiu:~/Tools/HouseMD$ jenv help
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>再安装HouseMD就很简单:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xiaobaoqiu@xiaobaoqiu:~/Tools/HouseMD$ jenv install housemd
</span><span class='line'>Installing: housemd 0.2.7
</span><span class='line'>Parsing http://jenv.mvnsearch.org/candidate/housemd/download/0.2.7/Linux/x86_64
</span><span class='line'>
</span><span class='line'>Downloading: housemd 0.2.7
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<h2>. 3.Greys-Anatomy</h2>

<p>Greys是一个java进程执行过程中的异常诊断工具。 在不中断程序执行的情况下轻松完成问题排查工作.</p>

<p>源码: <a href="https://github.com/oldmanpushcart/greys-anatomy">https://github.com/oldmanpushcart/greys-anatomy</a></p>

<p>使用范例: <a href="https://github.com/oldmanpushcart/greys-anatomy/wiki/Getting-Start">https://github.com/oldmanpushcart/greys-anatomy/wiki/Getting-Start</a></p>

<p>交互方式: 命令行交互</p>

<p>功能:</p>

<pre><code>1.查看加载类，方法信息
2.方法执行监控（调用量，成功失败率，响应时间）
3.方法执行数据观测（参数，返回结果，异常信息等）
4.方法执行数据记录
5.性能开销渲染
6.方法执行数据自定义观测（js脚本）
7.查看方法调用堆栈
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[处理sql超时]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/08/22/chu-li-sqlchao-shi/"/>
    <updated>2015-08-22T14:18:23+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/08/22/chu-li-sqlchao-shi</id>
    <content type="html"><![CDATA[<p>最近组内又出现一次因为SQL慢查询导致业务整体雪崩的情况.很惭愧的是,那个慢查询SQL是我大概一年之前写的(一个统计的SQL,数据量又比较大),那时还很稚嫩.</p>

<p>之前组内出现这种情况一般是让DBA上一个慢查询脚本,直接暴力kill那些慢查询.</p>

<p>其实各个JDBC driver实现java.sql.Statement的时候都需要实现setQueryTimeout这个函数,其作用就是设置SQL的执行超时时间,当SQL超时会直接被取消掉并且抛出QLTimeoutException异常.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'>     * Sets the number of seconds the driver will wait for a
</span><span class='line'>     * &lt;code&gt;Statement&lt;/code&gt; object to execute to the given number of seconds.
</span><span class='line'>     *By default there is no limit on the amount of time allowed for a running
</span><span class='line'>     * statement to complete. If the limit is exceeded, an
</span><span class='line'>     * &lt;code&gt;SQLTimeoutException&lt;/code&gt; is thrown.
</span><span class='line'>     * A JDBC driver must apply this limit to the &lt;code&gt;execute&lt;/code&gt;,
</span><span class='line'>     * &lt;code&gt;executeQuery&lt;/code&gt; and &lt;code&gt;executeUpdate&lt;/code&gt; methods.
</span><span class='line'>     * &lt;p&gt;
</span><span class='line'>     * &lt;strong&gt;Note:&lt;/strong&gt; JDBC driver implementations may also apply this
</span><span class='line'>     * limit to {@code ResultSet} methods
</span><span class='line'>     * (consult your driver vendor documentation for details).
</span><span class='line'>     * &lt;p&gt;
</span><span class='line'>     * &lt;strong&gt;Note:&lt;/strong&gt; In the case of {@code Statement} batching, it is
</span><span class='line'>     * implementation defined as to whether the time-out is applied to
</span><span class='line'>     * individual SQL commands added via the {@code addBatch} method or to
</span><span class='line'>     * the entire batch of SQL commands invoked by the {@code executeBatch}
</span><span class='line'>     * method (consult your driver vendor documentation for details).
</span><span class='line'>     *
</span><span class='line'>     * @param seconds the new query timeout limit in seconds; zero means
</span><span class='line'>     *        there is no limit
</span><span class='line'>     * @exception SQLException if a database access error occurs,
</span><span class='line'>     * this method is called on a closed &lt;code&gt;Statement&lt;/code&gt;
</span><span class='line'>     *            or the condition seconds &gt;= 0 is not satisfied
</span><span class='line'>     * @see #getQueryTimeout
</span><span class='line'>     */
</span><span class='line'>    void setQueryTimeout(int seconds) throws SQLException;</span></code></pre></td></tr></table></div></figure>


<p>默认情况下都不设置超时时间(即默认值0).即永远不超时.Druid的Filter机制很容易的让我们设置这个查询超时时间.</p>

<h2>1.SQL超时时间Filter实现</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> * 设置SQL执行时间
</span><span class='line'> * 如果超时,查询被cancel,并抛出SQLTimeoutException异常
</span><span class='line'> *
</span><span class='line'> * @author: xiaobaoqiu  Date: 15-8-22 Time: 下午1:55
</span><span class='line'> */
</span><span class='line'>public class SqlTimeOutFilter extends FilterEventAdapter {
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 默认超时时间,单位秒
</span><span class='line'>     * 注意不要设置太小
</span><span class='line'>     */
</span><span class='line'>    private static final int QUERY_TIMEOUT_THRESHOLD_SECOND = 100;
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 超时时间,默认为QUERY_TIMEOUT_THRESHOLD_SECOND
</span><span class='line'>     */
</span><span class='line'>    private int timeoutThreshold = QUERY_TIMEOUT_THRESHOLD_SECOND;
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    protected void statementExecuteBefore(StatementProxy statement, String sql) {
</span><span class='line'>        setQueryTimeout(statement);
</span><span class='line'>        super.statementExecuteBefore(statement, sql);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    protected void statementExecuteBatchBefore(StatementProxy statement) {
</span><span class='line'>        setQueryTimeout(statement);
</span><span class='line'>        super.statementExecuteBatchBefore(statement);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    protected void statementExecuteUpdateBefore(StatementProxy statement, String sql) {
</span><span class='line'>        setQueryTimeout(statement);
</span><span class='line'>        super.statementExecuteUpdateBefore(statement, sql);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    protected void statementExecuteQueryBefore(StatementProxy statement, String sql) {
</span><span class='line'>        setQueryTimeout(statement);
</span><span class='line'>        super.statementExecuteQueryBefore(statement, sql);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 设置Statement超时时间,
</span><span class='line'>     * statement.setQueryTimeout单位是秒,0表示没有限制.这个函数可能会抛出SQLException异常,场景:
</span><span class='line'>     *      1.数据库访问错误
</span><span class='line'>     *      2.在一个已经关闭的Statement上调用这个方法
</span><span class='line'>     *      3.超时时间不满足seconds &gt;= 0的条件
</span><span class='line'>     *
</span><span class='line'>     * @param statement
</span><span class='line'>     */
</span><span class='line'>    private void setQueryTimeout(StatementProxy statement) {
</span><span class='line'>        try {
</span><span class='line'>            statement.setQueryTimeout(timeoutThreshold);
</span><span class='line'>        }catch (SQLException se) {
</span><span class='line'>            //TODO: do something
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public int getTimeoutThreshold() {
</span><span class='line'>        return timeoutThreshold;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public void setTimeoutThreshold(int timeoutThreshold) {
</span><span class='line'>        this.timeoutThreshold = timeoutThreshold;
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>2.SQL超时时间Filter使用</h2>

<p>默认的DruidDataSource就支持设置设置Filter:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void setProxyFilters(List&lt;Filter&gt; filters) {
</span><span class='line'>        if (filters != null) {
</span><span class='line'>            this.filters.addAll(filters);
</span><span class='line'>        }
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>我们可以实现DataSourceFactory(参考默认实现DefaultDataSourceFactory),在创建DataSource的时候调用setProxyFilters加上我们自己写的Filter:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class DruidDataSourceFactory implements DataSourceFactory {
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    public DataSource create(String host, int port, String username, String password, String dbName, int corePoolSize,
</span><span class='line'>                             int maxPoolSize, String jdbcUrlOption, boolean autoCommit) throws ResourceException {
</span><span class='line'>        DruidDataSource dataSource = new DruidDataSource();//使用默认实现DruidDataSource
</span><span class='line'>        //设置dataSource参数, username等
</span><span class='line'>
</span><span class='line'>        //设置dataSource的Filter
</span><span class='line'>        List&lt;Filter&gt; filters = Lists.newArrayList();
</span><span class='line'>        SqlTimeOutFilter timeOutFilter = new SqlTimeOutFilter();
</span><span class='line'>        filters.add(timeOutFilter);
</span><span class='line'>        dataSource.setProxyFilters(filters);
</span><span class='line'>        
</span><span class='line'>        //dataSource初始化等操作
</span><span class='line'>        ...
</span><span class='line'>
</span><span class='line'>        return dataSource;
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>关于超时时间设置的一篇博文,很全面:</p>

<p><a href="http://www.importnew.com/2466.html">http://www.importnew.com/2466.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MyBatis空where拦截器]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/08/22/mybatiskong-wherelan-jie-qi/"/>
    <updated>2015-08-22T12:37:48+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/08/22/mybatiskong-wherelan-jie-qi</id>
    <content type="html"><![CDATA[<p>最近项目中出现了至少两次因为Mybatis的动态where条件不满足导致实际sql语句的where条件为空,进而查询全表,当数据量比较大的时候,导致OOM的情况.</p>

<p>如何禁止这种情况,个人觉得三种措施:</p>

<ul>
<li>1.在逻辑层面加充分的参数有效性检查;</li>
<li>2.在where条件中如果索引条件都不满足,加上1=2这种必然失败的条件;</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;where&gt;
</span><span class='line'>    &lt;choose&gt;
</span><span class='line'>        &lt;when test="id != null"&gt;
</span><span class='line'>            ...
</span><span class='line'>        &lt;/when&gt;
</span><span class='line'>        ...
</span><span class='line'>        &lt;otherwise&gt;
</span><span class='line'>        and 1=2
</span><span class='line'>        &lt;/otherwise&gt;
</span><span class='line'>    &lt;/choose&gt;
</span><span class='line'>&lt;/where&gt;</span></code></pre></td></tr></table></div></figure>


<ul>
<li>3.Mybatis拦截器;</li>
</ul>


<p>前两种措施都是依赖人,从这个层面讲,是不靠谱的,即一个策略不是强制的,就是不靠谱的.相对而言,第三种是不依赖程序员的自觉性,是最靠谱的.乘周六有时间,实现一个简单的Mybatis拦截器来拦截where条件为空的SQL语句.</p>

<h1>1.实现</h1>

<p>先上代码,这里拦截了SqlCommandType为select,update,delete这三种类型.出现情况目前只是打日志.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> * Mybatis拦截器, 拦截:
</span><span class='line'> *      select语句where条件为空
</span><span class='line'> *      update语句where条件为空
</span><span class='line'> *      delete语句where条件为空
</span><span class='line'> *
</span><span class='line'> * 处理: 目前只是打warning日志,因为项目中存在数据量很少的表读全表的情况(比如加载数据进缓存)
</span><span class='line'> *      TODO:后续考虑设置拦截器的白名单,不在白名单的触发where条件为空的直接抛出异常.
</span><span class='line'> *
</span><span class='line'> * @author: xiaobaoqiu  Date: 15-8-22 Time: 上午10:26
</span><span class='line'> */
</span><span class='line'>@Intercepts({ @Signature(
</span><span class='line'>        type = StatementHandler.class,
</span><span class='line'>        method = "prepare",
</span><span class='line'>        args = { Connection.class }) })
</span><span class='line'>public class EmptyWhereInterceptor implements Interceptor {
</span><span class='line'>
</span><span class='line'>    private static final Logger logger = LoggerFactory.getLogger(EmptyWhereInterceptor.class);
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 拦截的 COMMAND 类型
</span><span class='line'>     */
</span><span class='line'>    private static final Set&lt;String&gt; INTERCEPTOR_COMMAND = Sets.newHashSet("select", "update", "delete");
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    public Object intercept(Invocation invocation) throws Throwable {
</span><span class='line'>        StatementHandler handler = (StatementHandler) invocation.getTarget();
</span><span class='line'>
</span><span class='line'>        //获取实际的StatementHandler
</span><span class='line'>        if (handler instanceof RoutingStatementHandler) {
</span><span class='line'>            handler = (BaseStatementHandler) ReflectUtil.getFieldValue(handler, "delegate");
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        //获取SqlCommandType
</span><span class='line'>        String commandType = getCommandType(handler);
</span><span class='line'>
</span><span class='line'>        if (INTERCEPTOR_COMMAND.contains(commandType)) {
</span><span class='line'>            String originSql = handler.getBoundSql().getSql().toLowerCase();  //获取sql
</span><span class='line'>            if (!originSql.contains("where")) {
</span><span class='line'>                logger.warn("禁止使用不带where条件的SQL语句.原始SQL={}", originSql);
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        return invocation.proceed();
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    public Object plugin(Object target) {
</span><span class='line'>        return Plugin.wrap(target, this);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    public void setProperties(Properties properties) {
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 获取Command类型,小写化返回
</span><span class='line'>     *
</span><span class='line'>     * @param handler
</span><span class='line'>     * @return
</span><span class='line'>     */
</span><span class='line'>    private String getCommandType(StatementHandler handler) {
</span><span class='line'>        MappedStatement mappedStatement = (MappedStatement) ReflectUtil.getFieldValue(handler, "mappedStatement");
</span><span class='line'>        return mappedStatement.getSqlCommandType().toString().toLowerCase();
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>包括一个简单反射工具的实现:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> * 反射工具
</span><span class='line'> *
</span><span class='line'> * @author: xiaobaoqiu  Date: 15-8-22 Time: 上午11:52
</span><span class='line'> */
</span><span class='line'>public class ReflectUtil {
</span><span class='line'>    public ReflectUtil() {
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 改变 Accessible,便于访问private等属性
</span><span class='line'>     * @param field
</span><span class='line'>     */
</span><span class='line'>    private static void makeAccessible(Field field) {
</span><span class='line'>        if(!Modifier.isPublic(field.getModifiers())) {
</span><span class='line'>            field.setAccessible(true);
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 获取 object 的字段,字段名称为filedName,获取不到返回null
</span><span class='line'>     * @param object
</span><span class='line'>     * @param filedName
</span><span class='line'>     * @return
</span><span class='line'>     */
</span><span class='line'>    private static Field getDeclaredField(Object object, String filedName) {
</span><span class='line'>        Class superClass = object.getClass();
</span><span class='line'>
</span><span class='line'>        while(superClass != Object.class) {
</span><span class='line'>            try {
</span><span class='line'>                return superClass.getDeclaredField(filedName);
</span><span class='line'>            } catch (NoSuchFieldException var4) {
</span><span class='line'>                superClass = superClass.getSuperclass();
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        return null;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 获取object字段fieldName的值,如果字段不存在直接抛异常
</span><span class='line'>     *
</span><span class='line'>     * @param object
</span><span class='line'>     * @param fieldName
</span><span class='line'>     * @return
</span><span class='line'>     */
</span><span class='line'>    public static Object getFieldValue(Object object, String fieldName) {
</span><span class='line'>        Field field = getDeclaredField(object, fieldName);
</span><span class='line'>        if(field == null) {
</span><span class='line'>            throw new IllegalArgumentException("Could not find field [" + fieldName + "] on target [" + object + "]");
</span><span class='line'>        } else {
</span><span class='line'>            makeAccessible(field);
</span><span class='line'>            Object result = null;
</span><span class='line'>
</span><span class='line'>            try {
</span><span class='line'>                result = field.get(object);
</span><span class='line'>            } catch (IllegalAccessException var5) {
</span><span class='line'>                var5.printStackTrace();
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>            return result;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 设置object字段fieldName的值,如果字段不存在直接抛异常
</span><span class='line'>     *
</span><span class='line'>     * @param object
</span><span class='line'>     * @param fieldName
</span><span class='line'>     * @param value
</span><span class='line'>     */
</span><span class='line'>    public static void setFieldValue(Object object, String fieldName, Object value) {
</span><span class='line'>        Field field = getDeclaredField(object, fieldName);
</span><span class='line'>        if(field == null) {
</span><span class='line'>            throw new IllegalArgumentException("Could not find field [" + fieldName + "] on target [" + object + "]");
</span><span class='line'>        } else {
</span><span class='line'>            makeAccessible(field);
</span><span class='line'>
</span><span class='line'>            try {
</span><span class='line'>                field.set(object, value);
</span><span class='line'>            } catch (IllegalAccessException var5) {
</span><span class='line'>                var5.printStackTrace();
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h1>2.Mybatis的Interceptor原理</h1>

<p><a href="http://www.tuicool.com/articles/RbyUfu">这篇文章</a>很好的解释了Mybatis的Interceptor机制.</p>

<p>mybatis读取配置再xml文件中Interceptor,通过反射构造其实例，将所有的Interceptor保存到InterceptorChain中。</p>

<p>mybatis的拦截器只能代理指定的四个类：ParameterHandler、ResultSetHandler、StatementHandler以及Executor。</p>

<p>参考:</p>

<p><a href="http://www.tuicool.com/articles/RbyUfu">http://www.tuicool.com/articles/RbyUfu</a></p>

<p><a href="http://blog.csdn.net/hupanfeng/article/details/9247379">http://blog.csdn.net/hupanfeng/article/details/9247379</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mysql PacketTooBigException]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/08/12/mysql-packettoobigexception/"/>
    <updated>2015-08-12T16:44:38+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/08/12/mysql-packettoobigexception</id>
    <content type="html"><![CDATA[<p>最近做一个同步线上数据导dev或者beta环境的小工具.今天遇到一个小异常:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Caused by: com.mysql.jdbc.PacketTooBigException: Packet for query is too large (17610152 &gt; 16777216). You can change this value on the server by setting the max_allowed_packet' variable.</span></code></pre></td></tr></table></div></figure>


<p>原因就是一次插入的数据太大了.Mysql存在数据包最大大小的配置,默认是1M,这里我们的dev环境是16M,但是我这里出现了大于16M的数据packet:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>mysql&gt; show VARIABLES like '%max_allowed_packet%';
</span><span class='line'>+--------------------------+------------+
</span><span class='line'>| Variable_name            | Value      |
</span><span class='line'>+--------------------------+------------+
</span><span class='line'>| max_allowed_packet       | 16777216   |
</span><span class='line'>| slave_max_allowed_packet | 1073741824 |
</span><span class='line'>+--------------------------+------------+</span></code></pre></td></tr></table></div></figure>


<p>修改max_allowed_packet:</p>

<ul>
<li>1.set global max_allowed_packet = 2<em>1024</em>1024*10</li>
<li>2.修改my.conf文件(windows为my.ini)</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>max_allowed_packet      = 16M</span></code></pre></td></tr></table></div></figure>


<p>注意点:</p>

<ul>
<li>1.保证Master和Slave的max_allowed_packet参数一致(一般都要求所以参数一致);</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Oomkiller]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/08/08/oomkiller/"/>
    <updated>2015-08-08T12:33:53+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/08/08/oomkiller</id>
    <content type="html"><![CDATA[<p>最近dev环境的Tomcat服务,还有dev环境的crate服务老是出现问题,现象就是Tomcat应用自己停了.导致测试中老是感觉莫名其妙.跟了一下原因,发现背后就是著名的oom-killer.</p>

<p>其实出现这个问题早就预料到了,8G内存的虚拟机器上面跑了接近20个Tomcat应用,每个Tomcat至少要求了0.5G的内存,很多要求的是默认的2G的内存.</p>

<p>这里主要简单介绍一下oomkiller是什么东西,原理是什么,以及对我们的影响.</p>

<h1>1.oomkiller简介</h1>

<p>简单的说,Linux 内核有个机制叫OOM killer(Out-Of-Memory killer)，该机制会监控那些占用内存过大，尤其是瞬间很快消耗大量内存的进程(为什么后面会讲到)，为了防止内存耗尽而内核会把该进程杀掉,从而腾出内存留给系统用。</p>

<p>现象就是相关的日志文件(/var/log/messages)里面会看到下面类似的 Out of memory: Kill process 信息(日志里面把机器host去掉了),还包括一些如pid，process name，cpu mask，trace等信息:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Aug  4 22:03:18  kernel: Out of memory: Kill process 21447 (java) score 81 or sacrifice child
</span><span class='line'>Aug  4 22:03:18  kernel: Killed process 21447, UID 40001, (java) total-vm:4242176kB, anon-rss:711240kB, file-rss:1832kB
</span><span class='line'>Aug  5 01:17:21  ntpd[1195]: synchronized to Xx.xx.xxx.xx, stratum 3
</span><span class='line'>Aug  5 01:35:52  kernel: java invoked oom-killer: gfp_mask=0xd0, order=0, oom_adj=0, oom_score_adj=0
</span><span class='line'>Aug  5 01:35:52  kernel: java cpuset=/ mems_allowed=0
</span><span class='line'>Aug  5 01:35:52  kernel: Pid: 17391, comm: java Not tainted 2.6.32-358.23.2.el6.x86_64 #1</span></code></pre></td></tr></table></div></figure>


<h1>2.oomkiller原理</h1>

<p>Linux 内核根据应用程序的要求分配内存，通常来说应用程序分配了内存但是并没有实际全部使用，为了提高性能，这部分没用的内存可以留作它用，这部分内存是属于每个进程的，内核直接回收利用的话比较麻烦，所以内核采用一种过度分配内存(over-commit memory)的办法来间接利用这部分 “空闲” 的内存，提高整体内存的使用效率。</p>

<p>所谓的过度分配内存,可以理解为"打白条",进程A告诉系统我需要2G内存,系统只会答应不会拒绝,因为系统认为任何一个进程不可能每时每刻都全部占用其申请的内存.所以实际上系统并没有给进程A完整的2G内存,而是需要使用的时候才临时分配.这就好像银行现金肯定远远小于所以储户的总值,因为银行认为不可能所以储户同一时间把所以的钱都取出来.</p>

<p>一般来说这样做没有问题，但当大多数应用程序都消耗完自己的内存的时候麻烦就来了，因为这些应用程序的内存需求加起来超出了物理内存(包括 swap)的容量，内核(OOM killer)必须杀掉一些进程才能腾出空间保障系统正常运行。</p>

<p>用银行的例子来讲可能更容易懂一些，部分储户取钱的时候银行不怕，银行有足够的存款应付，当全国所以的储户(或者绝大多数储户)都取钱而且每个人都想把自己钱取完的时候银行的麻烦就来了，银行实际上是没有这么多钱给大家取的。</p>

<h3>2.1 根据什么kill</h3>

<p>内核检测到系统内存不足,然后挑选并杀掉某个进程的过程可以参考内核源代码 linux/mm/oom_kill.c，当系统内存不足的时候，oom_kill被触发，然后选择一个进程杀掉，如何判断和选择一个进程呢，总不能随机选吧?系统会根据进程使用内存的情况给进程打分,选择进程kill的时候主要根据这个分数,打分的机制很朴素:最占用内存的进程。</p>

<p>每个进程的分数都由进程的oom_score记录:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[baoqiu.xiao@Xxx ~]$cat /proc/26893/oom_score
</span><span class='line'>76
</span><span class='line'>[baoqiu.xiao@Xxx ~]$ cat /proc/14969/oom_score
</span><span class='line'>82</span></code></pre></td></tr></table></div></figure>


<p>另外一个重要的参数就是进程的oom_adj,表示该pid进程被oom killer杀掉的权重，介于 [-17,15]之间，越高的权重，意味着更可能被oom killer选中，-17表示禁止被kill掉。默认为0.</p>

<p>一些其他的细节:</p>

<pre><code>1.子进程会继承父进程的oom_adj;
2.OOM不适合于解决内存泄漏(Memory leak)的问题;
3.有时free查看还有充足的内存，但还是会触发OOM，是因为该进程可能占用了特殊的内存地址空间;
</code></pre>

<h3>2.2 如何关闭oomkiller</h3>

<p>有几种方法关闭oomkiller机制:</p>

<ul>
<li>1.调整oom_adj
将进程的oom_adj设置为17即禁止了该进程被kill.</li>
</ul>


<p>比如系统的ssh一般是禁止oom的:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[baoqiu.xiao@ ~]$ ps aux | grep sshd
</span><span class='line'>root      1208  0.0  0.0  64116   296 ?        Ss   May28   1:47 /usr/sbin/sshd
</span><span class='line'>[baoqiu.xiao@ ~]$ cat /proc/1208/oom_adj 
</span><span class='line'>-17</span></code></pre></td></tr></table></div></figure>


<p>其他需要禁用,可以如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pgrep -f "sshd" | while read PID; do echo -17 &gt; /proc/$PID/oom_adj;done</span></code></pre></td></tr></table></div></figure>


<p>其实在oom-killer的日志中我们是可以看到未-17的一些应用:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Aug  5 01:35:52 l-crm4.des.dev.cn0 kernel: [ pid ]   uid  tgid total_vm      rss cpu oom_adj oom_score_adj name
</span><span class='line'>...
</span><span class='line'>Aug  5 01:35:52 l-crm4.des.dev.cn0 kernel: [ 1187]     0  1187    16029       73   2     -17         -1000 sshd
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>2.修改内核参数
sysctl 下有2个可配置选项：</p>

<p>  vm.panic_on_oom = 0                 #内存不够时内核是否直接panic,0表示开启
  vm.oom_kill_allocating_task = 1         #oom-killer是否选择当前正在申请内存的进程进行kill</p></li>
</ul>


<p>只要设置/etc/sysctl.conf文件中vm.panic_on_oom=1就表示关闭oom-killer(线上环境一般不推荐):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># sysctl -w vm.panic_on_oom=1
</span><span class='line'>vm.panic_on_oom = 1   //1表示关闭，默认为0表示开启OOM
</span><span class='line'># sysctl -p</span></code></pre></td></tr></table></div></figure>


<p>参考: <a href="http://lwn.net/Articles/317814/">http://lwn.net/Articles/317814/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[反射的效率]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/08/03/fan-she-de-xiao-lu/"/>
    <updated>2015-08-03T20:54:57+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/08/03/fan-she-de-xiao-lu</id>
    <content type="html"><![CDATA[<h1>1.toString实现</h1>

<p>测试不同的toString实现方式的效率，目前包括的case：</p>

<pre><code>1.String的+连接生成；
2.StringBuilder生成；
3.StringBuffer生成；
4.Guava的ToStringHelper生成；
5.Apache.commons.lang3的lang3的ToStringBuilder生成;
6.Apache.commons.lang3的ReflectionToStringBuilder生成;
</code></pre>

<p>toString的对象包含各种类型的属性：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private int age;
</span><span class='line'>
</span><span class='line'>private String name;
</span><span class='line'>
</span><span class='line'>private String address;
</span><span class='line'>
</span><span class='line'>private List&lt;String&gt; phone;
</span><span class='line'>
</span><span class='line'>private BigDecimal salary;
</span><span class='line'>
</span><span class='line'>private Map&lt;String, Object&gt; attrs;</span></code></pre></td></tr></table></div></figure>


<p>各个toString的实现版本，其中ReflectionToStringBuilder是我们项目中使用最多的，因为它最简单：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> * 使用字符串+
</span><span class='line'> * @return
</span><span class='line'> */
</span><span class='line'>public String concatToString() {
</span><span class='line'>    return "Person{" +
</span><span class='line'>            "age=" + age +
</span><span class='line'>            ", name='" + name + '\'' +
</span><span class='line'>            ", address='" + address + '\'' +
</span><span class='line'>            ", phone=" + phone +
</span><span class='line'>            ", salary=" + salary +
</span><span class='line'>            ", attrs=" + attrs +
</span><span class='line'>            '}';
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/**
</span><span class='line'> * 使用StringBuilder
</span><span class='line'> * @return
</span><span class='line'> */
</span><span class='line'>public String stringBuilderToString() {
</span><span class='line'>    StringBuilder builder = new StringBuilder("Person{");
</span><span class='line'>    builder.append("age=").append(age)
</span><span class='line'>            .append(", name='").append(name).append("'")
</span><span class='line'>            .append(", address='").append(address).append("'")
</span><span class='line'>            .append(", phone=").append(phone)
</span><span class='line'>            .append(", salary=").append(salary)
</span><span class='line'>            .append(", attrs=").append(attrs)
</span><span class='line'>            .append("}");
</span><span class='line'>    return builder.toString();
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/**
</span><span class='line'> * 使用StringBuffer
</span><span class='line'> * @return
</span><span class='line'> */
</span><span class='line'>public String stringBufferToString() {
</span><span class='line'>    StringBuffer buffer = new StringBuffer("Person{");
</span><span class='line'>    buffer.append("age=").append(age)
</span><span class='line'>            .append(", name='").append(name).append("'")
</span><span class='line'>            .append(", address='").append(address).append("'")
</span><span class='line'>            .append(", phone=").append(phone)
</span><span class='line'>            .append(", salary=").append(salary)
</span><span class='line'>            .append(", attrs=").append(attrs)
</span><span class='line'>            .append("}");
</span><span class='line'>    return buffer.toString();
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/**
</span><span class='line'> * Guava的Objects,即ToStringHelper
</span><span class='line'> * @return
</span><span class='line'> */
</span><span class='line'>public String toStringHelperToString() {
</span><span class='line'>    return Objects.toStringHelper(this)
</span><span class='line'>            .add("age", age)
</span><span class='line'>            .add("name", name)
</span><span class='line'>            .add("address", address)
</span><span class='line'>            .add("phone", phone)
</span><span class='line'>            .add("salary", salary)
</span><span class='line'>            .add("attrs", attrs)
</span><span class='line'>            .toString();
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/**
</span><span class='line'> * apache.commons.lang3的ToStringBuilder
</span><span class='line'> * @return
</span><span class='line'> */
</span><span class='line'>public String toStringBuilderToString() {
</span><span class='line'>    return new ToStringBuilder(this)
</span><span class='line'>            .append("age", age)
</span><span class='line'>            .append("name", name)
</span><span class='line'>            .append("address", address)
</span><span class='line'>            .append("phone", phone)
</span><span class='line'>            .append("salary", salary)
</span><span class='line'>            .append("attrs", attrs)
</span><span class='line'>            .toString();
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/**
</span><span class='line'> * apache.commons.lang3的ReflectionToStringBuilder
</span><span class='line'> * @return
</span><span class='line'> */
</span><span class='line'>public String reflectionToStringBuilderToString() {
</span><span class='line'>    return ReflectionToStringBuilder.reflectionToString(this, ToStringStyle.SIMPLE_STYLE);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>OS是Ubuntu 14.04 LTS版本，Java版本是1.7.0_80。跑1000次，记录最大最小平均时间:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Concat Min(微秒)=25.385
</span><span class='line'>Concat Max(微秒)=2218.851
</span><span class='line'>Concat Avg(微秒)=56.728432999999995
</span><span class='line'>
</span><span class='line'>StringBuilder Min(微秒)=22.501
</span><span class='line'>StringBuilder Max(微秒)=6934.066
</span><span class='line'>StringBuilder Avg(微秒)=50.724183
</span><span class='line'>
</span><span class='line'>StringBuffer Min(微秒)=29.553
</span><span class='line'>StringBuffer Max(微秒)=3159.808
</span><span class='line'>StringBuffer Avg(微秒)=64.113464
</span><span class='line'>
</span><span class='line'>ToStringHelper Min(微秒)=44.893
</span><span class='line'>ToStringHelper Max(微秒)=9503.836
</span><span class='line'>ToStringHelper Avg(微秒)=112.351293
</span><span class='line'>
</span><span class='line'>ToStringBuilder Min(微秒)=62.806
</span><span class='line'>ToStringBuilder Max(微秒)=20228.186
</span><span class='line'>ToStringBuilder Avg(微秒)=194.728656
</span><span class='line'>
</span><span class='line'>ReflectionToStringBuilder Min(微秒)=37.057
</span><span class='line'>ReflectionToStringBuilder Max(微秒)=11402.172
</span><span class='line'>ReflectionToStringBuilder Avg(微秒)=219.219879</span></code></pre></td></tr></table></div></figure>


<p>整理成表格，数据如下：</p>

<table>
<thead>
<tr>
<th style="text-align:center;">toString策略 </th>
<th style="text-align:center;"> 平均(微秒) </th>
<th style="text-align:center;"> 最大(微秒) </th>
<th style="text-align:center;"> 最小(微秒)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">Concat </td>
<td style="text-align:center;">56.728433  </td>
<td style="text-align:center;">2218.851 </td>
<td style="text-align:center;"> 25.385</td>
</tr>
<tr>
<td style="text-align:center;">StringBuilder </td>
<td style="text-align:center;">50.724183  </td>
<td style="text-align:center;">6934.066 </td>
<td style="text-align:center;"> 22.501</td>
</tr>
<tr>
<td style="text-align:center;">StringBuffer </td>
<td style="text-align:center;">64.113464  </td>
<td style="text-align:center;">3159.808 </td>
<td style="text-align:center;"> 29.553</td>
</tr>
<tr>
<td style="text-align:center;">ToStringHelper </td>
<td style="text-align:center;">112.351293  </td>
<td style="text-align:center;">9503.836 </td>
<td style="text-align:center;"> 44.893</td>
</tr>
<tr>
<td style="text-align:center;">ToStringBuilder </td>
<td style="text-align:center;">194.728656  </td>
<td style="text-align:center;">20228.186 </td>
<td style="text-align:center;"> 62.806</td>
</tr>
<tr>
<td style="text-align:center;">ReflectionToStringBuilder </td>
<td style="text-align:center;">219.219879  </td>
<td style="text-align:center;">11402.172 </td>
<td style="text-align:center;"> 37.057</td>
</tr>
</tbody>
</table>


<p>通过上面的数据，concat和StringBuilder及StringBuffer的速度差不多。其他集中语法糖普遍慢一些，我们最常用的ReflectionToStringBuilder实际上是最慢的一个版本。</p>

<h3>1.1 实现原理</h3>

<p>简单分析一下各个toString方式的实现原理。</p>

<ul>
<li>1.Concat</li>
</ul>


<p>没什么说的，使用的是字符串的拼接。</p>

<ul>
<li>2.StringBuilder</li>
</ul>


<p>内部使用char数组，每次append都会先检查数组空间释放足够，不够的话先申请一块临时数组，大小是原来的两倍大小，再用Arrays.copyOf将数据拷贝。</p>

<ul>
<li>3.StringBuffer</li>
</ul>


<p>和StringBuilder一样，也是继承自AbstractStringBuilder类，唯一区别是为了保证线程安全，变更数据的方法都加上了synchronized关键字。</p>

<ul>
<li>4.ToStringHelper</li>
</ul>


<p>Guava的ToStringHelper内部实现是一个简单链表，每个链表节点包含name，value以及下一个节点的指针。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private static final class ValueHolder {
</span><span class='line'>        String name;
</span><span class='line'>        Object value;
</span><span class='line'>        Objects.ToStringHelper.ValueHolder next;
</span><span class='line'>
</span><span class='line'>        private ValueHolder() {
</span><span class='line'>        }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>ToStringHelper类持有链表头节点和尾节点。每次调用add都是在链表尾部加一个节点，toString() 的时候遍历整个链表讲内容加到一个StringBuilder中。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static final class ToStringHelper {
</span><span class='line'>    private final String className;
</span><span class='line'>    private Objects.ToStringHelper.ValueHolder holderHead;
</span><span class='line'>    private Objects.ToStringHelper.ValueHolder holderTail;
</span><span class='line'>
</span><span class='line'>    public Objects.ToStringHelper add(String name, long value) {
</span><span class='line'>        return this.addHolder(name, String.valueOf(value));
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    private Objects.ToStringHelper addHolder(String name, @Nullable Object value) {
</span><span class='line'>        Objects.ToStringHelper.ValueHolder valueHolder = this.addHolder();
</span><span class='line'>        valueHolder.value = value;
</span><span class='line'>        valueHolder.name = (String)Preconditions.checkNotNull(name);
</span><span class='line'>        return this;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    private Objects.ToStringHelper.ValueHolder addHolder() {
</span><span class='line'>        Objects.ToStringHelper.ValueHolder valueHolder = new Objects.ToStringHelper.ValueHolder();
</span><span class='line'>        this.holderTail = this.holderTail.next = valueHolder;
</span><span class='line'>        return valueHolder;
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<ul>
<li>5.ToStringBuilder</li>
</ul>


<p>ToStringBuilder内部使用一个StringBuffer，默认大小为512.另外一个style设定来toString的样式，每次执行append都跳转到对应的ToStringStyle的append函数实现上，并将当前的StringBuffer带过去(StringBuffer来存储数据，ToStringStyle来保证格式)：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class ToStringBuilder implements Builder&lt;String&gt; {
</span><span class='line'>    private static volatile ToStringStyle defaultStyle;
</span><span class='line'>    private final StringBuffer buffer;
</span><span class='line'>    private final Object object;
</span><span class='line'>    private final ToStringStyle style;
</span><span class='line'>
</span><span class='line'>    static {
</span><span class='line'>    defaultStyle = ToStringStyle.DEFAULT_STYLE;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public ToStringBuilder append(String fieldName, int value) {
</span><span class='line'>        this.style.append(this.buffer, fieldName, value);
</span><span class='line'>        return this;
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>ToStringStyle的append实现，每个append都很简单，就是往StringBuffer中append数据：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void append(StringBuffer buffer, String fieldName, int value) {
</span><span class='line'>    this.appendFieldStart(buffer, fieldName);
</span><span class='line'>    this.appendDetail(buffer, fieldName, value);
</span><span class='line'>    this.appendFieldEnd(buffer, fieldName);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>protected void appendDetail(StringBuffer buffer, String fieldName, int value) {
</span><span class='line'>    buffer.append(value);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>6.ReflectionToStringBuilder</li>
</ul>


<p>ReflectionToStringBuilder实际上是继承自ToStringBuilder，每次都构建一个ReflectionToStringBuilder对象，toString的实现是使用反射完成，首先反射当前类的所以属性，再逐级往上获取父类并反射获取其属性,每拿到一个属性，调用一次ToStringBuilder的append方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static &lt;T&gt; String toString(
</span><span class='line'>        final T object, final ToStringStyle style, final boolean outputTransients,
</span><span class='line'>        final boolean outputStatics, final Class&lt;? super T&gt; reflectUpToClass) {
</span><span class='line'>    return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)
</span><span class='line'>            .toString();
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public String toString() {
</span><span class='line'>        if (this.getObject() == null) {
</span><span class='line'>            return this.getStyle().getNullText();
</span><span class='line'>        }
</span><span class='line'>        Class&lt;?&gt; clazz = this.getObject().getClass();
</span><span class='line'>        this.appendFieldsIn(clazz);
</span><span class='line'>        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {
</span><span class='line'>            clazz = clazz.getSuperclass();
</span><span class='line'>            this.appendFieldsIn(clazz);
</span><span class='line'>        }
</span><span class='line'>        return super.toString();
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    protected void appendFieldsIn(final Class&lt;?&gt; clazz) {
</span><span class='line'>        if (clazz.isArray()) {
</span><span class='line'>            this.reflectionAppendArray(this.getObject());
</span><span class='line'>            return;
</span><span class='line'>        }
</span><span class='line'>        final Field[] fields = clazz.getDeclaredFields();
</span><span class='line'>        AccessibleObject.setAccessible(fields, true);
</span><span class='line'>        for (final Field field : fields) {
</span><span class='line'>            final String fieldName = field.getName();
</span><span class='line'>            if (this.accept(field)) {
</span><span class='line'>                try {
</span><span class='line'>                    // Warning: Field.get(Object) creates wrappers objects
</span><span class='line'>                    // for primitive types.
</span><span class='line'>                    final Object fieldValue = this.getValue(field);
</span><span class='line'>                    this.append(fieldName, fieldValue);
</span><span class='line'>                } catch (final IllegalAccessException ex) {
</span><span class='line'>                    //this can't happen. Would get a Security exception
</span><span class='line'>                    // instead
</span><span class='line'>                    //throw a runtime exception in case the impossible
</span><span class='line'>                    // happens.
</span><span class='line'>                    throw new InternalError("Unexpected IllegalAccessException: " + ex.getMessage());
</span><span class='line'>                }
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<h1>2.beanCopy</h1>

<p>beanCopy由很多种方式，Spring和Apache都有实现版本，这里测试各个版本的性能.包括：</p>

<pre><code>1.原始的get/set
2.Spring的BeanUtils
3.cglib的BeanCopier
4.apache的BeanUtils
5.apache的PropertyUtils
</code></pre>

<p>原因是前段时间项目上很简单的接口时间很慢，最后同事跟到的问题是使用Spring的beanCopy方式，因为接口涉及上百个bean的属性拷贝，因此比较明显的反应了各种beancopy实现方式的差异；我们最常用的应该是Spring版本的BeanUtils。apache的BeanUtils的设计有点反人类(第一个参数是dest，第二个参数是source)。</p>

<p>各个包的版本：</p>

<pre><code>1.Spring : 3.2.1
2.cglib : 3.1
3.commons-beanutils : 1.9.2
</code></pre>

<p>各种方式的实现很简单：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class GetSetCopy {
</span><span class='line'>    public static HotelVo copy(HotelEntity entity) {
</span><span class='line'>        HotelVo vo = new HotelVo();
</span><span class='line'>        vo.setId(entity.getId());
</span><span class='line'>        vo.setName(entity.getName());
</span><span class='line'>        vo.setAddress(entity.getAddress());
</span><span class='line'>        vo.setPhone(entity.getPhone());
</span><span class='line'>        vo.setCreateTime(entity.getCreateTime());
</span><span class='line'>        vo.setUpdateTime(entity.getUpdateTime());
</span><span class='line'>        vo.setPrice(entity.getPrice());
</span><span class='line'>        vo.setKp(entity.getKp());
</span><span class='line'>
</span><span class='line'>        return vo;
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public class ApacheBeanUtilsCopy {
</span><span class='line'>    public static HotelVo copy(HotelEntity entity) throws Exception {
</span><span class='line'>        HotelVo vo = new HotelVo();
</span><span class='line'>        BeanUtils.copyProperties(vo, entity);
</span><span class='line'>        return vo;
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public class ApachePropertyUtilsCopy {
</span><span class='line'>    public static HotelVo copy(HotelEntity entity) throws Exception {
</span><span class='line'>        HotelVo vo = new HotelVo();
</span><span class='line'>        PropertyUtils.copyProperties(vo, entity);
</span><span class='line'>        return vo;
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public class CglibBeanCopy {
</span><span class='line'>    public static HotelVo copy(HotelEntity entity) {
</span><span class='line'>        HotelVo vo = new HotelVo();
</span><span class='line'>        BeanCopier copier = BeanCopier.create(entity.getClass(), HotelVo.class, false);
</span><span class='line'>        copier.copy(entity, vo, null);
</span><span class='line'>        return vo;
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public class SpringBeanUtilsCopy {
</span><span class='line'>    public static HotelVo copy(HotelEntity entity) {
</span><span class='line'>        HotelVo vo = new HotelVo();
</span><span class='line'>        BeanUtils.copyProperties(entity, vo);
</span><span class='line'>        return vo;
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>测试的一个结果，每个copy运行10000次(各个Copy的第一次copy都很慢，跑10000次基本可以抹平这些差异)：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GetSetCopy Min(微秒)=1.466
</span><span class='line'>GetSetCopy Max(微秒)=804.236
</span><span class='line'>GetSetCopy Avg(微秒)=1.7923529
</span><span class='line'>
</span><span class='line'>Spring-BeanUtils Min(微秒)=3.339
</span><span class='line'>Spring-BeanUtils Max(微秒)=99795.719
</span><span class='line'>Spring-BeanUtils Avg(微秒)=28.2915534
</span><span class='line'>
</span><span class='line'>Apache-BeanUtils Min(微秒)=9.812
</span><span class='line'>Apache-BeanUtils Max(微秒)=92416.696
</span><span class='line'>Apache-BeanUtils Avg(微秒)=79.0868131
</span><span class='line'>
</span><span class='line'>Apache-PropertyUtils Min(微秒)=7.083
</span><span class='line'>Apache-PropertyUtils Max(微秒)=6405.457
</span><span class='line'>Apache-PropertyUtils Avg(微秒)=22.114272
</span><span class='line'>
</span><span class='line'>Cglib-BeanCopy Min(微秒)=7.707
</span><span class='line'>Cglib-BeanCopy Max(微秒)=156932.173
</span><span class='line'>Cglib-BeanCopy Avg(微秒)=33.135989</span></code></pre></td></tr></table></div></figure>


<table>
<thead>
<tr>
<th style="text-align:center;">copy策略 </th>
<th style="text-align:center;"> 平均(微秒) </th>
<th style="text-align:center;"> 最大(微秒) </th>
<th style="text-align:center;"> 最小(微秒)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">GetSet </td>
<td style="text-align:center;">1.7923529  </td>
<td style="text-align:center;">804.236 </td>
<td style="text-align:center;"> 1.466</td>
</tr>
<tr>
<td style="text-align:center;">Spring-BeanUtils </td>
<td style="text-align:center;">28.2915534  </td>
<td style="text-align:center;">99795.719</td>
<td style="text-align:center;"> 3.339</td>
</tr>
<tr>
<td style="text-align:center;">Apache-BeanUtils </td>
<td style="text-align:center;">79.0868131 </td>
<td style="text-align:center;">6405.457 </td>
<td style="text-align:center;"> 9.812</td>
</tr>
<tr>
<td style="text-align:center;">Apache-PropertyUtils </td>
<td style="text-align:center;">22.114272  </td>
<td style="text-align:center;">9503.836 </td>
<td style="text-align:center;"> 7.083</td>
</tr>
<tr>
<td style="text-align:center;">Cglib-BeanCopy </td>
<td style="text-align:center;">33.135989  </td>
<td style="text-align:center;">156932.173</td>
<td style="text-align:center;"> 7.707</td>
</tr>
</tbody>
</table>


<p>原始的get/set是最快的，而且是快一个数量级。Apache-BeanUtils是最慢的。Spring-BeanUtils的性能还是比其他几个强一些（这是个错觉，其实Cglib-BeanCopy比Spring-BeanUtils快，见下面的分析）。</p>

<h3>2.1 实现原理</h3>

<p>简单分析一下各个bean copy方式的实现原理。</p>

<ul>
<li>1.原始的get/set</li>
</ul>


<p>没什么好说的，最原始。</p>

<ul>
<li>2.Spring的BeanUtils</li>
</ul>


<p>Spring的BeanUtils可以使用String [] ignoreProperties 指定忽略某些属性的复制，当我们需要手动处理一些特定属性的时候挺有用。</p>

<p>copyProperties的原理很我们想想的一样：</p>

<pre><code>1.获取target类的属性列表；
2.循环遍历target属性，对每个属性，如果由write方法并且不在ignoreProperties里面，调用soure对应属性的read方法获取属性值，再调用target的write方法；
</code></pre>

<p>细节：</p>

<pre><code>1.缓存
获取target类的属性列表的时候有缓存，见CachedIntrospectionResults类。这也再一定成都上解释了为什么第一次调用会慢一些。
2.Accessible
注意，source的read和target的write方法可以不是Accessible的，即可以是private等修饰的方法；
3.浅拷贝
注意其拷贝是浅拷贝。
</code></pre>

<p>大致的代码(精简了一些)：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private static void copyProperties(Object source, Object target, Class&lt;?&gt; editable, String[] ignoreProperties) throws BeansException {
</span><span class='line'>
</span><span class='line'>        PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable);    //获取target的属性描述符，有缓存
</span><span class='line'>        List ignoreList = ignoreProperties != null?Arrays.asList(ignoreProperties):null;
</span><span class='line'>        PropertyDescriptor[] arr$ = targetPds;
</span><span class='line'>        int len$ = targetPds.length;
</span><span class='line'>
</span><span class='line'>        for(int i$ = 0; i$ &lt; len$; ++i$) {
</span><span class='line'>            PropertyDescriptor targetPd = arr$[i$];
</span><span class='line'>            if(targetPd.getWriteMethod() != null && (ignoreProperties == null || !ignoreList.contains(targetPd.getName()))) {   //有write方法并且不在ignoreProperties中
</span><span class='line'>                PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName());
</span><span class='line'>                if(sourcePd != null && sourcePd.getReadMethod() != null) {
</span><span class='line'>                    try {
</span><span class='line'>                        Method ex = sourcePd.getReadMethod();   //获取source的read方法
</span><span class='line'>                        if(!Modifier.isPublic(ex.getDeclaringClass().getModifiers())) {
</span><span class='line'>                            ex.setAccessible(true);
</span><span class='line'>                        }
</span><span class='line'>
</span><span class='line'>                        Object value = ex.invoke(source, new Object[0]);    //调用source的read方法获取属性对应的value
</span><span class='line'>                        Method writeMethod = targetPd.getWriteMethod();
</span><span class='line'>                        if(!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {
</span><span class='line'>                            writeMethod.setAccessible(true);
</span><span class='line'>                        }
</span><span class='line'>
</span><span class='line'>                        writeMethod.invoke(target, new Object[]{value});    //调用target的write方法
</span><span class='line'>                    } catch (Throwable var15) {
</span><span class='line'>                        throw new FatalBeanException("Could not copy properties from source to target", var15);
</span><span class='line'>                    }
</span><span class='line'>                }
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<ul>
<li>3.cglib的BeanCopier</li>
</ul>


<p>BeanCopier是CGLIB包中的一个工具类，使用基于动态代理机制的方式进行Bean Copy。因为使用生成的子类中的方法进行属性复制，所以会比使用反射机制的复制在效率上会高出很多。前面一直想写一片代理方面的Blog，一直没完成，尽量他会补上，到时候会分析CGLIB的原理。</p>

<p>我们这里的测试结果显示BeanCopier还不如Spring的BeanUtils，原因说BeanCopier.create的创建效率会比较低，所以在使用过程中建议将 BeanCopier.create 创建的对象声明为 static，避免使用中每次都去创建新的 BeanCopier 对象。我测试中发现，如果我们只显示的调用一次create方法，发现起速度明显快于Spring的BeanUtils(起最小值甚至小于get/set方式的最小值)：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GetSetCopy Min(微秒)=1.46
</span><span class='line'>GetSetCopy Max(微秒)=2149.855
</span><span class='line'>GetSetCopy Avg(微秒)=2.0715596
</span><span class='line'>
</span><span class='line'>Spring-BeanUtils Min(微秒)=3.669
</span><span class='line'>Spring-BeanUtils Max(微秒)=101262.127
</span><span class='line'>Spring-BeanUtils Avg(微秒)=29.613658
</span><span class='line'>
</span><span class='line'>Apache-BeanUtils Min(微秒)=10.174
</span><span class='line'>Apache-BeanUtils Max(微秒)=80342.749
</span><span class='line'>Apache-BeanUtils Avg(微秒)=82.383995
</span><span class='line'>
</span><span class='line'>Apache-PropertyUtils Min(微秒)=5.468
</span><span class='line'>Apache-PropertyUtils Max(微秒)=17185.561
</span><span class='line'>Apache-PropertyUtils Avg(微秒)=26.5104518
</span><span class='line'>
</span><span class='line'>Cglib-BeanCopy Min(微秒)=0.745
</span><span class='line'>Cglib-BeanCopy Max(微秒)=130832.581
</span><span class='line'>Cglib-BeanCopy Avg(微秒)=14.6252958</span></code></pre></td></tr></table></div></figure>


<ul>
<li>4.apache的BeanUtils</li>
</ul>


<p>主要代码大致如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void copyProperties(Object dest, Object orig) throws IllegalAccessException, InvocationTargetException {
</span><span class='line'>    BeanUtilsBean.getInstance().copyProperties(dest, orig);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public void copyProperties(Object dest, Object orig) throws IllegalAccessException, InvocationTargetException {
</span><span class='line'>        int i;
</span><span class='line'>        String name;
</span><span class='line'>        Object e;
</span><span class='line'>        if(orig instanceof DynaBean) {  //DynaBean ？？
</span><span class='line'>            DynaProperty[] origDescriptors = ((DynaBean)orig).getDynaClass().getDynaProperties(); 
</span><span class='line'>
</span><span class='line'>            for(i = 0; i &lt; origDescriptors.length; ++i) {
</span><span class='line'>                name = origDescriptors[i].getName();
</span><span class='line'>                if(this.getPropertyUtils().isReadable(orig, name) && this.getPropertyUtils().isWriteable(dest, name)) {
</span><span class='line'>                    e = ((DynaBean)orig).get(name);
</span><span class='line'>                    this.copyProperty(dest, name, e);
</span><span class='line'>                }
</span><span class='line'>            }
</span><span class='line'>        } else if(orig instanceof Map) {    //原始数据是一个Map，即支持从一个Map到target属性的拷贝
</span><span class='line'>            Map var8 = (Map)orig;
</span><span class='line'>            Iterator var10 = var8.entrySet().iterator();
</span><span class='line'>
</span><span class='line'>            while(var10.hasNext()) {
</span><span class='line'>                Entry var11 = (Entry)var10.next();
</span><span class='line'>                String var12 = (String)var11.getKey();
</span><span class='line'>                if(this.getPropertyUtils().isWriteable(dest, var12)) {
</span><span class='line'>                    this.copyProperty(dest, var12, var11.getValue());
</span><span class='line'>                }
</span><span class='line'>            }
</span><span class='line'>        } else { 
</span><span class='line'>            PropertyDescriptor[] var9 = this.getPropertyUtils().getPropertyDescriptors(orig);   //获取target的属性描述符，有缓存
</span><span class='line'>
</span><span class='line'>            for(i = 0; i &lt; var9.length; ++i) {
</span><span class='line'>                name = var9[i].getName();
</span><span class='line'>                //要求source的read方法是Accessible，target的write方法是Accessible
</span><span class='line'>                if(!"class".equals(name) && this.getPropertyUtils().isReadable(orig, name) && this.getPropertyUtils().isWriteable(dest, name)) {
</span><span class='line'>                    try {
</span><span class='line'>                        e = this.getPropertyUtils().getSimpleProperty(orig, name);  //获取source对应属性的value
</span><span class='line'>                        this.copyProperty(dest, name, e);   //设置target对应属性
</span><span class='line'>                    } catch (NoSuchMethodException var7) {
</span><span class='line'>                        ;
</span><span class='line'>                    }
</span><span class='line'>                }
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>细节：</p>

<pre><code>1.BeanUtilsBean实例
BeanUtilsBean需要第一次new实例，因此第一次调用会慢一些。
2.缓存
获取target类的属性列表的时候有缓存，见BeanIntrospectionData类。这也再一定成都上解释了为什么第一次调用会慢一些。
3.Accessible
注意，source的read和target的write方法要求都是Accessible的；
4.浅拷贝
其拷贝是浅拷贝。
</code></pre>

<ul>
<li>5.apache的PropertyUtils
PropertyUtils的实现和BeanUtils的实现基本一致。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void copyProperties(Object dest, Object orig) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException {
</span><span class='line'>    PropertyUtilsBean.getInstance().copyProperties(dest, orig);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public void copyProperties(Object dest, Object orig) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException {
</span><span class='line'>        int i;
</span><span class='line'>        String name;
</span><span class='line'>        Object e;
</span><span class='line'>        if(orig instanceof DynaBean) {
</span><span class='line'>            DynaProperty[] origDescriptors = ((DynaBean)orig).getDynaClass().getDynaProperties();
</span><span class='line'>
</span><span class='line'>            for(i = 0; i &lt; origDescriptors.length; ++i) {
</span><span class='line'>                name = origDescriptors[i].getName();
</span><span class='line'>                if(this.isReadable(orig, name) && this.isWriteable(dest, name)) {
</span><span class='line'>                    try {
</span><span class='line'>                        e = ((DynaBean)orig).get(name);
</span><span class='line'>                        if(dest instanceof DynaBean) {
</span><span class='line'>                            ((DynaBean)dest).set(name, e);
</span><span class='line'>                        } else {
</span><span class='line'>                            this.setSimpleProperty(dest, name, e);
</span><span class='line'>                        }
</span><span class='line'>                    } catch (NoSuchMethodException var9) {
</span><span class='line'>                        if(this.log.isDebugEnabled()) {
</span><span class='line'>                            this.log.debug("Error writing to \'" + name + "\' on class \'" + dest.getClass() + "\'", var9);
</span><span class='line'>                        }
</span><span class='line'>                    }
</span><span class='line'>                }
</span><span class='line'>            }
</span><span class='line'>        } else if(orig instanceof Map) {    //sorcce是一个Map
</span><span class='line'>            Iterator var10 = ((Map)orig).entrySet().iterator();
</span><span class='line'>
</span><span class='line'>            while(true) {
</span><span class='line'>                Entry var12;
</span><span class='line'>                do {
</span><span class='line'>                    if(!var10.hasNext()) {
</span><span class='line'>                        return;
</span><span class='line'>                    }
</span><span class='line'>
</span><span class='line'>                    var12 = (Entry)var10.next();
</span><span class='line'>                    name = (String)var12.getKey();
</span><span class='line'>                } while(!this.isWriteable(dest, name)); //要求target对应属性是Accessible的
</span><span class='line'>
</span><span class='line'>                try {
</span><span class='line'>                    if(dest instanceof DynaBean) {
</span><span class='line'>                        ((DynaBean)dest).set(name, var12.getValue());
</span><span class='line'>                    } else {
</span><span class='line'>                        this.setSimpleProperty(dest, name, var12.getValue());
</span><span class='line'>                    }
</span><span class='line'>                } catch (NoSuchMethodException var8) {
</span><span class='line'>                    if(this.log.isDebugEnabled()) {
</span><span class='line'>                        this.log.debug("Error writing to \'" + name + "\' on class \'" + dest.getClass() + "\'", var8);
</span><span class='line'>                    }
</span><span class='line'>                }
</span><span class='line'>            }
</span><span class='line'>        } else {
</span><span class='line'>            PropertyDescriptor[] var11 = this.getPropertyDescriptors(orig); //获取target对象属性的描述符，有缓存
</span><span class='line'>
</span><span class='line'>            for(i = 0; i &lt; var11.length; ++i) {
</span><span class='line'>                name = var11[i].getName();
</span><span class='line'>                if(this.isReadable(orig, name) && this.isWriteable(dest, name)) {   //要求source的read方法是Accessible，target的write方法是Accessible
</span><span class='line'>                    try {
</span><span class='line'>                        e = this.getSimpleProperty(orig, name); //获取source对应属性的值
</span><span class='line'>                        if(dest instanceof DynaBean) {
</span><span class='line'>                            ((DynaBean)dest).set(name, e);
</span><span class='line'>                        } else {
</span><span class='line'>                            this.setSimpleProperty(dest, name, e);  //设置target对应属性的值
</span><span class='line'>                        }
</span><span class='line'>                    } catch (NoSuchMethodException var7) {
</span><span class='line'>                        if(this.log.isDebugEnabled()) {
</span><span class='line'>                            this.log.debug("Error writing to \'" + name + "\' on class \'" + dest.getClass() + "\'", var7);
</span><span class='line'>                        }
</span><span class='line'>                    }
</span><span class='line'>                }
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<h1>3.问题</h1>

<p>碰到一个小问题，因为涉及到同一个方法的多次调用，发现第一次调用的时间远大于后面的调用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GetSetCopy-1(微秒) : 1114.744
</span><span class='line'>GetSetCopy-2(微秒) : 2.087
</span><span class='line'>GetSetCopy-3(微秒) : 1.684
</span><span class='line'>GetSetCopy-4(微秒) : 1.694
</span><span class='line'>GetSetCopy-5(微秒) : 1.828
</span><span class='line'>GetSetCopy-6(微秒) : 1.742
</span><span class='line'>GetSetCopy-7(微秒) : 1.705
</span><span class='line'>GetSetCopy-8(微秒) : 1.68
</span><span class='line'>GetSetCopy-9(微秒) : 1.669
</span><span class='line'>GetSetCopy-10(微秒) : 1.693</span></code></pre></td></tr></table></div></figure>


<p>怀疑：</p>

<pre><code>1.GetSetCopy类的初始化；
2.拷贝的目标对象类(这里即HotelVo)初始化；
3.方法调用的缓存；
</code></pre>

<p>尝试发现如果调用前先显示的new一个GetSetCopy对象和一个HotelVo对象，可以将第一次的时间下降到50微妙左右。如果再外面显示的调用一次copy方法，则循环内的第一次copy会降到和其他次的拷贝时间一样。</p>

<h3>3.1 原理</h3>

<p>待补充，会涉及到JVM一些JIT的优化等问题，自己也很期待到底什么原因&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mycli]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/08/01/mycli/"/>
    <updated>2015-08-01T10:37:00+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/08/01/mycli</id>
    <content type="html"><![CDATA[<p>相信很多同学都喜欢使用命令行和Mysql交互而不喜欢各种图形化的客户端，我也是其中之一。</p>

<p>使用命令行交互的一个缺点就是没有自动补全等功能，很多时候忘记字段叫什么，不得不去看一下见表语句。</p>

<p>现在Mycli帮我们搞定这个问题了。Mycli是一个自带自动补全和语法高亮的Mysql客户端，也适用于MariaDB和Percona。赶紧使用Mycli替换你所以的alias吧。</p>

<p>Mycli官网：<a href="http://mycli.net/">http://mycli.net/</a></p>

<h1>1.安装</h1>

<p>Linux下可以使用Python的包管理器pip安装，首先你得有pip，我使用的是Ubuntu：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo apt-get install python-pip</span></code></pre></td></tr></table></div></figure>


<p>之后就可以安装Mycli了，可能需要sudo权限，因为它会往python的lib目录下加一些包</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pip install mycli</span></code></pre></td></tr></table></div></figure>


<p>高端的Mac同学使用brew就可以了。</p>

<p>感觉Windows被抛弃，更详细的安装见：<a href="http://mycli.net/install">http://mycli.net/install</a></p>

<p>源代码github地址：<a href="https://github.com/dbcli/mycli">https://github.com/dbcli/mycli</a></p>

<p>使用pg数据库的同学可以使用类似的工具：pgcli</p>

<h1>2.使用</h1>

<p>使用上没啥特别，看看Mycli的手册就可以了，这里将英文简单翻译一下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xiaobaoqiu@xiaobaoqiu:~/Sublime/Sublime2$ mycli --help
</span><span class='line'>Usage: mycli [OPTIONS] [DATABASE]
</span><span class='line'>
</span><span class='line'>Options:
</span><span class='line'>  -h, --host TEXT             数据库host
</span><span class='line'>  -P, --port TEXT             数据库端口. Honors $MYSQL_TCP_PORT
</span><span class='line'>  -u, --user TEXT             用户名
</span><span class='line'>  -S, --socket TEXT       链接数据库使用的socket文件
</span><span class='line'>  -p, --password          密码
</span><span class='line'>  --pass TEXT                 密码
</span><span class='line'>  -v, --version               版本
</span><span class='line'>  -D, --database TEXT         数据库名字
</span><span class='line'>  -R, --prompt TEXT           提示格式(默认: "\t \u@\h:\d&gt; ")
</span><span class='line'>  -l, --logfile FILENAME      将每个查询和查询的结构记录到文件
</span><span class='line'>  --help                      帮助文档</span></code></pre></td></tr></table></div></figure>


<p>一个本机的截图如下：
<img src="http://xiaobaoqiu.github.io/images/mysql/Mycli_usage.png"></p>

<h1>3.配置</h1>

<p>配置文件默认为：~/.myclirc，我们可以简单的看一下配置,都比较简单：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># vi: ft=dosini
</span><span class='line'>[main]
</span><span class='line'>
</span><span class='line'># Enables context sensitive auto-completion. If this is disabled the all
</span><span class='line'># possible completions will be listed.
</span><span class='line'>smart_completion = True
</span><span class='line'>
</span><span class='line'># Multi-line mode allows breaking up the sql statements into multiple lines. If
</span><span class='line'># this is set to True, then the end of the statements must have a semi-colon.
</span><span class='line'># If this is set to False then sql statements can't be split into multiple
</span><span class='line'># lines. End of line (return) is considered as the end of the statement.
</span><span class='line'>multi_line = False
</span><span class='line'>
</span><span class='line'># log_file location.
</span><span class='line'>log_file = ~/.mycli.log
</span><span class='line'>
</span><span class='line'># Default log level. Possible values: "CRITICAL", "ERROR", "WARNING", "INFO"
</span><span class='line'># and "DEBUG".
</span><span class='line'>log_level = INFO
</span><span class='line'>
</span><span class='line'># Timing of sql statments and table rendering.
</span><span class='line'>timing = True
</span><span class='line'>
</span><span class='line'># Table format. Possible values: psql, plain, simple, grid, fancy_grid, pipe,
</span><span class='line'># orgtbl, rst, mediawiki, html, latex, latex_booktabs.
</span><span class='line'># Recommended: psql, fancy_grid and grid.
</span><span class='line'>table_format = psql
</span><span class='line'>
</span><span class='line'># Syntax Style. Possible values: manni, igor, xcode, vim, autumn, vs, rrt,
</span><span class='line'># native, perldoc, borland, tango, emacs, friendly, monokai, paraiso-dark,
</span><span class='line'># colorful, murphy, bw, pastie, paraiso-light, trac, default, fruity
</span><span class='line'>syntax_style = default
</span><span class='line'>
</span><span class='line'># Keybindings: Possible values: emacs, vi
</span><span class='line'>key_bindings = emacs
</span><span class='line'>
</span><span class='line'># MySQL prompt
</span><span class='line'># \t - Product type (Percona, MySQL, Mariadb)
</span><span class='line'># \u - Username
</span><span class='line'># \h - Hostname of the server
</span><span class='line'># \d - Database name
</span><span class='line'>prompt = '\t \u@\h:\d&gt; '</span></code></pre></td></tr></table></div></figure>


<h1>4.源码</h1>

<p>Mycli是python开发的，原因是起基于的prompt_toolkit正是python开发的。</p>

<p>prompt_toolkit的git地址：<a href="https://github.com/jonathanslenders/python-prompt-toolkit.git">https://github.com/jonathanslenders/python-prompt-toolkit.git</a></p>

<p>prompt_toolkit使用著名的Pygments来做语法高亮。相信很多博客系统(包括我使用的octopress)也是使用这个来做语法高亮，突然发现世界这么小&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分词]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/07/17/fen-ci/"/>
    <updated>2015-07-17T01:24:30+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/07/17/fen-ci</id>
    <content type="html"><![CDATA[<p>最近有需求需要使用crate搜索时候的分词功能,正好研究一下搜索中分词相关的基础知识
.</p>

<h1>1.什么是分词</h1>

<h1>2.为什么要分词</h1>

<h1>3.怎么做分词</h1>

<p>参考：<a href="http://my.oschina.net/apdplat/blog/412921">http://my.oschina.net/apdplat/blog/412921</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Crate服务load飙高]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/07/16/cratefu-wu-loadbiao-gao/"/>
    <updated>2015-07-16T05:02:20+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/07/16/cratefu-wu-loadbiao-gao</id>
    <content type="html"><![CDATA[<p>前段时间搜索处理个P3的故障,原因是用户输入超级长的搜索字段,导致crate服务器load飙高,进而对外服务失败.</p>

<p>持续时间约10分钟.但是对我而言,最大的问题是这10分钟内,对crate服务器我什么都做不了.经过这次问题,准备好好看看crate以及背后ES的源码.</p>

<p>虽然解决方案是限制用户输入(这一点和google以及百度做法是一样的,百度的查询限制在38个汉字以内).</p>

<h1>1.like查询</h1>

<p>有问题的字段是name字段,使用crate的简单的like查询.根据官方文档,crate的like查询支持两种通配符:</p>

<pre><code>% : 0个或者多个字符
_ : 单个字符
</code></pre>

<p>需要注意的注意,使用like查询可能导致慢查询.特别是当使用前置通配符开头的like查询.因为这种情况下crate需要去迭代所有行,而不能使用索引.
如果向获取更好的性能,可以考虑使用全文索引.</p>

<p>like参考:<a href="https://crate.io/docs/en/latest/sql/queries.html#like">https://crate.io/docs/en/latest/sql/queries.html#like</a></p>

<p>全文索引参考: <a href="https://crate.io/docs/en/latest/sql/fulltext.html">https://crate.io/docs/en/latest/sql/fulltext.html</a> <a href="https://crate.io/docs/en/latest/sql/ddl.html#fulltext-indices">https://crate.io/docs/en/latest/sql/ddl.html#fulltext-indices</a></p>

<h1>2.crate符取异常日志</h1>

<p>这里贴一下当时crate服务器的异常:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>org.elasticsearch.index.query.QueryParsingException: [merchant_sea] Failed to parse
</span><span class='line'>        at org.elasticsearch.index.query.IndexQueryParserService.parseQuery(IndexQueryParserService.java:370)
</span><span class='line'>        at org.elasticsearch.action.count.TransportCountAction.shardOperation(TransportCountAction.java:187)
</span><span class='line'>        at org.elasticsearch.action.count.CrateTransportCountAction.shardOperation(CrateTransportCountAction.java:119)
</span><span class='line'>        at org.elasticsearch.action.count.CrateTransportCountAction.shardOperation(CrateTransportCountAction.java:49)
</span><span class='line'>        at org.elasticsearch.action.support.broadcast.TransportBroadcastOperationAction$AsyncBroadcastAction$1.run(TransportBroadcastOperationAction.java:171)
</span><span class='line'>        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
</span><span class='line'>        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
</span><span class='line'>        at java.lang.Thread.run(Thread.java:745)
</span><span class='line'>Caused by: org.apache.lucene.util.automaton.TooComplexToDeterminizeException: Determinizing automaton would result in more than 10000 states.
</span><span class='line'>        at org.apache.lucene.util.automaton.Operations.determinize(Operations.java:743)
</span><span class='line'>        at org.apache.lucene.util.automaton.RunAutomaton.&lt;init&gt;(RunAutomaton.java:138)
</span><span class='line'>        at org.apache.lucene.util.automaton.ByteRunAutomaton.&lt;init&gt;(ByteRunAutomaton.java:32)
</span><span class='line'>        at org.apache.lucene.util.automaton.CompiledAutomaton.&lt;init&gt;(CompiledAutomaton.java:203)
</span><span class='line'>        at org.apache.lucene.search.AutomatonQuery.&lt;init&gt;(AutomatonQuery.java:84)
</span><span class='line'>        at org.apache.lucene.search.AutomatonQuery.&lt;init&gt;(AutomatonQuery.java:65)
</span><span class='line'>        at org.apache.lucene.search.WildcardQuery.&lt;init&gt;(WildcardQuery.java:57)
</span><span class='line'>        at org.elasticsearch.index.query.WildcardQueryParser.parse(WildcardQueryParser.java:106)
</span><span class='line'>        at org.elasticsearch.index.query.QueryParseContext.parseInnerQuery(QueryParseContext.java:281)
</span><span class='line'>        at org.elasticsearch.index.query.BoolQueryParser.parse(BoolQueryParser.java:93)
</span><span class='line'>        at org.elasticsearch.index.query.QueryParseContext.parseInnerQuery(QueryParseContext.java:281)
</span><span class='line'>        at org.elasticsearch.index.query.BoolQueryParser.parse(BoolQueryParser.java:93)
</span><span class='line'>        at org.elasticsearch.index.query.QueryParseContext.parseInnerQuery(QueryParseContext.java:281)
</span><span class='line'>        at org.elasticsearch.index.query.BoolQueryParser.parse(BoolQueryParser.java:93)
</span><span class='line'>        at org.elasticsearch.index.query.QueryParseContext.parseInnerQuery(QueryParseContext.java:281)
</span><span class='line'>        at org.elasticsearch.index.query.BoolQueryParser.parse(BoolQueryParser.java:93)
</span><span class='line'>        at org.elasticsearch.index.query.QueryParseContext.parseInnerQuery(QueryParseContext.java:281)
</span><span class='line'>        at org.elasticsearch.index.query.BoolQueryParser.parse(BoolQueryParser.java:93)
</span><span class='line'>        at org.elasticsearch.index.query.QueryParseContext.parseInnerQuery(QueryParseContext.java:281)
</span><span class='line'>        at org.elasticsearch.index.query.IndexQueryParserService.innerParse(IndexQueryParserService.java:382)
</span><span class='line'>        at org.elasticsearch.index.query.IndexQueryParserService.parse(IndexQueryParserService.java:281)
</span><span class='line'>        at org.elasticsearch.index.query.IndexQueryParserService.parse(IndexQueryParserService.java:276)
</span><span class='line'>        at org.elasticsearch.index.query.IndexQueryParserService.parseQuery(IndexQueryParserService.java:354)
</span><span class='line'>        ... 7 more</span></code></pre></td></tr></table></div></figure>


<h1>3.背后的原理</h1>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[系统当前用户]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/07/16/xi-tong-dang-qian-yong-hu/"/>
    <updated>2015-07-16T04:25:57+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/07/16/xi-tong-dang-qian-yong-hu</id>
    <content type="html"><![CDATA[<p>经常需要查看当前服务器哪些用户在登录,以及他们都在干什么.</p>

<p>下面总结一些命令,其中last应该是最常用的命令.</p>

<h1>1.w</h1>

<p>w - Show who is logged on and what they are doing.</p>

<p>主要字段:</p>

<pre><code>LOGIN@: 什么时间登录的
PCPU: 当前进程所用时间
WHAT: 用户当前正在使用的命令
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xiaobaoqiu@xiaobaoqiu:~/octopress$ w
</span><span class='line'> 20:32:42 up  9:59, 15 users,  load average: 1.80, 1.26, 1.17
</span><span class='line'>USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
</span><span class='line'>xiaobaoq tty7     :0               10:34    9:58m 22:26   0.48s init --user
</span><span class='line'>xiaobaoq pts/1    :0               10:35    2:22m  0.12s  0.12s /bin/bash
</span><span class='line'>xiaobaoq pts/2    :0               11:12   44:10   0.26s  0.19s ssh cn6
</span><span class='line'>xiaobaoq pts/7    :0               11:12    9:02m  0.15s  0.09s ssh cn6
</span><span class='line'>xiaobaoq pts/8    :0               11:28    5:56m  0.09s  0.03s ssh cn5
</span><span class='line'>xiaobaoq pts/12   :0               13:09    3:03m  0.30s  0.24s ssh cn0
</span><span class='line'>xiaobaoq pts/13   :0               13:09    3:14m  0.13s  0.07s mysql -h...
</span><span class='line'>xiaobaoq pts/14   :0               13:09    3:00m  1.23s  1.17s ssh cn0
</span><span class='line'>xiaobaoq pts/18   :0               13:09    3:03m  3.42s  3.35s ssh cn0
</span><span class='line'>xiaobaoq pts/20   :0               13:14    3:01m  0.45s  0.39s mysql -h...
</span><span class='line'>xiaobaoq pts/22   :0               13:26    7:01m  0.13s  0.07s ssh cn0
</span><span class='line'>xiaobaoq pts/23   :0               14:02   40:34   0.17s  0.17s /bin/bash
</span><span class='line'>xiaobaoq pts/24   :0               14:03    2.00s  0.23s  0.00s w
</span><span class='line'>xiaobaoq pts/25   :0               14:36    2:02   0.24s  0.18s ssh cn5
</span><span class='line'>xiaobaoq pts/26   :0               17:41    2:47m  0.09s  0.09s /bin/bash</span></code></pre></td></tr></table></div></figure>


<h1>2.who</h1>

<p>who - show who is logged on</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xiaobaoqiu@xiaobaoqiu:~/octopress$ who
</span><span class='line'>xiaobaoqiu tty7         2015-07-15 10:34 (:0)
</span><span class='line'>xiaobaoqiu pts/1        2015-07-15 10:35 (:0)
</span><span class='line'>xiaobaoqiu pts/2        2015-07-15 11:12 (:0)
</span><span class='line'>xiaobaoqiu pts/7        2015-07-15 11:12 (:0)
</span><span class='line'>xiaobaoqiu pts/8        2015-07-15 11:28 (:0)
</span><span class='line'>xiaobaoqiu pts/12       2015-07-15 13:09 (:0)
</span><span class='line'>xiaobaoqiu pts/13       2015-07-15 13:09 (:0)
</span><span class='line'>xiaobaoqiu pts/14       2015-07-15 13:09 (:0)
</span><span class='line'>xiaobaoqiu pts/18       2015-07-15 13:09 (:0)
</span><span class='line'>xiaobaoqiu pts/20       2015-07-15 13:14 (:0)
</span><span class='line'>xiaobaoqiu pts/22       2015-07-15 13:26 (:0)
</span><span class='line'>xiaobaoqiu pts/23       2015-07-15 14:02 (:0)
</span><span class='line'>xiaobaoqiu pts/24       2015-07-15 14:03 (:0)
</span><span class='line'>xiaobaoqiu pts/25       2015-07-15 14:36 (:0)
</span><span class='line'>xiaobaoqiu pts/26       2015-07-15 17:41 (:0)</span></code></pre></td></tr></table></div></figure>


<h1>3.users</h1>

<p>users - print the user names of users currently logged in to the current host</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xiaobaoqiu@xiaobaoqiu:~/octopress$ users
</span><span class='line'>xiaobaoqiu xiaobaoqiu xiaobaoqiu xiaobaoqiu xiaobaoqiu xiaobaoqiu xiaobaoqiu xiaobaoqiu xiaobaoqiu xiaobaoqiu xiaobaoqiu xiaobaoqiu xiaobaoqiu xiaobaoqiu xiaobaoqiu</span></code></pre></td></tr></table></div></figure>


<h1>4.whoami</h1>

<p>whoami - print effective userid</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xiaobaoqiu@xiaobaoqiu:~/octopress$ whoami
</span><span class='line'>xiaobaoqiu
</span><span class='line'>
</span><span class='line'>xiaobaoqiu@xiaobaoqiu:~/octopress$ who am i
</span><span class='line'>xiaobaoqiu pts/24       2015-07-15 14:03 (:0)
</span><span class='line'>
</span><span class='line'>xiaobaoqiu@xiaobaoqiu:~/octopress$ who mom likes
</span><span class='line'>xiaobaoqiu pts/24       2015-07-15 14:03 (:0)</span></code></pre></td></tr></table></div></figure>


<h1>5.id</h1>

<p>id - print real and effective user and group IDs</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xiaobaoqiu@xiaobaoqiu:~/octopress$ id
</span><span class='line'>uid=1000(xiaobaoqiu) gid=1000(xiaobaoqiu) 组=1000(xiaobaoqiu),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),108(lpadmin),124(sambashare)</span></code></pre></td></tr></table></div></figure>


<h1>6.last</h1>

<p>last, lastb - show listing of last logged in users</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xiaobaoqiu@xiaobaoqiu:~/octopress$ last
</span><span class='line'>xiaobaoq pts/26       :0               Wed Jul 15 17:41   still logged in   
</span><span class='line'>xiaobaoq pts/25       :0               Wed Jul 15 14:36   still logged in   
</span><span class='line'>xiaobaoq pts/24       :0               Wed Jul 15 14:03   still logged in   
</span><span class='line'>xiaobaoq pts/23       :0               Wed Jul 15 14:02   still logged in   
</span><span class='line'>xiaobaoq pts/22       :0               Wed Jul 15 13:26   still logged in   
</span><span class='line'>xiaobaoq pts/20       :0               Wed Jul 15 13:14   still logged in   
</span><span class='line'>xiaobaoq pts/20       :0               Wed Jul 15 13:14 - 13:14  (00:00)    
</span><span class='line'>xiaobaoq pts/18       :0               Wed Jul 15 13:09   still logged in   
</span><span class='line'>xiaobaoq pts/14       :0               Wed Jul 15 13:09   still logged in   
</span><span class='line'>xiaobaoq pts/13       :0               Wed Jul 15 13:09   still logged in   
</span><span class='line'>xiaobaoq pts/12       :0               Wed Jul 15 13:09   still logged in   
</span><span class='line'>xiaobaoq pts/8        :0               Wed Jul 15 11:28   still logged in   
</span><span class='line'>xiaobaoq pts/7        :0               Wed Jul 15 11:12   still logged in   
</span><span class='line'>xiaobaoq pts/2        :0               Wed Jul 15 11:12   still logged in   
</span><span class='line'>xiaobaoq pts/1        :0               Wed Jul 15 10:35   still logged in</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux进制转换]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/07/07/linuxjin-zhi-zhuan-huan/"/>
    <updated>2015-07-07T03:27:54+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/07/07/linuxjin-zhi-zhuan-huan</id>
    <content type="html"><![CDATA[<p>经常涉及到进制的转换,比如线上处理问题时候经常需要转换线程id到16进制.</p>

<h1>1.进制转换</h1>

<h3>2.1.shell运算</h3>

<p> Shell 运算把一个数字从给定的进制转换位十进制.如果数字以运算展开式的形式提供,那么假定它带有十进制符号,除非 它前面带有 0（这种情况假定是八进制）或 0x（这种情况假定是十六进制）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xiaobaoqiu@xiaobaoqiu:~/myshell$ echo $((010))
</span><span class='line'>8
</span><span class='line'>xiaobaoqiu@xiaobaoqiu:~/myshell$ echo $((0x10))
</span><span class='line'>16</span></code></pre></td></tr></table></div></figure>


<p>也可以指定 2 到 64 之间的任意进制,超过64进制则不支持.格式如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$((BASE#NUMBER))</span></code></pre></td></tr></table></div></figure>


<p>使用举例如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xiaobaoqiu@xiaobaoqiu:~/myshell$ echo $((2#10))
</span><span class='line'>2
</span><span class='line'>xiaobaoqiu@xiaobaoqiu:~/myshell$ echo $((5#10))
</span><span class='line'>5
</span><span class='line'>xiaobaoqiu@xiaobaoqiu:~/myshell$ echo $((8#10))
</span><span class='line'>8
</span><span class='line'>xiaobaoqiu@xiaobaoqiu:~/myshell$ echo $((10#10))
</span><span class='line'>10
</span><span class='line'>xiaobaoqiu@xiaobaoqiu:~/myshell$ echo $((16#10))
</span><span class='line'>16
</span><span class='line'>xiaobaoqiu@xiaobaoqiu:~/myshell$ echo $((64#10))
</span><span class='line'>64
</span><span class='line'>xiaobaoqiu@xiaobaoqiu:~/myshell$ echo $((100#10))
</span><span class='line'>bash: 100#10: 无效的算数进制 （错误符号是 "100#10"）</span></code></pre></td></tr></table></div></figure>


<h3>2.2.bc</h3>

<p>bc是一种任意精度运算语言,大多数 UNIX/Linux 安装程序都提供.因为它允许您指定输出进制,所以当您需要以十进制以外的进制输出时,这是一种很好的技术.</p>

<p>bc 的特殊变量 ibase 和 obase 分别包含用于输入和输出的进制的值.缺省情况下,都被设置为 10.要执行进制转换,需要改变其中的一个或两个值,然后提供一个数字.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xiaobaoqiu@xiaobaoqiu:~/myshell$ echo 'obase=16; 10' | bc
</span><span class='line'>A
</span><span class='line'>xiaobaoqiu@xiaobaoqiu:~/myshell$ echo 'obase=16; ibase=10; 10' | bc
</span><span class='line'>A
</span><span class='line'>xiaobaoqiu@xiaobaoqiu:~/myshell$ echo 'obase=10; ibase=16; 10' | bc
</span><span class='line'>16</span></code></pre></td></tr></table></div></figure>


<h3>2.3.printf</h3>

<p>格式化参数和C语言的格式一致:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xiaobaoqiu@xiaobaoqiu:~/myshell$ printf "%X\n" 100
</span><span class='line'>64
</span><span class='line'>xiaobaoqiu@xiaobaoqiu:~/myshell$ printf "%d\n" 0x10
</span><span class='line'>16</span></code></pre></td></tr></table></div></figure>


<h1>2.自定义shell</h1>

<p>自己写一个shell,处理多个输入,任意进制到任意进制的转换.通过这个脚本,学习了一下shell处理option的方式.</p>

<p>原理很简单,就是利用上面说道的bc命令.shell脚本如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/bin/bash
</span><span class='line'>while getopts :i:o: opt 
</span><span class='line'>do
</span><span class='line'>        case "$opt" in
</span><span class='line'>        i) #输入的参数的进制
</span><span class='line'>           #echo "Found the -i option,with vale $OPTARG"
</span><span class='line'>           ibase=$OPTARG
</span><span class='line'>           ;;
</span><span class='line'>        o) #输出参数进制
</span><span class='line'>           #echo "Found the -o option,with vale $OPTARG"
</span><span class='line'>           obase=$OPTARG
</span><span class='line'>           ;;
</span><span class='line'>        *) #当有不认识的选项的时候arg为?
</span><span class='line'>           echo "unkonw argument, Usage : "
</span><span class='line'>           echo "$1 -i 10 -o 16 1 2 3 4 5 6 ..."
</span><span class='line'>           exit 1
</span><span class='line'>        esac
</span><span class='line'>done
</span><span class='line'>
</span><span class='line'>#跳过opt参数
</span><span class='line'>shift $[$OPTIND - 1]
</span><span class='line'>
</span><span class='line'>#参数检验
</span><span class='line'>if [ ! $ibase ]; then
</span><span class='line'>    echo "Usage : $0 -i 10 -o 16 1 2 3 4 5 6 ..."
</span><span class='line'>    exit 1
</span><span class='line'>fi
</span><span class='line'>
</span><span class='line'>if [ ! $obase ]; then
</span><span class='line'>    echo "Usage : $0 -i 10 -o 16 1 2 3 4 5 6 ..."
</span><span class='line'>    exit 1
</span><span class='line'>fi
</span><span class='line'>
</span><span class='line'>echo "输入进制:$ibase"
</span><span class='line'>echo "输出进制:$obase"
</span><span class='line'>
</span><span class='line'>#执行进制转换
</span><span class='line'>for i in $@
</span><span class='line'>do
</span><span class='line'>    echo "obase=$obase; ibase=$ibase; $i" |bc
</span><span class='line'>done</span></code></pre></td></tr></table></div></figure>


<h3>1.bc</h3>

<h3>2.bc</h3>

<p>简单使用如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xiaobaoqiu@xiaobaoqiu:~/myshell$ ./trans -i 10 -o 16 100
</span><span class='line'>输入进制:10
</span><span class='line'>输出进制:16
</span><span class='line'>64</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RateLimiter]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/07/02/ratelimiter/"/>
    <updated>2015-07-02T17:24:16+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/07/02/ratelimiter</id>
    <content type="html"><![CDATA[<p>昨天CodeReview的时候看到同时使用RateLimiter这个类用作QPS访问限制.学习一下这个类.</p>

<p>RateLimiter是Guava的concurrent包下的一个用于限制访问频率的类.</p>

<h1>1.限流</h1>

<p>每个API接口都是有访问上限的,当访问频率或者并发量超过其承受范围时候,我们就必须考虑限流来保证接口的可用性或者降级可用性.即接口也需要安装上保险丝,以防止非预期的请求对系统压力过大而引起的系统瘫痪.</p>

<p>通常的策略就是拒绝多余的访问,或者让多余的访问排队等待服务,或者引流.</p>

<p>如果要准确的控制QPS,简单的做法是维护一个单位时间内的Counter,如判断单位时间已经过去,则将Counter重置零.此做法被认为没有很好的处理单位时间的边界,比如在前一秒的最后一毫秒里和下一秒的第一毫秒都触发了最大的请求数,将目光移动一下,就看到在两毫秒内发生了两倍的QPS.</p>

<p><img src="http://xiaobaoqiu.github.io/images/guava/simple_RateLimiter.png"></p>

<h1>2.限流算法</h1>

<p>常用的更平滑的限流算法有两种:漏桶算法和令牌桶算法.</p>

<p>很多传统的服务提供商如华为中兴都有类似的专利,参考:
<a href="http://www.google.com/patents/CN1536815A?cl=zh">http://www.google.com/patents/CN1536815A?cl=zh</a></p>

<h3>2.1 漏桶算法</h3>

<p>漏桶(Leaky Bucket)算法思路很简单,水(请求)先进入到漏桶里,漏桶以一定的速度出水(接口有响应速率),当水流入速度过大会直接溢出(访问频率超过接口响应速率),然后就拒绝请求,可以看出漏桶算法能强行限制数据的传输速率.示意图如下:</p>

<p><img src="http://xiaobaoqiu.github.io/images/guava/rate-limit1.png"></p>

<p>可见这里有两个变量,一个是桶的大小,支持流量突发增多时可以存多少的水(burst),另一个是水桶漏洞的大小(rate)，伪代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>double rate;               // leak rate in calls/s
</span><span class='line'>double burst;              // bucket size in calls
</span><span class='line'>
</span><span class='line'>long refreshTime;          // time for last water refresh
</span><span class='line'>double water;              // water count at refreshTime
</span><span class='line'>
</span><span class='line'>refreshWater() {
</span><span class='line'>    long  now = getTimeOfDay();
</span><span class='line'>    
</span><span class='line'>    //水随着时间流逝,不断流走,最多就流干到0.
</span><span class='line'>    water = max(0, water- (now - refreshTime)*rate); 
</span><span class='line'>    refreshTime = now;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>bool permissionGranted() {
</span><span class='line'>    refreshWater();
</span><span class='line'>    if (water &lt; burst) { // 水桶还没满,继续加1
</span><span class='line'>        water ++;
</span><span class='line'>        return true;
</span><span class='line'>    } else {
</span><span class='line'>        return false;
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>因为漏桶的漏出速率是固定的参数,所以,即使网络中不存在资源冲突(没有发生拥塞),漏桶算法也不能使流突发(burst)到端口速率.因此,漏桶算法对于存在突发特性的流量来说缺乏效率.</p>

<h3>2.2 令牌桶算法</h3>

<p>令牌桶算法(Token Bucket)和 Leaky Bucket 效果一样但方向相反的算法,更加容易理解.随着时间流逝,系统会按恒定1/QPS时间间隔(如果QPS=100,则间隔是10ms)往桶里加入Token(想象和漏洞漏水相反,有个水龙头在不断的加水),如果桶已经满了就不再加了.新请求来临时,会各自拿走一个Token,如果没有Token可拿了就阻塞或者拒绝服务.</p>

<p><img src="http://xiaobaoqiu.github.io/images/guava/token_bucket.JPG"></p>

<p>令牌桶的另外一个好处是可以方便的改变速度. 一旦需要提高速率,则按需提高放入桶中的令牌的速率.
一般会定时(比如100毫秒)往桶中增加一定数量的令牌, 有些变种算法则实时的计算应该增加的令牌的数量.</p>

<h1>3.RateLimiter简介</h1>

<p>Google开源工具包Guava提供了限流工具类RateLimiter,该类基于令牌桶算法(Token Bucket)来完成限流,非常易于使用.RateLimiter经常用于限制对一些物理资源或者逻辑资源的访问速率.它支持两种获取permits接口,一种是如果拿不到立刻返回false,一种会阻塞等待一段时间看能不能拿到.</p>

<p>RateLimiter和Java中的信号量(java.util.concurrent.Semaphore)类似,Semaphore通常用于限制并发量.</p>

<p>源码注释中的一个例子,比如我们有很多任务需要执行,但是我们不希望每秒超过两个任务执行,那么我们就可以使用RateLimiter:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>final RateLimiter rateLimiter = RateLimiter.create(2.0);
</span><span class='line'>void submitTasks(List&lt;Runnable&gt; tasks, Executor executor) {
</span><span class='line'>    for (Runnable task : tasks) {
</span><span class='line'>        rateLimiter.acquire(); // may wait
</span><span class='line'>        executor.execute(task);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>另外一个例子,假如我们会产生一个数据流,然后我们想以每秒5kb的速度发送出去.我们可以每获取一个令牌(permit)就发送一个byte的数据,这样我们就可以通过一个每秒5000个令牌的RateLimiter来实现:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>final RateLimiter rateLimiter = RateLimiter.create(5000.0);
</span><span class='line'>void submitPacket(byte[] packet) {
</span><span class='line'>    rateLimiter.acquire(packet.length);
</span><span class='line'>    networkService.send(packet);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>另外,我们也可以使用非阻塞的形式达到降级运行的目的,即使用非阻塞的tryAcquire()方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if(limiter.tryAcquire()) { //未请求到limiter则立即返回false
</span><span class='line'>    doSomething();
</span><span class='line'>}else{
</span><span class='line'>    doSomethingElse();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h1>4.RateLimiter主要接口</h1>

<p>RateLimiter其实是一个abstract类,但是它提供了几个static方法用于创建RateLimiter:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'>* 创建一个稳定输出令牌的RateLimiter，保证了平均每秒不超过permitsPerSecond个请求
</span><span class='line'>* 当请求到来的速度超过了permitsPerSecond，保证每秒只处理permitsPerSecond个请求
</span><span class='line'>* 当这个RateLimiter使用不足(即请求到来速度小于permitsPerSecond)，会囤积最多permitsPerSecond个请求
</span><span class='line'>*/
</span><span class='line'>public static RateLimiter create(double permitsPerSecond);
</span><span class='line'>
</span><span class='line'>/**
</span><span class='line'>* 创建一个稳定输出令牌的RateLimiter，保证了平均每秒不超过permitsPerSecond个请求
</span><span class='line'>* 还包含一个热身期(warmup period),热身期内，RateLimiter会平滑的将其释放令牌的速率加大，直到起达到最大速率
</span><span class='line'>* 同样，如果RateLimiter在热身期没有足够的请求(unused),则起速率会逐渐降低到冷却状态
</span><span class='line'>* 
</span><span class='line'>* 设计这个的意图是为了满足那种资源提供方需要热身时间，而不是每次访问都能提供稳定速率的服务的情况(比如带缓存服务，需要定期刷新缓存的)
</span><span class='line'>* 参数warmupPeriod和unit决定了其从冷却状态到达最大速率的时间
</span><span class='line'>*/
</span><span class='line'>public static RateLimiter create(double permitsPerSecond, long warmupPeriod, TimeUnit unit);</span></code></pre></td></tr></table></div></figure>


<p>提供了两个获取令牌的方法,不带参数表示获取一个令牌.如果没有令牌则一直等待,返回等待的时间(单位为秒),没有被限流则直接返回0.0:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public double acquire();
</span><span class='line'>
</span><span class='line'>public double acquire(int permits);</span></code></pre></td></tr></table></div></figure>


<p>尝试获取令牌,分为待超时时间和不带超时时间两种:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public boolean tryAcquire();
</span><span class='line'>//尝试获取一个令牌,立即返回
</span><span class='line'>public boolean tryAcquire(int permits);
</span><span class='line'>public boolean tryAcquire(long timeout, TimeUnit unit);
</span><span class='line'>//尝试获取permits个令牌,带超时时间
</span><span class='line'>public boolean tryAcquire(int permits, long timeout, TimeUnit unit);</span></code></pre></td></tr></table></div></figure>


<h1>5.RateLimiter设计</h1>

<p>考虑一下RateLimiter是如何设计的,并且为什么要这样设计.</p>

<p>RateLimiter的主要功能就是提供一个稳定的速率,实现方式就是通过限制请求流入的速度,比如计算请求等待合适的时间阈值.</p>

<p>实现QPS速率的最简单的方式就是记住上一次请求的最后授权时间,然后保证1/QPS秒内不允许请求进入.比如QPS=5,如果我们保证最后一个被授权请求之后的200ms的时间内没有请求被授权,那么我们就达到了预期的速率.如果一个请求现在过来但是最后一个被授权请求是在100ms之前,那么我们就要求当前这个请求等待100ms.按照这个思路,请求15个新令牌(许可证)就需要3秒.</p>

<p>有一点很重要:上面这个设计思路的RateLimiter记忆非常的浅,它的脑容量非常的小,只记得上一次被授权的请求的时间.如果RateLimiter的一个被授权请求q之前很长一段时间没有被使用会怎么样?这个RateLimiter会立马忘记过去这一段时间的利用不足,而只记得刚刚的请求q.</p>

<p>过去一段时间的利用不足意味着有过剩的资源是可以利用的.这种情况下,RateLimiter应该加把劲(speed up for a while)将这些过剩的资源利用起来.比如在向网络中发生数据的场景(限流),过去一段时间的利用不足可能意味着网卡缓冲区是空的,这种场景下,我们是可以加速发送来将这些过程的资源利用起来.</p>

<p>另一方面,过去一段时间的利用不足可能意味着处理请求的服务器对即将到来的请求是准备不足的(less ready for future requests),比如因为很长一段时间没有请求当前服务器的cache是陈旧的,进而导致即将到来的请求会触发一个昂贵的操作(比如重新刷新全量的缓存).</p>

<p>为了处理这种情况,RateLimiter中增加了一个维度的信息,就是过去一段时间的利用不足(past underutilization),代码中使用storedPermits变量表示.当没有利用不足这个变量为0,最大能达到maxStoredPermits(maxStoredPermits表示完全没有利用).因此,请求的令牌可能从两个地方来:</p>

<pre><code>1.过去剩余的令牌(stored permits, 可能没有)
2.现有的令牌(fresh permits,当前这段时间还没用完的令牌)
</code></pre>

<p>我们将通过一个例子来解释它是如何工作的:</p>

<p>对一个每秒产生一个令牌的RateLimiter,每有一个没有使用令牌的一秒,我们就将storedPermits加1,如果RateLimiter在10秒都没有使用,则storedPermits变成10.0.这个时候,一个请求到来并请求三个令牌(acquire(3)),我们将从storedPermits中的令牌为其服务,storedPermits变为7.0.这个请求之后立马又有一个请求到来并请求10个令牌,我们将从storedPermits剩余的7个令牌给这个请求,剩下还需要三个令牌,我们将从RateLimiter新产生的令牌中获取.我们已经知道,RateLimiter每秒新产生1个令牌,就是说上面这个请求还需要的3个请求就要求其等待3秒.</p>

<p>想象一个RateLimiter每秒产生一个令牌,现在完全没有使用(处于初始状态),限制一个昂贵的请求acquire(100)过来.如果我们选择让这个请求等待100秒再允许其执行,这显然很荒谬.我们为什么什么也不做而只是傻傻的等待100秒,一个更好的做法是允许这个请求立即执行(和acquire(1)没有区别),然后将随后到来的请求推迟到正确的时间点.这种策略,我们允许这个昂贵的任务立即执行,并将随后到来的请求推迟100秒.这种策略就是让任务的执行和等待同时进行.</p>

<p>一个重要的结论:RateLimiter不会记最后一个请求,而是即下一个请求允许执行的时间.这也可以很直白的告诉我们到达下一个调度时间点的时间间隔.然后定一个一段时间未使用的Ratelimiter也很简单:下一个调度时间点已经过去,这个时间点和现在时间的差就是Ratelimiter多久没有被使用,我们会将这一段时间翻译成storedPermits.所有,如果每秒钟产生一个令牌(rate==1),并且正好每秒来一个请求,那么storedPermits就不会增长.</p>

<h1>6.RateLimiter主要源码</h1>

<p>RateLimiter定义了两个create函数用于构建不同形式的RateLimiter:</p>

<pre><code>1.public static RateLimiter create(double permitsPerSecond)
用于创建SmoothBursty类型的RateLimiter
2.public static RateLimiter create(double permitsPerSecond, long warmupPeriod, TimeUnit unit)
用于创建
</code></pre>

<p>源码下面以acquire为例子,分析一下RateLimiter如何实现限流:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public double acquire() {
</span><span class='line'>    return acquire(1);
</span><span class='line'>}
</span><span class='line'>public double acquire(int permits) {
</span><span class='line'>    long microsToWait = reserve(permits);
</span><span class='line'>    stopwatch.sleepMicrosUninterruptibly(microsToWait);
</span><span class='line'>    return 1.0 * microsToWait / SECONDS.toMicros(1L);
</span><span class='line'>}
</span><span class='line'>final long reserve(int permits) {
</span><span class='line'>    checkPermits(permits);
</span><span class='line'>    synchronized (mutex()) {    //应对并发情况需要同步
</span><span class='line'>      return reserveAndGetWaitLength(permits, stopwatch.readMicros());
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>final long reserveAndGetWaitLength(int permits, long nowMicros) {
</span><span class='line'>    long momentAvailable = reserveEarliestAvailable(permits, nowMicros);
</span><span class='line'>    return max(momentAvailable - nowMicros, 0);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>下面方法来自RateLimiter的具体实现类SmoothRateLimiter:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>final long reserveEarliestAvailable(int requiredPermits, long nowMicros) {
</span><span class='line'>    resync(nowMicros);  //补充令牌
</span><span class='line'>    long returnValue = nextFreeTicketMicros;
</span><span class='line'>    //这次请求消耗的令牌数目
</span><span class='line'>    double storedPermitsToSpend = min(requiredPermits, this.storedPermits);
</span><span class='line'>    double freshPermits = requiredPermits - storedPermitsToSpend;
</span><span class='line'>
</span><span class='line'>    long waitMicros = storedPermitsToWaitTime(this.storedPermits, storedPermitsToSpend)
</span><span class='line'>        + (long) (freshPermits * stableIntervalMicros);
</span><span class='line'>
</span><span class='line'>    this.nextFreeTicketMicros = nextFreeTicketMicros + waitMicros;
</span><span class='line'>    this.storedPermits -= storedPermitsToSpend;
</span><span class='line'>    return returnValue;
</span><span class='line'>}
</span><span class='line'>private void resync(long nowMicros) {
</span><span class='line'>    // if nextFreeTicket is in the past, resync to now
</span><span class='line'>    if (nowMicros &gt; nextFreeTicketMicros) {
</span><span class='line'>        storedPermits = min(maxPermits,
</span><span class='line'>        storedPermits + (nowMicros - nextFreeTicketMicros) / stableIntervalMicros);
</span><span class='line'>        nextFreeTicketMicros = nowMicros;
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>另外，对于storedPermits的使用，RateLimiter存在两种策略，二者区别主要体现在使用storedPermits时候需要等待的时间。这个逻辑由storedPermitsToWaitTime函数实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> * Translates a specified portion of our currently stored permits which we want to
</span><span class='line'> * spend/acquire, into a throttling time. Conceptually, this evaluates the integral
</span><span class='line'> * of the underlying function we use, for the range of
</span><span class='line'> * [(storedPermits - permitsToTake), storedPermits].
</span><span class='line'> *
</span><span class='line'> * &lt;p&gt;This always holds: {@code 0 &lt;= permitsToTake &lt;= storedPermits}
</span><span class='line'> */
</span><span class='line'>abstract long storedPermitsToWaitTime(double storedPermits, double permitsToTake);</span></code></pre></td></tr></table></div></figure>


<p>存在两种策略就是为了应对我们上面讲到的，存在资源使用不足大致分为两种情况：
    (1).资源确实使用不足，这些剩余的资源我们私海可以使用的；
    (2).提供资源的服务过去还没准备好，比如服务刚启动等；</p>

<p>为此，RateLimiter实际上由两种实现策略，其实现分别见SmoothBursty和SmoothWarmingUp。二者主要的区别就是storedPermitsToWaitTime实现以及maxPermits数量的计算。</p>

<h3>6.1 SmoothBursty</h3>

<p>SmoothBursty使用storedPermits不需要额外等待时间。并且默认maxBurstSeconds未1，因此maxPermits为permitsPerSecond，即最多可以存储1秒的剩余令牌，比如QPS=5，则maxPermits=5.</p>

<p>下面这个RateLimiter的入口就是用来创建SmoothBursty类型的RateLimiter，</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static RateLimiter create(double permitsPerSecond)</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'>     * This implements a "bursty" RateLimiter, where storedPermits are translated to
</span><span class='line'>     * zero throttling. The maximum number of permits that can be saved (when the RateLimiter is
</span><span class='line'>     * unused) is defined in terms of time, in this sense: if a RateLimiter is 2qps, and this
</span><span class='line'>     * time is specified as 10 seconds, we can save up to 2 * 10 = 20 permits.
</span><span class='line'>     */
</span><span class='line'>    static final class SmoothBursty extends SmoothRateLimiter {
</span><span class='line'>        /** The work (permits) of how many seconds can be saved up if this RateLimiter is unused? */
</span><span class='line'>        final double maxBurstSeconds;
</span><span class='line'>
</span><span class='line'>        SmoothBursty(SleepingStopwatch stopwatch, double maxBurstSeconds) {
</span><span class='line'>            super(stopwatch);
</span><span class='line'>            this.maxBurstSeconds = maxBurstSeconds;
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        void doSetRate(double permitsPerSecond, double stableIntervalMicros) {
</span><span class='line'>            double oldMaxPermits = this.maxPermits;
</span><span class='line'>            maxPermits = maxBurstSeconds * permitsPerSecond;
</span><span class='line'>            System.out.println("maxPermits=" + maxPermits);
</span><span class='line'>            if (oldMaxPermits == Double.POSITIVE_INFINITY) {
</span><span class='line'>                // if we don't special-case this, we would get storedPermits == NaN, below
</span><span class='line'>                storedPermits = maxPermits;
</span><span class='line'>            } else {
</span><span class='line'>                storedPermits = (oldMaxPermits == 0.0)
</span><span class='line'>                        ? 0.0 // initial state
</span><span class='line'>                        : storedPermits * maxPermits / oldMaxPermits;
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        long storedPermitsToWaitTime(double storedPermits, double permitsToTake) {
</span><span class='line'>            return 0L;
</span><span class='line'>        }
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>一个简单的使用示意图及解释，下面私海一个QPS=4的SmoothBursty:</p>

<pre><code>(1).t=0,这时候storedPermits=0，请求1个令牌，等待时间=0；
(2).t=1,这时候storedPermits=3，请求3个令牌，等待时间=0；
(3).t=2,这时候storedPermits=4，请求10个令牌，等待时间=0，超前使用了2个令牌；
(4).t=3,这时候storedPermits=0，请求1个令牌，等待时间=0.5；
</code></pre>

<p>代码的输出：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>maxPermits=4.0, storedPermits=7.2E-4, stableIntervalMicros=250000.0, nextFreeTicketMicros=1472
</span><span class='line'>acquire(1), sleepSecond=0.0
</span><span class='line'>
</span><span class='line'>maxPermits=4.0, storedPermits=3.012212, stableIntervalMicros=250000.0, nextFreeTicketMicros=1004345
</span><span class='line'>acquire(3), sleepSecond=0.0
</span><span class='line'>
</span><span class='line'>maxPermits=4.0, storedPermits=4.0, stableIntervalMicros=250000.0, nextFreeTicketMicros=2004668
</span><span class='line'>acquire(10), sleepSecond=0.0
</span><span class='line'>
</span><span class='line'>maxPermits=4.0, storedPermits=0.0, stableIntervalMicros=250000.0, nextFreeTicketMicros=3504668
</span><span class='line'>acquire(1), sleepSecond=0.499591</span></code></pre></td></tr></table></div></figure>


<p><img src="http://xiaobaoqiu.github.io/images/guava/BurstyRateLimiter.png"></p>

<h3>6.2 SmoothWarmingUp</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static final class SmoothWarmingUp extends SmoothRateLimiter {
</span><span class='line'>        private final long warmupPeriodMicros;
</span><span class='line'>        /**
</span><span class='line'>         * The slope of the line from the stable interval (when permits == 0), to the cold interval
</span><span class='line'>         * (when permits == maxPermits)
</span><span class='line'>         */
</span><span class='line'>        private double slope;
</span><span class='line'>        private double halfPermits;
</span><span class='line'>
</span><span class='line'>        SmoothWarmingUp(SleepingStopwatch stopwatch, long warmupPeriod, TimeUnit timeUnit) {
</span><span class='line'>            super(stopwatch);
</span><span class='line'>            this.warmupPeriodMicros = timeUnit.toMicros(warmupPeriod);
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        @Override
</span><span class='line'>        void doSetRate(double permitsPerSecond, double stableIntervalMicros) {
</span><span class='line'>            double oldMaxPermits = maxPermits;
</span><span class='line'>            maxPermits = warmupPeriodMicros / stableIntervalMicros;
</span><span class='line'>            halfPermits = maxPermits / 2.0;
</span><span class='line'>            // Stable interval is x, cold is 3x, so on average it's 2x. Double the time -&gt; halve the rate
</span><span class='line'>            double coldIntervalMicros = stableIntervalMicros * 3.0;
</span><span class='line'>            slope = (coldIntervalMicros - stableIntervalMicros) / halfPermits;
</span><span class='line'>            if (oldMaxPermits == Double.POSITIVE_INFINITY) {
</span><span class='line'>                // if we don't special-case this, we would get storedPermits == NaN, below
</span><span class='line'>                storedPermits = 0.0;
</span><span class='line'>            } else {
</span><span class='line'>                storedPermits = (oldMaxPermits == 0.0)
</span><span class='line'>                        ? maxPermits // initial state is cold
</span><span class='line'>                        : storedPermits * maxPermits / oldMaxPermits;
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        @Override
</span><span class='line'>        long storedPermitsToWaitTime(double storedPermits, double permitsToTake) {
</span><span class='line'>            double availablePermitsAboveHalf = storedPermits - halfPermits;
</span><span class='line'>            long micros = 0;
</span><span class='line'>            // measuring the integral on the right part of the function (the climbing line)
</span><span class='line'>            if (availablePermitsAboveHalf &gt; 0.0) {
</span><span class='line'>                double permitsAboveHalfToTake = min(availablePermitsAboveHalf, permitsToTake);
</span><span class='line'>                micros = (long) (permitsAboveHalfToTake * (permitsToTime(availablePermitsAboveHalf)
</span><span class='line'>                        + permitsToTime(availablePermitsAboveHalf - permitsAboveHalfToTake)) / 2.0);
</span><span class='line'>                permitsToTake -= permitsAboveHalfToTake;
</span><span class='line'>            }
</span><span class='line'>            // measuring the integral on the left part of the function (the horizontal line)
</span><span class='line'>            micros += (stableIntervalMicros * permitsToTake);
</span><span class='line'>            return micros;
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        private double permitsToTime(double permits) {
</span><span class='line'>            return stableIntervalMicros + permits * slope;
</span><span class='line'>        }
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>maxPermits等于热身(warmup)期间能产生的令牌数，比如QPS=4，warmup为2秒，则maxPermits=8.halfPermits为maxPermits的一半.</p>

<p>参考注释中的神图：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> *          ^ throttling
</span><span class='line'> *          |
</span><span class='line'> * 3*stable +                  /
</span><span class='line'> * interval |                 /.
</span><span class='line'> *  (cold)  |                / .
</span><span class='line'> *          |               /  .   &lt;-- "warmup period" is the area of the trapezoid between
</span><span class='line'> * 2*stable +              /   .       halfPermits and maxPermits
</span><span class='line'> * interval |             /    .
</span><span class='line'> *          |            /     .
</span><span class='line'> *          |           /      .
</span><span class='line'> *   stable +----------/  WARM . }
</span><span class='line'> * interval |          .   UP  . } &lt;-- this rectangle (from 0 to maxPermits, and
</span><span class='line'> *          |          . PERIOD. }     height == stableInterval) defines the cooldown period,
</span><span class='line'> *          |          .       . }     and we want cooldownPeriod == warmupPeriod
</span><span class='line'> *          |---------------------------------&gt; storedPermits
</span><span class='line'> *              (halfPermits) (maxPermits)
</span><span class='line'> *</span></code></pre></td></tr></table></div></figure>


<p>下面是我们QPS=4，warmup为2秒时候对应的图。
<img src="http://xiaobaoqiu.github.io/images/guava/SmoothWarmingUp.png"></p>

<p>maxPermits=8，halfPermits=4，和SmoothBursty相同的请求序列：</p>

<pre><code>(1).t=0,这时候storedPermits=8，请求1个令牌，使用1个storedPermits消耗时间=1×(0.75+0.625)/2=0.6875秒；
(2).t=1,这时候storedPermits=8，请求3个令牌，使用3个storedPermits消耗时间=3×(0.75+0.375)/2=1.6875秒(注意已经超过1秒了，意味着下次产生新Permit时间为2.6875)；
(3).t=2,这时候storedPermits=5，请求10个令牌，使用5个storedPermits消耗时间=1×(0.375+0.25)/2+4*0.25=1.3125秒，再加上额外请求的5个新产生的Permit需要消耗=5*0.25=1.25秒，即总共需要耗时2.5625秒，则下一次产生新的Permit时间为2.6875+2.5625=5.25，注意当前请求私海2.6875才返回的，之前一直阻塞；
(4).t=3,因为前一个请求阻塞到2.6875，实际这个请求3.6875才到达RateLimiter，请求1个令牌，storedPermits=0，下一次产生新Permit时间为5.25，因此总共需要等待5.25-3.6875=1.5625秒；
</code></pre>

<p>实际执行结果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>warmupPeriodMicros=2000000
</span><span class='line'>stableIntervalMicros=250000.0, maxPermits=8.0, halfPermits=4.0, coldIntervalMicros=750000.0, slope=125000.0, storedPermits=8.0
</span><span class='line'>
</span><span class='line'>maxPermits=8.0, storedPermits=8.0, stableIntervalMicros=250000.0, nextFreeTicketMicros=1524
</span><span class='line'>acquire(1), sleepSecond=0.0
</span><span class='line'>
</span><span class='line'>maxPermits=8.0, storedPermits=8.0, stableIntervalMicros=250000.0, nextFreeTicketMicros=1001946
</span><span class='line'>acquire(3), sleepSecond=0.0
</span><span class='line'>
</span><span class='line'>maxPermits=8.0, storedPermits=5.0, stableIntervalMicros=250000.0, nextFreeTicketMicros=2689446
</span><span class='line'>acquire(10), sleepSecond=0.687186
</span><span class='line'>
</span><span class='line'>maxPermits=8.0, storedPermits=0.0, stableIntervalMicros=250000.0, nextFreeTicketMicros=5251946
</span><span class='line'>acquire(1), sleepSecond=1.559174</span></code></pre></td></tr></table></div></figure>


<h1>7.其他限流器</h1>

<p>ASP.NET版本的一个比较成熟限流器:WebApiThrottle
参考：<a href="http://www.cnblogs.com/mushroom/archive/2015/07/21/4659200.html">http://www.cnblogs.com/mushroom/archive/2015/07/21/4659200.html</a></p>

<p>参考:
<a href="https://github.com/springside/springside4/wiki/Rate-Limiter">https://github.com/springside/springside4/wiki/Rate-Limiter</a></p>

<p><a href="https://en.wikipedia.org/wiki/Token_bucket">https://en.wikipedia.org/wiki/Token_bucket</a></p>

<p><a href="https://en.wikipedia.org/wiki/Leaky_bucket">https://en.wikipedia.org/wiki/Leaky_bucket</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux文件编码]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/06/30/linuxwen-jian-ge-shi/"/>
    <updated>2015-06-30T03:07:46+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/06/30/linuxwen-jian-ge-shi</id>
    <content type="html"><![CDATA[<p>在多系统直接传输文件经常碰到文件编码的问题.</p>

<h1>1.查看编码</h1>

<p>查看文件的编码有很多种方式</p>

<h3>1.1 file</h3>

<p>file命令输出了文件的格式和编码.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xiaobaoqiu@xiaobaoqiu:~/octopress$ file _config.yml
</span><span class='line'>_config.yml: UTF-8 Unicode text</span></code></pre></td></tr></table></div></figure>


<h3>1.2 vi</h3>

<p>vi打开文件之后,输入:set fileencoding就可以获得文件编码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fileencoding=utf-8</span></code></pre></td></tr></table></div></figure>


<h1>2.转换编码</h1>

<h3>2.1 vi</h3>

<p>使用vi也可以变更文件编码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>:set fileencoding=utf8</span></code></pre></td></tr></table></div></figure>


<h3>2.2 iconv</h3>

<p>使用iconv命令,iconv几个主要参数(man):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>输入/输出格式规范：
</span><span class='line'>-f, --from-code=名称 原始文本编码
</span><span class='line'>-t, --to-code=名称 输出编码
</span><span class='line'>
</span><span class='line'>信息：
</span><span class='line'>-l, --list 列举所有已知的字符集
</span><span class='line'>
</span><span class='line'>输出控制：
</span><span class='line'>-c 从输出中忽略无效的字符
</span><span class='line'>-o, --output=FILE 输出到文件
</span><span class='line'>-s, --silent 关闭警告
</span><span class='line'>--verbose 打印进度信息</span></code></pre></td></tr></table></div></figure>


<p>使用例子,文件infile从GB18030编码转换至UTF-8编码并写入到文件outfile中:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xiaobaoqiu@xiaobaoqiu:~/temp$ cat infile 
</span><span class='line'>���
</span><span class='line'>xiaobaoqiu@xiaobaoqiu:~/temp$ iconv -f GB18030 -t utf-8 infile -o outfile
</span><span class='line'>xiaobaoqiu@xiaobaoqiu:~/temp$ cat outfile 
</span><span class='line'>测试</span></code></pre></td></tr></table></div></figure>


<p>也可以从管道输入,比如直接访问www.google.com.hk,不出意外会是乱码(使用的big5中文编码),可以转换成utf8</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xiaobaoqiu@xiaobaoqiu:~/temp$ curl -l 'www.google.com.hk' | iconv -f big5 -t gbk</span></code></pre></td></tr></table></div></figure>


<p>iconv基于GPL公开源代码,是GNU项目的一部分.目前，libiconv已经包含在C运行时刻库libc.so中。因此，Linux平台上使用iconv库函数的程序，需要包含&lt;iconv.h>文件.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux Swap]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/06/23/linux-swap/"/>
    <updated>2015-06-23T19:35:55+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/06/23/linux-swap</id>
    <content type="html"><![CDATA[<p>最近一台机器出现swap报警,从监控图上也看到swap的使用一直存在.</p>

<p>服务器上只有一个Tomcat应用和一些定时任务.</p>

<h1>1.什么是swap</h1>

<p>inux操作系统将物理内存分为多个小的内存块，称之为页(pages). 当应用请求的物理内存不够分配时，操作系统会将一段时间之内不用的内存页交换至swap分区，从而为应用释放内存空间。</p>

<p>Swap对于系统过来说非常重要：</p>

<pre><code>1.首先，当主内存不够用时，操作系统可以swap out一部分内存页，迅速为当前急需内存的应用或者进程分配内存；
2.其次，某些内存页只在应用初始化阶段用到，之后可能就不再使用了，操作系统可以将这些内存页swap out，从而为应用或者磁盘cache腾出更多的内存空间;
</code></pre>

<h1>2.swap会带来哪些问题</h1>

<p>我们知道，计算机磁盘I/O通常是系统的瓶颈所在。主内存的读写速度是纳秒级别，而磁盘读写速度是毫秒级别，两者相差3、4个数量级。然而，即使是当前广泛使用的SSD，读写速度相比主内存或者CPU cache也相差2、3个数量级。系统发生swap交换越多，那么系统自然也越慢。</p>

<p>特别对于web服务器来说，都是面对用户的交互式应用，因此响应速度尤其重要。如果系统经常因为swap交换而变得响应迟钝，那么用户体验效果可想而知。</p>

<p>总结成一句话：swap分区要有，在关键时刻不至于让你的应用因为内存不够用而被操作系统OOM KILLER干掉；但是不到关键时刻不要进行swap交换，因为这些操作会影响系统的响应速度。</p>

<p>关于swap的swap in和swap out可以从vmstat命令查看(si表示swap in, so表示swap out).参考:
<a href="http://xiaobaoqiu.github.io/blog/2015/01/26/vmstatgong-ju/">http://xiaobaoqiu.github.io/blog/2015/01/26/vmstatgong-ju/</a></p>

<h1>3.查看swap占用</h1>

<p>free命令, 参考:
<a href="http://xiaobaoqiu.github.io/blog/2014/09/04/linux-memory-usage/">http://xiaobaoqiu.github.io/blog/2014/09/04/linux-memory-usage/</a></p>

<h1>4.找到swap占用元凶</h1>

<p>Linux系统中有一个文件smaps文件，记录了当前进程所对应的内存映像信息，路径为/proc/$pid/smaps.以本机的一个线程为例子:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xiaobaoqiu@xiaobaoqiu:~/octopress$ sudo cat /proc/3555/smaps | head -16
</span><span class='line'>00400000-00401000 r-xp 00000000 08:13 3444936                            /usr/local/jdk1.7.0_72/bin/java
</span><span class='line'>Size:                  4 kB
</span><span class='line'>Rss:                   4 kB
</span><span class='line'>Pss:                   4 kB
</span><span class='line'>Shared_Clean:          0 kB
</span><span class='line'>Shared_Dirty:          0 kB
</span><span class='line'>Private_Clean:         4 kB
</span><span class='line'>Private_Dirty:         0 kB
</span><span class='line'>Referenced:            4 kB
</span><span class='line'>Anonymous:             0 kB
</span><span class='line'>AnonHugePages:         0 kB
</span><span class='line'>Swap:                  0 kB
</span><span class='line'>KernelPageSize:        4 kB
</span><span class='line'>MMUPageSize:           4 kB
</span><span class='line'>Locked:                0 kB
</span><span class='line'>VmFlags: rd ex mr mw me dw</span></code></pre></td></tr></table></div></figure>


<p>其中Swap表示这个线程占有Swap的情况.</p>

<p>查看swap的占有情况的脚本,按照占用swap的占用多少从高到底排序:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/bin/bash
</span><span class='line'>
</span><span class='line'>function getswap {
</span><span class='line'>SUM=0
</span><span class='line'>OVERALL=0
</span><span class='line'>for DIR in `find /proc/ -maxdepth 1 -type d | egrep "^/proc/[0-9]"` ; do
</span><span class='line'>PID=`echo $DIR | cut -d / -f 3`
</span><span class='line'>PROGNAME=`ps -p $PID -o comm --no-headers`
</span><span class='line'>for SWAP in `grep Swap $DIR/smaps 2&gt;/dev/null| awk '{ print $2 }'`
</span><span class='line'>do
</span><span class='line'>let SUM=$SUM+$SWAP
</span><span class='line'>done
</span><span class='line'>echo "PID=$PID    Swap used(KB): $SUM    ($PROGNAME )"
</span><span class='line'>let OVERALL=$OVERALL+$SUM
</span><span class='line'>SUM=0
</span><span class='line'>
</span><span class='line'>done
</span><span class='line'>echo "Overall swap used: $OVERALL"
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>getswap|sort -k4nr</span></code></pre></td></tr></table></div></figure>


<p>然后运行:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo ~/check_swap.sh</span></code></pre></td></tr></table></div></figure>


<h1>5.清除被占用的swap</h1>

<p>在我们明确知道哪些进程吃swap以后，接下来的问题就是我们如何释放这些swap，释放swap的意思就是把交换到swap中的数据swap in到物理内存页中。</p>

<pre><code>1.重启吃swap的服务，比如重启一下我们的java进程;
2.swapoff + swapon
这个方法的好处是，不用重启服务，但是需要确保现在有足够的物理内存可以容下从swap中释放出来的数据。下面给出了swapoff和swapon的具体做法，注意看swapoff后和swapon后，free的输出有什么异同;

sudo /sbin/swapoff -a
sudo /sbin/swapon -a

swapoff后，free的输出里，swap分区的大小变为0，占用变为0,也就是说swap分区中的数据已经释放到物理内存中，同时swap分区被禁用。swapon后，free的输出里，swap分区的容量又恢复了
，也就是说swap分区重新被启用了。当然我们可以把这两个命令写到一起：

sudo /sbin/swapoff -a &amp;&amp; sudo /sbin/swapon -a
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mysql InnoDB锁和死锁]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/06/03/mysql-innodbsi-suo/"/>
    <updated>2015-06-03T01:09:23+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/06/03/mysql-innodbsi-suo</id>
    <content type="html"><![CDATA[<p>在使用Mysql的业务中,经常会碰到各种Mysql的死锁.一直以来,都对Mysql的死锁不甚了解,这次我们的发布中也出现了一次死锁,趁这次机会,好好学习一下Mysql的死锁.我们的死锁的讨论是在InnoDB引擎基础上的.</p>

<h1>1.MySQL索引</h1>

<h3>1.1 聚簇索引(Clustered Indexes)</h3>

<p>InnoDB存储引擎的数据组织方式,是聚簇索引表：完整的记录,存储在主键索引中,通过主键索引,就可以获取记录所有的列.</p>

<p>每个InnoDB的表有一个特殊的索引称之为聚簇索引,每行的数据就是存储在聚簇索引中.通常,聚簇索引和主键同义.</p>

<p>当你在你的表上面定义一个主键时,InnoDB将其作为聚簇索引.建议为你的表都创建一个主键.如果没有唯一并且非空的一列或者多列(用来做你的主键),那么可以创建一个自动填充的自增列(比如ID)</p>

<p>如果你的表没有定义主键,MySQL会将第一个所有列都非空的UNIQUE索引作为聚簇索引.</p>

<p>如果你的表不存在这样的UNIQUE索引(见上),InnoDB内部会自动隐式生成一个包含行ID的列并在其上面建立聚簇索引.这一列按行ID排序.行ID是一个6-byte的严格单调自增的字段.因此,按照行在物理上是按照插入顺序排序的.</p>

<p>聚簇所有是如何加速查询的呢?通过聚簇所有访问一行非常快,这是因为在聚簇索引上搜索会直接定位到包含你需要的行的数据所在的页上(page).</p>

<p>参考: <a href="http://dev.mysql.com/doc/refman/5.6/en/innodb-index-types.html">http://dev.mysql.com/doc/refman/5.6/en/innodb-index-types.html</a></p>

<h3>1.2 二级索引(Secondary Indexes)</h3>

<p>除了聚簇索引其他索引都是二级索引.在InnoDB中每个二级索引记录都包含了这一行的主键列和当前这个二级索引包含的列.InnoDB使用二级索引中包含的主键取索引这一行对应的聚簇索引,进而找到这一行完整的数据.</p>

<p>如果主键很长,则二级索引会占有更多的空间,因此建议使用短的列做主键.</p>

<h1>2.MySQL锁</h1>

<p>Innodb具备表锁和行锁,其中表锁是MySQL提供的,跟存储引擎无关;行锁是Innodb存储引擎实现.</p>

<h3>2.1 共享锁和排他锁</h3>

<pre><code>1.共享锁(S)
允许一个事务去读一行,阻止其他事务获得相同数据集的排他锁.
2.排他锁(X)
允许获得排他锁的事务更新数据,阻止其他事务取得相同数据集的共享读锁和排他写锁.
</code></pre>

<p>另外,为了允许行锁和表锁共存,实现多粒度锁机制,InnoDB还有两种内部使用的意向锁(Intention Locks),这两种意向锁都是表锁.</p>

<pre><code>1.意向共享锁(IS)
事务打算给数据行加行共享锁,事务在给一个数据行加共享锁前必须先取得该表的IS锁.
2.意向排他锁(IX)
事务打算给数据行加行排他锁,事务在给一个数据行加排他锁前必须先取得该表的IX锁.
</code></pre>

<p>上面这四种锁的兼容性Conflict表示冲突不能共存,Compatible表示可以共存:</p>

<pre><code>   |     X     |      IX     |      S     |  IS
X  | Conflict  |  Conflict   | Conflict   | Conflict
IX | Conflict  |  Compatible | Conflict   | Compatible
S  | Conflict  |  Conflict   | Compatible | Compatible
IS | Conflict  |  Compatible | Compatible | Compatible
</code></pre>

<h3>2.2 什么时候会加锁</h3>

<pre><code>1.共享锁(S)
    SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE
2.排他锁(X)
    SELECT * FROM table_name WHERE ... FOR UPDATE
</code></pre>

<p>参考: <a href="http://dev.mysql.com/doc/refman/5.6/en/innodb-lock-modes.html">http://dev.mysql.com/doc/refman/5.6/en/innodb-lock-modes.html</a></p>

<h3>2.3 当前请求锁</h3>

<p>使用show engine innodb status命令查看当前请求锁的信息.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>mysql&gt; show engine innodb status \G;</span></code></pre></td></tr></table></div></figure>


<p>可以从information_schema.INNODB_LOCKS表中查看锁的信息.
比如事物A:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>mysql&gt; select * from t;
</span><span class='line'>+----+------+
</span><span class='line'>| id | num  |
</span><span class='line'>+----+------+
</span><span class='line'>| 10 |    0 |
</span><span class='line'>|  1 |    1 |
</span><span class='line'>|  3 |    4 |
</span><span class='line'>|  2 |    7 |
</span><span class='line'>| 11 |    8 |
</span><span class='line'>|  4 |    9 |
</span><span class='line'>+----+------+
</span><span class='line'>6 rows in set (0.00 sec)
</span><span class='line'>
</span><span class='line'>mysql&gt; select * from t where num &lt; 4 lock in share mode;
</span><span class='line'>+----+------+
</span><span class='line'>| id | num  |
</span><span class='line'>+----+------+
</span><span class='line'>| 10 |    0 |
</span><span class='line'>|  1 |    1 |
</span><span class='line'>+----+------+
</span><span class='line'>2 rows in set (0.00 sec)
</span></code></pre></td></tr></table></div></figure>


<p>然后事物B去做插入就可能被阻塞:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>mysql&gt; insert into t(num) values(4);</span></code></pre></td></tr></table></div></figure>


<p>这是很可以查询锁信息:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>mysql&gt; select * from information_schema.INNODB_LOCKS \G;
</span><span class='line'>*************************** 1. row ***************************
</span><span class='line'>    lock_id: 5E05:0:138228:3
</span><span class='line'>lock_trx_id: 5E05
</span><span class='line'>  lock_mode: X,GAP
</span><span class='line'>  lock_type: RECORD
</span><span class='line'> lock_table: `test`.`t`
</span><span class='line'> lock_index: `n`
</span><span class='line'> lock_space: 0
</span><span class='line'>  lock_page: 138228
</span><span class='line'>   lock_rec: 3
</span><span class='line'>  lock_data: 7, 2
</span><span class='line'>*************************** 2. row ***************************
</span><span class='line'>    lock_id: 5E02:0:138228:3
</span><span class='line'>lock_trx_id: 5E02
</span><span class='line'>  lock_mode: S
</span><span class='line'>  lock_type: RECORD
</span><span class='line'> lock_table: `test`.`t`
</span><span class='line'> lock_index: `n`
</span><span class='line'> lock_space: 0
</span><span class='line'>  lock_page: 138228
</span><span class='line'>   lock_rec: 3
</span><span class='line'>  lock_data: 7, 2</span></code></pre></td></tr></table></div></figure>


<h3>2.2 锁的算法(Record Lock,Gap Lock,Next-Key Lock)</h3>

<p>InnoDB有三种类型的行锁:record locks,gap locks和next-key locks:索引锁是在单个索引记录上的锁;区间锁是两个索引记录之间的锁,或者第一个索引之前的锁,或者最后一个索引之后的锁;Next-Key锁是索引锁和该索引之前的gap锁的结合.</p>

<pre><code>1.索引锁(Record Lock)
索引锁总是锁定索引(可能多条),即使表上面没有索引(这种情况,InnoDB会隐式的用自增id创建一个聚簇索引).一级索引只对一级索引加锁,二级索引对二级索引和对应的一级索引加锁.注意记录锁锁的是索引记录,不是具体的数据记录.

2.区间锁(Gap Lock)
锁定索引记录间隙的锁,确保索引记录的间隙不变,间隙锁是针对事务隔离等级是可重复读(Repeatable Read)或以上级别而言的.

间隙锁一般是针对非唯一索引而言的

3.Next-Key Lock
默认情况,InnoDB使用REPEATABLE READ事物隔离级别,并且innodb_locks_unsafe_for_binlog这个系统设置无效.这时InnoDB使用next-key锁来做搜索(searches)和索引扫描(index scans),以此来防止幻读(参考:http://dev.mysql.com/doc/refman/5.6/en/innodb-next-key-locking.html).
</code></pre>

<h3>2.3 区间锁</h3>

<p>区间锁的一个简单例子:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CREATE TABLE `t` (
</span><span class='line'>  `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '自增主键',
</span><span class='line'>  `num` int(11) DEFAULT NULL,
</span><span class='line'>  PRIMARY KEY (`id`),
</span><span class='line'>  KEY `n` (`num`)
</span><span class='line'>) ENGINE=InnoDB DEFAULT CHARSET=utf8
</span><span class='line'>
</span><span class='line'>insert into t(`num`) values(1, 7, 4, 9);
</span><span class='line'>
</span><span class='line'>mysql&gt; select * from t;
</span><span class='line'>+----+------+
</span><span class='line'>| id | num  |
</span><span class='line'>+----+------+
</span><span class='line'>|  1 |    1 |
</span><span class='line'>|  3 |    4 |
</span><span class='line'>|  2 |    7 |
</span><span class='line'>|  4 |    9 |
</span><span class='line'>+----+------+
</span><span class='line'>4 rows in set (0.01 sec)</span></code></pre></td></tr></table></div></figure>


<p>表中现在有4条记录,其中普通索引(二级索引n)生成了5个Gap:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(负无穷, 1), (1, 4), (4, 7), (7, 9), (9, 正无穷)</span></code></pre></td></tr></table></div></figure>


<p>现在Session A以共享锁获取num=4的数据,Session B想要插入数据,就有可能造成锁等待导致超时从而重启事务,因为Session A以共享锁获取num=4的数据,会产生gap锁将区间(1, 4)和区间(4, 7)锁住,因此这两个区间的插入会失败:</p>

<p><img src="http://xiaobaoqiu.github.io/images/mysql/gap_lock.png"></p>

<p>间隙锁在InnoDB的作用就是防止其它事务的插入操作，以此来达到防止幻读的发生。另外，在上面的例子中，我们选择的是一个普通（非唯一）索引字段来测试的，这不是随便选的，因为如果InnoDB扫描的是一个主键、或是一个唯一索引的话，那InnoDB只会采用行锁方式来加锁，而不会使用Next-Key Lock的方式，也就是说不会对索引之间的间隙加锁.</p>

<p>要禁止间隙锁的话，可以把隔离级别降为读已提交，或者开启参数innodb_locks_unsafe_for_binlog.</p>

<p>参考:
<a href="http://www.cnblogs.com/sliverdang/p/3163455.html">http://www.cnblogs.com/sliverdang/p/3163455.html</a></p>

<p><a href="http://ouyanggod.iteye.com/blog/2166215">http://ouyanggod.iteye.com/blog/2166215</a></p>

<p><a href="http://dev.mysql.com/doc/refman/5.6/en/innodb-record-level-locks.html">http://dev.mysql.com/doc/refman/5.6/en/innodb-record-level-locks.html</a></p>

<h1>3.snapshot read和current read</h1>

<p>MySQL的两种read方式:</p>

<pre><code>1.快照读(snapshot read或者consistent read)
快照读,读取的是记录的可见版本(有可能是历史版本),不用加锁;

通常,简单的select操作,属于快照读,不加锁,比如:
```
select * from table where ?
```
2.当前读(current read或者lock read)
当前读,读取的是记录的最新版本,并且,当前读返回的记录,都会加上锁,保证其他事务不会再并发修改这条记录.

特殊的读操作,插入/更新/删除操作,属于当前读,需要加锁.比如:
```
select * from table where ? lock in share mode
select * from table where ? for update
insert into table values (…)
update table set ? where ?
delete from table where ?
```
所有以上的语句,都属于当前读,读取记录的最新版本.并且,读取之后,还需要保证其他并发事务不能修改当前记录,对读取记录加锁.其中,除了第一条语句,对读取记录加S锁 (共享锁)外,其他的操作,都加的是X锁(排它锁).
</code></pre>

<p>总之一句话:有加锁的查询都认为是当前读.</p>

<p>快照读大大的提高了数据读取的并发.快照读的一个简单示意图,快照数据就是当前数据之前的版本数据,可能有多个版本的快照数据,每个快照数据中包含了版本信息(如时间戳等):</p>

<p><img src="http://xiaobaoqiu.github.io/images/mysql/snapshot_read.png"></p>

<p>为什么将插入/更新/删除操作,都归为当前读?可以看看下面这个更新操作,在数据库中的执行流程：</p>

<p><img src="http://xiaobaoqiu.github.io/images/mysql/update-lock.jpg"></p>

<p>从图中,可以看到,一个Update操作的具体流程.当Update SQL被发给MySQL后,MySQL Server会根据where条件,读取第一条满足条件的记录,然后InnoDB引擎会将第一条记录返回,并加锁(current read).待MySQL Server收到这条加锁的记录之后,会再发起一个Update请求,更新这条记录.一条记录操作完成,再读取下一条记录,直至没有满足条件的记录为止.因此,Update操作内部,就包含了一个当前读.同理,Delete操作也一样.Insert操作会稍微有些不同,简单来说,就是Insert操作可能会触发Unique Key的冲突检查,也会进行一个当前读.</p>

<p>注：根据上图的交互,针对一条当前读的SQL语句,InnoDB与MySQL Server的交互,是一条一条进行的,因此,加锁也是一条一条进行的.先对一条满足条件的记录加锁,返回给MySQL Server,做一些DML操作；然后在读取下一条加锁,直至读取完毕.</p>

<h3>3.1不同隔离界别下的snapshot read</h3>

<p>在Read Committed级别下,快照读总是读取被锁定行的最新的快照数据.而在Repeatable Read和Serializable级别,快照读读取的是事物开始时候的行数据版本.</p>

<p>下面是一个简单的例子,一个很简单的表,插入一条数据:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CREATE TABLE `parent` (   `id` int(10) NOT NULL,   PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
</span><span class='line'>
</span><span class='line'>insert into parent (id) values(1);</span></code></pre></td></tr></table></div></figure>


<p>我们起两个事务,一个读取(Session A),一个更新(Session B),用来验证不同事务隔离级别下快照读的差异:</p>

<pre><code>1.Session A中首先开始事物,查询id=1的数据,这时候,无论在Read Committed还是Repeatable Read级别,结果都是1;
2.Session B然后开始事物,并执行update操作,没有commit;
3.这时候Session A再查询id=1的数据,显然Read Committed还是Repeatable Read级别,结果都是1;(在Read Uncommited灰度到未提交的脏数据).
4.Session B提交事物;
5.这时候Session A再查询id=1的数据,就发现差异:Read Committed级别下读取到被修改的数据,而Repeatable Read读取的还是老数据.因为Read Committed只读取最新的快照数据,而Repeatable Read是参考当前事物开始时间来读取快照数据.
</code></pre>

<p>首先是Repeatable Read的结果:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>mysql&gt; SELECT @@session.tx_isolation;
</span><span class='line'>+------------------------+
</span><span class='line'>| @@session.tx_isolation |
</span><span class='line'>+------------------------+
</span><span class='line'>| REPEATABLE-READ        |
</span><span class='line'>+------------------------+
</span><span class='line'>
</span><span class='line'>mysql&gt; select * from parent where id = 1;
</span><span class='line'>+----+
</span><span class='line'>| id |
</span><span class='line'>+----+
</span><span class='line'>|  1 |
</span><span class='line'>+----+</span></code></pre></td></tr></table></div></figure>


<p><img src="http://xiaobaoqiu.github.io/images/mysql/snapshot_read_RR.png"></p>

<p>下面是Read Committed的结果(Session B一旦提交,Session A未commit的情况下就能读到Session B提交的数据.):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>mysql&gt; SELECT @@session.tx_isolation;
</span><span class='line'>+------------------------+
</span><span class='line'>| @@session.tx_isolation |
</span><span class='line'>+------------------------+
</span><span class='line'>| READ-COMMITTED         |
</span><span class='line'>+------------------------+
</span><span class='line'>
</span><span class='line'>mysql&gt; select * from parent where id = 1;
</span><span class='line'>+----+
</span><span class='line'>| id |
</span><span class='line'>+----+
</span><span class='line'>|  1 |
</span><span class='line'>+----+</span></code></pre></td></tr></table></div></figure>


<p><img src="http://xiaobaoqiu.github.io/images/mysql/snapshot_read_RC.png"></p>

<h1>4.InnoDB MVCC</h1>

<p>InnoDB是一种多版本存储引擎,它必须保存各行老版本信息,这个信息存在一个称之为回滚段(rollback segment)的数据结构中.</p>

<p>在Mysql内部,InnoDB为每行数据额外增加三个字段:</p>

<pre><code>1.一个6-byte的名为DB_TRX_ID字段,用来表示最后一个插入(insert)或者更新(update)这行记录的事物的标记.注意,删除(delete)也被当成一种更新,只是标记这一行的一个额外的bit位来表征这个数据被删除.
2.一个7-byte的名为DB_ROLL_PTR字段,称之为回滚指针(roll pointer).这个指针指向写在rollback segment中的undo log记录.如果这一行被更新了,undo log就包含了能够将这一行完全恢复到修改之前的信息.
3.一个6-byte的DB_ROW_ID字段,用来存行id(row ID),行id是插入数据的时候自动严格递增生成的.如果InnoDB自动产生了一个聚簇索引(clustered index),这个索引就包含行id.否在行id就不会在任何索引中出现.
</code></pre>

<p>InnoDB使用存储在rollback segment中的信息(undo log)去实现事物回滚时候的undo操作.另外,InnoDB也是使用这个信息构建快照读(consistent read或者snapshot read)时候的行数据.</p>

<p>rollback segment中的Undo logs分为插入(insert)和更新(update)的undo logs.</p>

<p>经常提交你的事物,包括那些只是consistent reads的事物.否则(长时间不提事物)会导致InnoDB不能及时废弃update undo logs中的数据,进而导致rollback segment中数据太大挤占你的表空间(tablespace).</p>

<p>rollback segment中undo log记录的物理大小(physical size)通常小于对应的插入或者更新的行数.你可以使用这个信息取计算你的rollback segment需要的空间.</p>

<p>在InnoDB多版本方案中,当你删除一行记录,实际上行不会立即被物理删除.只有当这个删除对应的update undo log被废弃的时候这行记录才会真正被物理删除.此删除操作被称为清除(purge)是通过Purge后台进程实现的,这个过程非常的快,通常其顺序和SQL语句执行删除的顺序一致.Purge进程定期扫描InnoDB的undo,按照先读老undo,再读新undo的顺序,读取每条undo record.</p>

<p>参考:
<a href="http://hedengcheng.com/?p=148">http://hedengcheng.com/?p=148</a>
<a href="https://dev.mysql.com/doc/refman/5.0/en/innodb-multi-versioning.html">https://dev.mysql.com/doc/refman/5.0/en/innodb-multi-versioning.html</a></p>

<h1>5.隔离级别(Isolation Level)</h1>

<h3>5.1 InnoDB的4种隔离级别</h3>

<p>MySQL InnoDB定义的4种隔离级别：</p>

<pre><code>1.Read Uncommited
2.Read Committed (RC)
3.Repeatable Read (RR)
4.Serializable
</code></pre>

<p>Read Uncommited安全级别比较低,因此很少使用.Serializable隔离级别读写冲突,因此并发度急剧下降,在MySQL/InnoDB下不建议使用.
Repeatable Read是InnoDB默认的事物级别.Oracle和MS SQL的默认级别是Read Committed.</p>

<h3>5.2脏读,不可重复读,幻读</h3>

<p>在事务并行下出现的几个问题:</p>

<pre><code>1.脏读
可能读取到其他会话中未提交事务修改的数据,在Read Uncommited级别下可能出现.
2.不可重复读
同一个事物中前后两次读取的内容不一致,在Read Uncommited和Read Committed会出现.
3.幻读
如果另一个事务同时提交了新数据(本事务查询时候感知不到这个变更),本事务再更新时,就会惊奇的发现了这些新数据(比如触发违反了uniq key等),就好像之前读到的数据是鬼影一样的幻觉.这种情况就是上述说的,快照读和当前读一起存在的情况,会出现幻读的场景.必须使用当前读,才能避免幻读.比如：select ...lock in share mode和select ...for update.
</code></pre>

<p>各个事物界别下可能出现的问题:</p>

<table>
<thead>
<tr>
<th>隔离级别</th>
<th style="text-align:center;">脏读(Dirty Read)</th>
<th style="text-align:center;">不可重复读(NonRepeatable Read)</th>
<th style="text-align:center;">幻读(Phantom Read)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Read Uncommited</td>
<td style="text-align:center;">可能</td>
<td style="text-align:center;">可能</td>
<td style="text-align:center;">可能</td>
</tr>
<tr>
<td>Read Committed</td>
<td style="text-align:center;">不可能</td>
<td style="text-align:center;">可能</td>
<td style="text-align:center;">可能</td>
</tr>
<tr>
<td>Repeatable Read</td>
<td style="text-align:center;">不可能</td>
<td style="text-align:center;">不可能</td>
<td style="text-align:center;">可能</td>
</tr>
<tr>
<td>Serializable</td>
<td style="text-align:center;">不可能</td>
<td style="text-align:center;">不可能</td>
<td style="text-align:center;">不可能</td>
</tr>
</tbody>
</table>


<p>幻读的一个示例,Session A在insert之前先select查看数据是否存在,结果告知可以插入,这时候Session B变更数据并提交.Session A再插入会因为主键冲突失败:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>mysql&gt; SELECT @@session.tx_isolation;
</span><span class='line'>+------------------------+
</span><span class='line'>| @@session.tx_isolation |
</span><span class='line'>+------------------------+
</span><span class='line'>| READ-COMMITTED         |
</span><span class='line'>+------------------------+
</span><span class='line'>
</span><span class='line'>mysql&gt; select * from parent where id = 1;
</span><span class='line'>+----+
</span><span class='line'>| id |
</span><span class='line'>+----+
</span><span class='line'>|  1 |
</span><span class='line'>+----+</span></code></pre></td></tr></table></div></figure>


<p><img src="http://xiaobaoqiu.github.io/images/mysql/phantom_read.png"></p>

<p>那么，InnoDB指出的可以避免幻读是怎么回事呢?</p>

<pre><code>http://dev.mysql.com/doc/refman/5.6/en/innodb-record-level-locks.html

By default, InnoDB operates in REPEATABLE READ transaction isolation level and with the innodb_locks_unsafe_for_binlog system variable disabled. In this case, InnoDB uses next-key locks for searches and index scans, which prevents phantom rows (see Section 13.6.8.5, “Avoiding the Phantom Problem Using Next-Key Locking”).
</code></pre>

<p>简单翻译就是，当隔离级别是可重复读，且禁用innodb_locks_unsafe_for_binlog的情况下，在搜索和扫描index的时候使用的next-key locks可以避免幻读.</p>

<p>关键点在于，是InnoDB默认对一个普通的查询也会加next-key locks，还是说需要应用自己来加锁呢？如果单看这一句，可能会以为InnoDB对普通的查询也加了锁，如果是，那和序列化（SERIALIZABLE）的区别又在哪里呢?</p>

<p>MySQL manual里还有一段:</p>

<pre><code>http://dev.mysql.com/doc/refman/5.6/en/innodb-next-key-locking.html
Avoiding the Phantom Problem Using Next-Key Locking

To prevent phantoms, InnoDB uses an algorithm called next-key locking that combines index-row locking with gap locking.

You can use next-key locking to implement a uniqueness check in your application: If you read your data in share mode and do not see a duplicate for a row you are going to insert, then you can safely insert your row and know that the next-key lock set on the successor of your row during the read prevents anyone meanwhile inserting a duplicate for your row. Thus, the next-key locking enables you to “lock” the nonexistence of something in your table.
</code></pre>

<p>根据这一段,我们可以理解为,InnoDB提供了next-key locks，但需要应用程序自己去加锁,才能防止幻读.manual里提供一个例子:</p>

<pre><code>SELECT * FROM child WHERE id &gt; 100 FOR UPDATE;
</code></pre>

<p>这样,InnoDB会给id大于100的行(假如child表里有一行id为102),以及100-102,102+的gap都加上锁.可以使用show innodb status来查看是否给表加上了锁.</p>

<p>结论就是:MySQL InnoDB的REPEATABLE READ并不保证避免幻读,需要应用使用加锁读来保证.而这个加锁度使用到的机制就是next-key locks.</p>

<h3>5.3 修改隔离级别</h3>

<p>InnoDB默认是可重复读的(REPEATABLE READ).可以在命令行用&ndash;transaction-isolation选项,或在选项文件里,为所有连接设置默认隔离级别.</p>

<p>在my.inf文件的[mysqld]节里类似如下设置该选项:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>transaction-isolation = {READ-UNCOMMITTED | READ-COMMITTED | REPEATABLE-READ | SERIALIZABLE}</span></code></pre></td></tr></table></div></figure>


<p>用户可以用SET TRANSACTION语句改变单个会话或者所有新进连接的隔离级别:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE}</span></code></pre></td></tr></table></div></figure>


<h1>6.死锁</h1>

<pre><code>1.死锁发生的条件
互斥条件：一个资源每次只能被一个进程使用；
请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放；
不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺；
循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。
</code></pre>

<p>系统检测到死锁后,会自动回滚其中事务较小的一个(记得好像根据undo日志的大小来决定).</p>

<p>对于DB而言，导致死锁意味着发生了循环等待，在InnoDB中由于行锁的引入，比较容易发生死锁，下面总结一些发生死锁的情况（不全）：
    1. 同一索引上,两个session相反的顺序加锁多行记录;
    2. Primary key和Secondary index，通过primary key找到记录，更新Secondary index字段与通过Secondary index更新记录;
    3. UPDATE/DELETE通过不同的二级索引更新多条记录,可能造成在Primary key上不同的加锁顺序,可以参考之前一篇博客:<a href="http://www.gpfeng.com/?p=406">http://www.gpfeng.com/?p=406</a></p>

<h3>6.1死锁实例</h3>

<h3>6.2查看死锁信息</h3>

<h3>6.3解决死锁</h3>

<p>参考:</p>

<p><a href="http://hedengcheng.com/?p=771">http://hedengcheng.com/?p=771</a></p>

<p><a href="http://dev.mysql.com/doc/refman/5.6/en/innodb-record-level-locks.html">http://dev.mysql.com/doc/refman/5.6/en/innodb-record-level-locks.html</a></p>

<p><a href="http://novoland.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/2014/07/26/MySQL%E6%80%BB%E7%BB%93.html">http://novoland.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/2014/07/26/MySQL%E6%80%BB%E7%BB%93.html</a></p>

<p><a href="http://wiki.corp.qunar.com/pages/viewpage.action?pageId=76820049">http://wiki.corp.qunar.com/pages/viewpage.action?pageId=76820049</a>
<a href="http://wiki.corp.qunar.com/pages/viewpage.action?pageId=50520113">http://wiki.corp.qunar.com/pages/viewpage.action?pageId=50520113</a></p>

<p>Mysql锁基础知识 <a href="http://wiki.corp.qunar.com/pages/viewpage.action?pageId=64807317">http://wiki.corp.qunar.com/pages/viewpage.action?pageId=64807317</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[动态数据源]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/06/02/dong-tai-shu-ju-yuan/"/>
    <updated>2015-06-02T02:42:35+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/06/02/dong-tai-shu-ju-yuan</id>
    <content type="html"><![CDATA[<h1>1.数据库层面的动态数据源</h1>

<p>比如多个读库(Read),可以配置一个虚拟IP,每次读数据库的请求被均衡的分配到各个读库(使用Keepalived等).</p>

<p>这中方式对应用程序是透明的.</p>

<h1>2.数据库Proxy</h1>

<p>很多现成的数据库Proxy,在Proxy中可以做负载均衡(一般使用LVS,Keepalived等现成应用),权限验证,过滤,业务缓存等控制逻辑.比如:</p>

<pre><code>1.360基于mysql-proxy的Atlas
Atlas是由 Qihoo 360,Web平台部基础架构团队开发维护的一个基于MySQL协议的数据中间层项目。它是在mysql-proxy 0.8.2版本的基础上，对其进行了优化，增加了一些新的功能特性。360内部使用Atlas运行的mysql业务，每天承载的读写请求数达几十亿条。
github:https://github.com/Qihoo360/Atlas
参考:https://github.com/Qihoo360/Atlas/wiki/Atlas%E7%9A%84%E6%9E%B6%E6%9E%84

2.阿里的DRDS
分布式关系型数据库服务（Distribute Relational Database Service，简称DRDS）是一种水平拆分、可平滑扩缩容、读写分离的在线分布式数据库服务。前身为淘宝开源的TDDL，是近千个应用首选组件，已稳定服务了七年以上。已经商业化.
参考:http://docs.aliyun.com/?spm=5176.7622920.9.2.qGx2nq#/pub/drds/brief-manual/summary&amp;summary

3.网易的分布式数据库中间件DDB
DDB（Distributed database）是网易杭研院立项最早，应用最为广泛的后台产品之一，也是国内最早出现的基于现有database之上开发的分布式数据库中间件，目前依然在为网易易信，云音乐，云阅读等大型互联网产品提供稳定的数据库服务。
参考:http://www.majin163.com/2014/09/24/ddb-introduce/

4.百度DDBS
</code></pre>

<h1>3.代码层面</h1>

<p>使用Spring实现数据源动态配置,可以在代码层面达到Master-Slave数据库分离的效果.</p>

<p>其实原理很简单,需要做两个工作:</p>

<pre><code>1.实现一个根据不同key使用不同实际DataSource的自定义DataSource;
2.在请求的ThreadLocal中保存当前请求需要使用的数据库的key;
</code></pre>

<p>其中第一个工作Spring已经帮我们做了,见类org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource.</p>

<h3>3.1 AbstractRoutingDataSource简介</h3>

<p>下面简单介绍这个类:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> * 抽象的javax.sql.DataSource实现，可以完成基于一个查找key来路由 #getConnection()到某些特性目标DataSourcesd的一个。一般通过绑定线程上下文来决定。
</span><span class='line'> */
</span><span class='line'>public abstract class AbstractRoutingDataSource extends AbstractDataSource implements InitializingBean {
</span><span class='line'>private Map&lt;Object, Object&gt; targetDataSources;
</span><span class='line'>
</span><span class='line'>    private Object defaultTargetDataSource;
</span><span class='line'>
</span><span class='line'>    private boolean lenientFallback = true;
</span><span class='line'>
</span><span class='line'>    private DataSourceLookup dataSourceLookup = new JndiDataSourceLookup();
</span><span class='line'>
</span><span class='line'>    private Map&lt;Object, DataSource&gt; resolvedDataSources;
</span><span class='line'>
</span><span class='line'>    private DataSource resolvedDefaultDataSource;
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 设置目标DataSources的map映射，其中查找key作为 map的key。
</span><span class='line'>     * 这个映射的value可以是对象的DataSource实例，或者是一个数据源name的字符串（可以被DataSourceLookup解析）。
</span><span class='line'>     *
</span><span class='line'>     * key可以是任意的类型，只要实现了普通的查找处理。
</span><span class='line'>     * 具体的key表示形式，将会被resolveSpecifiedLookupKey和determineCurrentLookupKey处理
</span><span class='line'>     *
</span><span class='line'>     */
</span><span class='line'>    public void setTargetDataSources(Map&lt;Object, Object&gt; targetDataSources) {
</span><span class='line'>        this.targetDataSources = targetDataSources;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 设置默认目标数据源。如果我们在map中找不到对应的key时，则会使用这里设置的默认数据源
</span><span class='line'>     */
</span><span class='line'>    public void setDefaultTargetDataSource(Object defaultTargetDataSource) {
</span><span class='line'>        this.defaultTargetDataSource = defaultTargetDataSource;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 指定默认的DataSource，当通过指定的查找key不能找到对应的DataSource。
</span><span class='line'>     * 如果为false，则直接返回失败，如果为true，则使用默认的数据源。默认为true
</span><span class='line'>     */
</span><span class='line'>    public void setLenientFallback(boolean lenientFallback) {
</span><span class='line'>        this.lenientFallback = lenientFallback;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 设置DataSourceLookup的实现类，该实现类可以把字符串配置的数据源，解析成我们需要的DataSource类.默认使用JndiDataSourceLookup。
</span><span class='line'>     *
</span><span class='line'>     * JndiDataSourceLookup方法使用ref bean方式获取配置文件中配置的dataSource数据源，也就是我们一般使用xml中配置datasource的方式就是jndi。
</span><span class='line'>     */
</span><span class='line'>    public void setDataSourceLookup(DataSourceLookup dataSourceLookup) {
</span><span class='line'>        this.dataSourceLookup = (dataSourceLookup != null ? dataSourceLookup : new JndiDataSourceLookup());
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>    * 初始化,将targetDataSources转换成resolvedDataSources
</span><span class='line'>    */
</span><span class='line'>    public void afterPropertiesSet() {
</span><span class='line'>        if (this.targetDataSources == null) {
</span><span class='line'>            throw new IllegalArgumentException("Property 'targetDataSources' is required");
</span><span class='line'>        }
</span><span class='line'>        this.resolvedDataSources = new HashMap&lt;Object, DataSource&gt;(this.targetDataSources.size());
</span><span class='line'>        for (Map.Entry entry : this.targetDataSources.entrySet()) {
</span><span class='line'>            Object lookupKey = resolveSpecifiedLookupKey(entry.getKey());
</span><span class='line'>            DataSource dataSource = resolveSpecifiedDataSource(entry.getValue());
</span><span class='line'>            this.resolvedDataSources.put(lookupKey, dataSource);
</span><span class='line'>        }
</span><span class='line'>        if (this.defaultTargetDataSource != null) {
</span><span class='line'>            this.resolvedDefaultDataSource = resolveSpecifiedDataSource(this.defaultTargetDataSource);
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 根据lookupKey获取map中存放的key值，默认两者是一样的
</span><span class='line'>     */
</span><span class='line'>    protected Object resolveSpecifiedLookupKey(Object lookupKey) {
</span><span class='line'>        return lookupKey;
</span><span class='line'>    }
</span><span class='line'>    /**
</span><span class='line'>     * 转换从获取map中存放的dataSource
</span><span class='line'>     */
</span><span class='line'>    protected DataSource resolveSpecifiedDataSource(Object dataSource) throws IllegalArgumentException {
</span><span class='line'>        if (dataSource instanceof DataSource) {
</span><span class='line'>            return (DataSource) dataSource;
</span><span class='line'>        }
</span><span class='line'>        else if (dataSource instanceof String) {
</span><span class='line'>            return this.dataSourceLookup.getDataSource((String) dataSource);
</span><span class='line'>        }
</span><span class='line'>        else {
</span><span class='line'>            throw new IllegalArgumentException(
</span><span class='line'>                    "Illegal data source value - only [javax.sql.DataSource] and String supported: " + dataSource);
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>    * 这里就是抽象类给我们实现的接口方法，根据我们的配置上下文，抽象类决定实现哪个连接
</span><span class='line'>    */
</span><span class='line'>    public Connection getConnection() throws SQLException {
</span><span class='line'>        return determineTargetDataSource().getConnection();
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public Connection getConnection(String username, String password) throws SQLException {
</span><span class='line'>        return determineTargetDataSource().getConnection(username, password);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    protected DataSource determineTargetDataSource() {
</span><span class='line'>        Assert.notNull(this.resolvedDataSources, "DataSource router not initialized");
</span><span class='line'>        Object lookupKey = determineCurrentLookupKey();
</span><span class='line'>        DataSource dataSource = this.resolvedDataSources.get(lookupKey);
</span><span class='line'>        if (dataSource == null && (this.lenientFallback || lookupKey == null)) {
</span><span class='line'>            dataSource = this.resolvedDefaultDataSource;
</span><span class='line'>        }
</span><span class='line'>        if (dataSource == null) {
</span><span class='line'>            throw new IllegalStateException("Cannot determine target DataSource for lookup key [" + lookupKey + "]");
</span><span class='line'>        }
</span><span class='line'>        return dataSource;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>    * 这里是我们使用这个抽象类需要实现的方法，主要就是告诉该抽象类，当前需要使用的数据源的key是什么，这样抽象类就可以知道使用哪个数据库连接
</span><span class='line'>    */
</span><span class='line'>    protected abstract Object determineCurrentLookupKey();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>我们可以继承这个类实现自己的RoutingDataSource,只需要实现determineCurrentLookupKey()方法.下面是一个实现示例,其中DataSourceKeyHolder用来在ThreadLocal中保存key,而我们的RoutingDataSource就可以从ThreadLocal中获取key来决定使用那个具体的数据源:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class RoutingDataSource extends AbstractRoutingDataSource {
</span><span class='line'>    @Override
</span><span class='line'>    protected Object determineCurrentLookupKey() {
</span><span class='line'>        return DataSourceKeyHolder.getDataSource();
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public class DataSourceKeyHolder {
</span><span class='line'>    private static final ThreadLocal&lt;String&gt; holder = new ThreadLocal&lt;String&gt;();
</span><span class='line'>
</span><span class='line'>    public static String getDataSource() {
</span><span class='line'>        return holder.get();
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public static void putDataSource(String value) {
</span><span class='line'>        holder.set(value);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public static void clear(){
</span><span class='line'>        holder.remove();
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>3.2 自己实现RoutingDataSource</h3>

<p>Spring自带的AbstractRoutingDataSource功能强大,但是略先麻烦(最终使用的其实只有resolvedDataSources这个Map).我们完全可以自己实现一个简单的RoutingDataSource,比如我们要实现读写分离的动态数据库,一个简单实现如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class RoutingDataSource extends AbstractDataSource implements InitializingBean {
</span><span class='line'>    /**
</span><span class='line'>     * 写库, key是String
</span><span class='line'>     */
</span><span class='line'>    private Map&lt;String, DataSource&gt; writeDataSourceMap;
</span><span class='line'>    /**
</span><span class='line'>     * 读库, key是String
</span><span class='line'>     */
</span><span class='line'>    private Map&lt;String, DataSource&gt; readDataSourceMap;
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    public Connection getConnection() throws SQLException {
</span><span class='line'>        //从上下文中获取key
</span><span class='line'>        ConnectionKey connectionKey = ConnectionKeyHolder.get();
</span><span class='line'>        try {
</span><span class='line'>            //默认情况,返回随机一个写库
</span><span class='line'>            if (connectionKey == null) {
</span><span class='line'>                return fetchConnection(writeDataSourceMap, null);
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>            //只读
</span><span class='line'>            if (connectionKey.getType().equals(ConnectionKey.READ)) {
</span><span class='line'>                return fetchConnection(readDataSourceMap, connectionKey.getKey());
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>            //可读可写
</span><span class='line'>            if (connectionKey.getType().equals(ConnectionKey.READ_WRITE)) {
</span><span class='line'>                return fetchConnection(writeDataSourceMap, connectionKey.getKey());
</span><span class='line'>            }
</span><span class='line'>        } catch (Exception e) {
</span><span class='line'>            logger.error("getConnectionError", e);
</span><span class='line'>            if (e instanceof SQLException) {
</span><span class='line'>                throw (SQLException) e;
</span><span class='line'>            } else {
</span><span class='line'>                throw new SQLException(e);
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        // impossible code
</span><span class='line'>        throw new IllegalArgumentException("invalid connection type: " + connectionKey.getType() + ", key: "
</span><span class='line'>                + connectionKey.getKey());
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 根据key从对应的Map中获取数据库连接
</span><span class='line'>     *
</span><span class='line'>     * @param dbSourceMap
</span><span class='line'>     * @param key
</span><span class='line'>     * @return
</span><span class='line'>     * @throws SQLException
</span><span class='line'>     */
</span><span class='line'>    private Connection fetchConnection(final Map&lt;String, DataSource&gt; dbSourceMap, String key) throws SQLException {
</span><span class='line'>        if (key == null || key.length() == 0) { // null key, return a random read connection
</span><span class='line'>            key = randomKey(dbSourceMap);
</span><span class='line'>        }
</span><span class='line'>        if (dbSourceMap.get(key) == null) {
</span><span class='line'>            key = randomKey(dbSourceMap);
</span><span class='line'>        }
</span><span class='line'>        return dbSourceMap.get(key).getConnection();
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 随机获取一个Key
</span><span class='line'>     * @return
</span><span class='line'>     */
</span><span class='line'>    private String randomKey(final Map&lt;String, DataSource&gt; dbSourceMap) {
</span><span class='line'>        String[] keys = dbSourceMap.keySet().toArray(new String[0]);
</span><span class='line'>        int size = dbSourceMap.size();
</span><span class='line'>        int rand = new Random().nextInt(size);
</span><span class='line'>        return keys[rand];
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    public Connection getConnection(String username, String password) throws SQLException {
</span><span class='line'>        throw new UnsupportedOperationException();
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    public void afterPropertiesSet() throws Exception {
</span><span class='line'>        Preconditions.checkArgument(MapUtils.isNotEmpty(writeDataSourceMap));
</span><span class='line'>        Preconditions.checkArgument(MapUtils.isNotEmpty(readDataSourceMap));
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public void setWriteDataSource(Map&lt;String, DataSource&gt; writeDataSourceMap) {
</span><span class='line'>        this.writeDataSourceMap = writeDataSourceMap;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public void setReadDataSourceMap(Map&lt;String, DataSource&gt; readDataSourceMap) {
</span><span class='line'>        this.readDataSourceMap = readDataSourceMap;
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public class ConnectionKey {
</span><span class='line'>    /**
</span><span class='line'>     * 读库,只读
</span><span class='line'>     */
</span><span class='line'>    public static final String READ = "R";
</span><span class='line'>    /**
</span><span class='line'>     * 写库,可读可写
</span><span class='line'>     */
</span><span class='line'>    public static final String READ_WRITE = "RW";
</span><span class='line'>
</span><span class='line'>    private String type;
</span><span class='line'>    private String key;
</span><span class='line'>
</span><span class='line'>    public ConnectionKey() {
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public ConnectionKey(String type, String key) {
</span><span class='line'>        this.type = type;
</span><span class='line'>        this.key = key;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public String getType() {
</span><span class='line'>        return type;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public String getKey() {
</span><span class='line'>        return key;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public void setType(String type) {
</span><span class='line'>        this.type = type;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public void setKey(String key) {
</span><span class='line'>        this.key = key;
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public class ConnectionKeyHolder {
</span><span class='line'>    private static ThreadLocal&lt;ConnectionKey&gt; connType = new ThreadLocal&lt;ConnectionKey&gt;();
</span><span class='line'>
</span><span class='line'>    public static void set(ConnectionKey type) {
</span><span class='line'>        connType.set(type);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public static ConnectionKey get() {
</span><span class='line'>        return connType.get();
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public static void release() {
</span><span class='line'>        connType.remove();
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>3.3 使用实现动态数据源</h3>

<p>以我们自己实现的为例子,我们简单展示一下如何使用Spring加上AOP使用我们的动态数据源.</p>

<p>首先定义使用读库和使用写库的注解:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'>* 使用读库的注解,value()代表key
</span><span class='line'>*/
</span><span class='line'>@Target({ ElementType.TYPE, ElementType.METHOD })
</span><span class='line'>@Retention(RetentionPolicy.RUNTIME)
</span><span class='line'>@Documented
</span><span class='line'>public @interface Read {
</span><span class='line'>    String value() default "";
</span><span class='line'>}
</span><span class='line'>/**
</span><span class='line'>* 使用写库的注解,value()代表key
</span><span class='line'>*/
</span><span class='line'>@Target({ ElementType.TYPE, ElementType.METHOD })
</span><span class='line'>@Retention(RetentionPolicy.RUNTIME)
</span><span class='line'>@Documented
</span><span class='line'>public @interface Write {
</span><span class='line'>    String value() default "";
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后定义Aspect,逻辑很简单,只是在执行我们的业务逻辑之前给线程上文写入ConnectionKey信息:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class RoutingAop {
</span><span class='line'>
</span><span class='line'>    protected Logger log = LoggerFactory.getLogger(getClass());
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 解析读库的注解
</span><span class='line'>     *
</span><span class='line'>     * @param pjp
</span><span class='line'>     * @param read
</span><span class='line'>     * @return
</span><span class='line'>     * @throws Throwable
</span><span class='line'>     */
</span><span class='line'>    public Object aroundRead(ProceedingJoinPoint pjp, Read read) throws Throwable {
</span><span class='line'>        ConnectionKey origType = ConnectionKeyHolder.get();
</span><span class='line'>        try {
</span><span class='line'>            ConnectionKey newType = ConnectionKey.buildReadConnectionKey(read.value());
</span><span class='line'>            ConnectionKeyHolder.set(newType);
</span><span class='line'>            return pjp.proceed();
</span><span class='line'>        } catch (Throwable throwable) {
</span><span class='line'>            log.warn("error while processing read method", throwable);
</span><span class='line'>            throw throwable;
</span><span class='line'>        } finally {
</span><span class='line'>            if (origType != null) {
</span><span class='line'>                ConnectionKeyHolder.set(origType);
</span><span class='line'>            } else {
</span><span class='line'>                ConnectionKeyHolder.release();
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 解析写库的注解
</span><span class='line'>     *
</span><span class='line'>     * @param pjp
</span><span class='line'>     * @param write
</span><span class='line'>     * @return
</span><span class='line'>     * @throws Throwable
</span><span class='line'>     */
</span><span class='line'>    public Object aroundWrite(ProceedingJoinPoint pjp, Write write) throws Throwable {
</span><span class='line'>        ConnectionKey origType = ConnectionKeyHolder.get();
</span><span class='line'>        try {
</span><span class='line'>            ConnectionKey newType = ConnectionKey.buildWriteConnectionKey(write.value());
</span><span class='line'>            ConnectionKeyHolder.set(newType);
</span><span class='line'>            return pjp.proceed();
</span><span class='line'>        } catch (Throwable throwable) {
</span><span class='line'>            log.warn("error while processing write method", throwable);
</span><span class='line'>            throw throwable;
</span><span class='line'>        } finally {
</span><span class='line'>            if (origType != null) {
</span><span class='line'>                ConnectionKeyHolder.set(origType);
</span><span class='line'>            } else {
</span><span class='line'>                ConnectionKeyHolder.release();
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在Spring配置文件中定义好各个读库和各个写库,定义我们的RoutingDataSource的bean,之后扫描注解就可以了:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;!-- DataSource 写库  --&gt;
</span><span class='line'>&lt;bean id="writeDataSource" class="..."&gt;
</span><span class='line'>
</span><span class='line'>&lt;!-- DataSource 读库  --&gt;
</span><span class='line'>&lt;bean id="readDataSource" class="..."&gt;
</span><span class='line'>
</span><span class='line'>&lt;bean id="routingDataSource" class="com.Xxx.RoutingDataSource"&gt;
</span><span class='line'>    &lt;property name="writeDataSourceMap"&gt;
</span><span class='line'>        &lt;map key-type="java.lang.String" value-type="javax.sql.DataSource"&gt;
</span><span class='line'>            &lt;entry key="write1" value-ref="writeDataSource"/&gt;
</span><span class='line'>        &lt;/map&gt;
</span><span class='line'>    &lt;/property&gt;
</span><span class='line'>    &lt;property name="readDataSourceMap"&gt;
</span><span class='line'>        &lt;map key-type="java.lang.String" value-type="javax.sql.DataSource"&gt;
</span><span class='line'>            &lt;entry key="read1" value-ref="readDataSource"/&gt;
</span><span class='line'>        &lt;/map&gt;
</span><span class='line'>    &lt;/property&gt;
</span><span class='line'>&lt;/bean&gt;
</span><span class='line'>
</span><span class='line'>&lt;bean id="routingAop" class="com.Xxx.RoutingAop"/&gt;
</span><span class='line'>&lt;!-- 定义Read Write注解扫描  --&gt;
</span><span class='line'>&lt;aop:config&gt;
</span><span class='line'>    &lt;aop:aspect ref="routingAop"&gt;
</span><span class='line'>        &lt;aop:around method="aroundRead" arg-names="read" pointcut="@annotation(read) &amp;&amp; execution(public * com.Xxx.controller.*.*(..))" /&gt;
</span><span class='line'>    &lt;/aop:aspect&gt;
</span><span class='line'>
</span><span class='line'>    &lt;aop:aspect ref="routingAop"&gt;
</span><span class='line'>        &lt;aop:around method="aroundWrite" arg-names="write" pointcut="@annotation(write) &amp;&amp; execution(public * com.Xxx.controller.*.*(..)) " /&gt;
</span><span class='line'>    &lt;/aop:aspect&gt;
</span><span class='line'>&lt;/aop:config&gt;
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elasticsearch配置解析]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/05/21/elasticsearchpei-zhi-jie-xi/"/>
    <updated>2015-05-21T04:31:05+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/05/21/elasticsearchpei-zhi-jie-xi</id>
    <content type="html"><![CDATA[<p>可以使用正则grep出各个配置项:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>grep '^#\w' elasticsearch.yml</span></code></pre></td></tr></table></div></figure>


<p>解析Elasticsearch的配置文件elasticsearch.yml中各个关键参数的意义:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>################################### Cluster ###################################
</span><span class='line'>elasticsearch的config文件夹里面有两个配置文件：elasticsearch.yml和logging.yml，第一个是es的基本配置文件，第二个是日志配置文件，es也是使用log4j来记录日志的，所以logging.yml里的设置按普通log4j配置文件来设置就行了。下面主要讲解下elasticsearch.yml这个文件中可配置的东西。
</span><span class='line'>
</span><span class='line'>cluster.name: elasticsearch
</span><span class='line'>配置es的集群名称，默认是elasticsearch，es会自动发现在同一网段下的es，如果在同一网段下有多个集群，就可以用这个属性来区分不同的集群。
</span><span class='line'>
</span><span class='line'>node.name: "Franz Kafka"
</span><span class='line'>节点名，默认随机指定一个name列表中名字，该列表在es的jar包中config文件夹里name.txt文件中，其中有很多作者添加的有趣名字。
</span><span class='line'>
</span><span class='line'>node.master: true
</span><span class='line'>指定该节点是否有资格被选举成为node，默认是true，es是默认集群中的第一台机器为master，如果这台机挂了就会重新选举master。
</span><span class='line'>
</span><span class='line'>node.data: true
</span><span class='line'>指定该节点是否存储索引数据，默认为true。
</span><span class='line'>
</span><span class='line'>index.number_of_shards: 5
</span><span class='line'>设置默认索引分片个数，默认为5片。
</span><span class='line'>
</span><span class='line'>index.number_of_replicas: 1
</span><span class='line'>设置默认索引副本个数，默认为1个副本。
</span><span class='line'>
</span><span class='line'>path.conf: /path/to/conf
</span><span class='line'>设置配置文件的存储路径，默认是es根目录下的config文件夹。
</span><span class='line'>
</span><span class='line'>path.data: /path/to/data
</span><span class='line'>设置索引数据的存储路径，默认是es根目录下的data文件夹，可以设置多个存储路径，用逗号隔开，例：
</span><span class='line'>path.data: /path/to/data1,/path/to/data2
</span><span class='line'>
</span><span class='line'>path.work: /path/to/work
</span><span class='line'>设置临时文件的存储路径，默认是es根目录下的work文件夹。
</span><span class='line'>
</span><span class='line'>path.logs: /path/to/logs
</span><span class='line'>设置日志文件的存储路径，默认是es根目录下的logs文件夹
</span><span class='line'>
</span><span class='line'>path.plugins: /path/to/plugins
</span><span class='line'>设置插件的存放路径，默认是es根目录下的plugins文件夹
</span><span class='line'>
</span><span class='line'>bootstrap.mlockall: true
</span><span class='line'>设置为true来锁住内存。因为当jvm开始swapping时es的效率会降低，所以要保证它不swap，可以把ES_MIN_MEM和ES_MAX_MEM两个环境变量设置成同一个值，并且保证机器有足够的内存分配给es。同时也要允许elasticsearch的进程可以锁住内存，linux下可以通过`ulimit -l unlimited`命令。设置ES_HEAP_SIZE表示ES_MIN_MEM和ES_MAX_MEM相同且为ES_HEAP_SIZE的值.
</span><span class='line'>
</span><span class='line'>network.bind_host: 192.168.0.1
</span><span class='line'>设置绑定的ip地址，可以是ipv4或ipv6的，默认为0.0.0.0。
</span><span class='line'>
</span><span class='line'>network.publish_host: 192.168.0.1
</span><span class='line'>设置其它节点和该节点交互的ip地址，如果不设置它会自动判断，值必须是个真实的ip地址。
</span><span class='line'>
</span><span class='line'>network.host: 192.168.0.1
</span><span class='line'>这个参数是用来同时设置bind_host和publish_host上面两个参数。
</span><span class='line'>
</span><span class='line'>transport.tcp.port: 9300
</span><span class='line'>设置节点间交互的tcp端口，默认是9300。
</span><span class='line'>
</span><span class='line'>transport.tcp.compress: true
</span><span class='line'>设置是否压缩tcp传输时的数据，默认为false，不压缩。
</span><span class='line'>
</span><span class='line'>http.port: 9200
</span><span class='line'>设置对外服务的http端口，默认为9200。
</span><span class='line'>
</span><span class='line'>http.max_content_length: 100mb
</span><span class='line'>设置内容的最大容量，默认100mb
</span><span class='line'>
</span><span class='line'>http.enabled: false
</span><span class='line'>是否使用http协议对外提供服务，默认为true，开启。
</span><span class='line'>
</span><span class='line'>gateway.type: local
</span><span class='line'>gateway的类型，默认为local即为本地文件系统，可以设置为本地文件系统，分布式文件系统，hadoop的HDFS，和amazon的s3服务器，其它文件系统的设置方法下次再详细说。
</span><span class='line'>
</span><span class='line'>gateway.recover_after_nodes: 1
</span><span class='line'>设置集群中N个节点启动时进行数据恢复，默认为1。
</span><span class='line'>
</span><span class='line'>gateway.recover_after_time: 5m
</span><span class='line'>设置初始化数据恢复进程的超时时间，默认是5分钟。
</span><span class='line'>
</span><span class='line'>gateway.expected_nodes: 2
</span><span class='line'>设置这个集群中节点的数量，默认为2.一旦一旦这N个节点启动(并且数字和recover_after_nodes相同),就会立即开始数据恢复而不用等待gateway.recover_after_time时间之后再开始.
</span><span class='line'>
</span><span class='line'>cluster.routing.allocation.node_initial_primaries_recoveries: 4
</span><span class='line'>初始化数据恢复时，并发恢复线程的个数，默认为4。
</span><span class='line'>
</span><span class='line'>cluster.routing.allocation.node_concurrent_recoveries: 2
</span><span class='line'>添加删除节点或负载均衡时并发恢复线程的个数，默认为4。
</span><span class='line'>
</span><span class='line'>indices.recovery.max_size_per_sec: 0
</span><span class='line'>设置数据恢复时限制的带宽，如入100mb，默认为0，即无限制。
</span><span class='line'>
</span><span class='line'>indices.recovery.concurrent_streams: 5
</span><span class='line'>设置这个参数来限制从其它分片恢复数据时最大同时打开并发流的个数，默认为5。
</span><span class='line'>
</span><span class='line'>discovery.zen.minimum_master_nodes: 1
</span><span class='line'>设置这个参数来保证集群中的节点可以知道其它N个有master资格的节点。默认为1，对于大的集群来说，可以设置大一点的值(2-4).
</span><span class='line'>
</span><span class='line'>discovery.zen.ping.timeout: 3s
</span><span class='line'>设置集群中自动发现其它节点时ping连接超时时间，默认为3秒，对于比较差的网络环境可以高点的值来防止自动发现时出错。
</span><span class='line'>
</span><span class='line'>discovery.zen.ping.multicast.enabled: false
</span><span class='line'>设置是否打开多播发现节点，默认是true。使用单播发现节点策略(Unicast discovery)允许显示的控制使用哪个节点去发现集群.
</span><span class='line'>
</span><span class='line'>discovery.zen.ping.unicast.hosts: ["host1", "host2:port", "host3[portX-portY]"]
</span><span class='line'>设置集群中master节点的初始列表，可以通过这些节点来自动发现新加入集群的节点。
</span><span class='line'>
</span><span class='line'>下面是一些查询时的慢日志参数设置,默认日志级别为TRACE.
</span><span class='line'>超过10秒的查询打印warn日志,超过5秒的查询打印info日志,超过2秒的查询打印debug日志,超过0.5秒的查询打印trace日志
</span><span class='line'>index.search.slowlog.level: TRACE
</span><span class='line'>index.search.slowlog.threshold.query.warn: 10s
</span><span class='line'>index.search.slowlog.threshold.query.info: 5s
</span><span class='line'>index.search.slowlog.threshold.query.debug: 2s
</span><span class='line'>index.search.slowlog.threshold.query.trace: 500ms
</span><span class='line'>
</span><span class='line'>index.search.slowlog.threshold.fetch.warn: 1s
</span><span class='line'>index.search.slowlog.threshold.fetch.info: 800ms
</span><span class='line'>index.search.slowlog.threshold.fetch.debug:500ms
</span><span class='line'>index.search.slowlog.threshold.fetch.trace: 200ms
</span><span class='line'>
</span><span class='line'>超过10秒的查检索引打印warn日志,超过5秒的查检索引打印info日志,超过2秒的查检索引打印debug日志,超过0.5秒的查检索引打印trace日志
</span><span class='line'>index.indexing.slowlog.threshold.index.warn: 10s
</span><span class='line'>index.indexing.slowlog.threshold.index.info: 5s
</span><span class='line'>index.indexing.slowlog.threshold.index.debug: 2s
</span><span class='line'>index.indexing.slowlog.threshold.index.trace: 500ms
</span><span class='line'>
</span><span class='line'>下面是GC日志相关的配置,young GC超过1000ms打印warn日志,超过700ms打印info日志,超过400ms打印的debug日志
</span><span class='line'>monitor.jvm.gc.young.warn: 1000ms
</span><span class='line'>monitor.jvm.gc.young.info: 700ms
</span><span class='line'>monitor.jvm.gc.young.debug: 400ms
</span><span class='line'>
</span><span class='line'>full GC超过10s打印warn日志,超过5s打印info日志,超过2s打印的debug日志
</span><span class='line'>monitor.jvm.gc.old.warn: 10s
</span><span class='line'>monitor.jvm.gc.old.info: 5s
</span><span class='line'>monitor.jvm.gc.old.debug: 2s</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
</feed>
