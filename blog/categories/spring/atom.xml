<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Spring | xiaobaoqiu Blog]]></title>
  <link href="http://xiaobaoqiu.github.io/blog/categories/spring/atom.xml" rel="self"/>
  <link href="http://xiaobaoqiu.github.io/"/>
  <updated>2017-02-04T17:21:43+08:00</updated>
  <id>http://xiaobaoqiu.github.io/</id>
  <author>
    <name><![CDATA[xiaobaoqiu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ShallowEtagHeaderFilter]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2017/02/03/shallowetagheaderfilter/"/>
    <updated>2017-02-03T11:56:21+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2017/02/03/shallowetagheaderfilter</id>
    <content type="html"><![CDATA[<ul>
<li><a href="#1.%E8%83%8C%E6%99%AF">1.背景</a></li>
<li><a href="#2.Mysql%E6%B5%81%E5%BC%8F%E8%AF%BB%E5%8F%96">2.Mysql流式读取</a></li>
<li><a href="#3.ShallowEtagHeaderFilter">3.ShallowEtagHeaderFilter</a></li>
</ul>


<h2 id="1.背景">1.背景</h2>


<p>之前组内遇到的一个 ShallowEtagHeaderFilter 导致流式导出失效的问题, 具体的问题分析不是我做的, 这里记录下问题及原理.</p>

<p>现象就是一个数据导出接口, 用户的频繁调用导致线上内存吃满, 进而频繁 GC 导致 CPU 过高最终影响用户请求.</p>

<h2 id="2.Mysql流式读取">2.Mysql流式读取</h2>


<p>先交代一下导出接口的实现方式, 考虑到导出数据可能比较大导致撑爆内存, 数据导出是流式导出的.</p>

<p>默认情况下, 我们的select从服务器一次取出所有数据放在客户端内存中, 当一条SQL返回数据量较大时可能会出现OOM.</p>

<p>这里首先涉及到Mysql如何配置流式读取数据, 涉及到两个配置(第一个配置很重要很容易被忘记)</p>

<pre><code>1.Mysql连接串中配置上参数useCursorFetch=true;
2.Sql中配置上FetchSize等参数
</code></pre>

<p>下面以MyBatis为例子, 通过设置Mapper文件中select的属性来启用这一特性</p>

<pre><code>&lt;select id="xxx" fetchSize="100" resultSetType="FORWARD_ONLY"&gt;
    ...
&lt;/select&gt;
</code></pre>

<p>然后, 配合 ResultHandler 就可以实现逐行流式处理数据库中的记录.</p>

<p>我们就是采用这种方式, 流式获取数据写到 Response 的输出流中.</p>

<h2 id="3.ShallowEtagHeaderFilter">3.ShallowEtagHeaderFilter</h2>




<h4 id="3.1 Content-Length 和 Transfer-Encoding">3.1 Content-Length 和 Transfer-Encoding</h4>


<p>在描述问题之前, 我们先普及一下 Http 请求中 Content-Length 和 Transfer-Encoding 的知识.</p>

<p>Content-Length 用于描述HTTP消息实体的传输长度(the transfer-length of the message-body), 需要注意消息实体长度和消息实体传输长度是有区别, 比如说gzip压缩下, 消息实体长度是压缩前的长度, 消息实体的传输长度是gzip压缩后的长度.</p>

<p>通过读取 Content-Length 这个信息, 服务器/客户端可以预先知道数据量的大小, 以便预先分配空间.</p>

<p>Transfer-Encoding 所描述的是消息请求(request)和响应(response)所附带的实体对象(entity)的传输形式. 可选值有: chunked 和 identity, 其中chunked指把要发送传输的数据切割成一系列的块数据传输, identity指传输时不做任何处理, 自身的本质数据形式传输. 举个例子, 如果我们要传输一本小说到服务器, chunked方式就会先把这本小说分成一章一章的, 然后逐个章节上传, 而identity方式则是从小说的第一个字按顺序传输到最后一个字结束.</p>

<p>HTTP/1.1 规定, 所有服务器必须支持 Chunked 类型的 Transfer-Encoding, 通过这个头部, 服务器不必在返回回应报文的时候预先知道返回 Body 的大小, 而是将数据分割到一个一个的 Chunk 中(每个 Chunk 通过特定的头部和尾部区分, 最后一个 Chunk 大小为 0, 以表示报文结束), 然后持续不断地写入 TCP 流, 通过这个机制, 可以实现服务器数据到客户端的流式输出.</p>

<p>注意关于 Content-Length 和 Transfer-Encoding 一个准则: 有了Transfer-Encoding, 则不能有Content-Length</p>

<p>参考:
<a href="https://tools.ietf.org/html/rfc2616#section-4.4.">https://tools.ietf.org/html/rfc2616#section-4.4.</a>
<a href="http://www.cnblogs.com/jcli/archive/2012/10/19/2730440.html">http://www.cnblogs.com/jcli/archive/2012/10/19/2730440.html</a>
<a href="http://blog.csdn.net/pud_zha/article/details/8809878">http://blog.csdn.net/pud_zha/article/details/8809878</a></p>

<h4 id="3.2 问题分析">3.2 问题分析</h4>


<p>按照我们上面的分析, 我们的 Response 的 Transfer-Encoding 肯定是 chunked, 并且没有设置 Content-Length.但是我们发现请求的 Response 中存在 Content-Length 字段.</p>

<p>我们将请求的 Response 分为三个阶段:
    (1).从数据库读取数据;
    (2).服务器端整理数据发往浏览器端;
    (3).浏览器端接受数据;</p>

<p>现在已知从 Mysql 中读取数据是流式的, 而浏览器接收到的数据不是流式的, 因此问题审核出在服务器端.</p>

<p>最终定位到的罪魁祸首是一个 ShallowEtagHeaderFilter 的 Filter.</p>

<h4 id="3.3 ShallowEtagHeaderFilter原理">3.3 ShallowEtagHeaderFilter原理</h4>


<p>ShallowEtagHeaderFilter 继承了 OncePerRequestFilter, 我们可以分析一下 ShallowEtagHeaderFilter 的主要代码逻辑:</p>

<pre><code>    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {

        response = new ShallowEtagResponseWrapper(response);    //1.将所有的请求包装成 ShallowEtagResponseWrapper

        filterChain.doFilter(request, response);        //2. 其他 filter

        updateResponse(request, response);      //3.返回给客户端之前处理一次 response
    }
</code></pre>

<p>看一下包装 ShallowEtagResponseWrapper 做了什么:
(其实看注释就已经知道, 将所有写到 output stream 和 writer 的内容缓冲起来放到, 并提供 oByteArray() 方法用于读取缓冲的数据):</p>

<pre><code>    /**
     * {@link HttpServletRequest} wrapper that buffers all content written to the
     * {@linkplain #getOutputStream() output stream} and {@linkplain #getWriter() writer},
     * and allows this content to be retrieved via a {@link #toByteArray() byte array}.
     */
    private static class ShallowEtagResponseWrapper extends HttpServletResponseWrapper {

        private final ByteArrayOutputStream content = new ByteArrayOutputStream();

        private final ServletOutputStream outputStream = new ResponseServletOutputStream();

        private PrintWriter writer;
        ...
        public PrintWriter getWriter() throws IOException { //获取 writer, 采用自定义的 ResponsePrintWriter, 后续的写会将内容写到 content 中
            if (this.writer == null) {
                String characterEncoding = getCharacterEncoding();
                this.writer = (characterEncoding != null ? new ResponsePrintWriter(characterEncoding) :
                        new ResponsePrintWriter(WebUtils.DEFAULT_CHARACTER_ENCODING));
            }
            return this.writer;
        }
        private byte[] toByteArray() {  // 读取 content 内容
            return this.content.toByteArray();
        }

        // 自定义 ServletOutputStream, write操作将内容写入到 content 中
        private class ResponseServletOutputStream extends ServletOutputStream {
            @Override
            public void write(int b) throws IOException {
                content.write(b);   //写到 content 中
            }
            ...
        }

        // 自定义 PrintWriter, 写入到 content 中
        private class ResponsePrintWriter extends PrintWriter {
            private ResponsePrintWriter(String characterEncoding) throws UnsupportedEncodingException {
                super(new OutputStreamWriter(content, characterEncoding));
            }
            ...
        }
    }
</code></pre>

<p>最后我们看看 updateResponse 做了什么事:</p>

<pre><code>    private void updateResponse(HttpServletRequest request, HttpServletResponse response) throws IOException {
        ...
        byte[] body = responseWrapper.toByteArray();        //缓冲起来的数据
        int statusCode = responseWrapper.getStatusCode();

        if (isEligibleForEtag(request, responseWrapper, statusCode, body)) {
            String responseETag = generateETagHeaderValue(body);    //基于内容生成 ETag
            response.setHeader(HEADER_ETAG, responseETag);      //设置 ETag Header

            String requestETag = request.getHeader(HEADER_IF_NONE_MATCH);   //If-None-Match 
            if (responseETag.equals(requestETag)) {                 //请求的If-None-Match和ETag相同, 则304
                response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);    //304
            } else {
                copyBodyToResponse(body, response);     //将缓冲的内容写入到 response 中
            }
        } else {
            ...
            copyBodyToResponse(body, response);
        }
    }

    private void copyBodyToResponse(byte[] body, HttpServletResponse response) throws IOException {
        if (body.length &gt; 0) {
            response.setContentLength(body.length);         //设置 Content-Length
            FileCopyUtils.copy(body, response.getOutputStream());       //ShallowEtagResponseWrapper数据拷贝到response中
        }
    }
</code></pre>

<p>总结 ShallowEtagHeaderFilter 作用:
    1.ShallowEtagHeaderFilter 缓冲了写到 response 的所有数据;
    2.如果请求的 If-None-Match 头部信息和当前根据内容生成的 ETag 相同,则请求为 304;
    3.最后 ShallowEtagHeaderFilter 将缓冲的所有内容一次性写到 response 中;</p>

<p>需要注意的是, 使用这个 ShallowEtagHeaderFilter, 服务端的性能并没有得到提高, 因为请求逻辑还是执行了, 只是没往客户端发送, 因此节省了一定的网络带宽.</p>

<p>另外, 这个 ShallowEtagHeaderFilter 会让 Transfer-Encoding=Chunked 失效(我们这里就是这种情况).</p>

<h4 id="3.4 解决方案">3.4 解决方案</h4>


<p>根据上面的分析, 我们这里的问题就很好解释了, ShallowEtagHeaderFilter 将我们的流式写缓冲起来, 最后一次性写给客户端并且设置上了 Content-Length 字段.</p>

<p>关于这个问题, 其实很多人都遇到坑了, 有人给 Spring 提 Bug 了, 但是官网认为只是误用(我赞同这种观点).
参考: <a href="https://jira.spring.io/browse/SPR-10855">https://jira.spring.io/browse/SPR-10855</a></p>

<p>解决很简单, 去掉 ShallowEtagHeaderFilter 这个过滤器, 或者给 ShallowEtagHeaderFilter 配置 url pattern 的时候排除掉流式的接口.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring上传组件冲突]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2016/12/30/springshang-chuan-zu-jian-chong-tu/"/>
    <updated>2016-12-30T16:53:49+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2016/12/30/springshang-chuan-zu-jian-chong-tu</id>
    <content type="html"><![CDATA[<p>最近会整理记录这一段时间组内同事以及个人遇到的一些问题。</p>

<ul>
<li><a href="#1.%E8%83%8C%E6%99%AF">1.背景</a></li>
<li><a href="#2.Spring%E4%B8%8A%E4%BC%A0%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90">2.Spring上传机制分析</a></li>
<li><a href="#3.%E5%86%B2%E7%AA%81%E5%88%86%E6%9E%90">3.冲突分析</a></li>
<li><a href="#4.%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3">4.问题解决</a></li>
</ul>


<h2 id="1.背景">1.背景</h2>


<p>问题：Spring上传组件的冲突
背景：同事在原有的上传模块中增加了一个新的文件接口，导致就的上传接口不可用的故障。</p>

<p>新增的配置就是Spring自带的上传解析器：</p>

<pre><code>    &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt;
        &lt;property name="defaultEncoding" value="utf-8"/&gt;
    &lt;/bean&gt;
</code></pre>

<p>示例代码如下：</p>

<pre><code>    ApiResult upload(@RequestParam("uploadFile") CommonsMultipartFile uploadFile) {
        ...
    }
</code></pre>

<p>原始的上传使用的是 commons-fileupload 组件，简单示例代码如下：</p>

<pre><code>upload(HttpServletRequest request) {
        //1.从请求中解析出文件
        ServletFileUpload servletFileUpload = createServletFileUpload();
        List&lt;FileItem&gt; itemList = servletFileUpload.parseRequest(request);
        Map&lt;String, Serializable&gt; fields = getFileFields(itemList);
        FileItem file = (FileItem) fields.get("Filedata");

        //2.内容写本地
        File f = new File(generateFilePath(...));
        FileOutputStream out = new FileOutputStream(f);
        out.write(file.get());
}
</code></pre>

<h2 id="2.Spring上传机制分析">2.Spring上传机制分析</h2>


<p>首先我们从Spring处理请求的源头开始分析，看看Spring是如何支持文件上传的。</p>

<p>1.DispatcherServlet中doDispatch方法中,如果请求是文件上传,会首先将 HttpServletRequest 请求做预处理,转换为 MultipartHttpServletRequest
```
processedRequest = checkMultipart(request);</p>

<pre><code>protected HttpServletRequest checkMultipart(HttpServletRequest request) throws MultipartException {
    if (this.multipartResolver != null &amp;&amp; this.multipartResolver.isMultipart(request)) {    //是文件上传请求
        if (request instanceof MultipartHttpServletRequest) {   //已经是 MultipartHttpServletRequest 了
        }
        else {
            return this.multipartResolver.resolveMultipart(request);    //转换为 MultipartHttpServletRequest
        }
    }
    // If not returned before: return original request.
    return request;
}
</code></pre>

<pre><code>这块两个问题:

    1.如何判定一个请求是不是文件上传请求
    2.转换为 MultipartHttpServletRequest 做了什么事

先看如何判定审核文件上传请求,就是 multipartResolver.isMultipart 的代码,跟代码会涉及到 CommonsMultipartResolver, ServletFileUpload, FileUploadBase,发现判定有两个条件

    (1). 请求是 Post 请求. 参见 ServletFileUpload.isMultipartContent()
    (2).请求 contentType 必须以 multipart/ 开通. 参见 FileUploadBase.isMultipartContent()

 下面看第二个问题,转换 MultipartHttpServletRequest 做的什么事,这个工作由 MultipartResolver.resolveMultipart 完成,我们可以看看注释:
</code></pre>

<pre><code>/**
 * Parse the given HTTP request into multipart files and parameters,
 * and wrap the request inside a
 * {@link org.springframework.web.multipart.MultipartHttpServletRequest} object
 * that provides access to file descriptors and makes contained
 * parameters accessible via the standard ServletRequest methods.
 */
MultipartHttpServletRequest resolveMultipart(HttpServletRequest request) throws MultipartException;
</code></pre>

<pre><code class="`"> 其主要的代码实现在,主要的工作是, 首先将HttpServletRequest的inputStream最终塞入了FileItemStreamImpl的stream中,随后ServletFileUpload类逐个对FileItemStream进行处理（生成FileItem）,通过Streams.copy方法对inputStream进行read操作，此时request中的inputStream被消耗(inputStream只能被读取一次), 最后将List&lt;FileItem&gt;返回,ServletFileUpload的解析方法执行完毕.
</code></pre>

<pre><code> public List&lt;FileItem&gt; parseRequest(RequestContext ctx) throws FileUploadException {
    List&lt;FileItem&gt; items = new ArrayList&lt;FileItem&gt;();
    FileItemIterator iter = getItemIterator(ctx);       //1. 构造FileItemStreamImpl
    ...
    while (iter.hasNext()) {                                            //2.逐个对FileItemStream进行处理
        final FileItemStream item = iter.next();
        ...
        FileItem fileItem = fac.createItem(item.getFieldName(), item.getContentType(), item.isFormField(), fileName);       //2.1 构造一个 FileItem
        items.add(fileItem);
        ...
        Streams.copy(item.openStream(), fileItem.getOutputStream(), true);      //2.2 数据读取
    }
    return items;   // 3. 返回
}
</code></pre>

<p>// 下面是更详细的代码
//1.将HttpServletRequest的inputStream最终塞入了FileItemStreamImpl的stream中
FileItemIteratorImpl(RequestContext ctx) throws FileUploadException, IOException {
    InputStream input = ctx.getInputStream();
    &hellip;
    multi = new MultipartStream(input, boundary, notifier);
    &hellip;
    findNextItem();
}</p>

<p>//2.2 数据读取,看看如何将 request 的 inputstream 数据拷贝到 FileItem 中
    /<em>*
     * Copies the contents of the given {@link InputStream} to the given {@link OutputStream}.
     </em>/
    public static long copy(InputStream inputStream, OutputStream outputStream, boolean closeOutputStream)
            throws IOException {
        return copy(inputStream, outputStream, closeOutputStream, new byte[DEFAULT_BUFFER_SIZE]);
    }
 ```
 主要代码的位置:CommonsMultipartResolver.parseRequest, FileUploadBase.parseRequest, FileItemIteratorImpl</p>

<p> 一个需要注意的点,在DispatcherServlet 中, MultipartResolver 的Bean的名称是写死的:</p>

<pre><code class="`">    /** Well-known name for the MultipartResolver object in the bean factory for this namespace. */
    public static final String MULTIPART_RESOLVER_BEAN_NAME = "multipartResolver";

    private void initMultipartResolver(ApplicationContext context) {
        try {
            this.multipartResolver = context.getBean(MULTIPART_RESOLVER_BEAN_NAME, MultipartResolver.class);    //bean的name固定
            if (logger.isDebugEnabled()) {
                logger.debug("Using MultipartResolver [" + this.multipartResolver + "]");
            }
        }
    }
</code></pre>

<h2 id="3.冲突分析">3.冲突分析</h2>


<p>multipartResolver是一个全局的文件上传处理器,配置上 multipartResolver 这个Bean之后,全局的文件上传都会经过 multipartResolver 处理(读取并解析request的 inputstream ).而 inputstream 仅能处理一次,导致处理完的 HttpServletRequest 中的 inputStream 已经没有内容.</p>

<p>因此后面配置使用的 commons-fileupload 的 ServletFileUpload 无法从 request 中解析出文件上传内容.</p>

<h2 id="4.问题解决">4.问题解决</h2>


<p>几个解决方案:</p>

<pre><code>1.全局统一使用一个解析方式(统一使用 ServletFileUpload 或者 MultipartResolver 方式);
2.继承 CommonsMultipartResolver 实现自定义的 MultipartResolver, 覆写isMultipart方法, 仅部分 url 的上传请求走我们自定义的 MultipartResolver 处理器,保证新老逻辑兼容;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从代理到Spring事务2-AOP]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2016/07/15/cong-dai-li-dao-springshi-wu-aop/"/>
    <updated>2016-07-15T14:26:22+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2016/07/15/cong-dai-li-dao-springshi-wu-aop</id>
    <content type="html"><![CDATA[<ul>
<li><a href="#1.Spring%20AOP">1.Spring AOP</a>

<ul>
<li><a href="#1.1%20%E4%BB%A3%E7%90%86%E7%B1%BB%E5%9E%8B%E9%80%89%E6%8B%A9">1.1 代理类型选择</a></li>
<li><a href="#1.2%20%E4%BB%A3%E7%90%86%E8%B0%83%E7%94%A8">11.2 代理调用</a></li>
<li><a href="#1.3%20Understanding%20AOP%20Proxies">1.3 Understanding AOP Proxies</a></li>
<li><a href="#1.4%20Spring%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%AB%E5%B9%B6%E8%A7%A3%E6%9E%90%E9%85%8D%E7%BD%AE">1.4 Spring如何识别并解析配置</a></li>
<li><a href="#1.5%20Spring%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0AOP">1.5 Spring如何使用代理实现AOP</a></li>
</ul>
</li>
</ul>


<h2 id="1.Spring AOP">1.Spring AOP</h2>


<p>Spring的AOP(Aspect Oriented Programming，面向切面编程)是一个强大的机制，常用场景在日志、安全、异常处理、事务等。Spring AOP的原理正是基于代理。</p>

<p>我想了解的问题包括：</p>

<pre><code>(1).Spring AOP使用什么机制做代理；
(2).Spring 怎么使用代理达到AOP目的；
</code></pre>

<h4 id="#1.1 代理类型选择">#1.1 代理类型选择</h4>


<p>先看看Spring是如何选择代理，先看看 <a href="http://docs.spring.io/spring/docs/3.0.x/reference/aop.html">Spring官方AOP文档</a> 的说明：</p>

<pre><code>Spring AOP defaults to using standard J2SE dynamic proxies for AOP proxies. This enables any interface (or set of interfaces) to be proxied.

Spring AOP can also use CGLIB proxies. This is necessary to proxy classes, rather than interfaces. CGLIB is used by default if a business object does not implement an interface. As it is good practice to program to interfaces rather than classes, business classes normally will implement one or more business interfaces. It is possible to force the use of CGLIB, in those (hopefully rare) cases where you need to advise a method that is not declared on an interface, or where you need to pass a proxied object to a method as a concrete type.
</code></pre>

<p>官方文档的结论是：当业务Bean实现了一个或多个接口的时候，默认使用Java动态代理，当业务Bean没有实现任何接口的时候使用CGLib。</p>

<p>我们来看看相关代码，Spring使用AopProxy表示AOP中的代理，它的作用只要一个：创建代理对象。它有两个实现类：JdkDynamicAopProxy 和 CglibAopProxy ：</p>

<pre><code>public interface AopProxy {
    Object getProxy();

    Object getProxy(ClassLoader classLoader);
}

// JdkDynamicAopProxy 实现了 InvocationHandler，实际产生代理类使用 Proxy
final class JdkDynamicAopProxy implements AopProxy, InvocationHandler, Serializable {
    public Object getProxy(ClassLoader classLoader) {
        ...
        return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);
    }
}

final class CglibAopProxy implements AopProxy, Serializable {
    public Object getProxy(ClassLoader classLoader) {
        Class&lt;?&gt; rootClass = this.advised.getTargetClass();

        // 配置 CGLIB Enhancer...
        Enhancer enhancer = createEnhancer();
        enhancer.setSuperclass(proxySuperClass);
        enhancer.setStrategy(new UndeclaredThrowableStrategy(UndeclaredThrowableException.class));
        enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(this.advised));
        enhancer.setInterceptDuringConstruction(false);

        Callback[] callbacks = getCallbacks(rootClass);
        enhancer.setCallbacks(callbacks);
        enhancer.setCallbackFilter(new ProxyCallbackFilter(
                this.advised.getConfigurationOnlyCopy(), this.fixedInterceptorMap, this.fixedInterceptorOffset));

        Class&lt;?&gt;[] types = new Class[callbacks.length]; //CGLib的回调机制
        for (int x = 0; x &lt; types.length; x++) {
            types[x] = callbacks[x].getClass();
        }
        enhancer.setCallbackTypes(types);

        // 产生代理类并产生代理类的一个instance
        Object proxy;
        if (this.constructorArgs != null) {
            proxy = enhancer.create(this.constructorArgTypes, this.constructorArgs);
        } else {
            proxy = enhancer.create();
        }

        return proxy;
    }
}
</code></pre>

<p>AopProxyFactory的默认实现类DefaultAopProxyFactory：</p>

<pre><code>    public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {
        if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {
            Class targetClass = config.getTargetClass();
            if (targetClass == null) {
                throw new AopConfigException("TargetSource cannot determine target class: " +
                        "Either an interface or a target is required for proxy creation.");
            }
            if (targetClass.isInterface()) {    //被代理类，实现了接口，就使用Java动态代理
                return new JdkDynamicAopProxy(config);
            }
            return CglibProxyFactory.createCglibProxy(config);  //没有实现接口使用 CGLib代理
        }
        else {
            return new JdkDynamicAopProxy(config);
        }
    }
</code></pre>

<p>其中 AdvisedSupport 是 AOP配置管理的基类。这几个配置的说明可以参见 ProxyConfig 类。其中我注释的地方和官方文档是一致的。</p>

<h4 id="#1.2 代理调用">#1.2 代理调用</h4>


<p>得到代理对象之后的下一步就是调用代理逻辑，这部分实现直接看 JdkDynamicAopProxy.invoke() 代码：</p>

<pre><code>public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    //TargetSource包括被代理者的一些属性
    TargetSource targetSource = this.advised.targetSource;
    try {
        Object retVal;

        // 具体的被代理对象
        target = targetSource.getTarget();
        if (target != null) {
            targetClass = target.getClass();
        }

        // 从代理配置中获取方法上的 MethodInterceptor
        List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);

        // 没有 MethodInterceptor，直接反射调用
        if (chain.isEmpty()) {
            retVal = AopUtils.invokeJoinpointUsingReflection(target, method, args);
        } else {
            // 创建 MethodInvocation 并调用
            invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);
            retVal = invocation.proceed();
        }

        return retVal;
    }
}
</code></pre>

<p>先看看如何获取方法上的 MethodInterceptor，AdvisedSupport其实只是对这个做缓存，实际调用 DefaultAdvisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice：</p>

<pre><code>/**
 * 从提供的配置实例config中获取advisor列表,遍历处理这些advisor
 * 如果是PointcutAdvisor,则判断此Advisor能否应用到目标方法method上.
 * 将满足条件的Advisor通过AdvisorAdaptor转化成Interceptor列表返回
 */
public List&lt;Object&gt; getInterceptorsAndDynamicInterceptionAdvice(
        Advised config, Method method, Class targetClass) {

    List&lt;Object&gt; interceptorList = new ArrayList&lt;Object&gt;(config.getAdvisors().length);
    boolean hasIntroductions = hasMatchingIntroductions(config, targetClass);
    AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();
    for (Advisor advisor : config.getAdvisors()) {
        if (advisor instanceof PointcutAdvisor) {
            PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;
            if (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(targetClass)) {
                //将Advisor转化成Interceptor
                MethodInterceptor[] interceptors = registry.getInterceptors(advisor);
                MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();

                //检查当前advisor的pointcut是否可以匹配当前方法
                if (MethodMatchers.matches(mm, method, targetClass, hasIntroductions)) {
                    if (mm.isRuntime()) {
                        // Creating a new object instance in the getInterceptors() method
                        // isn't a problem as we normally cache created chains.
                        for (MethodInterceptor interceptor : interceptors) {
                            interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm));
                        }
                    }
                    else {
                        interceptorList.addAll(Arrays.asList(interceptors));
                    }
                }
            }
        }
        ...
    }
    return interceptorList;
}
</code></pre>

<p>下面看看这些 Interceptor 是如何起作用的，看 ReflectiveMethodInvocation 的 proceed() 方法逻辑：</p>

<pre><code>public Object proceed() throws Throwable {
    // currentInterceptorIndex 表示 Interceptor 链中的当前调用的下标
    Object interceptorOrInterceptionAdvice = this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);
    if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {
        InterceptorAndDynamicMethodMatcher dm = (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;
        // 运行时参数(arguments)是否满足匹配条件
        if (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) {
            return dm.interceptor.invoke(this);
        } else {
            // 不匹配，直接跳过当前这个 Interceptor，执行下一个 Interceptor
            return proceed();
        }
    }
}
</code></pre>

<h4 id="#1.3 Understanding AOP Proxies">#1.3 Understanding AOP Proxies</h4>


<p>这里其实完全参考Spring AOP官方文档的一节就行了：<a href="http://docs.spring.io/spring/docs/3.0.x/reference/aop.html#aop-understanding-aop-proxies">http://docs.spring.io/spring/docs/3.0.x/reference/aop.html#aop-understanding-aop-proxies</a></p>

<p>看懂了这一节，能很明白为什么内部调用的方法上的事务注解无效，我们日常犯的错误基本不会有了。</p>

<h4 id="#1.4 Spring如何识别并解析配置">#1.4 Spring如何识别并解析配置</h4>


<p>我们都是通过XML文件的形式使用Spring，Spring使用XmlBeanDefinitionReader类来读取解析XML文件，XmlBeanDefinitionReader使用DefaultBeanDefinitionDocumentReader，再调用BeanDefinitionParserDelegate，其中会根据配置的不同找到对应的NamespaceHandler来处理对应的标签。NamespaceHandler是一个接口，一个具体接口就是解析XML中的一个Element得到一个Spring容器中的一个Bean。</p>

<pre><code>public interface NamespaceHandler {
    BeanDefinition parse(Element element, ParserContext parserContext);
}
</code></pre>

<p>NamespaceHandler的具体实现类很多，其中几个我们感兴趣的AopNamespaceHandler，MvcNamespaceHandler，QScheduleNamespaceHandler，QConfigNamespaceHandler，QmqClientNamespaceHandler等，看到这里大家应该很熟悉了。我们来看两个实现吧：</p>

<pre><code>public class AopNamespaceHandler extends NamespaceHandlerSupport {
    public void init() {
        registerBeanDefinitionParser("config", new ConfigBeanDefinitionParser());
        registerBeanDefinitionParser("aspectj-autoproxy", new AspectJAutoProxyBeanDefinitionParser());
        registerBeanDefinitionDecorator("scoped-proxy", new ScopedProxyBeanDefinitionDecorator());
        registerBeanDefinitionParser("spring-configured", new SpringConfiguredBeanDefinitionParser());
    }
}

public class MvcNamespaceHandler extends NamespaceHandlerSupport {
    public void init() {
        registerBeanDefinitionParser("annotation-driven", new AnnotationDrivenBeanDefinitionParser());
        registerBeanDefinitionParser("default-servlet-handler", new DefaultServletHandlerBeanDefinitionParser());
        registerBeanDefinitionParser("interceptors", new InterceptorsBeanDefinitionParser());
        registerBeanDefinitionParser("resources", new ResourcesBeanDefinitionParser());
        registerBeanDefinitionParser("view-controller", new ViewControllerBeanDefinitionParser());
    }
}
</code></pre>

<p>就是说Spring将配置根据作用分成不同的namespace，每个NamespaceHandler只解析自己独有的几个配置，比如AopNamespaceHandler负责解析scoped-proxy等几个配置，比如我们在配置文件配上：</p>

<p>```</p>

<!--aop就表示namespace-->


<p>&lt;aop:config proxy-target-class=&ldquo;true&rdquo;/></p>

<p>```
最后就会找到AopNamespaceHandler类解析这个配置。那出了这些带namespace的配置，正常的配置谁来解析？DefaultBeanDefinitionDocumentReader。</p>

<p>spring在解析的过程中，会去收集spring.*.jar/META-INF下的spring.handlers,spring.schemas文件，这2个文件就是指明了解析spring中自定义标签的Namespace类。如果自己开发Spring组件，需要增加新的标签，也可以按照这个机制。<a href="www.qunar.com">我司</a>的同学可以看看qmq-client包下的META-INF下的这两个文件。</p>

<p>到目前为止，大致知道了谁来解析AOP相关的标签。我们继续看看 AopNamespaceHandler 的代码，它的init()的方法就是给每个标签找一个解析器，比如 aop:config 这个配置就会找到 ConfigBeanDefinitionParser 这个解析器。,些解析器只有一个parse入口函数。</p>

<p>最后放一张AOP相关的图(来源：<a href="http://blog.csdn.net/moreevan/article/details/11977115">http://blog.csdn.net/moreevan/article/details/11977115</a>)</p>

<p><img src="/images/spring/aop_class.png"></p>

<h4 id="#1.5 Spring如何使用代理实现AOP">#1.5 Spring如何使用代理实现AOP</h4>


<p>最后我们整理一下Spring使用代理实现AOP整个流程的步骤。</p>

<p>1.我们在代码中使用引入bean；
2.Spring从BeanFactory总获取bean(ApplicationContext.getBean)，参见AbstractBeanFactory.getBean代码：</p>

<pre><code>    public Object getBean(String name) throws BeansException {
        return doGetBean(name, null, null, false);
    }
    protected &lt;T&gt; T doGetBean(final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly)
            throws BeansException {

        final String beanName = transformedBeanName(name);
        Object bean;

        // 创建单例的bean
        if (mbd.isSingleton()) {
            sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() {
                public Object getObject() throws BeansException {
                    try {
                        return createBean(beanName, mbd, args);    //创建Bean
                    }
                }
            });
            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
        }
    }
</code></pre>

<p>3.触发Bean的创建，参考AbstractAutowireCapableBeanFactory.createBean代码：</p>

<pre><code>    public Object createBean(Class beanClass, int autowireMode, boolean dependencyCheck) throws BeansException {
        // Use non-singleton bean definition, to avoid registering bean as dependent bean.
        RootBeanDefinition bd = new RootBeanDefinition(beanClass, autowireMode, dependencyCheck);
        bd.setScope(BeanDefinition.SCOPE_PROTOTYPE);
        return createBean(beanClass.getName(), bd, null);       //---1
    }
    protected Object createBean(final String beanName, final RootBeanDefinition mbd, final Object[] args)
            throws BeanCreationException {
        ...
        Object beanInstance = doCreateBean(beanName, mbd, args);        //---2
        return beanInstance;
    }
    protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) {
        // Eagerly cache singletons to be able to resolve circular references
        // even when triggered by lifecycle interfaces like BeanFactoryAware.
        boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;
                isSingletonCurrentlyInCreation(beanName));
        if (earlySingletonExposure) {
            addSingletonFactory(beanName, new ObjectFactory() {
                public Object getObject() throws BeansException {
                    return getEarlyBeanReference(beanName, mbd, bean);      //---3
                }
            });
        }

        // Initialize the bean instance.
        ...
        return exposedObject;
    }
    protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) {
        Object exposedObject = bean;
        if (bean != null &amp;&amp; !mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {
            for (BeanPostProcessor bp : getBeanPostProcessors()) {
                if (bp instanceof SmartInstantiationAwareBeanPostProcessor) {
                    SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;
                    exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);     //---逐层包装bean
                    if (exposedObject == null) {
                        return exposedObject;
                    }
                }
            }
        }
        return exposedObject;
    }
</code></pre>

<ol>
<li>触发代理类对象的创建，见 AbstractAutoProxyCreator，这个其实是一个 BeanPostProcessor，关于BeanPostProcessor的作用见它的注释：</li>
</ol>


<pre><code> * Factory hook that allows for custom modification of new bean instances,
 * e.g. checking for marker interfaces or wrapping them with proxies.
</code></pre>

<p>AbstractAutoProxyCreator代码：</p>

<pre><code>    public Object getEarlyBeanReference(Object bean, String beanName) throws BeansException {
        Object cacheKey = getCacheKey(bean.getClass(), beanName);
        this.earlyProxyReferences.put(cacheKey, Boolean.TRUE);
        return wrapIfNecessary(bean, beanName, cacheKey);
    }
    protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {
        // 获取被代理bean上的所有的 Advisor
        Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);
        if (specificInterceptors != DO_NOT_PROXY) {
            this.advisedBeans.put(cacheKey, Boolean.TRUE);
            //为制定类创建代理bean
            Object proxy = createProxy(bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));
            this.proxyTypes.put(cacheKey, proxy.getClass());
            return proxy;
        }
    }

    protected Object createProxy(
            Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource) {
        // ProxyFactory 继承自 ProxyConfig，局部变量
        ProxyFactory proxyFactory = new ProxyFactory();
        proxyFactory.copyFrom(this);

        // shouldProxyTargetClass表示显示的定义了proxy-target-class="true"
        // 没有定义则可能需要被代理类的 interface 信息
        if (!shouldProxyTargetClass(beanClass, beanName)) {
            Class&lt;?&gt;[] targetInterfaces = ClassUtils.getAllInterfacesForClass(beanClass, this.proxyClassLoader);
            for (Class&lt;?&gt; targetInterface : targetInterfaces) {
                proxyFactory.addInterface(targetInterface);
            }
        }

        Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);
        for (Advisor advisor : advisors) {
            proxyFactory.addAdvisor(advisor);
        }

        proxyFactory.setTargetSource(targetSource); //被代理者
        ...
        // 创建代理对象
        return proxyFactory.getProxy(this.proxyClassLoader);
    }
</code></pre>

<p>ProxyFactory.java:</p>

<pre><code>    public Object getProxy(ClassLoader classLoader) {
        return createAopProxy().getProxy(classLoader);
    }
    protected final synchronized AopProxy createAopProxy() {
        if (!this.active) {
            activate();
        }
        return getAopProxyFactory().createAopProxy(this);
    }
</code></pre>

<p>DefaultAopProxyFactory.java的createAopProxy，回到了我们 1.1 代理类型选择 中涉及的内容，整个过程串起来了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从代理到Spring事务3-Spring事务]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2016/07/07/springshi-wu/"/>
    <updated>2016-07-07T18:45:10+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2016/07/07/springshi-wu</id>
    <content type="html"><![CDATA[<ul>
<li><a href="#1.Spring%E4%BA%8B%E5%8A%A1">1.Spring事务</a>

<ul>
<li><a href="#1.1%20%E4%BA%8B%E5%8A%A1%E5%AE%9A%E4%B9%89">1.1 事务定义</a></li>
<li><a href="#1.2%20%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8">1.2 事务管理器</a></li>
<li><a href="#1.3%20How%20Transactional%20Works">1.3 How Transactional Works</a></li>
<li><a href="#1.4%20Roll%20Back">1.4 Roll Back</a></li>
<li><a href="#1.4%20Pitfalls">1.5 Pitfalls</a></li>
</ul>
</li>
</ul>


<h2 id="1.Spring事务">1.Spring事务</h2>


<p>我们使用事务的目标：</p>

<pre><code>The most common reason for using transactions in an application is to maintain a high degree of data integrity and consistency.
</code></pre>

<p>我的理解Spring事务中包括的几个主要要素，下面会一一讲解：</p>

<pre><code>1.事务定义：事务包含哪些属性
2.事务管理器：如何将我们对事务的诉求转化为数据库层面的实现
3.事务切面：Spring底层是如何将业务和事务串起来的
</code></pre>

<p>关于事务的使用是最简单的，通常分为 编程式事务 和 注解式事务：</p>

<h5>编程式事务</h5>

<p>代码直接使用PlatformTransactionManager，因此需要使用者自己管理事务的创建，提交，回滚，挂起等逻辑。</p>

<p>优点：灵活度大；
缺点：使用难度大，易出错，业务代码侵入大；</p>

<p><a href="http://www.tutorialspoint.com/spring/programmatic_management.htm">一个编程式事务的完整Demo</a></p>

<p>我们可以使用 Spring 提供的 TransactionTemplate 类来简化编程事务：</p>

<pre><code>    TransactionTemplate template = new TransactionTemplate();
    template.setIsolationLevel(org.springframework.transaction.TransactionDefinition.ISOLATION_DEFAULT);
    template.setPropagationBehavior(org.springframework.transaction.TransactionDefinition.PROPAGATION_REQUIRED);
    template.setTransactionManager(transactionManager);
    template.execute(new TransactionCallback&lt;UserAo&gt;() {
        @Override
        public UserAo doInTransaction(TransactionStatus status) {
             //business logic
        }
    });
</code></pre>

<p>我们可以看一下 TransactionTemplate 的实现代码，TransactionTemplate继承了DefaultTransactionDefinition(实现了TransactionDefinition)，使用TransactionDefinition需要我们给定一个TransactionManager，可以修改 事务隔离级别，事务传播行为等事务属性(其实是DefaultTransactionDefinition提供的功能)。</p>

<pre><code>    public &lt;T&gt; T execute(TransactionCallback&lt;T&gt; action) throws TransactionException {
        TransactionStatus status = this.transactionManager.getTransaction(this);    //获取并初始化事务，处理比如事务传播形式等
        T result;
        try {
            result = action.doInTransaction(status);    //业务逻辑，包括自定义的回滚
        } catch (RuntimeException ex) {
            // Transactional code threw application exception -&gt; rollback
            rollbackOnException(status, ex);
            throw ex;
        } catch (Error err) {
            // Transactional code threw error -&gt; rollback
            rollbackOnException(status, err);
            throw err;
        } catch (Exception ex) {
            // Transactional code threw unexpected exception -&gt; rollback
            rollbackOnException(status, ex);
            throw new UndeclaredThrowableException(ex, "TransactionCallback threw undeclared checked exception");
        }
        this.transactionManager.commit(status); //事务提交
        return result;
    }
</code></pre>

<p>其中 transactionManager.getTransaction(this) 的代码后面会详细分析。</p>

<h5>注解式事务</h5>

<p>使用 @Transactional 来管理事务，我们需要声明一个全局的事务管理器，以及事务对注解的支持：</p>

<pre><code>    &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
        &lt;property name="dataSource" ref="dataSource"/&gt;
    &lt;/bean&gt;

    &lt;tx:annotation-driven transaction-manager="txManager"/&gt;
</code></pre>

<p>优点：使用简单，业务代码侵入小；
缺点：理解有难度；</p>

<p>注意：Spring建议在具体业务实现类上使用Transactional注解，而不是在接口或则接口的方法上配置@Transactional注解：</p>

<pre><code>The Spring team’s recommendation is that you only annotate concrete classes with the @Transactional annotation, as opposed to annotating interfaces. 
You certainly can place the @Transactional annotation on an interface (or an interface method), but this will only work as you would expect it to if you are using interface-based proxies. 
The fact that annotations are not inherited means that if you are using class-based proxies (proxy-target-class=“true“) or the weaving-based aspect (mode=“aspectj“) then the transaction settings will not be recognised by the proxying/weaving infrastructure and the object will not be wrapped in a transactional proxy (which would be decidedly bad). 
So please do take the Spring team’s advice and only annotate concrete classes (and the methods of concrete classes) with the @Transactional annotation.
</code></pre>

<p>Transactional注解上可以设置很多事务相关的参数：</p>

<pre><code>public @interface Transactional {
    /**
     * 用于配置事务管理器，当系统中存在多个数据源多个事务管理器的时候有用
     * 配置 txManager1 这种 bean name
     */
    String value() default "";

    /**
     * 事务传播级别
     */
    Propagation propagation() default Propagation.REQUIRED;

    /**
     * 事务隔离级别
     */
    Isolation isolation() default Isolation.DEFAULT;

    /**
     * 事务超时时间
     */
    int timeout() default TransactionDefinition.TIMEOUT_DEFAULT;

    /**
     * 事务是否read-only
     * 注意：这个设置对真实的事务执行系统是一个 hint 而不是 强制要求有这个配置的情况下 write 一定导致失败
     */
    boolean readOnly() default false;

    /**
     * 定义0个或多个exception，当事务遇到这些异常的时候，事务会回滚
     */
    Class&lt;? extends Throwable&gt;[] rollbackFor() default {};

    /**
     * 定义0个或多个exception的name，当事务遇到这些异常的时候，事务会回滚
     * 最好定义完整的路径，比如 javax.servlet.ServletException 会代表 ServletException 本身及子类
     */
    String[] rollbackForClassName() default {};

    /**
     * 定义0个或多个exception，当事务遇到这些异常的时候，事务不会回滚
     */
    Class&lt;? extends Throwable&gt;[] noRollbackFor() default {};

    /**
     * 定义0个或多个exception的name，当事务遇到这些异常的时候，事务不会回滚
     */
    String[] noRollbackForClassName() default {};
}
</code></pre>

<h4 id="1.1 事务定义">1.1 事务定义</h4>


<p>如何定义一个事务，Spring中使用 TransactionDefinition 来定义一个事务的属性，使用接口的形式：</p>

<pre><code>public interface TransactionDefinition {
    /**
     * 事务传播行为,可选项参见 TransactionDefinition 中定义的 PROPAGATION_XXX
     */
    int getPropagationBehavior();

    /**
     * 事务隔离级别,可选项参见 TransactionDefinition 中定义的 ISOLATION_XXX
     * 只在 PROPAGATION_REQUIRED 和 PROPAGATION_REQUIRES_NEW 这两个事务传播行为配置下有效
     */
    int getIsolationLevel();

    /**
     * 事务超时时间,单位秒
     * 默认 TIMEOUT_DEFAULT = -1 表示使用底层实现的超时时间或者没有(不支持事务超时时间)
     * 只在 PROPAGATION_REQUIRED 和 PROPAGATION_REQUIRES_NEW 这两个事务传播行为配置下有效
     * 如果事务管理器不支持设置超时时间，而调用了这个接口会抛出异常
     */
    int getTimeout();

    boolean isReadOnly();

    /**
     * 事务name，允许为null
     * 对于申明式事务，默认的name为：完整的class名称.metho名称
     */
    String getName();
}
</code></pre>

<p>TransactionDefinition 有一个默认实现 DefaultTransactionDefinition，其中定义了事务几个属性的默认值：</p>

<pre><code>    private int propagationBehavior = PROPAGATION_REQUIRED;
    private int isolationLevel = ISOLATION_DEFAULT;
    private int timeout = TIMEOUT_DEFAULT;
    private boolean readOnly = false;
</code></pre>

<h5>事务传播</h5>

<p>关于事务的传播行为，这里简单介绍一下：</p>

<pre><code>    /**
     * 如果已经存在事务直接使用，如果不存在则创建一个新事务
     */
    int PROPAGATION_REQUIRED = 0;

    /**
     * 如果已经存在事务直接使用，如果不存在则不使用事务
     */
    int PROPAGATION_SUPPORTS = 1;

    /**
     * 如果已经存在事务直接使用，如果不存在则抛出异常
     */
    int PROPAGATION_MANDATORY = 2;

    /**
     * 创建一个新事务，如果如果已经存在事务则将当前事务挂起
     */
    int PROPAGATION_REQUIRES_NEW = 3;

    /**
     * 不使用事务，如果当前已经存在事务则将当前事务挂起
     */
    int PROPAGATION_NOT_SUPPORTED = 4;

    /**
     * 不使用事务，如果当前存在事务则跑出异常
     */
    int PROPAGATION_NEVER = 5;

    /**
     * 如果已经存在事务直接使用，则执行一个嵌套事务，如果当前没有事务就创建一个新事务
     */
    int PROPAGATION_NESTED = 6;
</code></pre>

<p>其中 PROPAGATION_NESTED 理解有点困难，可以参考 <a href="http://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/transaction.html#tx-propagation">Spring 的文档</a>：</p>

<pre><code>PROPAGATION_NESTED uses a single physical transaction with multiple savepoints that it can roll back to. 
Such partial rollbacks allow an inner transaction scope to trigger a rollback for its scope, with the outer transaction being able to continue the physical transaction despite some operations having been rolled back. 
This setting is typically mapped onto JDBC savepoints, so will only work with JDBC resource transactions. See Spring's DataSourceTransactionManager.
</code></pre>

<p>大致意思就是关于 SavePoint，JDBC定义了java.sql.SavePoint接口，提供在一个更细粒度的事务控制机制。当设置了一个保存点后，可以rollback到该保存点处的状态，而不是rollback整个事务。Connection接口的setSavepoint和releaseSavepoint方法可以设置和释放保存点。
而Spring中定义了 SavepointManager，用于 SavePoint 的创建(createSavepoint)，回滚(rollbackToSavepoint)，释放(releaseSavepoint)。</p>

<h5>事务隔离级别</h5>

<p>关于事务的隔离级别，也简单介绍一下，除了 ISOLATION_DEFAULT ，其余均使用 java.sql.Connection 中的隔离级别的定义：</p>

<pre><code>    /**
     * 使用底层数据源的隔离级别
     * 参考：java.sql.Connection.getTransactionIsolation()
     */
    int ISOLATION_DEFAULT = -1;

    /**
     * READ_UNCOMMITTED
     */
    int ISOLATION_READ_UNCOMMITTED = Connection.TRANSACTION_READ_UNCOMMITTED;

    /**
     * READ_COMMITTED
     */
    int ISOLATION_READ_COMMITTED = Connection.TRANSACTION_READ_COMMITTED;

    /**
     * REPEATABLE_READ
     */
    int ISOLATION_REPEATABLE_READ = Connection.TRANSACTION_REPEATABLE_READ;

    /**
     * SERIALIZABLE
     */
    int ISOLATION_SERIALIZABLE = Connection.TRANSACTION_SERIALIZABLE;
</code></pre>

<h4 id="1.2 事务管理器">1.2 事务管理器</h4>


<p>事务管理 Spring 使用 PlatformTransactionManager 定义，其中包含一个事务的三个主要操作，在业务开始之前开始事务，执行业务逻辑之后提交事务，业务逻辑异常则回滚事务：</p>

<pre><code>public interface PlatformTransactionManager {
    /**
     * 根据事务定义(TransactionDefinition),返回当前active事务或者创建一个新的事务
     * 注意：
     * 1.TransactionDefinition 中的隔离级别超时时间等设置只在创建了新事物的时候有效，如果使用当前已存在的事务则无效
     * 2.不是所有的事务管理器都支持 TransactionDefinition 中的所有属性，当事务管理器遇到不支持的属性则抛异常
     * 3.上条规则的例外是 read-only这个属性，如果事务管理器不支持这个属性直接忽略
     */
    TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;

    /**
     * 事务提交
     */
    void commit(TransactionStatus status) throws TransactionException;

    /**
     * 回滚事务
     */
    void rollback(TransactionStatus status) throws TransactionException;
}
</code></pre>

<p>我们熟悉的 JDBC 支持的事务管理器 DataSourceTransactionManager 就是其一个实现，其他还包括 JtaTransactionManager 等。</p>

<p>同时，Spring提供了一个 TransactionStatus 的就看便于再代码中控制事务以及获取事物状态。在PlatformTransactionManager中获取事务的返回值就是一个 TransactionStatus 对象。</p>

<h4 id="1.3 How Transactional Works">1.3 How Transactional Works</h4>


<p>下面会讲解我们使用的 Transactional 注解的工作原理，即当我们在Service的某个public方法上加上 @Transactional之后，从编译到调用这个方法整个过程中会发生什么，事务再其中如何起作用。</p>

<p>这个好像没什么讲的，就是AOP的实现原理。简单的说就是创建Bean的时候会创建一个代理Bean，使用AOP实现事务，参考上一届的AOP实现原理。我们可以参考 TransactionInterceptor 的代码。</p>

<h4 id="1.4 线程保持">1.4 线程保持</h4>




<h4 id="1.5 Roll Back">1.5 Roll Back</h4>


<p>主要关注Spring事务的回滚，其实主要就是要搞明白Spring在什么情况下会回滚。</p>

<h4 id="1.6 Pitfalls">1.6 Pitfalls</h4>


<p>事务的坑
<a href="http://www.ibm.com/developerworks/library/j-ts1/">http://www.ibm.com/developerworks/library/j-ts1/</a></p>

<p>代理实现选择器:
AdviceMode
TransactionManagementConfigurationSelector</p>

<p>声明事务切面实现:
TransactionInterceptor</p>

<p>事务实现
Connection关闭自动提交
ConnectionHolder来保持Connection</p>

<p>参考:
<a href="http://openwares.net/java/spring_mybatis_transaction.html">http://openwares.net/java/spring_mybatis_transaction.html</a>
<a href="http://my.oschina.net/guanzhenxing/blog/214228">http://my.oschina.net/guanzhenxing/blog/214228</a>
<a href="http://www.mybatis.org/spring/zh/transactions.html">http://www.mybatis.org/spring/zh/transactions.html</a>
<a href="http://tracylihui.github.io/2015/07/28/spring/Spring%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/">http://tracylihui.github.io/2015/07/28/spring/Spring%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</a>
<a href="http://www.cnblogs.com/davenkin/archive/2013/02/16/java-tranaction-1.html">http://www.cnblogs.com/davenkin/archive/2013/02/16/java-tranaction-1.html</a>
<a href="http://www.importnew.com/12300.html">http://www.importnew.com/12300.html</a>
详细介绍Spring事务管理: <a href="http://developer.51cto.com/art/200906/129854.htm">http://developer.51cto.com/art/200906/129854.htm</a>
spring事务原理1-事务的抽象: <a href="http://sqtds.github.io/2014/06/09/2014/spring-tx1/">http://sqtds.github.io/2014/06/09/2014/spring-tx1/</a>
Spring官方文档Transaction Management: <a href="http://docs.spring.io/autorepo/docs/spring/3.2.x/spring-framework-reference/html/transaction.html">http://docs.spring.io/autorepo/docs/spring/3.2.x/spring-framework-reference/html/transaction.html</a>
Spring官方文档Aspect Oriented Programming with Spring: <a href="http://docs.spring.io/spring/docs/3.0.x/reference/aop.html">http://docs.spring.io/spring/docs/3.0.x/reference/aop.html</a>
StackOverFlow Spring - @Transactional - What happens in background?: <a href="http://stackoverflow.com/questions/1099025/spring-transactional-what-happens-in-background">http://stackoverflow.com/questions/1099025/spring-transactional-what-happens-in-background</a>
Transaction strategies: Understanding transaction pitfalls: <a href="http://www.ibm.com/developerworks/library/j-ts1/">http://www.ibm.com/developerworks/library/j-ts1/</a>
Annotation-based Transactions in Spring: <a href="http://springinpractice.com/2008/03/18/annotation-based-transactions-in-spring">http://springinpractice.com/2008/03/18/annotation-based-transactions-in-spring</a>
Design principle behind Transaction framework with Spring 3: <a href="http://stackoverflow.com/questions/11789857/design-principle-behind-transaction-framework-with-spring-3">http://stackoverflow.com/questions/11789857/design-principle-behind-transaction-framework-with-spring-3</a>
Chapter 6. 使用Spring进行面向切面编程（AOP）: <a href="http://shouce.jb51.net/spring/aop.html">http://shouce.jb51.net/spring/aop.html</a>
wiki: <a href="http://wiki.corp.qunar.com/display/~yushen.ma/Spring+3.x-JDBC+Transaction">http://wiki.corp.qunar.com/display/~yushen.ma/Spring+3.x-JDBC+Transaction</a>
spring事务: <a href="http://wiki.corp.qunar.com/pages/viewpage.action?pageId=52084161">http://wiki.corp.qunar.com/pages/viewpage.action?pageId=52084161</a>
spring 事务: <a href="http://wiki.corp.qunar.com/pages/viewpage.action?pageId=93338632">http://wiki.corp.qunar.com/pages/viewpage.action?pageId=93338632</a>
aspectj事务: <a href="http://wiki.corp.qunar.com/pages/viewpage.action?pageId=92656954">http://wiki.corp.qunar.com/pages/viewpage.action?pageId=92656954</a></p>

<p>Demo:
编程事务: <a href="http://www.tutorialspoint.com/spring/programmatic_management.htm">http://www.tutorialspoint.com/spring/programmatic_management.htm</a>
声明事务: <a href="http://www.tutorialspoint.com/spring/declarative_management.htm">http://www.tutorialspoint.com/spring/declarative_management.htm</a></p>

<p>@Transactional注解工作原理：<a href="http://blog.csdn.net/dslztx/article/details/46636079">http://blog.csdn.net/dslztx/article/details/46636079</a>
分布式事务系列（1.2）Spring的事务体系： <a href="https://yq.aliyun.com/articles/39046">https://yq.aliyun.com/articles/39046</a>
spring transaction源码分析&ndash;事务架构：<a href="http://www.cnblogs.com/davidwang456/p/4309038.html">http://www.cnblogs.com/davidwang456/p/4309038.html</a></p>

<p><a href="http://blog.csdn.net/szwangdf/article/details/41516239">http://blog.csdn.net/szwangdf/article/details/41516239</a></p>

<p>AopProxy
DefaultAopProxyFactory</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从代理到Spring事务1-代理]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2016/03/11/cong-dai-li-dao-springshi-wu/"/>
    <updated>2016-03-11T17:15:46+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2016/03/11/cong-dai-li-dao-springshi-wu</id>
    <content type="html"><![CDATA[<ul>
<li><a href="#1.%E4%BB%A3%E7%90%86">1.代理</a>

<ul>
<li><a href="#1.1%20%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F">1.1 代理模式</a></li>
<li><a href="#1.2%20Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">1.2 Java动态代理</a></li>
<li><a href="#1.3%20CGLib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">1.3 CGLib动态代理</a>
<a href="#1.4%20Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%20VS%20CGLib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">1.4 Java动态代理 VS CGLib动态代理</a></li>
</ul>
</li>
</ul>


<p>最近再项目中发现不少同事(包括自己)不太理解默认情况下的Spring事务的运行机制(主要是不理解AOP机制),导致随意使用事务注解.因此也在很多场景事务不生效。因此想从代理机制开始理一下整个Spring声明式事务的原理。</p>

<p>因为篇幅太长，分成三个部分：</p>

<pre><code>(1).代理
(2).Spring的AOP
(3).Spring的事务
</code></pre>

<h2 id="1.代理">1.代理</h2>


<p>通常，我们代码中处理核心的业务逻辑，还包含一些枝节性的代码和功能，比如日志记录、消息发送、安全、事务保证和监控等。</p>

<p>我们通常期望将这些枝节性的代码功能和我们的核心业务逻辑分离，减少业务功能和枝节功能的耦合。这时候我们就要使用代理来达到我们的目的。</p>

<p>代理的作用是：为其它对象提供一种代理以控制对这个对象的访问。简单理解就是中间的作用。代理一般涉及到三个角色：</p>

<pre><code>(1).抽象角色：声明真实对象和代理对象的共同接口；
(2).代理角色：代理对象内部包含有真实角色的引用，从而可以操作真实角色，同时代理对象与真实对象有相同的接口，能在任何时候代替真实对象，同时代理对象可以在执行真实对 象前后加入特定的逻辑以实现功能的扩展；
(3).真实角色：代理角色所代表的真实对象，是我们最终要引用的对象；
</code></pre>

<h4 id="1.1 代理模式">1.1 代理模式</h4>


<p>代理模式是一个经典的设计模式，介绍往上很多。</p>

<p>下面是一个最简单的实现：</p>

<pre><code>public interface IHello {
    void hello();
}

public class HelloImpl implements IHello {
    @Override
    public void hello() {
        System.out.println("HelloImpl: Hello World.");
    }
}

public class HelloProxyImpl implements IHello {

    private IHello inner;

    public HelloProxyImpl(IHello inner) {
        this.inner = inner;
    }

    @Override
    public void hello() {
        doSomethingBefore();

        inner.hello();

        doSomethingAfter();
    }

    private void doSomethingBefore() {
        System.out.println("HelloProxyImpl: Before hello()...");
    }

    private void doSomethingAfter() {
        System.out.println("HelloProxyImpl: After hello()...");
    }

}
</code></pre>

<p>UML图大致如下：
<img src="/images/spring/proxy_mode.png"></p>

<p>从代码上我们可以看出，代理模式要求(这也是它的限制所在)：</p>

<pre><code>(1).代理类需要和被代理者一样实现相同的接口；
(2).代理类包含被代理者的引用；
</code></pre>

<h4 id="1.2 Java动态代理">1.2 Java动态代理</h4>


<p>代理模式我们可以理解为一种静态代理，其问题是需要我们显示的为每个需要被代理的类实现一个代理类，即一个代理类只能为i一个被代理者做代理的功能。如果有上千个类需要代理，估计要骂娘了。</p>

<p>java动态代理正是为了解决这个问题。主要通过java.lang.reflect.Proxy类和java.lang.reflect.InvocationHandler接口。我们只需要实现InvocationHandler接口，在实现invoke()方法的时候加上我们的代理逻辑。</p>

<p>一个简单的使用实例如下：</p>

<pre><code>/**
 * @author xiaobaoqiu  Date: 16-3-10 Time: 下午6:18
 */
public class JavaDynamicProxy implements InvocationHandler {

    /**
     * 被代理者
     */
    private Object inner;

    /**
     * 生成代理类
     */
    public static Object generateProxy(Object inner) {
        return Proxy.newProxyInstance(
                inner.getClass().getClassLoader(),
                inner.getClass().getInterfaces(),
                new JavaDynamicProxy(inner));
    }

    private JavaDynamicProxy(Object inner) {
        this.inner = inner;
    }

    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        doSomethingBefore();

        Object result = method.invoke(inner, args);

        doSomethingAfter();

        return result;
    }

    private void doSomethingBefore() {
        System.out.println("JavaDynamicProxy: Before...");
    }

    private void doSomethingAfter() {
        System.out.println("JavaDynamicProxy: After...");
    }
}

//使用
public static void main(String[] args) {
        //被动态代理的IHello实例对象A
        IHello helloA = new HelloImpl();
        //生成对象A的动态代理
        IHello helloAProxy = (IHello) JavaDynamicProxy.generateProxy(helloA);
        helloAProxy.hello();

        System.out.println("-------------------------------------------------");
        // 一个JavaDynamicProxy可以一直使用

        //被动态代理的IHello实例对象B
        IHello helloB = new HelloWithLogImpl();
        //生成对象B的动态代理
        IHello helloBProxy = (IHello) JavaDynamicProxy.generateProxy(helloB);
        helloBProxy.hello();

        System.out.println("-------------------------------------------------");
        //被动态代理对象IBye实例
        IBye bye = new ByeImpl();
        //生成IBye实例的动态代理
        IBye byeProxy = (IBye) JavaDynamicProxy.generateProxy(bye);
        byeProxy.bye();
}
</code></pre>

<p>JavaDynamicProxy.generateProxy的输出会是一个动态的代理类。debug信息如下，从debug信息我们大致知道，这个代理类的类名称为$Proxy0,内部包含一个属性名为h的属性，h指向的就是我们实现的InvocationHandler的类(这里即JavaDynamicProxy)的实例。</p>

<p><img src="/images/spring/java_proxy_debug.png"></p>

<p>但是Java动态代理的限制是：</p>

<pre><code>(1).被代理的类要求至少实现了一个Interface;
(2).被代理的类要求有public的构造函数(即没有显示的将其设置为private等);
(3).被代理的类要求不是final;
</code></pre>

<p>如下代理一个没有实现任何接口的类会报错
<code>
        //没有实现任何interface的类使不能被动态代理的
        System.out.println("-------------------------------------------------");
        HelloWithoutInterface helloC = new HelloWithoutInterface();
        //生成对象C的动态代理
        HelloWithoutInterface helloCProxy = (HelloWithoutInterface) JavaDynamicProxy.generateProxy(helloC);
        helloCProxy.hello();
</code>
错误信息如下：</p>

<pre><code>Exception in thread "main" java.lang.ClassCastException: com.sun.proxy.$Proxy2 cannot be cast to proxy.javaProxy.HelloWithoutInterface
    at proxy.javaProxy.JavaProxyMain.main(JavaProxyMain.java:42)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:606)
    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:140)
</code></pre>

<p>Java动态代理的机制是利用反射机制生成。具体代码可以debug，主要的代码如下：</p>

<pre><code>//Proxy.java
public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException {
    ...
    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);    //生成代理类
    ...
    return newInstance(cons, ih);   // 生成代理类的实例
}

private static Class&lt;?&gt; getProxyClass0(ClassLoader loader,  Class&lt;?&gt;... interfaces) {
        //生成代理类的主要逻辑在ProxyClassFactory
        return proxyClassCache.get(loader, interfaces);
}

//ProxyClassFactory的apply方法
public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) {
    ...
            String proxyPkg = null;     // 生成代理类的包路径
            ...
            if (proxyPkg == null) {
                // if no non-public proxy interfaces, use com.sun.proxy package
                proxyPkg = ReflectUtil.PROXY_PACKAGE + "."; //默认路径在com.sun.proxy下面
            }

            long num = nextUniqueNumber.getAndIncrement();  //代理类的序号， 我们熟悉的$Proxy0中的0
            String proxyName = proxyPkg + proxyClassNamePrefix + num;   //代理类的类名称

            //使用ProxyGenerator生成代理类的字节码
            byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces);
            //生成代理类
            return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length);
}

//ProxyGenerator.generateProxyClass的代码太恶心的...
</code></pre>

<p>我们可以自己使用ProxyGenerator来生成代理类并将其字节码记录下来：
<code>
    // 获取代理类的字节码
    byte[] classFile = ProxyGenerator.generateProxyClass("$Proxy0", ByeImpl.class.getInterfaces());
    //将字节码写文件，建议写成.class文件
</code></p>

<p>获取的字节码如下：</p>

<pre><code>import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.lang.reflect.UndeclaredThrowableException;
import proxy.sample.IBye;

public final class $Proxy0 extends Proxy implements IBye {
    private static Method m1;
    private static Method m3;
    private static Method m0;
    private static Method m2;

    public $Proxy0(InvocationHandler var1) throws  {
        super(var1);
    }

    public final boolean equals(Object var1) throws  {
        try {
            return ((Boolean)super.h.invoke(this, m1, new Object[]{var1})).booleanValue();
        } catch (RuntimeException | Error var3) {
            throw var3;
        } catch (Throwable var4) {
            throw new UndeclaredThrowableException(var4);
        }
    }

    public final void bye() throws  {
        try {
            super.h.invoke(this, m3, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final int hashCode() throws  {
        try {
            return ((Integer)super.h.invoke(this, m0, (Object[])null)).intValue();
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final String toString() throws  {
        try {
            return (String)super.h.invoke(this, m2, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    static {
        try {
            m1 = Class.forName("java.lang.Object").getMethod("equals", new Class[]{Class.forName("java.lang.Object")});
            m3 = Class.forName("proxy.sample.IBye").getMethod("bye", new Class[0]);
            m0 = Class.forName("java.lang.Object").getMethod("hashCode", new Class[0]);
            m2 = Class.forName("java.lang.Object").getMethod("toString", new Class[0]);
        } catch (NoSuchMethodException var2) {
            throw new NoSuchMethodError(var2.getMessage());
        } catch (ClassNotFoundException var3) {
            throw new NoClassDefFoundError(var3.getMessage());
        }
    }
}
</code></pre>

<p>从生成的类我们知道，代理类继承Proxy类(这就是为什么Proxy类内的InvocationHandler实例未protected)并实现我们需要的被代理者的Interface(比如这里的bye()方法)，另外它只要一个接受一个InvocationHandler为参数的构造函数。当我们调用代理类的bye()方法时候，其实是调用我们实现的InvocationHandler(即上面的JavaDynamicProxy)的invoke()方法，在invoke()方法里面，我们实现了我的代理逻辑。</p>

<p>我们这里这个Demo的大致UML图如下：</p>

<p><img src="/images/spring/java_dynamic_proxy.png"></p>

<p>参考：<a href="http://www.cnblogs.com/cruze/p/3819761.html">http://www.cnblogs.com/cruze/p/3819761.html</a></p>

<h4 id="1.3 CGLib动态代理">1.3 CGLib动态代理</h4>


<p>鉴于Java动态代理的限制，我们有需要代理没有任何实现接口的类的时候，可以考虑使用CGLib。CGLib的全称是Code Generate Library。CGLib的使用使用十分广泛，我们这里要讲的Spring AOP，以及EasyMock等。</p>

<p>同样先上Demo代码，我们只需要实现MethodInterceptor接口：</p>

<pre><code>/**
 * @author xiaobaoqiu  Date: 16-3-10 Time: 下午7:15
 */
public class CglibDynamicProxy implements MethodInterceptor {

    /**
     * 动态生成代理类
     */
    public Object generateProxy(Class cls) {
        Enhancer enhancer = new Enhancer();
        enhancer.setCallback(this);
//        enhancer.setCallbackFilter(); //filter
        enhancer.setSuperclass(cls);
        return enhancer.create();   // Enhancer也包含带参数的create方法
    }

    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        doSomethingBefore();

        Object result = proxy.invokeSuper(obj, args);

        doSomethingAfter();

        return result;
    }

    private void doSomethingBefore() {
        System.out.println("CglibDynamicProxy: Before...");
    }

    private void doSomethingAfter() {
        System.out.println("CglibDynamicProxy: After...");
    }
}

//使用
public static void main(String[] args) {
        CglibDynamicProxy proxy = new CglibDynamicProxy();
        //注意: 原始类的instance不需要存在，只需要Class类型

        //用接口IHello接, 或者 HelloImpl 接
        IHello helloAProxy = (IHello)proxy.generateProxy(HelloImpl.class);
        helloAProxy.hello();

        System.out.println("-------------------------------------------------");

        //用接口IHello接, 或者 HelloWithLogImpl 接
        IHello helloBProxy = (IHello)proxy.generateProxy(HelloWithLogImpl.class);
        helloBProxy.hello();

        System.out.println("-------------------------------------------------");

        //代理没有实现任何interface的类
        HelloWithoutInterface helloCProxy = (HelloWithoutInterface)proxy.generateProxy(HelloWithoutInterface.class);
        helloCProxy.hello();
}
</code></pre>

<p>同样我们debug一下，得到的信息如下，同样生成了代理类，类名称为proxy.sample.HelloImpl$$EnhancerByCGLIB$$b46b6f06，这个稀奇古怪的类名我们后面会分析：</p>

<p><img src="/images/spring/cglib_proxy_debug.png"></p>

<p>下面还是尝试分析CGLib动态代理的原理。默认情况下生成的代理class文件只存储在内存中，我们可以在代码中设置一个环境变量：</p>

<pre><code>System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, "/home/xiaobaoqiu/cglib_proxy");
</code></pre>

<p>之后我们在目标目录下得到很多的class，其中的proxy目录包含了生成的class文件。我们发现一大堆的class文件，类名都是稀奇古怪：</p>

<pre><code>xiaobaoqiu@xiaobaoqiu:~/cglib_proxy/proxy/javaProxy$ ll
-rw-rw-r-- 1 xiaobaoqiu xiaobaoqiu 2227  3月 21 18:38 HelloWithoutInterface$$EnhancerByCGLIB$$7d786e36.class
-rw-rw-r-- 1 xiaobaoqiu xiaobaoqiu 5555  3月 21 18:38 HelloWithoutInterface$$EnhancerByCGLIB$$e4e0e0f1.class
-rw-rw-r-- 1 xiaobaoqiu xiaobaoqiu 7744  3月 21 18:38 HelloWithoutInterface$$EnhancerByCGLIB$$e4e0e0f1$$FastClassByCGLIB$$814877d5.class
-rw-rw-r-- 1 xiaobaoqiu xiaobaoqiu 2673  3月 21 18:45 HelloWithoutInterface$$FastClassByCGLIB$$32a767a1.class
</code></pre>

<p>我们先看看class文件的生成策略。每个Class Generator(比如这里的Enhancer)都继承自AbstractClassGenerator(实现接口ClassGenerator，这个接口只有一个generateClass的方法)，需要实现其generateClass()方法。generateClassName()方法用来生成Class名称：</p>

<pre><code>private String generateClassName(Predicate nameTestPredicate) {
        return namingPolicy.getClassName(namePrefix, source.name, key, nameTestPredicate);
}

//namingPolicy的默认实现NamingPolicy
public String getClassName(String prefix, String source, Object key, Predicate names) {
    //prefix为被代理类的路径，
        String base =
            prefix + "$$" +                         //prefix为被代理类的路径
            source.substring(source.lastIndexOf('.') + 1) +     //获取生成代理类的类，比如我们这里的Enhancer
            getTag() + "$$" +                       //getTag()默认为ByCGLIB
            Integer.toHexString(STRESS_HASH_CODE ? 0 : key.hashCode()); //hashcode
        String attempt = base;
        int index = 2;
        while (names.evaluate(attempt))     //如果有重复，则再在后面加上下标，小标从2开始
            attempt = base + "_" + index++;
        return attempt;
}
</code></pre>

<p>下面正式进入class文件的生成原理分析，还是从源代码入手，enhancer.create()最终进入AbstractClassGenerator.create()方法，我们发现最终return的Object是从内部变量obj得来，因此，我们看看ClassLoaderData的生成逻辑：</p>

<pre><code>protected Object create(Object key) {
            ClassLoader loader = getClassLoader();
            Map&lt;ClassLoader, ClassLoaderData&gt; cache = CACHE;
            ClassLoaderData data = cache.get(loader);
            if (data == null) {
                synchronized (AbstractClassGenerator.class) {
                    data = cache.get(loader);
                    if (data == null) {
                        Map&lt;ClassLoader, ClassLoaderData&gt; newCache = new WeakHashMap&lt;ClassLoader, ClassLoaderData&gt;(cache);
                        data = new ClassLoaderData(classLoader);
                        newCache.put(classLoader, data);
                        CACHE = newCache;
                    }
                }
            }
            this.key = key;
            Object obj = data.get(this);
            if (obj instanceof Class) {
                return firstInstance((Class) obj);
            }
            return nextInstance(obj);
}

public ClassLoaderData(ClassLoader classLoader) {
            this.classLoader = new WeakReference&lt;ClassLoader&gt;(classLoader);
            Function&lt;AbstractClassGenerator, Object&gt; load =
                    new Function&lt;AbstractClassGenerator, Object&gt;() {
                        public Object apply(AbstractClassGenerator gen) {
                            Class klass = gen.generate(ClassLoaderData.this);   //生成class的关键代码
                            return gen.wrapCachedClass(klass);
                        }
                    };
            generatedClasses = new LoadingCache&lt;AbstractClassGenerator, Object, Object&gt;(GET_KEY, load);
}
</code></pre>

<p>因此我们将目光转到generate()中：</p>

<pre><code>//Enhancer的generate()方法
protected Class generate(ClassLoaderData data) {
        validate();
        if (superclass != null) {
            setNamePrefix(superclass.getName());
        } else if (interfaces != null) {
            setNamePrefix(interfaces[ReflectUtils.findPackageProtected(interfaces)].getName());
        }
        return super.generate(data);    //父类AbstractClassGenerator
}
// AbstractClassGenerator的generate()方法
protected Class generate(ClassLoaderData data) {
            //...
            ClassLoader classLoader = data.getClassLoader();
            this.setClassName(generateClassName(data.getUniqueNamePredicate()));    //代理类的类名称的生成逻辑
            //...
            byte[] b = strategy.generate(this);     //生成策略，默认实现DefaultGeneratorStrategy，生成class文件的字节码
            String className = ClassNameReader.getClassName(new ClassReader(b));
            ProtectionDomain protectionDomain = getProtectionDomain();
            synchronized (classLoader) { // just in case
                if (protectionDomain == null) {
                    gen = ReflectUtils.defineClass(className, b, classLoader);
                } else {
                    gen = ReflectUtils.defineClass(className, b, classLoader, protectionDomain);
                }
            }
            return gen;
            ...//异常处理
}

//DefaultGeneratorStrategy的generate()方法
public byte[] generate(ClassGenerator cg) throws Exception {
        DebuggingClassWriter cw = getClassVisitor();
        transform(cg).generateClass(cw);        //这里调用最终的generateClass()逻辑,Visitor模式
        return transform(cw.toByteArray()); //通过Visitor得到最后的字节码
}
</code></pre>

<p>所以最终的调用是Enhancer的generateClass()调用。这代码好晦涩，感觉和JVM加载字节码相关。</p>

<p>看一下CGLib生成的class文件，这个代理类继承了我们的被代理类并且实现了Factory类，类定义如下：</p>

<pre><code>public class HelloWithoutInterface$$EnhancerByCGLIB$$e4e0e0f1 extends proxy.javaProxy.HelloWithoutInterface implements net.sf.cglib.proxy.Factory {
    private boolean CGLIB$BOUND;
    public static java.lang.Object CGLIB$FACTORY_DATA;
    private static final java.lang.ThreadLocal CGLIB$THREAD_CALLBACKS;
    private static final net.sf.cglib.proxy.Callback[] CGLIB$STATIC_CALLBACKS;
    private net.sf.cglib.proxy.MethodInterceptor CGLIB$CALLBACK_0;
    private static final java.lang.reflect.Method CGLIB$hello$0$Method;
    private static final net.sf.cglib.proxy.MethodProxy CGLIB$hello$0$Proxy;
    private static final java.lang.Object[] CGLIB$emptyArgs;
    private static final java.lang.reflect.Method CGLIB$equals$1$Method;
    private static final net.sf.cglib.proxy.MethodProxy CGLIB$equals$1$Proxy;
    private static final java.lang.reflect.Method CGLIB$toString$2$Method;
    private static final net.sf.cglib.proxy.MethodProxy CGLIB$toString$2$Proxy;
    private static final java.lang.reflect.Method CGLIB$hashCode$3$Method;
    private static final net.sf.cglib.proxy.MethodProxy CGLIB$hashCode$3$Proxy;
    private static final java.lang.reflect.Method CGLIB$clone$4$Method;
    private static final net.sf.cglib.proxy.MethodProxy CGLIB$clone$4$Proxy;

    static void CGLIB$STATICHOOK1() { /* compiled code */ }

    final void CGLIB$hello$0() { /* compiled code */ }  //代理的方法

    public final void hello() { /* compiled code */ }   //代理的方法

    final boolean CGLIB$equals$1(java.lang.Object o) { /* compiled code */ }

    public final boolean equals(java.lang.Object o) { /* compiled code */ }

    final java.lang.String CGLIB$toString$2() { /* compiled code */ }

    public final java.lang.String toString() { /* compiled code */ }

    final int CGLIB$hashCode$3() { /* compiled code */ }

    public final int hashCode() { /* compiled code */ }

    final java.lang.Object CGLIB$clone$4() throws java.lang.CloneNotSupportedException { /* compiled code */ }

    protected final java.lang.Object clone() throws java.lang.CloneNotSupportedException { /* compiled code */ }

    public static net.sf.cglib.proxy.MethodProxy CGLIB$findMethodProxy(net.sf.cglib.core.Signature signature) { /* compiled code */ }

    public HelloWithoutInterface$$EnhancerByCGLIB$$e4e0e0f1() { /* compiled code */ }

    public static void CGLIB$SET_THREAD_CALLBACKS(net.sf.cglib.proxy.Callback[] callbacks) { /* compiled code */ }

    public static void CGLIB$SET_STATIC_CALLBACKS(net.sf.cglib.proxy.Callback[] callbacks) { /* compiled code */ }

    private static final void CGLIB$BIND_CALLBACKS(java.lang.Object o) { /* compiled code */ }

    public java.lang.Object newInstance(net.sf.cglib.proxy.Callback[] callbacks) { /* compiled code */ }

    public java.lang.Object newInstance(net.sf.cglib.proxy.Callback callback) { /* compiled code */ }

    public java.lang.Object newInstance(java.lang.Class[] classes, java.lang.Object[] objects, net.sf.cglib.proxy.Callback[] callbacks) { /* compiled code */ }

    public net.sf.cglib.proxy.Callback getCallback(int i) { /* compiled code */ }

    public void setCallback(int i, net.sf.cglib.proxy.Callback callback) { /* compiled code */ }

    public net.sf.cglib.proxy.Callback[] getCallbacks() { /* compiled code */ }

    public void setCallbacks(net.sf.cglib.proxy.Callback[] callbacks) { /* compiled code */ }
}
</code></pre>

<p>注意，我们生成的动态代理包含两个hello()相关的方法。我们可以使用javap获取其字节码,我们发现和我们被代理者同名的hello()方法是带代理逻辑的，而CGLIB$hello$0()这个则是原始被代理者的直接调用(不包含代理逻辑):</p>

<pre><code>xiaobaoqiu@xiaobaoqiu:~/cglib_proxy/proxy/javaProxy$ javap -c HelloWithoutInterface\$\$EnhancerByCGLIB\$\$e4e0e0f1.class
...
  final void CGLIB$hello$0();
    Code:
       0: aload_0
       1: invokespecial #36                 // Method proxy/javaProxy/HelloWithoutInterface.hello:()V
       4: return

  public final void hello();
    Code:
       0: aload_0
       1: getfield      #38                 // Field CGLIB$CALLBACK_0:Lnet/sf/cglib/proxy/MethodInterceptor;
       4: dup
       5: ifnonnull     17
       8: pop
       9: aload_0
      10: invokestatic  #42                 // Method CGLIB$BIND_CALLBACKS:(Ljava/lang/Object;)V
      13: aload_0
      14: getfield      #38                 // Field CGLIB$CALLBACK_0:Lnet/sf/cglib/proxy/MethodInterceptor;
      17: dup
      18: ifnull        37
      21: aload_0
      22: getstatic     #44                 // Field CGLIB$hello$0$Method:Ljava/lang/reflect/Method;
      25: getstatic     #46                 // Field CGLIB$emptyArgs:[Ljava/lang/Object;
      28: getstatic     #48                 // Field CGLIB$hello$0$Proxy:Lnet/sf/cglib/proxy/MethodProxy;
      31: invokeinterface #54,  5           // InterfaceMethod net/sf/cglib/proxy/MethodInterceptor.intercept:(Ljava/lang/Object;Ljava/lang/reflect/Method;[Ljava/lang/Object;Lnet/sf/cglib/proxy/MethodProxy;)Ljava/lang/Object;
      36: return
      37: aload_0
      38: invokespecial #36                 // Method proxy/javaProxy/HelloWithoutInterface.hello:()V
      41: return
...
</code></pre>

<p>遗留问题：
(1).为什么一个类会生成多个代理类，各个代理类都是什么用处；</p>

<p>CGLib代理同样存在限制：</p>

<pre><code>(1).private方法无法代理；
(2).final方法无法代理;
</code></pre>

<p>private方法和final方法看代理类的字节码会发现，代理类不会这些重写函数(子类没法重写)，因此会自动调用父类的。</p>

<p>参考：
<a href="http://www.cnblogs.com/cruze/p/3843996.html">cglib源码分析（四）：cglib 动态代理原理分析</a></p>

<p><a href="https://dzone.com/articles/cglib-missing-manual">CGLib: The Missing Manual</a></p>

<h4 id="#1.4 Java动态代理 VS CGLib动态代理">#1.4 Java动态代理 VS CGLib动态代理</h4>


<p>简单总结对比一下两种动态代理:</p>

<table>
<thead>
<tr>
<th style="text-align:center;">代理 </th>
<th style="text-align:center;"> 没有实现interface的类 </th>
<th style="text-align:center;"> protected方法 </th>
<th style="text-align:center;"> private方法 </th>
<th style="text-align:center;"> final类 </th>
<th style="text-align:center;"> final方法 </th>
<th style="text-align:center;"> 构造函数private的类 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">Java动态代理 </td>
<td style="text-align:center;"> 不支持 </td>
<td style="text-align:center;"> 不支持 </td>
<td style="text-align:center;"> 不支持 </td>
<td style="text-align:center;">支持 </td>
<td style="text-align:center;"> 支持 </td>
<td style="text-align:center;"> 支持 </td>
</tr>
<tr>
<td style="text-align:center;">CGLib动态代理 </td>
<td style="text-align:center;"> 支持 </td>
<td style="text-align:center;"> 支持  </td>
<td style="text-align:center;"> 不支持 </td>
<td style="text-align:center;">不支持 </td>
<td style="text-align:center;"> 不支持 </td>
<td style="text-align:center;"> 不支持 </td>
</tr>
</tbody>
</table>


<p>关于CGLib对protected方法的支持,可以在生成的代理类中看到.</p>

<pre><code>CGLib报错信息：
final类: Cannot subclass final class proxy.javaProxy.HelloWithFinal
构造方法私有的类: No visible constructors in class proxy.javaProxy.HelloWithoutConstructor
final方法: 不报错，但没有代理逻辑
</code></pre>

<p>在性能方面，通常认为Java动态代理生成代理类比CGLib生成代理类快，但是CGLib的代理类运行期性能会优于Java动态代理的代理类。不过通常性能都不是问题，如果确实很关心性能，建议直接使用ASM。</p>

<p>参考：
<a href="http://www.theserverside.com/news/thread.tss?thread_id=45089">Why do you think CGLib proxies are faster than JDK Proxies?</a></p>

<p><a href="https://community.oracle.com/docs/DOC-983406">Implement Your Own Proxy-Based AOP Framework Blog</a></p>

<p>BeanDefinitionParserDelegate
AnnotationDrivenBeanDefinitionParser</p>

<p>参考：
Spring加载资源分析：<a href="http://www.blogjava.net/heavensay/archive/2013/10/28/405699.html">http://www.blogjava.net/heavensay/archive/2013/10/28/405699.html</a></p>

<p>事务的坑
<a href="http://www.ibm.com/developerworks/library/j-ts1/">http://www.ibm.com/developerworks/library/j-ts1/</a></p>

<p>代理实现选择器:
AdviceMode
TransactionManagementConfigurationSelector</p>

<p>声明事务切面实现:
TransactionInterceptor</p>

<p>事务实现
Connection关闭自动提交
ConnectionHolder来保持Connection</p>

<p>参考:
<a href="http://openwares.net/java/spring_mybatis_transaction.html">http://openwares.net/java/spring_mybatis_transaction.html</a>
<a href="http://my.oschina.net/guanzhenxing/blog/214228">http://my.oschina.net/guanzhenxing/blog/214228</a>
<a href="http://www.mybatis.org/spring/zh/transactions.html">http://www.mybatis.org/spring/zh/transactions.html</a>
<a href="http://tracylihui.github.io/2015/07/28/spring/Spring%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/">http://tracylihui.github.io/2015/07/28/spring/Spring%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</a>
<a href="http://www.cnblogs.com/davenkin/archive/2013/02/16/java-tranaction-1.html">http://www.cnblogs.com/davenkin/archive/2013/02/16/java-tranaction-1.html</a>
<a href="http://www.importnew.com/12300.html">http://www.importnew.com/12300.html</a>
详细介绍Spring事务管理: <a href="http://developer.51cto.com/art/200906/129854.htm">http://developer.51cto.com/art/200906/129854.htm</a>
spring事务原理1-事务的抽象: <a href="http://sqtds.github.io/2014/06/09/2014/spring-tx1/">http://sqtds.github.io/2014/06/09/2014/spring-tx1/</a>
Spring官方文档Transaction Management: <a href="http://docs.spring.io/autorepo/docs/spring/3.2.x/spring-framework-reference/html/transaction.html">http://docs.spring.io/autorepo/docs/spring/3.2.x/spring-framework-reference/html/transaction.html</a>
Spring官方文档Aspect Oriented Programming with Spring: <a href="http://docs.spring.io/spring/docs/3.0.x/reference/aop.html">http://docs.spring.io/spring/docs/3.0.x/reference/aop.html</a>
StackOverFlow Spring - @Transactional - What happens in background?: <a href="http://stackoverflow.com/questions/1099025/spring-transactional-what-happens-in-background">http://stackoverflow.com/questions/1099025/spring-transactional-what-happens-in-background</a>
Transaction strategies: Understanding transaction pitfalls: <a href="http://www.ibm.com/developerworks/library/j-ts1/">http://www.ibm.com/developerworks/library/j-ts1/</a>
Annotation-based Transactions in Spring: <a href="http://springinpractice.com/2008/03/18/annotation-based-transactions-in-spring">http://springinpractice.com/2008/03/18/annotation-based-transactions-in-spring</a>
Design principle behind Transaction framework with Spring 3: <a href="http://stackoverflow.com/questions/11789857/design-principle-behind-transaction-framework-with-spring-3">http://stackoverflow.com/questions/11789857/design-principle-behind-transaction-framework-with-spring-3</a>
Chapter 6. 使用Spring进行面向切面编程（AOP）: <a href="http://shouce.jb51.net/spring/aop.html">http://shouce.jb51.net/spring/aop.html</a>
wiki: <a href="http://wiki.corp.qunar.com/display/~yushen.ma/Spring+3.x-JDBC+Transaction">http://wiki.corp.qunar.com/display/~yushen.ma/Spring+3.x-JDBC+Transaction</a>
spring事务: <a href="http://wiki.corp.qunar.com/pages/viewpage.action?pageId=52084161">http://wiki.corp.qunar.com/pages/viewpage.action?pageId=52084161</a>
spring 事务: <a href="http://wiki.corp.qunar.com/pages/viewpage.action?pageId=93338632">http://wiki.corp.qunar.com/pages/viewpage.action?pageId=93338632</a>
aspectj事务: <a href="http://wiki.corp.qunar.com/pages/viewpage.action?pageId=92656954">http://wiki.corp.qunar.com/pages/viewpage.action?pageId=92656954</a></p>

<p>Demo:
编程事务: <a href="http://www.tutorialspoint.com/spring/programmatic_management.htm">http://www.tutorialspoint.com/spring/programmatic_management.htm</a>
声明事务: <a href="http://www.tutorialspoint.com/spring/declarative_management.htm">http://www.tutorialspoint.com/spring/declarative_management.htm</a></p>

<p>@Transactional注解工作原理：<a href="http://blog.csdn.net/dslztx/article/details/46636079">http://blog.csdn.net/dslztx/article/details/46636079</a>
分布式事务系列（1.2）Spring的事务体系： <a href="https://yq.aliyun.com/articles/39046">https://yq.aliyun.com/articles/39046</a>
spring transaction源码分析&ndash;事务架构：<a href="http://www.cnblogs.com/davidwang456/p/4309038.html">http://www.cnblogs.com/davidwang456/p/4309038.html</a></p>

<p><a href="http://blog.csdn.net/szwangdf/article/details/41516239">http://blog.csdn.net/szwangdf/article/details/41516239</a></p>

<p>AopProxy
DefaultAopProxyFactory</p>
]]></content>
  </entry>
  
</feed>
