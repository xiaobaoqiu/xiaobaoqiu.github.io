<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Spring | xiaobaoqiu Blog]]></title>
  <link href="http://xiaobaoqiu.github.io/blog/categories/spring/atom.xml" rel="self"/>
  <link href="http://xiaobaoqiu.github.io/"/>
  <updated>2016-08-19T11:32:04+08:00</updated>
  <id>http://xiaobaoqiu.github.io/</id>
  <author>
    <name><![CDATA[xiaobaoqiu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[从代理到Spring事务2-AOP]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2016/07/15/cong-dai-li-dao-springshi-wu-aop/"/>
    <updated>2016-07-15T14:26:22+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2016/07/15/cong-dai-li-dao-springshi-wu-aop</id>
    <content type="html"><![CDATA[<ul>
<li><a href="#1.Spring%20AOP">1.Spring AOP</a>

<ul>
<li><a href="#1.1%20%E4%BB%A3%E7%90%86%E7%B1%BB%E5%9E%8B%E9%80%89%E6%8B%A9">1.1 代理类型选择</a></li>
<li><a href="#1.2%20%E4%BB%A3%E7%90%86%E8%B0%83%E7%94%A8">11.2 代理调用</a></li>
<li><a href="#1.3%20Understanding%20AOP%20Proxies">1.3 Understanding AOP Proxies</a></li>
<li><a href="#1.4%20Spring%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%AB%E5%B9%B6%E8%A7%A3%E6%9E%90%E9%85%8D%E7%BD%AE">1.4 Spring如何识别并解析配置</a></li>
<li><a href="#1.5%20Spring%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0AOP">1.5 Spring如何使用代理实现AOP</a></li>
</ul>
</li>
</ul>


<h2 id="1.Spring AOP">1.Spring AOP</h2>


<p>Spring的AOP(Aspect Oriented Programming，面向切面编程)是一个强大的机制，常用场景在日志、安全、异常处理、事务等。Spring AOP的原理正是基于代理。</p>

<p>我想了解的问题包括：</p>

<pre><code>(1).Spring AOP使用什么机制做代理；
(2).Spring 怎么使用代理达到AOP目的；
</code></pre>

<h4 id="#1.1 代理类型选择">#1.1 代理类型选择</h4>


<p>先看看Spring是如何选择代理，先看看 <a href="http://docs.spring.io/spring/docs/3.0.x/reference/aop.html">Spring官方AOP文档</a> 的说明：</p>

<pre><code>Spring AOP defaults to using standard J2SE dynamic proxies for AOP proxies. This enables any interface (or set of interfaces) to be proxied.

Spring AOP can also use CGLIB proxies. This is necessary to proxy classes, rather than interfaces. CGLIB is used by default if a business object does not implement an interface. As it is good practice to program to interfaces rather than classes, business classes normally will implement one or more business interfaces. It is possible to force the use of CGLIB, in those (hopefully rare) cases where you need to advise a method that is not declared on an interface, or where you need to pass a proxied object to a method as a concrete type.
</code></pre>

<p>官方文档的结论是：当业务Bean实现了一个或多个接口的时候，默认使用Java动态代理，当业务Bean没有实现任何接口的时候使用CGLib。</p>

<p>我们来看看相关代码，Spring使用AopProxy表示AOP中的代理，它的作用只要一个：创建代理对象。它有两个实现类：JdkDynamicAopProxy 和 CglibAopProxy ：</p>

<pre><code>public interface AopProxy {
    Object getProxy();

    Object getProxy(ClassLoader classLoader);
}

// JdkDynamicAopProxy 实现了 InvocationHandler，实际产生代理类使用 Proxy
final class JdkDynamicAopProxy implements AopProxy, InvocationHandler, Serializable {
    public Object getProxy(ClassLoader classLoader) {
        ...
        return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);
    }
}

final class CglibAopProxy implements AopProxy, Serializable {
    public Object getProxy(ClassLoader classLoader) {
        Class&lt;?&gt; rootClass = this.advised.getTargetClass();

        // 配置 CGLIB Enhancer...
        Enhancer enhancer = createEnhancer();
        enhancer.setSuperclass(proxySuperClass);
        enhancer.setStrategy(new UndeclaredThrowableStrategy(UndeclaredThrowableException.class));
        enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(this.advised));
        enhancer.setInterceptDuringConstruction(false);

        Callback[] callbacks = getCallbacks(rootClass);
        enhancer.setCallbacks(callbacks);
        enhancer.setCallbackFilter(new ProxyCallbackFilter(
                this.advised.getConfigurationOnlyCopy(), this.fixedInterceptorMap, this.fixedInterceptorOffset));

        Class&lt;?&gt;[] types = new Class[callbacks.length]; //CGLib的回调机制
        for (int x = 0; x &lt; types.length; x++) {
            types[x] = callbacks[x].getClass();
        }
        enhancer.setCallbackTypes(types);

        // 产生代理类并产生代理类的一个instance
        Object proxy;
        if (this.constructorArgs != null) {
            proxy = enhancer.create(this.constructorArgTypes, this.constructorArgs);
        } else {
            proxy = enhancer.create();
        }

        return proxy;
    }
}
</code></pre>

<p>AopProxyFactory的默认实现类DefaultAopProxyFactory：</p>

<pre><code>    public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {
        if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {
            Class targetClass = config.getTargetClass();
            if (targetClass == null) {
                throw new AopConfigException("TargetSource cannot determine target class: " +
                        "Either an interface or a target is required for proxy creation.");
            }
            if (targetClass.isInterface()) {    //被代理类，实现了接口，就使用Java动态代理
                return new JdkDynamicAopProxy(config);
            }
            return CglibProxyFactory.createCglibProxy(config);  //没有实现接口使用 CGLib代理
        }
        else {
            return new JdkDynamicAopProxy(config);
        }
    }
</code></pre>

<p>其中 AdvisedSupport 是 AOP配置管理的基类。这几个配置的说明可以参见 ProxyConfig 类。其中我注释的地方和官方文档是一致的。</p>

<h4 id="#1.2 代理调用">#1.2 代理调用</h4>


<p>得到代理对象之后的下一步就是调用代理逻辑，这部分实现直接看 JdkDynamicAopProxy.invoke() 代码：</p>

<pre><code>public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    //TargetSource包括被代理者的一些属性
    TargetSource targetSource = this.advised.targetSource;
    try {
        Object retVal;

        // 具体的被代理对象
        target = targetSource.getTarget();
        if (target != null) {
            targetClass = target.getClass();
        }

        // 从代理配置中获取方法上的 MethodInterceptor
        List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);

        // 没有 MethodInterceptor，直接反射调用
        if (chain.isEmpty()) {
            retVal = AopUtils.invokeJoinpointUsingReflection(target, method, args);
        } else {
            // 创建 MethodInvocation 并调用
            invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);
            retVal = invocation.proceed();
        }

        return retVal;
    }
}
</code></pre>

<p>先看看如何获取方法上的 MethodInterceptor，AdvisedSupport其实只是对这个做缓存，实际调用 DefaultAdvisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice：</p>

<pre><code>/**
 * 从提供的配置实例config中获取advisor列表,遍历处理这些advisor
 * 如果是PointcutAdvisor,则判断此Advisor能否应用到目标方法method上.
 * 将满足条件的Advisor通过AdvisorAdaptor转化成Interceptor列表返回
 */
public List&lt;Object&gt; getInterceptorsAndDynamicInterceptionAdvice(
        Advised config, Method method, Class targetClass) {

    List&lt;Object&gt; interceptorList = new ArrayList&lt;Object&gt;(config.getAdvisors().length);
    boolean hasIntroductions = hasMatchingIntroductions(config, targetClass);
    AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();
    for (Advisor advisor : config.getAdvisors()) {
        if (advisor instanceof PointcutAdvisor) {
            PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;
            if (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(targetClass)) {
                //将Advisor转化成Interceptor
                MethodInterceptor[] interceptors = registry.getInterceptors(advisor);
                MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();

                //检查当前advisor的pointcut是否可以匹配当前方法
                if (MethodMatchers.matches(mm, method, targetClass, hasIntroductions)) {
                    if (mm.isRuntime()) {
                        // Creating a new object instance in the getInterceptors() method
                        // isn't a problem as we normally cache created chains.
                        for (MethodInterceptor interceptor : interceptors) {
                            interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm));
                        }
                    }
                    else {
                        interceptorList.addAll(Arrays.asList(interceptors));
                    }
                }
            }
        }
        ...
    }
    return interceptorList;
}
</code></pre>

<p>下面看看这些 Interceptor 是如何起作用的，看 ReflectiveMethodInvocation 的 proceed() 方法逻辑：</p>

<pre><code>public Object proceed() throws Throwable {
    // currentInterceptorIndex 表示 Interceptor 链中的当前调用的下标
    Object interceptorOrInterceptionAdvice = this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);
    if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {
        InterceptorAndDynamicMethodMatcher dm = (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;
        // 运行时参数(arguments)是否满足匹配条件
        if (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) {
            return dm.interceptor.invoke(this);
        } else {
            // 不匹配，直接跳过当前这个 Interceptor，执行下一个 Interceptor
            return proceed();
        }
    }
}
</code></pre>

<h4 id="#1.3 Understanding AOP Proxies">#1.3 Understanding AOP Proxies</h4>


<p>这里其实完全参考Spring AOP官方文档的一节就行了：<a href="http://docs.spring.io/spring/docs/3.0.x/reference/aop.html#aop-understanding-aop-proxies">http://docs.spring.io/spring/docs/3.0.x/reference/aop.html#aop-understanding-aop-proxies</a></p>

<p>看懂了这一节，能很明白为什么内部调用的方法上的事务注解无效，我们日常犯的错误基本不会有了。</p>

<h4 id="#1.4 Spring如何识别并解析配置">#1.4 Spring如何识别并解析配置</h4>


<p>我们都是通过XML文件的形式使用Spring，Spring使用XmlBeanDefinitionReader类来读取解析XML文件，XmlBeanDefinitionReader使用DefaultBeanDefinitionDocumentReader，再调用BeanDefinitionParserDelegate，其中会根据配置的不同找到对应的NamespaceHandler来处理对应的标签。NamespaceHandler是一个接口，一个具体接口就是解析XML中的一个Element得到一个Spring容器中的一个Bean。</p>

<pre><code>public interface NamespaceHandler {
    BeanDefinition parse(Element element, ParserContext parserContext);
}
</code></pre>

<p>NamespaceHandler的具体实现类很多，其中几个我们感兴趣的AopNamespaceHandler，MvcNamespaceHandler，QScheduleNamespaceHandler，QConfigNamespaceHandler，QmqClientNamespaceHandler等，看到这里大家应该很熟悉了。我们来看两个实现吧：</p>

<pre><code>public class AopNamespaceHandler extends NamespaceHandlerSupport {
    public void init() {
        registerBeanDefinitionParser("config", new ConfigBeanDefinitionParser());
        registerBeanDefinitionParser("aspectj-autoproxy", new AspectJAutoProxyBeanDefinitionParser());
        registerBeanDefinitionDecorator("scoped-proxy", new ScopedProxyBeanDefinitionDecorator());
        registerBeanDefinitionParser("spring-configured", new SpringConfiguredBeanDefinitionParser());
    }
}

public class MvcNamespaceHandler extends NamespaceHandlerSupport {
    public void init() {
        registerBeanDefinitionParser("annotation-driven", new AnnotationDrivenBeanDefinitionParser());
        registerBeanDefinitionParser("default-servlet-handler", new DefaultServletHandlerBeanDefinitionParser());
        registerBeanDefinitionParser("interceptors", new InterceptorsBeanDefinitionParser());
        registerBeanDefinitionParser("resources", new ResourcesBeanDefinitionParser());
        registerBeanDefinitionParser("view-controller", new ViewControllerBeanDefinitionParser());
    }
}
</code></pre>

<p>就是说Spring将配置根据作用分成不同的namespace，每个NamespaceHandler只解析自己独有的几个配置，比如AopNamespaceHandler负责解析scoped-proxy等几个配置，比如我们在配置文件配上：</p>

<p>```</p>

<!--aop就表示namespace-->


<p>&lt;aop:config proxy-target-class=&ldquo;true&rdquo;/></p>

<p>```
最后就会找到AopNamespaceHandler类解析这个配置。那出了这些带namespace的配置，正常的配置谁来解析？DefaultBeanDefinitionDocumentReader。</p>

<p>spring在解析的过程中，会去收集spring.*.jar/META-INF下的spring.handlers,spring.schemas文件，这2个文件就是指明了解析spring中自定义标签的Namespace类。如果自己开发Spring组件，需要增加新的标签，也可以按照这个机制。<a href="www.qunar.com">我司</a>的同学可以看看qmq-client包下的META-INF下的这两个文件。</p>

<p>到目前为止，大致知道了谁来解析AOP相关的标签。我们继续看看 AopNamespaceHandler 的代码，它的init()的方法就是给每个标签找一个解析器，比如 aop:config 这个配置就会找到 ConfigBeanDefinitionParser 这个解析器。,些解析器只有一个parse入口函数。</p>

<p>最后放一张AOP相关的图(来源：<a href="http://blog.csdn.net/moreevan/article/details/11977115">http://blog.csdn.net/moreevan/article/details/11977115</a>)</p>

<p><img src="/images/spring/aop_class.png"></p>

<h4 id="#1.5 Spring如何使用代理实现AOP">#1.5 Spring如何使用代理实现AOP</h4>


<p>最后我们整理一下Spring使用代理实现AOP整个流程的步骤。</p>

<p>1.我们在代码中使用引入bean；
2.Spring从BeanFactory总获取bean(ApplicationContext.getBean)，参见AbstractBeanFactory.getBean代码：</p>

<pre><code>    public Object getBean(String name) throws BeansException {
        return doGetBean(name, null, null, false);
    }
    protected &lt;T&gt; T doGetBean(final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly)
            throws BeansException {

        final String beanName = transformedBeanName(name);
        Object bean;

        // 创建单例的bean
        if (mbd.isSingleton()) {
            sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() {
                public Object getObject() throws BeansException {
                    try {
                        return createBean(beanName, mbd, args);    //创建Bean
                    }
                }
            });
            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
        }
    }
</code></pre>

<p>3.触发Bean的创建，参考AbstractAutowireCapableBeanFactory.createBean代码：</p>

<pre><code>    public Object createBean(Class beanClass, int autowireMode, boolean dependencyCheck) throws BeansException {
        // Use non-singleton bean definition, to avoid registering bean as dependent bean.
        RootBeanDefinition bd = new RootBeanDefinition(beanClass, autowireMode, dependencyCheck);
        bd.setScope(BeanDefinition.SCOPE_PROTOTYPE);
        return createBean(beanClass.getName(), bd, null);       //---1
    }
    protected Object createBean(final String beanName, final RootBeanDefinition mbd, final Object[] args)
            throws BeanCreationException {
        ...
        Object beanInstance = doCreateBean(beanName, mbd, args);        //---2
        return beanInstance;
    }
    protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) {
        // Eagerly cache singletons to be able to resolve circular references
        // even when triggered by lifecycle interfaces like BeanFactoryAware.
        boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;
                isSingletonCurrentlyInCreation(beanName));
        if (earlySingletonExposure) {
            addSingletonFactory(beanName, new ObjectFactory() {
                public Object getObject() throws BeansException {
                    return getEarlyBeanReference(beanName, mbd, bean);      //---3
                }
            });
        }

        // Initialize the bean instance.
        ...
        return exposedObject;
    }
    protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) {
        Object exposedObject = bean;
        if (bean != null &amp;&amp; !mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {
            for (BeanPostProcessor bp : getBeanPostProcessors()) {
                if (bp instanceof SmartInstantiationAwareBeanPostProcessor) {
                    SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;
                    exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);     //---逐层包装bean
                    if (exposedObject == null) {
                        return exposedObject;
                    }
                }
            }
        }
        return exposedObject;
    }
</code></pre>

<ol>
<li>触发代理类对象的创建，见 AbstractAutoProxyCreator，这个其实是一个 BeanPostProcessor，关于BeanPostProcessor的作用见它的注释：</li>
</ol>


<pre><code> * Factory hook that allows for custom modification of new bean instances,
 * e.g. checking for marker interfaces or wrapping them with proxies.
</code></pre>

<p>AbstractAutoProxyCreator代码：</p>

<pre><code>    public Object getEarlyBeanReference(Object bean, String beanName) throws BeansException {
        Object cacheKey = getCacheKey(bean.getClass(), beanName);
        this.earlyProxyReferences.put(cacheKey, Boolean.TRUE);
        return wrapIfNecessary(bean, beanName, cacheKey);
    }
    protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {
        // 获取被代理bean上的所有的 Advisor
        Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);
        if (specificInterceptors != DO_NOT_PROXY) {
            this.advisedBeans.put(cacheKey, Boolean.TRUE);
            //为制定类创建代理bean
            Object proxy = createProxy(bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));
            this.proxyTypes.put(cacheKey, proxy.getClass());
            return proxy;
        }
    }

    protected Object createProxy(
            Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource) {
        // ProxyFactory 继承自 ProxyConfig，局部变量
        ProxyFactory proxyFactory = new ProxyFactory();
        proxyFactory.copyFrom(this);

        // shouldProxyTargetClass表示显示的定义了proxy-target-class="true"
        // 没有定义则可能需要被代理类的 interface 信息
        if (!shouldProxyTargetClass(beanClass, beanName)) {
            Class&lt;?&gt;[] targetInterfaces = ClassUtils.getAllInterfacesForClass(beanClass, this.proxyClassLoader);
            for (Class&lt;?&gt; targetInterface : targetInterfaces) {
                proxyFactory.addInterface(targetInterface);
            }
        }

        Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);
        for (Advisor advisor : advisors) {
            proxyFactory.addAdvisor(advisor);
        }

        proxyFactory.setTargetSource(targetSource); //被代理者
        ...
        // 创建代理对象
        return proxyFactory.getProxy(this.proxyClassLoader);
    }
</code></pre>

<p>ProxyFactory.java:</p>

<pre><code>    public Object getProxy(ClassLoader classLoader) {
        return createAopProxy().getProxy(classLoader);
    }
    protected final synchronized AopProxy createAopProxy() {
        if (!this.active) {
            activate();
        }
        return getAopProxyFactory().createAopProxy(this);
    }
</code></pre>

<p>DefaultAopProxyFactory.java的createAopProxy，回到了我们 1.1 代理类型选择 中涉及的内容，整个过程串起来了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从代理到Spring事务3-Spring事务]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2016/07/07/springshi-wu/"/>
    <updated>2016-07-07T18:45:10+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2016/07/07/springshi-wu</id>
    <content type="html"><![CDATA[<ul>
<li><a href="#1.Spring%E4%BA%8B%E5%8A%A1">1.Spring事务</a>

<ul>
<li><a href="#1.1%20%E4%BA%8B%E5%8A%A1%E5%AE%9A%E4%B9%89">1.1 事务定义</a></li>
<li><a href="#1.2%20%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8">1.2 事务管理器</a></li>
<li><a href="#1.3%20How%20Transactional%20Works">1.3 How Transactional Works</a></li>
<li><a href="#1.4%20Roll%20Back">1.4 Roll Back</a></li>
<li><a href="#1.4%20Pitfalls">1.5 Pitfalls</a></li>
</ul>
</li>
</ul>


<h2 id="1.Spring事务">1.Spring事务</h2>


<p>我们使用事务的目标：</p>

<pre><code>The most common reason for using transactions in an application is to maintain a high degree of data integrity and consistency.
</code></pre>

<p>我的理解Spring事务中包括的几个主要要素，下面会一一讲解：</p>

<pre><code>1.事务定义：事务包含哪些属性
2.事务管理器：如何将我们对事务的诉求转化为数据库层面的实现
3.事务切面：Spring底层是如何将业务和事务串起来的
</code></pre>

<p>关于事务的使用是最简单的，通常分为 编程式事务 和 注解式事务：</p>

<h5>编程式事务</h5>

<p>代码直接使用PlatformTransactionManager，因此需要使用者自己管理事务的创建，提交，回滚，挂起等逻辑。</p>

<p>优点：灵活度大；
缺点：使用难度大，易出错，业务代码侵入大；</p>

<p><a href="http://www.tutorialspoint.com/spring/programmatic_management.htm">一个编程式事务的完整Demo</a></p>

<p>我们可以使用 Spring 提供的 TransactionTemplate 类来简化编程事务：</p>

<pre><code>    TransactionTemplate template = new TransactionTemplate();
    template.setIsolationLevel(org.springframework.transaction.TransactionDefinition.ISOLATION_DEFAULT);
    template.setPropagationBehavior(org.springframework.transaction.TransactionDefinition.PROPAGATION_REQUIRED);
    template.setTransactionManager(transactionManager);
    template.execute(new TransactionCallback&lt;UserAo&gt;() {
        @Override
        public UserAo doInTransaction(TransactionStatus status) {
             //business logic
        }
    });
</code></pre>

<p>我们可以看一下 TransactionTemplate 的实现代码，TransactionTemplate继承了DefaultTransactionDefinition(实现了TransactionDefinition)，使用TransactionDefinition需要我们给定一个TransactionManager，可以修改 事务隔离级别，事务传播行为等事务属性(其实是DefaultTransactionDefinition提供的功能)。</p>

<pre><code>    public &lt;T&gt; T execute(TransactionCallback&lt;T&gt; action) throws TransactionException {
        TransactionStatus status = this.transactionManager.getTransaction(this);    //获取并初始化事务，处理比如事务传播形式等
        T result;
        try {
            result = action.doInTransaction(status);    //业务逻辑，包括自定义的回滚
        } catch (RuntimeException ex) {
            // Transactional code threw application exception -&gt; rollback
            rollbackOnException(status, ex);
            throw ex;
        } catch (Error err) {
            // Transactional code threw error -&gt; rollback
            rollbackOnException(status, err);
            throw err;
        } catch (Exception ex) {
            // Transactional code threw unexpected exception -&gt; rollback
            rollbackOnException(status, ex);
            throw new UndeclaredThrowableException(ex, "TransactionCallback threw undeclared checked exception");
        }
        this.transactionManager.commit(status); //事务提交
        return result;
    }
</code></pre>

<p>其中 transactionManager.getTransaction(this) 的代码后面会详细分析。</p>

<h5>注解式事务</h5>

<p>使用 @Transactional 来管理事务，我们需要声明一个全局的事务管理器，以及事务对注解的支持：</p>

<pre><code>    &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
        &lt;property name="dataSource" ref="dataSource"/&gt;
    &lt;/bean&gt;

    &lt;tx:annotation-driven transaction-manager="txManager"/&gt;
</code></pre>

<p>优点：使用简单，业务代码侵入小；
缺点：理解有难度；</p>

<p>注意：Spring建议在具体业务实现类上使用Transactional注解，而不是在接口或则接口的方法上配置@Transactional注解：</p>

<pre><code>The Spring team’s recommendation is that you only annotate concrete classes with the @Transactional annotation, as opposed to annotating interfaces. 
You certainly can place the @Transactional annotation on an interface (or an interface method), but this will only work as you would expect it to if you are using interface-based proxies. 
The fact that annotations are not inherited means that if you are using class-based proxies (proxy-target-class=“true“) or the weaving-based aspect (mode=“aspectj“) then the transaction settings will not be recognised by the proxying/weaving infrastructure and the object will not be wrapped in a transactional proxy (which would be decidedly bad). 
So please do take the Spring team’s advice and only annotate concrete classes (and the methods of concrete classes) with the @Transactional annotation.
</code></pre>

<p>Transactional注解上可以设置很多事务相关的参数：</p>

<pre><code>public @interface Transactional {
    /**
     * 用于配置事务管理器，当系统中存在多个数据源多个事务管理器的时候有用
     * 配置 txManager1 这种 bean name
     */
    String value() default "";

    /**
     * 事务传播级别
     */
    Propagation propagation() default Propagation.REQUIRED;

    /**
     * 事务隔离级别
     */
    Isolation isolation() default Isolation.DEFAULT;

    /**
     * 事务超时时间
     */
    int timeout() default TransactionDefinition.TIMEOUT_DEFAULT;

    /**
     * 事务是否read-only
     * 注意：这个设置对真实的事务执行系统是一个 hint 而不是 强制要求有这个配置的情况下 write 一定导致失败
     */
    boolean readOnly() default false;

    /**
     * 定义0个或多个exception，当事务遇到这些异常的时候，事务会回滚
     */
    Class&lt;? extends Throwable&gt;[] rollbackFor() default {};

    /**
     * 定义0个或多个exception的name，当事务遇到这些异常的时候，事务会回滚
     * 最好定义完整的路径，比如 javax.servlet.ServletException 会代表 ServletException 本身及子类
     */
    String[] rollbackForClassName() default {};

    /**
     * 定义0个或多个exception，当事务遇到这些异常的时候，事务不会回滚
     */
    Class&lt;? extends Throwable&gt;[] noRollbackFor() default {};

    /**
     * 定义0个或多个exception的name，当事务遇到这些异常的时候，事务不会回滚
     */
    String[] noRollbackForClassName() default {};
}
</code></pre>

<h4 id="1.1 事务定义">1.1 事务定义</h4>


<p>如何定义一个事务，Spring中使用 TransactionDefinition 来定义一个事务的属性，使用接口的形式：</p>

<pre><code>public interface TransactionDefinition {
    /**
     * 事务传播行为,可选项参见 TransactionDefinition 中定义的 PROPAGATION_XXX
     */
    int getPropagationBehavior();

    /**
     * 事务隔离级别,可选项参见 TransactionDefinition 中定义的 ISOLATION_XXX
     * 只在 PROPAGATION_REQUIRED 和 PROPAGATION_REQUIRES_NEW 这两个事务传播行为配置下有效
     */
    int getIsolationLevel();

    /**
     * 事务超时时间,单位秒
     * 默认 TIMEOUT_DEFAULT = -1 表示使用底层实现的超时时间或者没有(不支持事务超时时间)
     * 只在 PROPAGATION_REQUIRED 和 PROPAGATION_REQUIRES_NEW 这两个事务传播行为配置下有效
     * 如果事务管理器不支持设置超时时间，而调用了这个接口会抛出异常
     */
    int getTimeout();

    boolean isReadOnly();

    /**
     * 事务name，允许为null
     * 对于申明式事务，默认的name为：完整的class名称.metho名称
     */
    String getName();
}
</code></pre>

<p>TransactionDefinition 有一个默认实现 DefaultTransactionDefinition，其中定义了事务几个属性的默认值：</p>

<pre><code>    private int propagationBehavior = PROPAGATION_REQUIRED;
    private int isolationLevel = ISOLATION_DEFAULT;
    private int timeout = TIMEOUT_DEFAULT;
    private boolean readOnly = false;
</code></pre>

<h5>事务传播</h5>

<p>关于事务的传播行为，这里简单介绍一下：</p>

<pre><code>    /**
     * 如果已经存在事务直接使用，如果不存在则创建一个新事务
     */
    int PROPAGATION_REQUIRED = 0;

    /**
     * 如果已经存在事务直接使用，如果不存在则不使用事务
     */
    int PROPAGATION_SUPPORTS = 1;

    /**
     * 如果已经存在事务直接使用，如果不存在则抛出异常
     */
    int PROPAGATION_MANDATORY = 2;

    /**
     * 创建一个新事务，如果如果已经存在事务则将当前事务挂起
     */
    int PROPAGATION_REQUIRES_NEW = 3;

    /**
     * 不使用事务，如果当前已经存在事务则将当前事务挂起
     */
    int PROPAGATION_NOT_SUPPORTED = 4;

    /**
     * 不使用事务，如果当前存在事务则跑出异常
     */
    int PROPAGATION_NEVER = 5;

    /**
     * 如果已经存在事务直接使用，则执行一个嵌套事务，如果当前没有事务就创建一个新事务
     */
    int PROPAGATION_NESTED = 6;
</code></pre>

<p>其中 PROPAGATION_NESTED 理解有点困难，可以参考 <a href="http://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/transaction.html#tx-propagation">Spring 的文档</a>：</p>

<pre><code>PROPAGATION_NESTED uses a single physical transaction with multiple savepoints that it can roll back to. 
Such partial rollbacks allow an inner transaction scope to trigger a rollback for its scope, with the outer transaction being able to continue the physical transaction despite some operations having been rolled back. 
This setting is typically mapped onto JDBC savepoints, so will only work with JDBC resource transactions. See Spring's DataSourceTransactionManager.
</code></pre>

<p>大致意思就是关于 SavePoint，JDBC定义了java.sql.SavePoint接口，提供在一个更细粒度的事务控制机制。当设置了一个保存点后，可以rollback到该保存点处的状态，而不是rollback整个事务。Connection接口的setSavepoint和releaseSavepoint方法可以设置和释放保存点。
而Spring中定义了 SavepointManager，用于 SavePoint 的创建(createSavepoint)，回滚(rollbackToSavepoint)，释放(releaseSavepoint)。</p>

<h5>事务隔离级别</h5>

<p>关于事务的隔离级别，也简单介绍一下，除了 ISOLATION_DEFAULT ，其余均使用 java.sql.Connection 中的隔离级别的定义：</p>

<pre><code>    /**
     * 使用底层数据源的隔离级别
     * 参考：java.sql.Connection.getTransactionIsolation()
     */
    int ISOLATION_DEFAULT = -1;

    /**
     * READ_UNCOMMITTED
     */
    int ISOLATION_READ_UNCOMMITTED = Connection.TRANSACTION_READ_UNCOMMITTED;

    /**
     * READ_COMMITTED
     */
    int ISOLATION_READ_COMMITTED = Connection.TRANSACTION_READ_COMMITTED;

    /**
     * REPEATABLE_READ
     */
    int ISOLATION_REPEATABLE_READ = Connection.TRANSACTION_REPEATABLE_READ;

    /**
     * SERIALIZABLE
     */
    int ISOLATION_SERIALIZABLE = Connection.TRANSACTION_SERIALIZABLE;
</code></pre>

<h4 id="1.2 事务管理器">1.2 事务管理器</h4>


<p>事务管理 Spring 使用 PlatformTransactionManager 定义，其中包含一个事务的三个主要操作，在业务开始之前开始事务，执行业务逻辑之后提交事务，业务逻辑异常则回滚事务：</p>

<pre><code>public interface PlatformTransactionManager {
    /**
     * 根据事务定义(TransactionDefinition),返回当前active事务或者创建一个新的事务
     * 注意：
     * 1.TransactionDefinition 中的隔离级别超时时间等设置只在创建了新事物的时候有效，如果使用当前已存在的事务则无效
     * 2.不是所有的事务管理器都支持 TransactionDefinition 中的所有属性，当事务管理器遇到不支持的属性则抛异常
     * 3.上条规则的例外是 read-only这个属性，如果事务管理器不支持这个属性直接忽略
     */
    TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;

    /**
     * 事务提交
     */
    void commit(TransactionStatus status) throws TransactionException;

    /**
     * 回滚事务
     */
    void rollback(TransactionStatus status) throws TransactionException;
}
</code></pre>

<p>我们熟悉的 JDBC 支持的事务管理器 DataSourceTransactionManager 就是其一个实现，其他还包括 JtaTransactionManager 等。</p>

<p>同时，Spring提供了一个 TransactionStatus 的就看便于再代码中控制事务以及获取事物状态。在PlatformTransactionManager中获取事务的返回值就是一个 TransactionStatus 对象。</p>

<h4 id="1.3 How Transactional Works">1.3 How Transactional Works</h4>


<p>下面会讲解我们使用的 Transactional 注解的工作原理，即当我们在Service的某个public方法上加上 @Transactional之后，从编译到调用这个方法整个过程中会发生什么，事务再其中如何起作用。</p>

<p>这个好像没什么讲的，就是AOP的实现原理。简单的说就是创建Bean的时候会创建一个代理Bean，使用AOP实现事务，参考上一届的AOP实现原理。我们可以参考 TransactionInterceptor 的代码。</p>

<h4 id="1.4 线程保持">1.4 线程保持</h4>




<h4 id="1.5 Roll Back">1.5 Roll Back</h4>


<p>主要关注Spring事务的回滚，其实主要就是要搞明白Spring在什么情况下会回滚。</p>

<h4 id="1.6 Pitfalls">1.6 Pitfalls</h4>


<p>事务的坑
<a href="http://www.ibm.com/developerworks/library/j-ts1/">http://www.ibm.com/developerworks/library/j-ts1/</a></p>

<p>代理实现选择器:
AdviceMode
TransactionManagementConfigurationSelector</p>

<p>声明事务切面实现:
TransactionInterceptor</p>

<p>事务实现
Connection关闭自动提交
ConnectionHolder来保持Connection</p>

<p>参考:
<a href="http://openwares.net/java/spring_mybatis_transaction.html">http://openwares.net/java/spring_mybatis_transaction.html</a>
<a href="http://my.oschina.net/guanzhenxing/blog/214228">http://my.oschina.net/guanzhenxing/blog/214228</a>
<a href="http://www.mybatis.org/spring/zh/transactions.html">http://www.mybatis.org/spring/zh/transactions.html</a>
<a href="http://tracylihui.github.io/2015/07/28/spring/Spring%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/">http://tracylihui.github.io/2015/07/28/spring/Spring%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</a>
<a href="http://www.cnblogs.com/davenkin/archive/2013/02/16/java-tranaction-1.html">http://www.cnblogs.com/davenkin/archive/2013/02/16/java-tranaction-1.html</a>
<a href="http://www.importnew.com/12300.html">http://www.importnew.com/12300.html</a>
详细介绍Spring事务管理: <a href="http://developer.51cto.com/art/200906/129854.htm">http://developer.51cto.com/art/200906/129854.htm</a>
spring事务原理1-事务的抽象: <a href="http://sqtds.github.io/2014/06/09/2014/spring-tx1/">http://sqtds.github.io/2014/06/09/2014/spring-tx1/</a>
Spring官方文档Transaction Management: <a href="http://docs.spring.io/autorepo/docs/spring/3.2.x/spring-framework-reference/html/transaction.html">http://docs.spring.io/autorepo/docs/spring/3.2.x/spring-framework-reference/html/transaction.html</a>
Spring官方文档Aspect Oriented Programming with Spring: <a href="http://docs.spring.io/spring/docs/3.0.x/reference/aop.html">http://docs.spring.io/spring/docs/3.0.x/reference/aop.html</a>
StackOverFlow Spring - @Transactional - What happens in background?: <a href="http://stackoverflow.com/questions/1099025/spring-transactional-what-happens-in-background">http://stackoverflow.com/questions/1099025/spring-transactional-what-happens-in-background</a>
Transaction strategies: Understanding transaction pitfalls: <a href="http://www.ibm.com/developerworks/library/j-ts1/">http://www.ibm.com/developerworks/library/j-ts1/</a>
Annotation-based Transactions in Spring: <a href="http://springinpractice.com/2008/03/18/annotation-based-transactions-in-spring">http://springinpractice.com/2008/03/18/annotation-based-transactions-in-spring</a>
Design principle behind Transaction framework with Spring 3: <a href="http://stackoverflow.com/questions/11789857/design-principle-behind-transaction-framework-with-spring-3">http://stackoverflow.com/questions/11789857/design-principle-behind-transaction-framework-with-spring-3</a>
Chapter 6. 使用Spring进行面向切面编程（AOP）: <a href="http://shouce.jb51.net/spring/aop.html">http://shouce.jb51.net/spring/aop.html</a>
wiki: <a href="http://wiki.corp.qunar.com/display/~yushen.ma/Spring+3.x-JDBC+Transaction">http://wiki.corp.qunar.com/display/~yushen.ma/Spring+3.x-JDBC+Transaction</a>
spring事务: <a href="http://wiki.corp.qunar.com/pages/viewpage.action?pageId=52084161">http://wiki.corp.qunar.com/pages/viewpage.action?pageId=52084161</a>
spring 事务: <a href="http://wiki.corp.qunar.com/pages/viewpage.action?pageId=93338632">http://wiki.corp.qunar.com/pages/viewpage.action?pageId=93338632</a>
aspectj事务: <a href="http://wiki.corp.qunar.com/pages/viewpage.action?pageId=92656954">http://wiki.corp.qunar.com/pages/viewpage.action?pageId=92656954</a></p>

<p>Demo:
编程事务: <a href="http://www.tutorialspoint.com/spring/programmatic_management.htm">http://www.tutorialspoint.com/spring/programmatic_management.htm</a>
声明事务: <a href="http://www.tutorialspoint.com/spring/declarative_management.htm">http://www.tutorialspoint.com/spring/declarative_management.htm</a></p>

<p>@Transactional注解工作原理：<a href="http://blog.csdn.net/dslztx/article/details/46636079">http://blog.csdn.net/dslztx/article/details/46636079</a>
分布式事务系列（1.2）Spring的事务体系： <a href="https://yq.aliyun.com/articles/39046">https://yq.aliyun.com/articles/39046</a>
spring transaction源码分析&ndash;事务架构：<a href="http://www.cnblogs.com/davidwang456/p/4309038.html">http://www.cnblogs.com/davidwang456/p/4309038.html</a></p>

<p><a href="http://blog.csdn.net/szwangdf/article/details/41516239">http://blog.csdn.net/szwangdf/article/details/41516239</a></p>

<p>AopProxy
DefaultAopProxyFactory</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从代理到Spring事务1-代理]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2016/03/11/cong-dai-li-dao-springshi-wu/"/>
    <updated>2016-03-11T17:15:46+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2016/03/11/cong-dai-li-dao-springshi-wu</id>
    <content type="html"><![CDATA[<ul>
<li><a href="#1.%E4%BB%A3%E7%90%86">1.代理</a>

<ul>
<li><a href="#1.1%20%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F">1.1 代理模式</a></li>
<li><a href="#1.2%20Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">1.2 Java动态代理</a></li>
<li><a href="#1.3%20CGLib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">1.3 CGLib动态代理</a>
<a href="#1.4%20Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%20VS%20CGLib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">1.4 Java动态代理 VS CGLib动态代理</a></li>
</ul>
</li>
</ul>


<p>最近再项目中发现不少同事(包括自己)不太理解默认情况下的Spring事务的运行机制(主要是不理解AOP机制),导致随意使用事务注解.因此也在很多场景事务不生效。因此想从代理机制开始理一下整个Spring声明式事务的原理。</p>

<p>因为篇幅太长，分成三个部分：</p>

<pre><code>(1).代理
(2).Spring的AOP
(3).Spring的事务
</code></pre>

<h2 id="1.代理">1.代理</h2>


<p>通常，我们代码中处理核心的业务逻辑，还包含一些枝节性的代码和功能，比如日志记录、消息发送、安全、事务保证和监控等。</p>

<p>我们通常期望将这些枝节性的代码功能和我们的核心业务逻辑分离，减少业务功能和枝节功能的耦合。这时候我们就要使用代理来达到我们的目的。</p>

<p>代理的作用是：为其它对象提供一种代理以控制对这个对象的访问。简单理解就是中间的作用。代理一般涉及到三个角色：</p>

<pre><code>(1).抽象角色：声明真实对象和代理对象的共同接口；
(2).代理角色：代理对象内部包含有真实角色的引用，从而可以操作真实角色，同时代理对象与真实对象有相同的接口，能在任何时候代替真实对象，同时代理对象可以在执行真实对 象前后加入特定的逻辑以实现功能的扩展；
(3).真实角色：代理角色所代表的真实对象，是我们最终要引用的对象；
</code></pre>

<h4 id="1.1 代理模式">1.1 代理模式</h4>


<p>代理模式是一个经典的设计模式，介绍往上很多。</p>

<p>下面是一个最简单的实现：</p>

<pre><code>public interface IHello {
    void hello();
}

public class HelloImpl implements IHello {
    @Override
    public void hello() {
        System.out.println("HelloImpl: Hello World.");
    }
}

public class HelloProxyImpl implements IHello {

    private IHello inner;

    public HelloProxyImpl(IHello inner) {
        this.inner = inner;
    }

    @Override
    public void hello() {
        doSomethingBefore();

        inner.hello();

        doSomethingAfter();
    }

    private void doSomethingBefore() {
        System.out.println("HelloProxyImpl: Before hello()...");
    }

    private void doSomethingAfter() {
        System.out.println("HelloProxyImpl: After hello()...");
    }

}
</code></pre>

<p>UML图大致如下：
<img src="/images/spring/proxy_mode.png"></p>

<p>从代码上我们可以看出，代理模式要求(这也是它的限制所在)：</p>

<pre><code>(1).代理类需要和被代理者一样实现相同的接口；
(2).代理类包含被代理者的引用；
</code></pre>

<h4 id="1.2 Java动态代理">1.2 Java动态代理</h4>


<p>代理模式我们可以理解为一种静态代理，其问题是需要我们显示的为每个需要被代理的类实现一个代理类，即一个代理类只能为i一个被代理者做代理的功能。如果有上千个类需要代理，估计要骂娘了。</p>

<p>java动态代理正是为了解决这个问题。主要通过java.lang.reflect.Proxy类和java.lang.reflect.InvocationHandler接口。我们只需要实现InvocationHandler接口，在实现invoke()方法的时候加上我们的代理逻辑。</p>

<p>一个简单的使用实例如下：</p>

<pre><code>/**
 * @author xiaobaoqiu  Date: 16-3-10 Time: 下午6:18
 */
public class JavaDynamicProxy implements InvocationHandler {

    /**
     * 被代理者
     */
    private Object inner;

    /**
     * 生成代理类
     */
    public static Object generateProxy(Object inner) {
        return Proxy.newProxyInstance(
                inner.getClass().getClassLoader(),
                inner.getClass().getInterfaces(),
                new JavaDynamicProxy(inner));
    }

    private JavaDynamicProxy(Object inner) {
        this.inner = inner;
    }

    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        doSomethingBefore();

        Object result = method.invoke(inner, args);

        doSomethingAfter();

        return result;
    }

    private void doSomethingBefore() {
        System.out.println("JavaDynamicProxy: Before...");
    }

    private void doSomethingAfter() {
        System.out.println("JavaDynamicProxy: After...");
    }
}

//使用
public static void main(String[] args) {
        //被动态代理的IHello实例对象A
        IHello helloA = new HelloImpl();
        //生成对象A的动态代理
        IHello helloAProxy = (IHello) JavaDynamicProxy.generateProxy(helloA);
        helloAProxy.hello();

        System.out.println("-------------------------------------------------");
        // 一个JavaDynamicProxy可以一直使用

        //被动态代理的IHello实例对象B
        IHello helloB = new HelloWithLogImpl();
        //生成对象B的动态代理
        IHello helloBProxy = (IHello) JavaDynamicProxy.generateProxy(helloB);
        helloBProxy.hello();

        System.out.println("-------------------------------------------------");
        //被动态代理对象IBye实例
        IBye bye = new ByeImpl();
        //生成IBye实例的动态代理
        IBye byeProxy = (IBye) JavaDynamicProxy.generateProxy(bye);
        byeProxy.bye();
}
</code></pre>

<p>JavaDynamicProxy.generateProxy的输出会是一个动态的代理类。debug信息如下，从debug信息我们大致知道，这个代理类的类名称为$Proxy0,内部包含一个属性名为h的属性，h指向的就是我们实现的InvocationHandler的类(这里即JavaDynamicProxy)的实例。</p>

<p><img src="/images/spring/java_proxy_debug.png"></p>

<p>但是Java动态代理的限制是：</p>

<pre><code>(1).被代理的类要求至少实现了一个Interface;
(2).被代理的类要求有public的构造函数(即没有显示的将其设置为private等);
(3).被代理的类要求不是final;
</code></pre>

<p>如下代理一个没有实现任何接口的类会报错
<code>
        //没有实现任何interface的类使不能被动态代理的
        System.out.println("-------------------------------------------------");
        HelloWithoutInterface helloC = new HelloWithoutInterface();
        //生成对象C的动态代理
        HelloWithoutInterface helloCProxy = (HelloWithoutInterface) JavaDynamicProxy.generateProxy(helloC);
        helloCProxy.hello();
</code>
错误信息如下：</p>

<pre><code>Exception in thread "main" java.lang.ClassCastException: com.sun.proxy.$Proxy2 cannot be cast to proxy.javaProxy.HelloWithoutInterface
    at proxy.javaProxy.JavaProxyMain.main(JavaProxyMain.java:42)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:606)
    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:140)
</code></pre>

<p>Java动态代理的机制是利用反射机制生成。具体代码可以debug，主要的代码如下：</p>

<pre><code>//Proxy.java
public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException {
    ...
    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);    //生成代理类
    ...
    return newInstance(cons, ih);   // 生成代理类的实例
}

private static Class&lt;?&gt; getProxyClass0(ClassLoader loader,  Class&lt;?&gt;... interfaces) {
        //生成代理类的主要逻辑在ProxyClassFactory
        return proxyClassCache.get(loader, interfaces);
}

//ProxyClassFactory的apply方法
public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) {
    ...
            String proxyPkg = null;     // 生成代理类的包路径
            ...
            if (proxyPkg == null) {
                // if no non-public proxy interfaces, use com.sun.proxy package
                proxyPkg = ReflectUtil.PROXY_PACKAGE + "."; //默认路径在com.sun.proxy下面
            }

            long num = nextUniqueNumber.getAndIncrement();  //代理类的序号， 我们熟悉的$Proxy0中的0
            String proxyName = proxyPkg + proxyClassNamePrefix + num;   //代理类的类名称

            //使用ProxyGenerator生成代理类的字节码
            byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces);
            //生成代理类
            return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length);
}

//ProxyGenerator.generateProxyClass的代码太恶心的...
</code></pre>

<p>我们可以自己使用ProxyGenerator来生成代理类并将其字节码记录下来：
<code>
    // 获取代理类的字节码
    byte[] classFile = ProxyGenerator.generateProxyClass("$Proxy0", ByeImpl.class.getInterfaces());
    //将字节码写文件，建议写成.class文件
</code></p>

<p>获取的字节码如下：</p>

<pre><code>import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.lang.reflect.UndeclaredThrowableException;
import proxy.sample.IBye;

public final class $Proxy0 extends Proxy implements IBye {
    private static Method m1;
    private static Method m3;
    private static Method m0;
    private static Method m2;

    public $Proxy0(InvocationHandler var1) throws  {
        super(var1);
    }

    public final boolean equals(Object var1) throws  {
        try {
            return ((Boolean)super.h.invoke(this, m1, new Object[]{var1})).booleanValue();
        } catch (RuntimeException | Error var3) {
            throw var3;
        } catch (Throwable var4) {
            throw new UndeclaredThrowableException(var4);
        }
    }

    public final void bye() throws  {
        try {
            super.h.invoke(this, m3, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final int hashCode() throws  {
        try {
            return ((Integer)super.h.invoke(this, m0, (Object[])null)).intValue();
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final String toString() throws  {
        try {
            return (String)super.h.invoke(this, m2, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    static {
        try {
            m1 = Class.forName("java.lang.Object").getMethod("equals", new Class[]{Class.forName("java.lang.Object")});
            m3 = Class.forName("proxy.sample.IBye").getMethod("bye", new Class[0]);
            m0 = Class.forName("java.lang.Object").getMethod("hashCode", new Class[0]);
            m2 = Class.forName("java.lang.Object").getMethod("toString", new Class[0]);
        } catch (NoSuchMethodException var2) {
            throw new NoSuchMethodError(var2.getMessage());
        } catch (ClassNotFoundException var3) {
            throw new NoClassDefFoundError(var3.getMessage());
        }
    }
}
</code></pre>

<p>从生成的类我们知道，代理类继承Proxy类(这就是为什么Proxy类内的InvocationHandler实例未protected)并实现我们需要的被代理者的Interface(比如这里的bye()方法)，另外它只要一个接受一个InvocationHandler为参数的构造函数。当我们调用代理类的bye()方法时候，其实是调用我们实现的InvocationHandler(即上面的JavaDynamicProxy)的invoke()方法，在invoke()方法里面，我们实现了我的代理逻辑。</p>

<p>我们这里这个Demo的大致UML图如下：</p>

<p><img src="/images/spring/java_dynamic_proxy.png"></p>

<p>参考：<a href="http://www.cnblogs.com/cruze/p/3819761.html">http://www.cnblogs.com/cruze/p/3819761.html</a></p>

<h4 id="1.3 CGLib动态代理">1.3 CGLib动态代理</h4>


<p>鉴于Java动态代理的限制，我们有需要代理没有任何实现接口的类的时候，可以考虑使用CGLib。CGLib的全称是Code Generate Library。CGLib的使用使用十分广泛，我们这里要讲的Spring AOP，以及EasyMock等。</p>

<p>同样先上Demo代码，我们只需要实现MethodInterceptor接口：</p>

<pre><code>/**
 * @author xiaobaoqiu  Date: 16-3-10 Time: 下午7:15
 */
public class CglibDynamicProxy implements MethodInterceptor {

    /**
     * 动态生成代理类
     */
    public Object generateProxy(Class cls) {
        Enhancer enhancer = new Enhancer();
        enhancer.setCallback(this);
//        enhancer.setCallbackFilter(); //filter
        enhancer.setSuperclass(cls);
        return enhancer.create();   // Enhancer也包含带参数的create方法
    }

    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        doSomethingBefore();

        Object result = proxy.invokeSuper(obj, args);

        doSomethingAfter();

        return result;
    }

    private void doSomethingBefore() {
        System.out.println("CglibDynamicProxy: Before...");
    }

    private void doSomethingAfter() {
        System.out.println("CglibDynamicProxy: After...");
    }
}

//使用
public static void main(String[] args) {
        CglibDynamicProxy proxy = new CglibDynamicProxy();
        //注意: 原始类的instance不需要存在，只需要Class类型

        //用接口IHello接, 或者 HelloImpl 接
        IHello helloAProxy = (IHello)proxy.generateProxy(HelloImpl.class);
        helloAProxy.hello();

        System.out.println("-------------------------------------------------");

        //用接口IHello接, 或者 HelloWithLogImpl 接
        IHello helloBProxy = (IHello)proxy.generateProxy(HelloWithLogImpl.class);
        helloBProxy.hello();

        System.out.println("-------------------------------------------------");

        //代理没有实现任何interface的类
        HelloWithoutInterface helloCProxy = (HelloWithoutInterface)proxy.generateProxy(HelloWithoutInterface.class);
        helloCProxy.hello();
}
</code></pre>

<p>同样我们debug一下，得到的信息如下，同样生成了代理类，类名称为proxy.sample.HelloImpl$$EnhancerByCGLIB$$b46b6f06，这个稀奇古怪的类名我们后面会分析：</p>

<p><img src="/images/spring/cglib_proxy_debug.png"></p>

<p>下面还是尝试分析CGLib动态代理的原理。默认情况下生成的代理class文件只存储在内存中，我们可以在代码中设置一个环境变量：</p>

<pre><code>System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, "/home/xiaobaoqiu/cglib_proxy");
</code></pre>

<p>之后我们在目标目录下得到很多的class，其中的proxy目录包含了生成的class文件。我们发现一大堆的class文件，类名都是稀奇古怪：</p>

<pre><code>xiaobaoqiu@xiaobaoqiu:~/cglib_proxy/proxy/javaProxy$ ll
-rw-rw-r-- 1 xiaobaoqiu xiaobaoqiu 2227  3月 21 18:38 HelloWithoutInterface$$EnhancerByCGLIB$$7d786e36.class
-rw-rw-r-- 1 xiaobaoqiu xiaobaoqiu 5555  3月 21 18:38 HelloWithoutInterface$$EnhancerByCGLIB$$e4e0e0f1.class
-rw-rw-r-- 1 xiaobaoqiu xiaobaoqiu 7744  3月 21 18:38 HelloWithoutInterface$$EnhancerByCGLIB$$e4e0e0f1$$FastClassByCGLIB$$814877d5.class
-rw-rw-r-- 1 xiaobaoqiu xiaobaoqiu 2673  3月 21 18:45 HelloWithoutInterface$$FastClassByCGLIB$$32a767a1.class
</code></pre>

<p>我们先看看class文件的生成策略。每个Class Generator(比如这里的Enhancer)都继承自AbstractClassGenerator(实现接口ClassGenerator，这个接口只有一个generateClass的方法)，需要实现其generateClass()方法。generateClassName()方法用来生成Class名称：</p>

<pre><code>private String generateClassName(Predicate nameTestPredicate) {
        return namingPolicy.getClassName(namePrefix, source.name, key, nameTestPredicate);
}

//namingPolicy的默认实现NamingPolicy
public String getClassName(String prefix, String source, Object key, Predicate names) {
    //prefix为被代理类的路径，
        String base =
            prefix + "$$" +                         //prefix为被代理类的路径
            source.substring(source.lastIndexOf('.') + 1) +     //获取生成代理类的类，比如我们这里的Enhancer
            getTag() + "$$" +                       //getTag()默认为ByCGLIB
            Integer.toHexString(STRESS_HASH_CODE ? 0 : key.hashCode()); //hashcode
        String attempt = base;
        int index = 2;
        while (names.evaluate(attempt))     //如果有重复，则再在后面加上下标，小标从2开始
            attempt = base + "_" + index++;
        return attempt;
}
</code></pre>

<p>下面正式进入class文件的生成原理分析，还是从源代码入手，enhancer.create()最终进入AbstractClassGenerator.create()方法，我们发现最终return的Object是从内部变量obj得来，因此，我们看看ClassLoaderData的生成逻辑：</p>

<pre><code>protected Object create(Object key) {
            ClassLoader loader = getClassLoader();
            Map&lt;ClassLoader, ClassLoaderData&gt; cache = CACHE;
            ClassLoaderData data = cache.get(loader);
            if (data == null) {
                synchronized (AbstractClassGenerator.class) {
                    data = cache.get(loader);
                    if (data == null) {
                        Map&lt;ClassLoader, ClassLoaderData&gt; newCache = new WeakHashMap&lt;ClassLoader, ClassLoaderData&gt;(cache);
                        data = new ClassLoaderData(classLoader);
                        newCache.put(classLoader, data);
                        CACHE = newCache;
                    }
                }
            }
            this.key = key;
            Object obj = data.get(this);
            if (obj instanceof Class) {
                return firstInstance((Class) obj);
            }
            return nextInstance(obj);
}

public ClassLoaderData(ClassLoader classLoader) {
            this.classLoader = new WeakReference&lt;ClassLoader&gt;(classLoader);
            Function&lt;AbstractClassGenerator, Object&gt; load =
                    new Function&lt;AbstractClassGenerator, Object&gt;() {
                        public Object apply(AbstractClassGenerator gen) {
                            Class klass = gen.generate(ClassLoaderData.this);   //生成class的关键代码
                            return gen.wrapCachedClass(klass);
                        }
                    };
            generatedClasses = new LoadingCache&lt;AbstractClassGenerator, Object, Object&gt;(GET_KEY, load);
}
</code></pre>

<p>因此我们将目光转到generate()中：</p>

<pre><code>//Enhancer的generate()方法
protected Class generate(ClassLoaderData data) {
        validate();
        if (superclass != null) {
            setNamePrefix(superclass.getName());
        } else if (interfaces != null) {
            setNamePrefix(interfaces[ReflectUtils.findPackageProtected(interfaces)].getName());
        }
        return super.generate(data);    //父类AbstractClassGenerator
}
// AbstractClassGenerator的generate()方法
protected Class generate(ClassLoaderData data) {
            //...
            ClassLoader classLoader = data.getClassLoader();
            this.setClassName(generateClassName(data.getUniqueNamePredicate()));    //代理类的类名称的生成逻辑
            //...
            byte[] b = strategy.generate(this);     //生成策略，默认实现DefaultGeneratorStrategy，生成class文件的字节码
            String className = ClassNameReader.getClassName(new ClassReader(b));
            ProtectionDomain protectionDomain = getProtectionDomain();
            synchronized (classLoader) { // just in case
                if (protectionDomain == null) {
                    gen = ReflectUtils.defineClass(className, b, classLoader);
                } else {
                    gen = ReflectUtils.defineClass(className, b, classLoader, protectionDomain);
                }
            }
            return gen;
            ...//异常处理
}

//DefaultGeneratorStrategy的generate()方法
public byte[] generate(ClassGenerator cg) throws Exception {
        DebuggingClassWriter cw = getClassVisitor();
        transform(cg).generateClass(cw);        //这里调用最终的generateClass()逻辑,Visitor模式
        return transform(cw.toByteArray()); //通过Visitor得到最后的字节码
}
</code></pre>

<p>所以最终的调用是Enhancer的generateClass()调用。这代码好晦涩，感觉和JVM加载字节码相关。</p>

<p>看一下CGLib生成的class文件，这个代理类继承了我们的被代理类并且实现了Factory类，类定义如下：</p>

<pre><code>public class HelloWithoutInterface$$EnhancerByCGLIB$$e4e0e0f1 extends proxy.javaProxy.HelloWithoutInterface implements net.sf.cglib.proxy.Factory {
    private boolean CGLIB$BOUND;
    public static java.lang.Object CGLIB$FACTORY_DATA;
    private static final java.lang.ThreadLocal CGLIB$THREAD_CALLBACKS;
    private static final net.sf.cglib.proxy.Callback[] CGLIB$STATIC_CALLBACKS;
    private net.sf.cglib.proxy.MethodInterceptor CGLIB$CALLBACK_0;
    private static final java.lang.reflect.Method CGLIB$hello$0$Method;
    private static final net.sf.cglib.proxy.MethodProxy CGLIB$hello$0$Proxy;
    private static final java.lang.Object[] CGLIB$emptyArgs;
    private static final java.lang.reflect.Method CGLIB$equals$1$Method;
    private static final net.sf.cglib.proxy.MethodProxy CGLIB$equals$1$Proxy;
    private static final java.lang.reflect.Method CGLIB$toString$2$Method;
    private static final net.sf.cglib.proxy.MethodProxy CGLIB$toString$2$Proxy;
    private static final java.lang.reflect.Method CGLIB$hashCode$3$Method;
    private static final net.sf.cglib.proxy.MethodProxy CGLIB$hashCode$3$Proxy;
    private static final java.lang.reflect.Method CGLIB$clone$4$Method;
    private static final net.sf.cglib.proxy.MethodProxy CGLIB$clone$4$Proxy;

    static void CGLIB$STATICHOOK1() { /* compiled code */ }

    final void CGLIB$hello$0() { /* compiled code */ }  //代理的方法

    public final void hello() { /* compiled code */ }   //代理的方法

    final boolean CGLIB$equals$1(java.lang.Object o) { /* compiled code */ }

    public final boolean equals(java.lang.Object o) { /* compiled code */ }

    final java.lang.String CGLIB$toString$2() { /* compiled code */ }

    public final java.lang.String toString() { /* compiled code */ }

    final int CGLIB$hashCode$3() { /* compiled code */ }

    public final int hashCode() { /* compiled code */ }

    final java.lang.Object CGLIB$clone$4() throws java.lang.CloneNotSupportedException { /* compiled code */ }

    protected final java.lang.Object clone() throws java.lang.CloneNotSupportedException { /* compiled code */ }

    public static net.sf.cglib.proxy.MethodProxy CGLIB$findMethodProxy(net.sf.cglib.core.Signature signature) { /* compiled code */ }

    public HelloWithoutInterface$$EnhancerByCGLIB$$e4e0e0f1() { /* compiled code */ }

    public static void CGLIB$SET_THREAD_CALLBACKS(net.sf.cglib.proxy.Callback[] callbacks) { /* compiled code */ }

    public static void CGLIB$SET_STATIC_CALLBACKS(net.sf.cglib.proxy.Callback[] callbacks) { /* compiled code */ }

    private static final void CGLIB$BIND_CALLBACKS(java.lang.Object o) { /* compiled code */ }

    public java.lang.Object newInstance(net.sf.cglib.proxy.Callback[] callbacks) { /* compiled code */ }

    public java.lang.Object newInstance(net.sf.cglib.proxy.Callback callback) { /* compiled code */ }

    public java.lang.Object newInstance(java.lang.Class[] classes, java.lang.Object[] objects, net.sf.cglib.proxy.Callback[] callbacks) { /* compiled code */ }

    public net.sf.cglib.proxy.Callback getCallback(int i) { /* compiled code */ }

    public void setCallback(int i, net.sf.cglib.proxy.Callback callback) { /* compiled code */ }

    public net.sf.cglib.proxy.Callback[] getCallbacks() { /* compiled code */ }

    public void setCallbacks(net.sf.cglib.proxy.Callback[] callbacks) { /* compiled code */ }
}
</code></pre>

<p>注意，我们生成的动态代理包含两个hello()相关的方法。我们可以使用javap获取其字节码,我们发现和我们被代理者同名的hello()方法是带代理逻辑的，而CGLIB$hello$0()这个则是原始被代理者的直接调用(不包含代理逻辑):</p>

<pre><code>xiaobaoqiu@xiaobaoqiu:~/cglib_proxy/proxy/javaProxy$ javap -c HelloWithoutInterface\$\$EnhancerByCGLIB\$\$e4e0e0f1.class
...
  final void CGLIB$hello$0();
    Code:
       0: aload_0
       1: invokespecial #36                 // Method proxy/javaProxy/HelloWithoutInterface.hello:()V
       4: return

  public final void hello();
    Code:
       0: aload_0
       1: getfield      #38                 // Field CGLIB$CALLBACK_0:Lnet/sf/cglib/proxy/MethodInterceptor;
       4: dup
       5: ifnonnull     17
       8: pop
       9: aload_0
      10: invokestatic  #42                 // Method CGLIB$BIND_CALLBACKS:(Ljava/lang/Object;)V
      13: aload_0
      14: getfield      #38                 // Field CGLIB$CALLBACK_0:Lnet/sf/cglib/proxy/MethodInterceptor;
      17: dup
      18: ifnull        37
      21: aload_0
      22: getstatic     #44                 // Field CGLIB$hello$0$Method:Ljava/lang/reflect/Method;
      25: getstatic     #46                 // Field CGLIB$emptyArgs:[Ljava/lang/Object;
      28: getstatic     #48                 // Field CGLIB$hello$0$Proxy:Lnet/sf/cglib/proxy/MethodProxy;
      31: invokeinterface #54,  5           // InterfaceMethod net/sf/cglib/proxy/MethodInterceptor.intercept:(Ljava/lang/Object;Ljava/lang/reflect/Method;[Ljava/lang/Object;Lnet/sf/cglib/proxy/MethodProxy;)Ljava/lang/Object;
      36: return
      37: aload_0
      38: invokespecial #36                 // Method proxy/javaProxy/HelloWithoutInterface.hello:()V
      41: return
...
</code></pre>

<p>遗留问题：
(1).为什么一个类会生成多个代理类，各个代理类都是什么用处；</p>

<p>CGLib代理同样存在限制：</p>

<pre><code>(1).private方法无法代理；
(2).final方法无法代理;
</code></pre>

<p>private方法和final方法看代理类的字节码会发现，代理类不会这些重写函数(子类没法重写)，因此会自动调用父类的。</p>

<p>参考：
<a href="http://www.cnblogs.com/cruze/p/3843996.html">cglib源码分析（四）：cglib 动态代理原理分析</a></p>

<p><a href="https://dzone.com/articles/cglib-missing-manual">CGLib: The Missing Manual</a></p>

<h4 id="#1.4 Java动态代理 VS CGLib动态代理">#1.4 Java动态代理 VS CGLib动态代理</h4>


<p>简单总结对比一下两种动态代理:</p>

<table>
<thead>
<tr>
<th style="text-align:center;">代理 </th>
<th style="text-align:center;"> 没有实现interface的类 </th>
<th style="text-align:center;"> protected方法 </th>
<th style="text-align:center;"> private方法 </th>
<th style="text-align:center;"> final类 </th>
<th style="text-align:center;"> final方法 </th>
<th style="text-align:center;"> 构造函数private的类 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">Java动态代理 </td>
<td style="text-align:center;"> 不支持 </td>
<td style="text-align:center;"> 不支持 </td>
<td style="text-align:center;"> 不支持 </td>
<td style="text-align:center;">支持 </td>
<td style="text-align:center;"> 支持 </td>
<td style="text-align:center;"> 支持 </td>
</tr>
<tr>
<td style="text-align:center;">CGLib动态代理 </td>
<td style="text-align:center;"> 支持 </td>
<td style="text-align:center;"> 支持  </td>
<td style="text-align:center;"> 不支持 </td>
<td style="text-align:center;">不支持 </td>
<td style="text-align:center;"> 不支持 </td>
<td style="text-align:center;"> 不支持 </td>
</tr>
</tbody>
</table>


<p>关于CGLib对protected方法的支持,可以在生成的代理类中看到.</p>

<pre><code>CGLib报错信息：
final类: Cannot subclass final class proxy.javaProxy.HelloWithFinal
构造方法私有的类: No visible constructors in class proxy.javaProxy.HelloWithoutConstructor
final方法: 不报错，但没有代理逻辑
</code></pre>

<p>在性能方面，通常认为Java动态代理生成代理类比CGLib生成代理类快，但是CGLib的代理类运行期性能会优于Java动态代理的代理类。不过通常性能都不是问题，如果确实很关心性能，建议直接使用ASM。</p>

<p>参考：
<a href="http://www.theserverside.com/news/thread.tss?thread_id=45089">Why do you think CGLib proxies are faster than JDK Proxies?</a></p>

<p><a href="https://community.oracle.com/docs/DOC-983406">Implement Your Own Proxy-Based AOP Framework Blog</a></p>

<p>BeanDefinitionParserDelegate
AnnotationDrivenBeanDefinitionParser</p>

<p>参考：
Spring加载资源分析：<a href="http://www.blogjava.net/heavensay/archive/2013/10/28/405699.html">http://www.blogjava.net/heavensay/archive/2013/10/28/405699.html</a></p>

<p>事务的坑
<a href="http://www.ibm.com/developerworks/library/j-ts1/">http://www.ibm.com/developerworks/library/j-ts1/</a></p>

<p>代理实现选择器:
AdviceMode
TransactionManagementConfigurationSelector</p>

<p>声明事务切面实现:
TransactionInterceptor</p>

<p>事务实现
Connection关闭自动提交
ConnectionHolder来保持Connection</p>

<p>参考:
<a href="http://openwares.net/java/spring_mybatis_transaction.html">http://openwares.net/java/spring_mybatis_transaction.html</a>
<a href="http://my.oschina.net/guanzhenxing/blog/214228">http://my.oschina.net/guanzhenxing/blog/214228</a>
<a href="http://www.mybatis.org/spring/zh/transactions.html">http://www.mybatis.org/spring/zh/transactions.html</a>
<a href="http://tracylihui.github.io/2015/07/28/spring/Spring%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/">http://tracylihui.github.io/2015/07/28/spring/Spring%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</a>
<a href="http://www.cnblogs.com/davenkin/archive/2013/02/16/java-tranaction-1.html">http://www.cnblogs.com/davenkin/archive/2013/02/16/java-tranaction-1.html</a>
<a href="http://www.importnew.com/12300.html">http://www.importnew.com/12300.html</a>
详细介绍Spring事务管理: <a href="http://developer.51cto.com/art/200906/129854.htm">http://developer.51cto.com/art/200906/129854.htm</a>
spring事务原理1-事务的抽象: <a href="http://sqtds.github.io/2014/06/09/2014/spring-tx1/">http://sqtds.github.io/2014/06/09/2014/spring-tx1/</a>
Spring官方文档Transaction Management: <a href="http://docs.spring.io/autorepo/docs/spring/3.2.x/spring-framework-reference/html/transaction.html">http://docs.spring.io/autorepo/docs/spring/3.2.x/spring-framework-reference/html/transaction.html</a>
Spring官方文档Aspect Oriented Programming with Spring: <a href="http://docs.spring.io/spring/docs/3.0.x/reference/aop.html">http://docs.spring.io/spring/docs/3.0.x/reference/aop.html</a>
StackOverFlow Spring - @Transactional - What happens in background?: <a href="http://stackoverflow.com/questions/1099025/spring-transactional-what-happens-in-background">http://stackoverflow.com/questions/1099025/spring-transactional-what-happens-in-background</a>
Transaction strategies: Understanding transaction pitfalls: <a href="http://www.ibm.com/developerworks/library/j-ts1/">http://www.ibm.com/developerworks/library/j-ts1/</a>
Annotation-based Transactions in Spring: <a href="http://springinpractice.com/2008/03/18/annotation-based-transactions-in-spring">http://springinpractice.com/2008/03/18/annotation-based-transactions-in-spring</a>
Design principle behind Transaction framework with Spring 3: <a href="http://stackoverflow.com/questions/11789857/design-principle-behind-transaction-framework-with-spring-3">http://stackoverflow.com/questions/11789857/design-principle-behind-transaction-framework-with-spring-3</a>
Chapter 6. 使用Spring进行面向切面编程（AOP）: <a href="http://shouce.jb51.net/spring/aop.html">http://shouce.jb51.net/spring/aop.html</a>
wiki: <a href="http://wiki.corp.qunar.com/display/~yushen.ma/Spring+3.x-JDBC+Transaction">http://wiki.corp.qunar.com/display/~yushen.ma/Spring+3.x-JDBC+Transaction</a>
spring事务: <a href="http://wiki.corp.qunar.com/pages/viewpage.action?pageId=52084161">http://wiki.corp.qunar.com/pages/viewpage.action?pageId=52084161</a>
spring 事务: <a href="http://wiki.corp.qunar.com/pages/viewpage.action?pageId=93338632">http://wiki.corp.qunar.com/pages/viewpage.action?pageId=93338632</a>
aspectj事务: <a href="http://wiki.corp.qunar.com/pages/viewpage.action?pageId=92656954">http://wiki.corp.qunar.com/pages/viewpage.action?pageId=92656954</a></p>

<p>Demo:
编程事务: <a href="http://www.tutorialspoint.com/spring/programmatic_management.htm">http://www.tutorialspoint.com/spring/programmatic_management.htm</a>
声明事务: <a href="http://www.tutorialspoint.com/spring/declarative_management.htm">http://www.tutorialspoint.com/spring/declarative_management.htm</a></p>

<p>@Transactional注解工作原理：<a href="http://blog.csdn.net/dslztx/article/details/46636079">http://blog.csdn.net/dslztx/article/details/46636079</a>
分布式事务系列（1.2）Spring的事务体系： <a href="https://yq.aliyun.com/articles/39046">https://yq.aliyun.com/articles/39046</a>
spring transaction源码分析&ndash;事务架构：<a href="http://www.cnblogs.com/davidwang456/p/4309038.html">http://www.cnblogs.com/davidwang456/p/4309038.html</a></p>

<p><a href="http://blog.csdn.net/szwangdf/article/details/41516239">http://blog.csdn.net/szwangdf/article/details/41516239</a></p>

<p>AopProxy
DefaultAopProxyFactory</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[动态数据源]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/06/02/dong-tai-shu-ju-yuan/"/>
    <updated>2015-06-02T02:42:35+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/06/02/dong-tai-shu-ju-yuan</id>
    <content type="html"><![CDATA[<h1>1.数据库层面的动态数据源</h1>

<p>比如多个读库(Read),可以配置一个虚拟IP,每次读数据库的请求被均衡的分配到各个读库(使用Keepalived等).</p>

<p>这中方式对应用程序是透明的.</p>

<h1>2.数据库Proxy</h1>

<p>很多现成的数据库Proxy,在Proxy中可以做负载均衡(一般使用LVS,Keepalived等现成应用),权限验证,过滤,业务缓存等控制逻辑.比如:</p>

<pre><code>1.360基于mysql-proxy的Atlas
Atlas是由 Qihoo 360,Web平台部基础架构团队开发维护的一个基于MySQL协议的数据中间层项目。它是在mysql-proxy 0.8.2版本的基础上，对其进行了优化，增加了一些新的功能特性。360内部使用Atlas运行的mysql业务，每天承载的读写请求数达几十亿条。
github:https://github.com/Qihoo360/Atlas
参考:https://github.com/Qihoo360/Atlas/wiki/Atlas%E7%9A%84%E6%9E%B6%E6%9E%84

2.阿里的DRDS
分布式关系型数据库服务（Distribute Relational Database Service，简称DRDS）是一种水平拆分、可平滑扩缩容、读写分离的在线分布式数据库服务。前身为淘宝开源的TDDL，是近千个应用首选组件，已稳定服务了七年以上。已经商业化.
参考:http://docs.aliyun.com/?spm=5176.7622920.9.2.qGx2nq#/pub/drds/brief-manual/summary&amp;summary

3.网易的分布式数据库中间件DDB
DDB（Distributed database）是网易杭研院立项最早，应用最为广泛的后台产品之一，也是国内最早出现的基于现有database之上开发的分布式数据库中间件，目前依然在为网易易信，云音乐，云阅读等大型互联网产品提供稳定的数据库服务。
参考:http://www.majin163.com/2014/09/24/ddb-introduce/

4.百度DDBS
</code></pre>

<h1>3.代码层面</h1>

<p>使用Spring实现数据源动态配置,可以在代码层面达到Master-Slave数据库分离的效果.</p>

<p>其实原理很简单,需要做两个工作:</p>

<pre><code>1.实现一个根据不同key使用不同实际DataSource的自定义DataSource;
2.在请求的ThreadLocal中保存当前请求需要使用的数据库的key;
</code></pre>

<p>其中第一个工作Spring已经帮我们做了,见类org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource.</p>

<h3>3.1 AbstractRoutingDataSource简介</h3>

<p>下面简单介绍这个类:</p>

<pre><code>/**
 * 抽象的javax.sql.DataSource实现，可以完成基于一个查找key来路由 #getConnection()到某些特性目标DataSourcesd的一个。一般通过绑定线程上下文来决定。
 */
public abstract class AbstractRoutingDataSource extends AbstractDataSource implements InitializingBean {
private Map&lt;Object, Object&gt; targetDataSources;

    private Object defaultTargetDataSource;

    private boolean lenientFallback = true;

    private DataSourceLookup dataSourceLookup = new JndiDataSourceLookup();

    private Map&lt;Object, DataSource&gt; resolvedDataSources;

    private DataSource resolvedDefaultDataSource;

    /**
     * 设置目标DataSources的map映射，其中查找key作为 map的key。
     * 这个映射的value可以是对象的DataSource实例，或者是一个数据源name的字符串（可以被DataSourceLookup解析）。
     *
     * key可以是任意的类型，只要实现了普通的查找处理。
     * 具体的key表示形式，将会被resolveSpecifiedLookupKey和determineCurrentLookupKey处理
     *
     */
    public void setTargetDataSources(Map&lt;Object, Object&gt; targetDataSources) {
        this.targetDataSources = targetDataSources;
    }

    /**
     * 设置默认目标数据源。如果我们在map中找不到对应的key时，则会使用这里设置的默认数据源
     */
    public void setDefaultTargetDataSource(Object defaultTargetDataSource) {
        this.defaultTargetDataSource = defaultTargetDataSource;
    }

    /**
     * 指定默认的DataSource，当通过指定的查找key不能找到对应的DataSource。
     * 如果为false，则直接返回失败，如果为true，则使用默认的数据源。默认为true
     */
    public void setLenientFallback(boolean lenientFallback) {
        this.lenientFallback = lenientFallback;
    }

    /**
     * 设置DataSourceLookup的实现类，该实现类可以把字符串配置的数据源，解析成我们需要的DataSource类.默认使用JndiDataSourceLookup。
     *
     * JndiDataSourceLookup方法使用ref bean方式获取配置文件中配置的dataSource数据源，也就是我们一般使用xml中配置datasource的方式就是jndi。
     */
    public void setDataSourceLookup(DataSourceLookup dataSourceLookup) {
        this.dataSourceLookup = (dataSourceLookup != null ? dataSourceLookup : new JndiDataSourceLookup());
    }

    /**
    * 初始化,将targetDataSources转换成resolvedDataSources
    */
    public void afterPropertiesSet() {
        if (this.targetDataSources == null) {
            throw new IllegalArgumentException("Property 'targetDataSources' is required");
        }
        this.resolvedDataSources = new HashMap&lt;Object, DataSource&gt;(this.targetDataSources.size());
        for (Map.Entry entry : this.targetDataSources.entrySet()) {
            Object lookupKey = resolveSpecifiedLookupKey(entry.getKey());
            DataSource dataSource = resolveSpecifiedDataSource(entry.getValue());
            this.resolvedDataSources.put(lookupKey, dataSource);
        }
        if (this.defaultTargetDataSource != null) {
            this.resolvedDefaultDataSource = resolveSpecifiedDataSource(this.defaultTargetDataSource);
        }
    }

    /**
     * 根据lookupKey获取map中存放的key值，默认两者是一样的
     */
    protected Object resolveSpecifiedLookupKey(Object lookupKey) {
        return lookupKey;
    }
    /**
     * 转换从获取map中存放的dataSource
     */
    protected DataSource resolveSpecifiedDataSource(Object dataSource) throws IllegalArgumentException {
        if (dataSource instanceof DataSource) {
            return (DataSource) dataSource;
        }
        else if (dataSource instanceof String) {
            return this.dataSourceLookup.getDataSource((String) dataSource);
        }
        else {
            throw new IllegalArgumentException(
                    "Illegal data source value - only [javax.sql.DataSource] and String supported: " + dataSource);
        }
    }

    /**
    * 这里就是抽象类给我们实现的接口方法，根据我们的配置上下文，抽象类决定实现哪个连接
    */
    public Connection getConnection() throws SQLException {
        return determineTargetDataSource().getConnection();
    }

    public Connection getConnection(String username, String password) throws SQLException {
        return determineTargetDataSource().getConnection(username, password);
    }

    protected DataSource determineTargetDataSource() {
        Assert.notNull(this.resolvedDataSources, "DataSource router not initialized");
        Object lookupKey = determineCurrentLookupKey();
        DataSource dataSource = this.resolvedDataSources.get(lookupKey);
        if (dataSource == null &amp;&amp; (this.lenientFallback || lookupKey == null)) {
            dataSource = this.resolvedDefaultDataSource;
        }
        if (dataSource == null) {
            throw new IllegalStateException("Cannot determine target DataSource for lookup key [" + lookupKey + "]");
        }
        return dataSource;
    }

    /**
    * 这里是我们使用这个抽象类需要实现的方法，主要就是告诉该抽象类，当前需要使用的数据源的key是什么，这样抽象类就可以知道使用哪个数据库连接
    */
    protected abstract Object determineCurrentLookupKey();
}
</code></pre>

<p>我们可以继承这个类实现自己的RoutingDataSource,只需要实现determineCurrentLookupKey()方法.下面是一个实现示例,其中DataSourceKeyHolder用来在ThreadLocal中保存key,而我们的RoutingDataSource就可以从ThreadLocal中获取key来决定使用那个具体的数据源:</p>

<pre><code>public class RoutingDataSource extends AbstractRoutingDataSource {
    @Override
    protected Object determineCurrentLookupKey() {
        return DataSourceKeyHolder.getDataSource();
    }
}

public class DataSourceKeyHolder {
    private static final ThreadLocal&lt;String&gt; holder = new ThreadLocal&lt;String&gt;();

    public static String getDataSource() {
        return holder.get();
    }

    public static void putDataSource(String value) {
        holder.set(value);
    }

    public static void clear(){
        holder.remove();
    }
}
</code></pre>

<h3>3.2 自己实现RoutingDataSource</h3>

<p>Spring自带的AbstractRoutingDataSource功能强大,但是略先麻烦(最终使用的其实只有resolvedDataSources这个Map).我们完全可以自己实现一个简单的RoutingDataSource,比如我们要实现读写分离的动态数据库,一个简单实现如下:</p>

<pre><code>public class RoutingDataSource extends AbstractDataSource implements InitializingBean {
    /**
     * 写库, key是String
     */
    private Map&lt;String, DataSource&gt; writeDataSourceMap;
    /**
     * 读库, key是String
     */
    private Map&lt;String, DataSource&gt; readDataSourceMap;

    @Override
    public Connection getConnection() throws SQLException {
        //从上下文中获取key
        ConnectionKey connectionKey = ConnectionKeyHolder.get();
        try {
            //默认情况,返回随机一个写库
            if (connectionKey == null) {
                return fetchConnection(writeDataSourceMap, null);
            }

            //只读
            if (connectionKey.getType().equals(ConnectionKey.READ)) {
                return fetchConnection(readDataSourceMap, connectionKey.getKey());
            }

            //可读可写
            if (connectionKey.getType().equals(ConnectionKey.READ_WRITE)) {
                return fetchConnection(writeDataSourceMap, connectionKey.getKey());
            }
        } catch (Exception e) {
            logger.error("getConnectionError", e);
            if (e instanceof SQLException) {
                throw (SQLException) e;
            } else {
                throw new SQLException(e);
            }
        }

        // impossible code
        throw new IllegalArgumentException("invalid connection type: " + connectionKey.getType() + ", key: "
                + connectionKey.getKey());
    }

    /**
     * 根据key从对应的Map中获取数据库连接
     *
     * @param dbSourceMap
     * @param key
     * @return
     * @throws SQLException
     */
    private Connection fetchConnection(final Map&lt;String, DataSource&gt; dbSourceMap, String key) throws SQLException {
        if (key == null || key.length() == 0) { // null key, return a random read connection
            key = randomKey(dbSourceMap);
        }
        if (dbSourceMap.get(key) == null) {
            key = randomKey(dbSourceMap);
        }
        return dbSourceMap.get(key).getConnection();
    }

    /**
     * 随机获取一个Key
     * @return
     */
    private String randomKey(final Map&lt;String, DataSource&gt; dbSourceMap) {
        String[] keys = dbSourceMap.keySet().toArray(new String[0]);
        int size = dbSourceMap.size();
        int rand = new Random().nextInt(size);
        return keys[rand];
    }

    @Override
    public Connection getConnection(String username, String password) throws SQLException {
        throw new UnsupportedOperationException();
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        Preconditions.checkArgument(MapUtils.isNotEmpty(writeDataSourceMap));
        Preconditions.checkArgument(MapUtils.isNotEmpty(readDataSourceMap));
    }

    public void setWriteDataSource(Map&lt;String, DataSource&gt; writeDataSourceMap) {
        this.writeDataSourceMap = writeDataSourceMap;
    }

    public void setReadDataSourceMap(Map&lt;String, DataSource&gt; readDataSourceMap) {
        this.readDataSourceMap = readDataSourceMap;
    }
}

public class ConnectionKey {
    /**
     * 读库,只读
     */
    public static final String READ = "R";
    /**
     * 写库,可读可写
     */
    public static final String READ_WRITE = "RW";

    private String type;
    private String key;

    public ConnectionKey() {
    }

    public ConnectionKey(String type, String key) {
        this.type = type;
        this.key = key;
    }

    public String getType() {
        return type;
    }

    public String getKey() {
        return key;
    }

    public void setType(String type) {
        this.type = type;
    }

    public void setKey(String key) {
        this.key = key;
    }
}

public class ConnectionKeyHolder {
    private static ThreadLocal&lt;ConnectionKey&gt; connType = new ThreadLocal&lt;ConnectionKey&gt;();

    public static void set(ConnectionKey type) {
        connType.set(type);
    }

    public static ConnectionKey get() {
        return connType.get();
    }

    public static void release() {
        connType.remove();
    }
}
</code></pre>

<h3>3.3 使用实现动态数据源</h3>

<p>以我们自己实现的为例子,我们简单展示一下如何使用Spring加上AOP使用我们的动态数据源.</p>

<p>首先定义使用读库和使用写库的注解:</p>

<pre><code>/**
* 使用读库的注解,value()代表key
*/
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Read {
    String value() default "";
}
/**
* 使用写库的注解,value()代表key
*/
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Write {
    String value() default "";
}
</code></pre>

<p>然后定义Aspect,逻辑很简单,只是在执行我们的业务逻辑之前给线程上文写入ConnectionKey信息:</p>

<pre><code>public class RoutingAop {

    protected Logger log = LoggerFactory.getLogger(getClass());

    /**
     * 解析读库的注解
     *
     * @param pjp
     * @param read
     * @return
     * @throws Throwable
     */
    public Object aroundRead(ProceedingJoinPoint pjp, Read read) throws Throwable {
        ConnectionKey origType = ConnectionKeyHolder.get();
        try {
            ConnectionKey newType = ConnectionKey.buildReadConnectionKey(read.value());
            ConnectionKeyHolder.set(newType);
            return pjp.proceed();
        } catch (Throwable throwable) {
            log.warn("error while processing read method", throwable);
            throw throwable;
        } finally {
            if (origType != null) {
                ConnectionKeyHolder.set(origType);
            } else {
                ConnectionKeyHolder.release();
            }
        }
    }

    /**
     * 解析写库的注解
     *
     * @param pjp
     * @param write
     * @return
     * @throws Throwable
     */
    public Object aroundWrite(ProceedingJoinPoint pjp, Write write) throws Throwable {
        ConnectionKey origType = ConnectionKeyHolder.get();
        try {
            ConnectionKey newType = ConnectionKey.buildWriteConnectionKey(write.value());
            ConnectionKeyHolder.set(newType);
            return pjp.proceed();
        } catch (Throwable throwable) {
            log.warn("error while processing write method", throwable);
            throw throwable;
        } finally {
            if (origType != null) {
                ConnectionKeyHolder.set(origType);
            } else {
                ConnectionKeyHolder.release();
            }
        }
    }
}
</code></pre>

<p>在Spring配置文件中定义好各个读库和各个写库,定义我们的RoutingDataSource的bean,之后扫描注解就可以了:</p>

<p>```</p>

<!-- DataSource 写库  -->


<p><bean id="writeDataSource" class="..."></p>

<!-- DataSource 读库  -->


<p><bean id="readDataSource" class="..."></p>

<p><bean id="routingDataSource" class="com.Xxx.RoutingDataSource">
    <property name="writeDataSourceMap">
        <map key-type="java.lang.String" value-type="javax.sql.DataSource">
            <entry key="write1" value-ref="writeDataSource"/>
        </map>
    </property>
    <property name="readDataSourceMap">
        <map key-type="java.lang.String" value-type="javax.sql.DataSource">
            <entry key="read1" value-ref="readDataSource"/>
        </map>
    </property>
</bean></p>

<p><bean id="routingAop" class="com.Xxx.RoutingAop"/></p>

<!-- 定义Read Write注解扫描  -->


<p>&lt;aop:config>
    &lt;aop:aspect ref=&ldquo;routingAop&rdquo;>
        &lt;aop:around method=&ldquo;aroundRead&rdquo; arg-names=&ldquo;read&rdquo; pointcut=&ldquo;@annotation(read) &amp;&amp; execution(public * com.Xxx.controller.<em>.</em>(..))&rdquo; />
    &lt;/aop:aspect></p>

<pre><code>&lt;aop:aspect ref="routingAop"&gt;
    &lt;aop:around method="aroundWrite" arg-names="write" pointcut="@annotation(write) &amp;amp;&amp;amp; execution(public * com.Xxx.controller.*.*(..)) " /&gt;
&lt;/aop:aspect&gt;
</code></pre>

<p>&lt;/aop:config></p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring AOP无效]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/05/18/spring-aopwu-xiao/"/>
    <updated>2015-05-18T19:31:35+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/05/18/spring-aopwu-xiao</id>
    <content type="html"><![CDATA[<p>最近在重构项目,有一个场景:根据方法的返回值判断是否成功,成功则从入参里获取需要的参数,构造消息(Msg)并发送通知其他模块.</p>

<p>因为是比较通用的逻辑(判断返回值,获取参数,发送消息),因此做成Spring注解的形式,注解中会用AOP拦截方法获取方法的返回值和参数.</p>

<p>其中获取参数使用的是Spring SpEL表达式.</p>

<h1>1.使用背景</h1>

<p>碰到的一个问题是AOP拦截无法获取private,protected和inner方法的参数.使用场景如下:</p>

<h3>1.1 注解定义</h3>

<p>首先定义注解用于获取
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Target(ElementType.METHOD)
</span><span class='line'>@Retention(RetentionPolicy.RUNTIME)
</span><span class='line'>public @interface Param {
</span><span class='line'>    /&lt;em&gt;*
</span><span class='line'>     * 参数定义,标识了参数的获取方式,或常量值
</span><span class='line'>     &lt;/em&gt;/
</span><span class='line'>    String[] params();&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;/**
</span><span class='line'> * 操作类型,标识了当前这注解该被哪个处理类来处理
</span><span class='line'> */
</span><span class='line'>String[] operate();
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;}</span></code></pre></td></tr></table></div></figure></p>

<h3>1.2 定义切面</h3>

<pre><code>@Aspect
public class testAspect {
    /**
     * 根据注解获取切面
     */
    @Pointcut("@annotation(com.aaa.bbb.ccc.ParamGrabber)")
    public void aspectPointCut() {
    }

    /**
    * AOP, 定义方法返回之后的操作
    */
    @AfterReturning(value = "aspectPointCut()", returning = "returnValue")
    public void afterReturning(JoinPoint point, Object returnValue){
        //1.获取拦截的类和方法

        //2.获取方法上我们定义的特定注解

        //3.根据注解的参数中的spel表达式,从方法入参中获取我们需要的参数

        //4.一些列的Processor处理逻辑
    }
}
</code></pre>

<h3>1.3 处理类</h3>

<p>定义获取的参数之后的处理类的逻辑:
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public interface Processor {
</span><span class='line'>    /&lt;em&gt;*
</span><span class='line'>     * 本processor可以处理的操作类型
</span><span class='line'>     &lt;/em&gt;/
</span><span class='line'>    List&lt;String&gt; supportOperates();&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;/**
</span><span class='line'> *
</span><span class='line'> * 此processor的处理逻辑
</span><span class='line'> */
</span><span class='line'>void process(XxxContext context);
</span><span class='line'>
</span><span class='line'>/**
</span><span class='line'> * 返回值验证,是否需要执行process操作
</span><span class='line'> */
</span><span class='line'>boolean isReturnValid(XxxContext context, Object returnValue);
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;}
</span><span class='line'>&lt;code&gt;
</span><span class='line'>之后利用Spring就可以获取上下问中所有的实现类:
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>public class ProcessorSupport implements ApplicationContextAware, InitializingBean {
</span><span class='line'>    // Spring上下文
</span><span class='line'>    private ApplicationContext applicationContext;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;private final Multimap&lt;String, Processor&gt; processorMap = HashMultimap.create();
</span><span class='line'>
</span><span class='line'>@Override
</span><span class='line'>public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
</span><span class='line'>    this.applicationContext = applicationContext;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@Override
</span><span class='line'>public void afterPropertiesSet() throws Exception {
</span><span class='line'>    // 从Spring上下文获取Processor的所有具体实现类
</span><span class='line'>    Map&lt;String, Processor&gt; beansOfType = applicationContext.getBeansOfType(Processor.class);
</span><span class='line'>    for(Processor processor : beansOfType.values()) {
</span><span class='line'>        for(String op : processor.supportOperates()) {
</span><span class='line'>            processorMap.put(op, processor);
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>//根据注解中定义的operate来获取具体的处理类Processor
</span><span class='line'>@Override
</span><span class='line'>public Collection&lt;Processor&gt; getProcessor(String operate) {
</span><span class='line'>    return processorMap.get(operate);
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;}</span></code></pre></td></tr></table></div></figure></p>

<h3>1.4 使用</h3>

<p>使用的时候,首先得实现一个具体的Processor:
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class MyProcessor implements Processor {&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;public static final String SPECIFIC_PROCESSOR_KEY = "SPECIFIC_PROCESSOR_KEY";
</span><span class='line'>
</span><span class='line'>@Override
</span><span class='line'>public List&lt;String&gt; supportOperates() {
</span><span class='line'>    return ImmutableList.of(
</span><span class='line'>            SPECIFIC_PROCESSOR_KEY
</span><span class='line'>    );
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@Override
</span><span class='line'>public void process(XxxContext context) {
</span><span class='line'>    //获取注解解析得到的参数
</span><span class='line'>    Map&lt;String, Object&gt; parsedParam = context.getParsedParam();
</span><span class='line'>
</span><span class='line'>    //构建发送的消息内容
</span><span class='line'>    Msg msg = buildNoticeMsg(parsedParam);
</span><span class='line'>
</span><span class='line'>    //发送消息
</span><span class='line'>    noticeService.doNotice(msg);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@Override
</span><span class='line'>public boolean isReturnValid(XxxContext context, Object returnValue) {
</span><span class='line'>    //判断返回值是否有效...
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;}
</span><span class='line'>&lt;code&gt;
</span><span class='line'>具体使用的地方:
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>/&lt;em&gt;*
</span><span class='line'>* 根据SPECIFIC_PROCESSOR_KEY找到MyProcessor
</span><span class='line'>* params中使用SpEL获取参数中的某个属性
</span><span class='line'>&lt;/em&gt;/
</span><span class='line'>@Param(operate = MyProcessor.SPECIFIC_PROCESSOR_KEY, params = {
</span><span class='line'>        CrateConstants.KEYS_KEY + &ldquo;={#p0.![propertyName]}&rdquo;})
</span><span class='line'>public int batchInsert(List&lt;Tag&gt; tagList) {
</span><span class='line'>    if (CollectionUtils.isEmpty(tagList)) {
</span><span class='line'>        return 0;
</span><span class='line'>    }&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;return tagDao.insertBatchly(tagList);
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;}</span></code></pre></td></tr></table></div></figure></p>

<h1>2.问题</h1>

<h3>2.1 private和protected方法无效</h3>

<p>private和protected方法(通常为类的inner方法)无法使用我们定义的注解来达到目的,如下:
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//供外部调用的方法
</span><span class='line'>public class XxxService {
</span><span class='line'>    public int outerMethod(List&lt;Tag&gt; tagList) {
</span><span class='line'>        return innerMethod(tagList);
</span><span class='line'>    }
</span><span class='line'>}&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//被当前类的其他方法调用的内部方法
</span><span class='line'>@Param(operate = MyProcessor.SPECIFIC_PROCESSOR_KEY, params = {
</span><span class='line'>        CrateConstants.KEYS_KEY + &ldquo;={#p0.![propertyName]}&rdquo;})
</span><span class='line'>private int innerMethod(List&lt;Tag&gt; tagList) {
</span><span class='line'>    if (CollectionUtils.isEmpty(tagList)) {
</span><span class='line'>        return 0;
</span><span class='line'>    }&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;return tagDao.insertBatchly(tagList);
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;}</span></code></pre></td></tr></table></div></figure></p>

<h3>2.2 inner public方法无效</h3>

<p>定义如下:
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//供外部调用的方法
</span><span class='line'>public class XxxService {
</span><span class='line'>    public int outerMethod(List&lt;Tag&gt; tagList) {
</span><span class='line'>        return innerMethod(tagList);
</span><span class='line'>    }
</span><span class='line'>}&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//被当前类的其他方法调用的内部方法
</span><span class='line'>@Param(operate = MyProcessor.SPECIFIC_PROCESSOR_KEY, params = {
</span><span class='line'>        CrateConstants.KEYS_KEY + &ldquo;={#p0.![propertyName]}&rdquo;})
</span><span class='line'>public int innerMethod(List&lt;Tag&gt; tagList) {
</span><span class='line'>    if (CollectionUtils.isEmpty(tagList)) {
</span><span class='line'>        return 0;
</span><span class='line'>    }&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;return tagDao.insertBatchly(tagList);
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;}
</span><span class='line'>&lt;code&gt;
</span><span class='line'>调用的时候调用
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>xxxServiceIns.outerMethod(&hellip;);</span></code></pre></td></tr></table></div></figure></p>

<h1>3.原因</h1>

<h3>3.1 private和protected方法无效</h3>

<p>Spring的AOP框架基于代理实现的(proxy-based).使用原生的Java的代理是无法代理protected和private类型的方法(详见后续结束).</p>

<p>而CGLIB的代理虽然在技术上可以代理protected和private类型的方法,但是用于AOP的时候不推荐代理protected和private类型的方法.</p>

<p>结论就是,任何定义的pointcut只在public方法上有效.</p>

<p>参考:</p>

<p><a href="http://stackoverflow.com/questions/15093894/aspectj-pointcut-for-annotated-private-methods">http://stackoverflow.com/questions/15093894/aspectj-pointcut-for-annotated-private-methods</a></p>

<p>spring官方文档关于AOP的解释中也有相关的说明:</p>

<p><a href="http://docs.spring.io/spring/docs/3.1.x/spring-framework-reference/html/aop.html#aop-introduction-spring-defn">http://docs.spring.io/spring/docs/3.1.x/spring-framework-reference/html/aop.html#aop-introduction-spring-defn</a></p>

<h3>3.2 inner public方法无效</h3>

<p>原因其实就是一句话:Spring AOP是基于代理机制的.</p>

<p>考虑如下场景,当你拿到一个无代理的、无任何特殊之处的对象引用时:
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class SimplePojo implements SimpleInterface {
</span><span class='line'>    public void foo() {
</span><span class='line'>       // this next method invocation is a direct call on the &lsquo;this&rsquo; reference
</span><span class='line'>       this.bar();
</span><span class='line'>    }&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;public void bar() {
</span><span class='line'>    // some logic...
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;}
</span><span class='line'>&lt;code&gt;
</span><span class='line'>当你调用一个对象引用的方法时,此对象引用上的方法直接被调用,如下所示:
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>public static void main(String[] args) {
</span><span class='line'>   SimplePojo ins = new SimplePojo();
</span><span class='line'>   // this is a direct method call on the &lsquo;ins&rsquo; reference
</span><span class='line'>   ins.foo();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>
<img src="/images/sping/call_native.png"></p>

<p>当客户代码所持有的引用是一个代理的时候则略有不同了,当调用foo()方法时候,首先会调用原始foo()方法上的@Before的代码逻辑,然后调用原始的foo()方法,原始foo()方法内的bar()调用的是原始对象的this.bar(),即一旦调用最终抵达了目标对象 (此处为SimplePojo类的引用),任何对自身的调用例如this.bar()将对this引用进行调用而非代理。</p>

<p>这一点意义重大,它意味着自我调用将不会导致和方法调用关联的AOP通知得到执行的机会。
<code>
SimplePojo proxy = proxyFactory.getProxy(Pojo.class);
proxy.foo();
</code>
<img src="/images/sping/call_proxy.png"></p>

<p>参考:
<a href="http://m.oschina.net/blog/161387">http://m.oschina.net/blog/161387</a></p>

<h1>4.Spring AOP代理</h1>

<p>Spring AOP使用JDK动态代理或者CGLIB来为目标对象创建代理。</p>

<p>如果被代理的目标对象实现了至少一个接口,则会使用JDK动态代理。所有该目标类型实现的接口都将被代理。 若该目标对象没有实现任何接口,则创建一个CGLIB代理。</p>

<p>如果你希望强制使用CGLIB代理,(例如：希望代理目标对象的所有方法,而不只是实现自接口的方法) 那也可以。但是需要考虑以下问题:</p>

<pre><code>1.无法通知(advise)final方法,因为他们不能被覆写。
2.代理对象的构造器会被调用两次。因为在CGLIB代理模式下每一个代理对象都会 产生一个子类。每一个代理实例会生成两个对象：实际代理对象和它的一个实现了通知的子类实例 而是用JDK代理时不会出现这样的行为。通常情况下,调用代理类型的构造器两次并不是问题, 因为除了会发生指派外没有任何真正的逻辑被实现。
3.CGLib的效率没有使用JDK代理机制高,速度平均要慢8倍左右。
</code></pre>

<p>强制使用CGLIB代理需要将&lt;aop:config>的proxy-target-class属性设为true:
<code>
&lt;aop:config proxy-target-class="true"&gt;
   ...
&lt;/aop:config&gt;
</code></p>

<p>当使用@AspectJ自动代理时要强制使用CGLIB,请将&lt;aop:aspectj-autoproxy>的proxy-target-class属性设置为true:
<code>
&lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt;
</code></p>
]]></content>
  </entry>
  
</feed>
