<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Linux | xiaobaoqiu Blog]]></title>
  <link href="http://xiaobaoqiu.github.io/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://xiaobaoqiu.github.io/"/>
  <updated>2015-08-01T19:07:47+08:00</updated>
  <id>http://xiaobaoqiu.github.io/</id>
  <author>
    <name><![CDATA[xiaobaoqiu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[系统当前用户]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/07/16/xi-tong-dang-qian-yong-hu/"/>
    <updated>2015-07-16T04:25:57+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/07/16/xi-tong-dang-qian-yong-hu</id>
    <content type="html"><![CDATA[<p>经常需要查看当前服务器哪些用户在登录,以及他们都在干什么.</p>

<p>下面总结一些命令,其中last应该是最常用的命令.</p>

<h1>1.w</h1>

<p>w - Show who is logged on and what they are doing.</p>

<p>主要字段:</p>

<pre><code>LOGIN@: 什么时间登录的
PCPU: 当前进程所用时间
WHAT: 用户当前正在使用的命令
</code></pre>

<pre><code>xiaobaoqiu@xiaobaoqiu:~/octopress$ w
 20:32:42 up  9:59, 15 users,  load average: 1.80, 1.26, 1.17
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
xiaobaoq tty7     :0               10:34    9:58m 22:26   0.48s init --user
xiaobaoq pts/1    :0               10:35    2:22m  0.12s  0.12s /bin/bash
xiaobaoq pts/2    :0               11:12   44:10   0.26s  0.19s ssh cn6
xiaobaoq pts/7    :0               11:12    9:02m  0.15s  0.09s ssh cn6
xiaobaoq pts/8    :0               11:28    5:56m  0.09s  0.03s ssh cn5
xiaobaoq pts/12   :0               13:09    3:03m  0.30s  0.24s ssh cn0
xiaobaoq pts/13   :0               13:09    3:14m  0.13s  0.07s mysql -h...
xiaobaoq pts/14   :0               13:09    3:00m  1.23s  1.17s ssh cn0
xiaobaoq pts/18   :0               13:09    3:03m  3.42s  3.35s ssh cn0
xiaobaoq pts/20   :0               13:14    3:01m  0.45s  0.39s mysql -h...
xiaobaoq pts/22   :0               13:26    7:01m  0.13s  0.07s ssh cn0
xiaobaoq pts/23   :0               14:02   40:34   0.17s  0.17s /bin/bash
xiaobaoq pts/24   :0               14:03    2.00s  0.23s  0.00s w
xiaobaoq pts/25   :0               14:36    2:02   0.24s  0.18s ssh cn5
xiaobaoq pts/26   :0               17:41    2:47m  0.09s  0.09s /bin/bash
</code></pre>

<h1>2.who</h1>

<p>who - show who is logged on
<code>
xiaobaoqiu@xiaobaoqiu:~/octopress$ who
xiaobaoqiu tty7         2015-07-15 10:34 (:0)
xiaobaoqiu pts/1        2015-07-15 10:35 (:0)
xiaobaoqiu pts/2        2015-07-15 11:12 (:0)
xiaobaoqiu pts/7        2015-07-15 11:12 (:0)
xiaobaoqiu pts/8        2015-07-15 11:28 (:0)
xiaobaoqiu pts/12       2015-07-15 13:09 (:0)
xiaobaoqiu pts/13       2015-07-15 13:09 (:0)
xiaobaoqiu pts/14       2015-07-15 13:09 (:0)
xiaobaoqiu pts/18       2015-07-15 13:09 (:0)
xiaobaoqiu pts/20       2015-07-15 13:14 (:0)
xiaobaoqiu pts/22       2015-07-15 13:26 (:0)
xiaobaoqiu pts/23       2015-07-15 14:02 (:0)
xiaobaoqiu pts/24       2015-07-15 14:03 (:0)
xiaobaoqiu pts/25       2015-07-15 14:36 (:0)
xiaobaoqiu pts/26       2015-07-15 17:41 (:0)
</code></p>

<h1>3.users</h1>

<p>users - print the user names of users currently logged in to the current host
<code>
xiaobaoqiu@xiaobaoqiu:~/octopress$ users
xiaobaoqiu xiaobaoqiu xiaobaoqiu xiaobaoqiu xiaobaoqiu xiaobaoqiu xiaobaoqiu xiaobaoqiu xiaobaoqiu xiaobaoqiu xiaobaoqiu xiaobaoqiu xiaobaoqiu xiaobaoqiu xiaobaoqiu
</code></p>

<h1>4.whoami</h1>

<p>whoami - print effective userid
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xiaobaoqiu@xiaobaoqiu:~/octopress$ whoami
</span><span class='line'>xiaobaoqiu&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;xiaobaoqiu@xiaobaoqiu:~/octopress$ who am i
</span><span class='line'>xiaobaoqiu pts/24       2015-07-15 14:03 (:0)&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;xiaobaoqiu@xiaobaoqiu:~/octopress$ who mom likes
</span><span class='line'>xiaobaoqiu pts/24       2015-07-15 14:03 (:0)</span></code></pre></td></tr></table></div></figure></p>

<h1>5.id</h1>

<p>id - print real and effective user and group IDs
<code>
xiaobaoqiu@xiaobaoqiu:~/octopress$ id
uid=1000(xiaobaoqiu) gid=1000(xiaobaoqiu) 组=1000(xiaobaoqiu),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),108(lpadmin),124(sambashare)
</code></p>

<h1>6.last</h1>

<p>last, lastb - show listing of last logged in users
<code>
xiaobaoqiu@xiaobaoqiu:~/octopress$ last
xiaobaoq pts/26       :0               Wed Jul 15 17:41   still logged in   
xiaobaoq pts/25       :0               Wed Jul 15 14:36   still logged in   
xiaobaoq pts/24       :0               Wed Jul 15 14:03   still logged in   
xiaobaoq pts/23       :0               Wed Jul 15 14:02   still logged in   
xiaobaoq pts/22       :0               Wed Jul 15 13:26   still logged in   
xiaobaoq pts/20       :0               Wed Jul 15 13:14   still logged in   
xiaobaoq pts/20       :0               Wed Jul 15 13:14 - 13:14  (00:00)    
xiaobaoq pts/18       :0               Wed Jul 15 13:09   still logged in   
xiaobaoq pts/14       :0               Wed Jul 15 13:09   still logged in   
xiaobaoq pts/13       :0               Wed Jul 15 13:09   still logged in   
xiaobaoq pts/12       :0               Wed Jul 15 13:09   still logged in   
xiaobaoq pts/8        :0               Wed Jul 15 11:28   still logged in   
xiaobaoq pts/7        :0               Wed Jul 15 11:12   still logged in   
xiaobaoq pts/2        :0               Wed Jul 15 11:12   still logged in   
xiaobaoq pts/1        :0               Wed Jul 15 10:35   still logged in
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux进制转换]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/07/07/linuxjin-zhi-zhuan-huan/"/>
    <updated>2015-07-07T03:27:54+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/07/07/linuxjin-zhi-zhuan-huan</id>
    <content type="html"><![CDATA[<p>经常涉及到进制的转换,比如线上处理问题时候经常需要转换线程id到16进制.</p>

<h1>1.进制转换</h1>

<h3>2.1.shell运算</h3>

<p> Shell 运算把一个数字从给定的进制转换位十进制.如果数字以运算展开式的形式提供,那么假定它带有十进制符号,除非 它前面带有 0（这种情况假定是八进制）或 0x（这种情况假定是十六进制）</p>

<pre><code>xiaobaoqiu@xiaobaoqiu:~/myshell$ echo $((010))
8
xiaobaoqiu@xiaobaoqiu:~/myshell$ echo $((0x10))
16
</code></pre>

<p>也可以指定 2 到 64 之间的任意进制,超过64进制则不支持.格式如下:</p>

<pre><code>$((BASE#NUMBER))
</code></pre>

<p>使用举例如下:</p>

<pre><code>xiaobaoqiu@xiaobaoqiu:~/myshell$ echo $((2#10))
2
xiaobaoqiu@xiaobaoqiu:~/myshell$ echo $((5#10))
5
xiaobaoqiu@xiaobaoqiu:~/myshell$ echo $((8#10))
8
xiaobaoqiu@xiaobaoqiu:~/myshell$ echo $((10#10))
10
xiaobaoqiu@xiaobaoqiu:~/myshell$ echo $((16#10))
16
xiaobaoqiu@xiaobaoqiu:~/myshell$ echo $((64#10))
64
xiaobaoqiu@xiaobaoqiu:~/myshell$ echo $((100#10))
bash: 100#10: 无效的算数进制 （错误符号是 "100#10"）
</code></pre>

<h3>2.2.bc</h3>

<p>bc是一种任意精度运算语言,大多数 UNIX/Linux 安装程序都提供.因为它允许您指定输出进制,所以当您需要以十进制以外的进制输出时,这是一种很好的技术.</p>

<p>bc 的特殊变量 ibase 和 obase 分别包含用于输入和输出的进制的值.缺省情况下,都被设置为 10.要执行进制转换,需要改变其中的一个或两个值,然后提供一个数字.</p>

<pre><code>xiaobaoqiu@xiaobaoqiu:~/myshell$ echo 'obase=16; 10' | bc
A
xiaobaoqiu@xiaobaoqiu:~/myshell$ echo 'obase=16; ibase=10; 10' | bc
A
xiaobaoqiu@xiaobaoqiu:~/myshell$ echo 'obase=10; ibase=16; 10' | bc
16
</code></pre>

<h3>2.3.printf</h3>

<p>格式化参数和C语言的格式一致:</p>

<pre><code>xiaobaoqiu@xiaobaoqiu:~/myshell$ printf "%X\n" 100
64
xiaobaoqiu@xiaobaoqiu:~/myshell$ printf "%d\n" 0x10
16
</code></pre>

<h1>2.自定义shell</h1>

<p>自己写一个shell,处理多个输入,任意进制到任意进制的转换.通过这个脚本,学习了一下shell处理option的方式.</p>

<p>原理很简单,就是利用上面说道的bc命令.shell脚本如下:</p>

<pre><code>#!/bin/bash
while getopts :i:o: opt 
do
        case "$opt" in
        i) #输入的参数的进制
           #echo "Found the -i option,with vale $OPTARG"
           ibase=$OPTARG
           ;;
        o) #输出参数进制
           #echo "Found the -o option,with vale $OPTARG"
           obase=$OPTARG
           ;;
        *) #当有不认识的选项的时候arg为?
           echo "unkonw argument, Usage : "
           echo "$1 -i 10 -o 16 1 2 3 4 5 6 ..."
           exit 1
        esac
done

#跳过opt参数
shift $[$OPTIND - 1]

#参数检验
if [ ! $ibase ]; then
    echo "Usage : $0 -i 10 -o 16 1 2 3 4 5 6 ..."
    exit 1
fi

if [ ! $obase ]; then
    echo "Usage : $0 -i 10 -o 16 1 2 3 4 5 6 ..."
    exit 1
fi

echo "输入进制:$ibase"
echo "输出进制:$obase"

#执行进制转换
for i in $@
do
    echo "obase=$obase; ibase=$ibase; $i" |bc
done
</code></pre>

<h3>1.bc</h3>

<h3>2.bc</h3>

<p>简单使用如下:</p>

<pre><code>xiaobaoqiu@xiaobaoqiu:~/myshell$ ./trans -i 10 -o 16 100
输入进制:10
输出进制:16
64
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux文件编码]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/06/30/linuxwen-jian-ge-shi/"/>
    <updated>2015-06-30T03:07:46+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/06/30/linuxwen-jian-ge-shi</id>
    <content type="html"><![CDATA[<p>在多系统直接传输文件经常碰到文件编码的问题.</p>

<h1>1.查看编码</h1>

<p>查看文件的编码有很多种方式</p>

<h3>1.1 file</h3>

<p>file命令输出了文件的格式和编码.</p>

<pre><code>xiaobaoqiu@xiaobaoqiu:~/octopress$ file _config.yml
_config.yml: UTF-8 Unicode text
</code></pre>

<h3>1.2 vi</h3>

<p>vi打开文件之后,输入:set fileencoding就可以获得文件编码:</p>

<pre><code>fileencoding=utf-8
</code></pre>

<h1>2.转换编码</h1>

<h3>2.1 vi</h3>

<p>使用vi也可以变更文件编码</p>

<pre><code>:set fileencoding=utf8
</code></pre>

<h3>2.2 iconv</h3>

<p>使用iconv命令,iconv几个主要参数(man):</p>

<pre><code>输入/输出格式规范：
-f, --from-code=名称 原始文本编码
-t, --to-code=名称 输出编码

信息：
-l, --list 列举所有已知的字符集

输出控制：
-c 从输出中忽略无效的字符
-o, --output=FILE 输出到文件
-s, --silent 关闭警告
--verbose 打印进度信息
</code></pre>

<p>使用例子,文件infile从GB18030编码转换至UTF-8编码并写入到文件outfile中:</p>

<pre><code>xiaobaoqiu@xiaobaoqiu:~/temp$ cat infile 
���
xiaobaoqiu@xiaobaoqiu:~/temp$ iconv -f GB18030 -t utf-8 infile -o outfile
xiaobaoqiu@xiaobaoqiu:~/temp$ cat outfile 
测试
</code></pre>

<p>也可以从管道输入,比如直接访问www.google.com.hk,不出意外会是乱码(使用的big5中文编码),可以转换成utf8</p>

<pre><code>xiaobaoqiu@xiaobaoqiu:~/temp$ curl -l 'www.google.com.hk' | iconv -f big5 -t gbk
</code></pre>

<p>iconv基于GPL公开源代码,是GNU项目的一部分.目前，libiconv已经包含在C运行时刻库libc.so中。因此，Linux平台上使用iconv库函数的程序，需要包含&lt;iconv.h>文件.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux Swap]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/06/23/linux-swap/"/>
    <updated>2015-06-23T19:35:55+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/06/23/linux-swap</id>
    <content type="html"><![CDATA[<p>最近一台机器出现swap报警,从监控图上也看到swap的使用一直存在.</p>

<p>服务器上只有一个Tomcat应用和一些定时任务.</p>

<h1>1.什么是swap</h1>

<p>inux操作系统将物理内存分为多个小的内存块，称之为页(pages). 当应用请求的物理内存不够分配时，操作系统会将一段时间之内不用的内存页交换至swap分区，从而为应用释放内存空间。</p>

<p>Swap对于系统过来说非常重要：</p>

<pre><code>1.首先，当主内存不够用时，操作系统可以swap out一部分内存页，迅速为当前急需内存的应用或者进程分配内存；
2.其次，某些内存页只在应用初始化阶段用到，之后可能就不再使用了，操作系统可以将这些内存页swap out，从而为应用或者磁盘cache腾出更多的内存空间;
</code></pre>

<h1>2.swap会带来哪些问题</h1>

<p>我们知道，计算机磁盘I/O通常是系统的瓶颈所在。主内存的读写速度是纳秒级别，而磁盘读写速度是毫秒级别，两者相差3、4个数量级。然而，即使是当前广泛使用的SSD，读写速度相比主内存或者CPU cache也相差2、3个数量级。系统发生swap交换越多，那么系统自然也越慢。</p>

<p>特别对于web服务器来说，都是面对用户的交互式应用，因此响应速度尤其重要。如果系统经常因为swap交换而变得响应迟钝，那么用户体验效果可想而知。</p>

<p>总结成一句话：swap分区要有，在关键时刻不至于让你的应用因为内存不够用而被操作系统OOM KILLER干掉；但是不到关键时刻不要进行swap交换，因为这些操作会影响系统的响应速度。</p>

<p>关于swap的swap in和swap out可以从vmstat命令查看(si表示swap in, so表示swap out).参考:
<a href="http://xiaobaoqiu.github.io/blog/2015/01/26/vmstatgong-ju/">http://xiaobaoqiu.github.io/blog/2015/01/26/vmstatgong-ju/</a></p>

<h1>3.查看swap占用</h1>

<p>free命令, 参考:
<a href="http://xiaobaoqiu.github.io/blog/2014/09/04/linux-memory-usage/">http://xiaobaoqiu.github.io/blog/2014/09/04/linux-memory-usage/</a></p>

<h1>4.找到swap占用元凶</h1>

<p>Linux系统中有一个文件smaps文件，记录了当前进程所对应的内存映像信息，路径为/proc/$pid/smaps.以本机的一个线程为例子:</p>

<pre><code>xiaobaoqiu@xiaobaoqiu:~/octopress$ sudo cat /proc/3555/smaps | head -16
00400000-00401000 r-xp 00000000 08:13 3444936                            /usr/local/jdk1.7.0_72/bin/java
Size:                  4 kB
Rss:                   4 kB
Pss:                   4 kB
Shared_Clean:          0 kB
Shared_Dirty:          0 kB
Private_Clean:         4 kB
Private_Dirty:         0 kB
Referenced:            4 kB
Anonymous:             0 kB
AnonHugePages:         0 kB
Swap:                  0 kB
KernelPageSize:        4 kB
MMUPageSize:           4 kB
Locked:                0 kB
VmFlags: rd ex mr mw me dw
</code></pre>

<p>其中Swap表示这个线程占有Swap的情况.</p>

<p>查看swap的占有情况的脚本,按照占用swap的占用多少从高到底排序:</p>

<pre><code>#!/bin/bash

function getswap {
SUM=0
OVERALL=0
for DIR in `find /proc/ -maxdepth 1 -type d | egrep "^/proc/[0-9]"` ; do
PID=`echo $DIR | cut -d / -f 3`
PROGNAME=`ps -p $PID -o comm --no-headers`
for SWAP in `grep Swap $DIR/smaps 2&gt;/dev/null| awk '{ print $2 }'`
do
let SUM=$SUM+$SWAP
done
echo "PID=$PID    Swap used(KB): $SUM    ($PROGNAME )"
let OVERALL=$OVERALL+$SUM
SUM=0

done
echo "Overall swap used: $OVERALL"
}

getswap|sort -k4nr
</code></pre>

<p>然后运行:</p>

<pre><code>sudo ~/check_swap.sh
</code></pre>

<h1>5.清除被占用的swap</h1>

<p>在我们明确知道哪些进程吃swap以后，接下来的问题就是我们如何释放这些swap，释放swap的意思就是把交换到swap中的数据swap in到物理内存页中。</p>

<pre><code>1.重启吃swap的服务，比如重启一下我们的java进程;
2.swapoff + swapon
这个方法的好处是，不用重启服务，但是需要确保现在有足够的物理内存可以容下从swap中释放出来的数据。下面给出了swapoff和swapon的具体做法，注意看swapoff后和swapon后，free的输出有什么异同;

sudo /sbin/swapoff -a
sudo /sbin/swapon -a

swapoff后，free的输出里，swap分区的大小变为0，占用变为0,也就是说swap分区中的数据已经释放到物理内存中，同时swap分区被禁用。swapon后，free的输出里，swap分区的容量又恢复了
，也就是说swap分区重新被启用了。当然我们可以把这两个命令写到一起：

sudo /sbin/swapoff -a &amp;&amp; sudo /sbin/swapon -a
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[虚拟IP和IP漂移]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/04/02/xu-ni-iphe-ippiao-yi/"/>
    <updated>2015-04-02T22:39:14+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/04/02/xu-ni-iphe-ippiao-yi</id>
    <content type="html"><![CDATA[<p>学习一下虚拟IP和IP漂移的概念。</p>

<h1>1.虚拟IP</h1>

<p>在 TCP/IP 的架构下，所有想上网的电脑，不论是用何种方式连上网路，都必须要有一个唯一的 IP-address。事实上IP地址是主机硬件地址的一种抽象，简单的说，MAC地址是物理地址，IP地址是逻辑地址。</p>

<p>虚拟IP，就是一个未分配给真实主机的IP，也就是说对外提供服务器的主机除了有一个真实IP外还有一个虚IP，使用这两个IP中的任意一个都可以连接到这台主机。</p>

<p>虚拟IP一般用作达到HA(High Availability)的目的,比如让所有项目中数据库链接一项配置的都是这个虚IP，当主服务器发生故障无法对外提供服务时，动态将这个虚IP切换到备用服务器。</p>

<h1>2.虚拟IP原理</h1>

<p>ARP是地址解析协议，它的作用很简单，将一个IP地址转换为MAC地址，然后给传输层使用。</p>

<p>每台主机中都有一个ARP高速缓存，存储同一个网络内的IP地址与MAC地址的对应关 系，以太网中的主机发送数据时会先从这个缓存中查询目标IP对应的MAC地址，会向这个MAC地址发送数据。操作系统会自动维护这个缓存。</p>

<p>在Linux下可以使用arp命令操作ARP高速缓存。</p>

<p>比如存在物理机A(IP是192.168.192.54 )和物理机器B(IP是192.168.192.40)，A作为对外服务的主服务器(比如数据库主库)，B作为备份机器，两台服务器之间的通信是通过Heartbeat，即主服务器会定时的给备份服务器发送数据包，告知主服务器服务正常，当备份服务器在规定时间内没有收到主服务器的Heartbeat，就会认为主服务器宕机，则备份服务器就会升级为主服务器。假设物理机A的ARP缓存如下：
<code>
地址                     类型    硬件地址            标志  Mask            接口
192.168.192.54           ether   ec:f4:bb:49:xx:xx   C                     eth0
192.168.192.237          ether   ec:f4:bb:49:xx:xx   C                     eth0
192.168.192.40           ether   28:e3:47:c0:xx:xx   C                     eth0
...
</code></p>

<p>另外物理机器B(IP是192.168.192.40)的ARP缓存如下：
<code>
地址                     类型    硬件地址            标志  Mask            接口
192.168.192.54           ether   ec:f4:bb:49:xx:xx   C                     eth0
192.168.192.237          ether   ec:f4:bb:49:xx:xx   C                     eth0
192.168.192.40           ether   ec:f4:bb:49:xx:xx   C                     eth0
...
</code></p>

<p>当机器B通过BeatHeart得知机器A对外服务质量低于预期的时候(比如发生故障，服务无响应)，会将自己的ARP缓存发送出去，让路由器修改路由表，告知虚拟地址应该指向我(物理机器B,192.168.192.40),这时候，外界再次访问虚拟IP的时候，机器B会变成主服务器，而A降级为备份服务器。这就完成了主从机器的自动切换，这一切对外界是透明的。</p>

<h1>3.IP漂移</h1>

<p>上面的VIP自动切换的过程就称之为IP漂移。</p>

<p>我们可以通过Keepalived来实现这个过程。 Keepalived是一个基于VRRP协议(Virtual Router Redundancy Protocol,即虚拟路由冗余协议)来实现的LVS(负载均衡器)服务高可用方案，可以利用其来避免单点故障。一个LVS服务会有2台服务器运行Keepalived，一台为主服务器（MASTER），一台为备份服务器（BACKUP），但是对外表现为一个虚拟IP，主服务器会发送特定的消息给备份服务器，当备份服务器收不到这个消息的时候，即主服务器宕机的时候， 备份服务器就会接管虚拟IP，继续提供服务，从而保证了高可用性。</p>
]]></content>
  </entry>
  
</feed>
