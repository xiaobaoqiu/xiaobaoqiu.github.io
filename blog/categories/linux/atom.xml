<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Linux | xiaobaoqiu Blog]]></title>
  <link href="http://xiaobaoqiu.github.io/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://xiaobaoqiu.github.io/"/>
  <updated>2015-08-22T13:37:32+08:00</updated>
  <id>http://xiaobaoqiu.github.io/</id>
  <author>
    <name><![CDATA[xiaobaoqiu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Oomkiller]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/08/08/oomkiller/"/>
    <updated>2015-08-08T12:33:53+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/08/08/oomkiller</id>
    <content type="html"><![CDATA[<p>最近dev环境的Tomcat服务,还有dev环境的crate服务老是出现问题,现象就是Tomcat应用自己停了.导致测试中老是感觉莫名其妙.跟了一下原因,发现背后就是著名的oom-killer.</p>

<p>其实出现这个问题早就预料到了,8G内存的虚拟机器上面跑了接近20个Tomcat应用,每个Tomcat至少要求了0.5G的内存,很多要求的是默认的2G的内存.</p>

<p>这里主要简单介绍一下oomkiller是什么东西,原理是什么,以及对我们的影响.</p>

<h1>1.oomkiller简介</h1>

<p>简单的说,Linux 内核有个机制叫OOM killer(Out-Of-Memory killer)，该机制会监控那些占用内存过大，尤其是瞬间很快消耗大量内存的进程(为什么后面会讲到)，为了防止内存耗尽而内核会把该进程杀掉,从而腾出内存留给系统用。</p>

<p>现象就是相关的日志文件(/var/log/messages)里面会看到下面类似的 Out of memory: Kill process 信息(日志里面把机器host去掉了),还包括一些如pid，process name，cpu mask，trace等信息:</p>

<pre><code>Aug  4 22:03:18  kernel: Out of memory: Kill process 21447 (java) score 81 or sacrifice child
Aug  4 22:03:18  kernel: Killed process 21447, UID 40001, (java) total-vm:4242176kB, anon-rss:711240kB, file-rss:1832kB
Aug  5 01:17:21  ntpd[1195]: synchronized to Xx.xx.xxx.xx, stratum 3
Aug  5 01:35:52  kernel: java invoked oom-killer: gfp_mask=0xd0, order=0, oom_adj=0, oom_score_adj=0
Aug  5 01:35:52  kernel: java cpuset=/ mems_allowed=0
Aug  5 01:35:52  kernel: Pid: 17391, comm: java Not tainted 2.6.32-358.23.2.el6.x86_64 #1
</code></pre>

<h1>2.oomkiller原理</h1>

<p>Linux 内核根据应用程序的要求分配内存，通常来说应用程序分配了内存但是并没有实际全部使用，为了提高性能，这部分没用的内存可以留作它用，这部分内存是属于每个进程的，内核直接回收利用的话比较麻烦，所以内核采用一种过度分配内存(over-commit memory)的办法来间接利用这部分 “空闲” 的内存，提高整体内存的使用效率。</p>

<p>所谓的过度分配内存,可以理解为"打白条",进程A告诉系统我需要2G内存,系统只会答应不会拒绝,因为系统认为任何一个进程不可能每时每刻都全部占用其申请的内存.所以实际上系统并没有给进程A完整的2G内存,而是需要使用的时候才临时分配.这就好像银行现金肯定远远小于所以储户的总值,因为银行认为不可能所以储户同一时间把所以的钱都取出来.</p>

<p>一般来说这样做没有问题，但当大多数应用程序都消耗完自己的内存的时候麻烦就来了，因为这些应用程序的内存需求加起来超出了物理内存(包括 swap)的容量，内核(OOM killer)必须杀掉一些进程才能腾出空间保障系统正常运行。</p>

<p>用银行的例子来讲可能更容易懂一些，部分储户取钱的时候银行不怕，银行有足够的存款应付，当全国所以的储户(或者绝大多数储户)都取钱而且每个人都想把自己钱取完的时候银行的麻烦就来了，银行实际上是没有这么多钱给大家取的。</p>

<h3>2.1 根据什么kill</h3>

<p>内核检测到系统内存不足,然后挑选并杀掉某个进程的过程可以参考内核源代码 linux/mm/oom_kill.c，当系统内存不足的时候，oom_kill被触发，然后选择一个进程杀掉，如何判断和选择一个进程呢，总不能随机选吧?系统会根据进程使用内存的情况给进程打分,选择进程kill的时候主要根据这个分数,打分的机制很朴素:最占用内存的进程。</p>

<p>每个进程的分数都由进程的oom_score记录:</p>

<pre><code>[baoqiu.xiao@Xxx ~]$cat /proc/26893/oom_score
76
[baoqiu.xiao@Xxx ~]$ cat /proc/14969/oom_score
82
</code></pre>

<p>另外一个重要的参数就是进程的oom_adj,表示该pid进程被oom killer杀掉的权重，介于 [-17,15]之间，越高的权重，意味着更可能被oom killer选中，-17表示禁止被kill掉。默认为0.</p>

<p>一些其他的细节:</p>

<pre><code>1.子进程会继承父进程的oom_adj;
2.OOM不适合于解决内存泄漏(Memory leak)的问题;
3.有时free查看还有充足的内存，但还是会触发OOM，是因为该进程可能占用了特殊的内存地址空间;
</code></pre>

<h3>2.2 如何关闭oomkiller</h3>

<p>有几种方法关闭oomkiller机制:</p>

<ul>
<li>1.调整oom_adj
将进程的oom_adj设置为17即禁止了该进程被kill.</li>
</ul>


<p>比如系统的ssh一般是禁止oom的:</p>

<pre><code>[baoqiu.xiao@ ~]$ ps aux | grep sshd
root      1208  0.0  0.0  64116   296 ?        Ss   May28   1:47 /usr/sbin/sshd
[baoqiu.xiao@ ~]$ cat /proc/1208/oom_adj 
-17
</code></pre>

<p>其他需要禁用,可以如下:</p>

<pre><code>pgrep -f "sshd" | while read PID; do echo -17 &gt; /proc/$PID/oom_adj;done
</code></pre>

<p>其实在oom-killer的日志中我们是可以看到未-17的一些应用:</p>

<pre><code>Aug  5 01:35:52 l-crm4.des.dev.cn0 kernel: [ pid ]   uid  tgid total_vm      rss cpu oom_adj oom_score_adj name
...
Aug  5 01:35:52 l-crm4.des.dev.cn0 kernel: [ 1187]     0  1187    16029       73   2     -17         -1000 sshd
...
</code></pre>

<ul>
<li><p>2.修改内核参数
sysctl 下有2个可配置选项：</p>

<p>  vm.panic_on_oom = 0                 #内存不够时内核是否直接panic,0表示开启
  vm.oom_kill_allocating_task = 1         #oom-killer是否选择当前正在申请内存的进程进行kill</p></li>
</ul>


<p>只要设置/etc/sysctl.conf文件中vm.panic_on_oom=1就表示关闭oom-killer(线上环境一般不推荐):</p>

<pre><code># sysctl -w vm.panic_on_oom=1
vm.panic_on_oom = 1   //1表示关闭，默认为0表示开启OOM
# sysctl -p
</code></pre>

<p>参考: <a href="http://lwn.net/Articles/317814/">http://lwn.net/Articles/317814/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[系统当前用户]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/07/16/xi-tong-dang-qian-yong-hu/"/>
    <updated>2015-07-16T04:25:57+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/07/16/xi-tong-dang-qian-yong-hu</id>
    <content type="html"><![CDATA[<p>经常需要查看当前服务器哪些用户在登录,以及他们都在干什么.</p>

<p>下面总结一些命令,其中last应该是最常用的命令.</p>

<h1>1.w</h1>

<p>w - Show who is logged on and what they are doing.</p>

<p>主要字段:</p>

<pre><code>LOGIN@: 什么时间登录的
PCPU: 当前进程所用时间
WHAT: 用户当前正在使用的命令
</code></pre>

<pre><code>xiaobaoqiu@xiaobaoqiu:~/octopress$ w
 20:32:42 up  9:59, 15 users,  load average: 1.80, 1.26, 1.17
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
xiaobaoq tty7     :0               10:34    9:58m 22:26   0.48s init --user
xiaobaoq pts/1    :0               10:35    2:22m  0.12s  0.12s /bin/bash
xiaobaoq pts/2    :0               11:12   44:10   0.26s  0.19s ssh cn6
xiaobaoq pts/7    :0               11:12    9:02m  0.15s  0.09s ssh cn6
xiaobaoq pts/8    :0               11:28    5:56m  0.09s  0.03s ssh cn5
xiaobaoq pts/12   :0               13:09    3:03m  0.30s  0.24s ssh cn0
xiaobaoq pts/13   :0               13:09    3:14m  0.13s  0.07s mysql -h...
xiaobaoq pts/14   :0               13:09    3:00m  1.23s  1.17s ssh cn0
xiaobaoq pts/18   :0               13:09    3:03m  3.42s  3.35s ssh cn0
xiaobaoq pts/20   :0               13:14    3:01m  0.45s  0.39s mysql -h...
xiaobaoq pts/22   :0               13:26    7:01m  0.13s  0.07s ssh cn0
xiaobaoq pts/23   :0               14:02   40:34   0.17s  0.17s /bin/bash
xiaobaoq pts/24   :0               14:03    2.00s  0.23s  0.00s w
xiaobaoq pts/25   :0               14:36    2:02   0.24s  0.18s ssh cn5
xiaobaoq pts/26   :0               17:41    2:47m  0.09s  0.09s /bin/bash
</code></pre>

<h1>2.who</h1>

<p>who - show who is logged on
<code>
xiaobaoqiu@xiaobaoqiu:~/octopress$ who
xiaobaoqiu tty7         2015-07-15 10:34 (:0)
xiaobaoqiu pts/1        2015-07-15 10:35 (:0)
xiaobaoqiu pts/2        2015-07-15 11:12 (:0)
xiaobaoqiu pts/7        2015-07-15 11:12 (:0)
xiaobaoqiu pts/8        2015-07-15 11:28 (:0)
xiaobaoqiu pts/12       2015-07-15 13:09 (:0)
xiaobaoqiu pts/13       2015-07-15 13:09 (:0)
xiaobaoqiu pts/14       2015-07-15 13:09 (:0)
xiaobaoqiu pts/18       2015-07-15 13:09 (:0)
xiaobaoqiu pts/20       2015-07-15 13:14 (:0)
xiaobaoqiu pts/22       2015-07-15 13:26 (:0)
xiaobaoqiu pts/23       2015-07-15 14:02 (:0)
xiaobaoqiu pts/24       2015-07-15 14:03 (:0)
xiaobaoqiu pts/25       2015-07-15 14:36 (:0)
xiaobaoqiu pts/26       2015-07-15 17:41 (:0)
</code></p>

<h1>3.users</h1>

<p>users - print the user names of users currently logged in to the current host
<code>
xiaobaoqiu@xiaobaoqiu:~/octopress$ users
xiaobaoqiu xiaobaoqiu xiaobaoqiu xiaobaoqiu xiaobaoqiu xiaobaoqiu xiaobaoqiu xiaobaoqiu xiaobaoqiu xiaobaoqiu xiaobaoqiu xiaobaoqiu xiaobaoqiu xiaobaoqiu xiaobaoqiu
</code></p>

<h1>4.whoami</h1>

<p>whoami - print effective userid
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xiaobaoqiu@xiaobaoqiu:~/octopress$ whoami
</span><span class='line'>xiaobaoqiu&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;xiaobaoqiu@xiaobaoqiu:~/octopress$ who am i
</span><span class='line'>xiaobaoqiu pts/24       2015-07-15 14:03 (:0)&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;xiaobaoqiu@xiaobaoqiu:~/octopress$ who mom likes
</span><span class='line'>xiaobaoqiu pts/24       2015-07-15 14:03 (:0)</span></code></pre></td></tr></table></div></figure></p>

<h1>5.id</h1>

<p>id - print real and effective user and group IDs
<code>
xiaobaoqiu@xiaobaoqiu:~/octopress$ id
uid=1000(xiaobaoqiu) gid=1000(xiaobaoqiu) 组=1000(xiaobaoqiu),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),108(lpadmin),124(sambashare)
</code></p>

<h1>6.last</h1>

<p>last, lastb - show listing of last logged in users
<code>
xiaobaoqiu@xiaobaoqiu:~/octopress$ last
xiaobaoq pts/26       :0               Wed Jul 15 17:41   still logged in   
xiaobaoq pts/25       :0               Wed Jul 15 14:36   still logged in   
xiaobaoq pts/24       :0               Wed Jul 15 14:03   still logged in   
xiaobaoq pts/23       :0               Wed Jul 15 14:02   still logged in   
xiaobaoq pts/22       :0               Wed Jul 15 13:26   still logged in   
xiaobaoq pts/20       :0               Wed Jul 15 13:14   still logged in   
xiaobaoq pts/20       :0               Wed Jul 15 13:14 - 13:14  (00:00)    
xiaobaoq pts/18       :0               Wed Jul 15 13:09   still logged in   
xiaobaoq pts/14       :0               Wed Jul 15 13:09   still logged in   
xiaobaoq pts/13       :0               Wed Jul 15 13:09   still logged in   
xiaobaoq pts/12       :0               Wed Jul 15 13:09   still logged in   
xiaobaoq pts/8        :0               Wed Jul 15 11:28   still logged in   
xiaobaoq pts/7        :0               Wed Jul 15 11:12   still logged in   
xiaobaoq pts/2        :0               Wed Jul 15 11:12   still logged in   
xiaobaoq pts/1        :0               Wed Jul 15 10:35   still logged in
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux进制转换]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/07/07/linuxjin-zhi-zhuan-huan/"/>
    <updated>2015-07-07T03:27:54+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/07/07/linuxjin-zhi-zhuan-huan</id>
    <content type="html"><![CDATA[<p>经常涉及到进制的转换,比如线上处理问题时候经常需要转换线程id到16进制.</p>

<h1>1.进制转换</h1>

<h3>2.1.shell运算</h3>

<p> Shell 运算把一个数字从给定的进制转换位十进制.如果数字以运算展开式的形式提供,那么假定它带有十进制符号,除非 它前面带有 0（这种情况假定是八进制）或 0x（这种情况假定是十六进制）</p>

<pre><code>xiaobaoqiu@xiaobaoqiu:~/myshell$ echo $((010))
8
xiaobaoqiu@xiaobaoqiu:~/myshell$ echo $((0x10))
16
</code></pre>

<p>也可以指定 2 到 64 之间的任意进制,超过64进制则不支持.格式如下:</p>

<pre><code>$((BASE#NUMBER))
</code></pre>

<p>使用举例如下:</p>

<pre><code>xiaobaoqiu@xiaobaoqiu:~/myshell$ echo $((2#10))
2
xiaobaoqiu@xiaobaoqiu:~/myshell$ echo $((5#10))
5
xiaobaoqiu@xiaobaoqiu:~/myshell$ echo $((8#10))
8
xiaobaoqiu@xiaobaoqiu:~/myshell$ echo $((10#10))
10
xiaobaoqiu@xiaobaoqiu:~/myshell$ echo $((16#10))
16
xiaobaoqiu@xiaobaoqiu:~/myshell$ echo $((64#10))
64
xiaobaoqiu@xiaobaoqiu:~/myshell$ echo $((100#10))
bash: 100#10: 无效的算数进制 （错误符号是 "100#10"）
</code></pre>

<h3>2.2.bc</h3>

<p>bc是一种任意精度运算语言,大多数 UNIX/Linux 安装程序都提供.因为它允许您指定输出进制,所以当您需要以十进制以外的进制输出时,这是一种很好的技术.</p>

<p>bc 的特殊变量 ibase 和 obase 分别包含用于输入和输出的进制的值.缺省情况下,都被设置为 10.要执行进制转换,需要改变其中的一个或两个值,然后提供一个数字.</p>

<pre><code>xiaobaoqiu@xiaobaoqiu:~/myshell$ echo 'obase=16; 10' | bc
A
xiaobaoqiu@xiaobaoqiu:~/myshell$ echo 'obase=16; ibase=10; 10' | bc
A
xiaobaoqiu@xiaobaoqiu:~/myshell$ echo 'obase=10; ibase=16; 10' | bc
16
</code></pre>

<h3>2.3.printf</h3>

<p>格式化参数和C语言的格式一致:</p>

<pre><code>xiaobaoqiu@xiaobaoqiu:~/myshell$ printf "%X\n" 100
64
xiaobaoqiu@xiaobaoqiu:~/myshell$ printf "%d\n" 0x10
16
</code></pre>

<h1>2.自定义shell</h1>

<p>自己写一个shell,处理多个输入,任意进制到任意进制的转换.通过这个脚本,学习了一下shell处理option的方式.</p>

<p>原理很简单,就是利用上面说道的bc命令.shell脚本如下:</p>

<pre><code>#!/bin/bash
while getopts :i:o: opt 
do
        case "$opt" in
        i) #输入的参数的进制
           #echo "Found the -i option,with vale $OPTARG"
           ibase=$OPTARG
           ;;
        o) #输出参数进制
           #echo "Found the -o option,with vale $OPTARG"
           obase=$OPTARG
           ;;
        *) #当有不认识的选项的时候arg为?
           echo "unkonw argument, Usage : "
           echo "$1 -i 10 -o 16 1 2 3 4 5 6 ..."
           exit 1
        esac
done

#跳过opt参数
shift $[$OPTIND - 1]

#参数检验
if [ ! $ibase ]; then
    echo "Usage : $0 -i 10 -o 16 1 2 3 4 5 6 ..."
    exit 1
fi

if [ ! $obase ]; then
    echo "Usage : $0 -i 10 -o 16 1 2 3 4 5 6 ..."
    exit 1
fi

echo "输入进制:$ibase"
echo "输出进制:$obase"

#执行进制转换
for i in $@
do
    echo "obase=$obase; ibase=$ibase; $i" |bc
done
</code></pre>

<h3>1.bc</h3>

<h3>2.bc</h3>

<p>简单使用如下:</p>

<pre><code>xiaobaoqiu@xiaobaoqiu:~/myshell$ ./trans -i 10 -o 16 100
输入进制:10
输出进制:16
64
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux文件编码]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/06/30/linuxwen-jian-ge-shi/"/>
    <updated>2015-06-30T03:07:46+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/06/30/linuxwen-jian-ge-shi</id>
    <content type="html"><![CDATA[<p>在多系统直接传输文件经常碰到文件编码的问题.</p>

<h1>1.查看编码</h1>

<p>查看文件的编码有很多种方式</p>

<h3>1.1 file</h3>

<p>file命令输出了文件的格式和编码.</p>

<pre><code>xiaobaoqiu@xiaobaoqiu:~/octopress$ file _config.yml
_config.yml: UTF-8 Unicode text
</code></pre>

<h3>1.2 vi</h3>

<p>vi打开文件之后,输入:set fileencoding就可以获得文件编码:</p>

<pre><code>fileencoding=utf-8
</code></pre>

<h1>2.转换编码</h1>

<h3>2.1 vi</h3>

<p>使用vi也可以变更文件编码</p>

<pre><code>:set fileencoding=utf8
</code></pre>

<h3>2.2 iconv</h3>

<p>使用iconv命令,iconv几个主要参数(man):</p>

<pre><code>输入/输出格式规范：
-f, --from-code=名称 原始文本编码
-t, --to-code=名称 输出编码

信息：
-l, --list 列举所有已知的字符集

输出控制：
-c 从输出中忽略无效的字符
-o, --output=FILE 输出到文件
-s, --silent 关闭警告
--verbose 打印进度信息
</code></pre>

<p>使用例子,文件infile从GB18030编码转换至UTF-8编码并写入到文件outfile中:</p>

<pre><code>xiaobaoqiu@xiaobaoqiu:~/temp$ cat infile 
���
xiaobaoqiu@xiaobaoqiu:~/temp$ iconv -f GB18030 -t utf-8 infile -o outfile
xiaobaoqiu@xiaobaoqiu:~/temp$ cat outfile 
测试
</code></pre>

<p>也可以从管道输入,比如直接访问www.google.com.hk,不出意外会是乱码(使用的big5中文编码),可以转换成utf8</p>

<pre><code>xiaobaoqiu@xiaobaoqiu:~/temp$ curl -l 'www.google.com.hk' | iconv -f big5 -t gbk
</code></pre>

<p>iconv基于GPL公开源代码,是GNU项目的一部分.目前，libiconv已经包含在C运行时刻库libc.so中。因此，Linux平台上使用iconv库函数的程序，需要包含&lt;iconv.h>文件.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux Swap]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/06/23/linux-swap/"/>
    <updated>2015-06-23T19:35:55+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/06/23/linux-swap</id>
    <content type="html"><![CDATA[<p>最近一台机器出现swap报警,从监控图上也看到swap的使用一直存在.</p>

<p>服务器上只有一个Tomcat应用和一些定时任务.</p>

<h1>1.什么是swap</h1>

<p>inux操作系统将物理内存分为多个小的内存块，称之为页(pages). 当应用请求的物理内存不够分配时，操作系统会将一段时间之内不用的内存页交换至swap分区，从而为应用释放内存空间。</p>

<p>Swap对于系统过来说非常重要：</p>

<pre><code>1.首先，当主内存不够用时，操作系统可以swap out一部分内存页，迅速为当前急需内存的应用或者进程分配内存；
2.其次，某些内存页只在应用初始化阶段用到，之后可能就不再使用了，操作系统可以将这些内存页swap out，从而为应用或者磁盘cache腾出更多的内存空间;
</code></pre>

<h1>2.swap会带来哪些问题</h1>

<p>我们知道，计算机磁盘I/O通常是系统的瓶颈所在。主内存的读写速度是纳秒级别，而磁盘读写速度是毫秒级别，两者相差3、4个数量级。然而，即使是当前广泛使用的SSD，读写速度相比主内存或者CPU cache也相差2、3个数量级。系统发生swap交换越多，那么系统自然也越慢。</p>

<p>特别对于web服务器来说，都是面对用户的交互式应用，因此响应速度尤其重要。如果系统经常因为swap交换而变得响应迟钝，那么用户体验效果可想而知。</p>

<p>总结成一句话：swap分区要有，在关键时刻不至于让你的应用因为内存不够用而被操作系统OOM KILLER干掉；但是不到关键时刻不要进行swap交换，因为这些操作会影响系统的响应速度。</p>

<p>关于swap的swap in和swap out可以从vmstat命令查看(si表示swap in, so表示swap out).参考:
<a href="http://xiaobaoqiu.github.io/blog/2015/01/26/vmstatgong-ju/">http://xiaobaoqiu.github.io/blog/2015/01/26/vmstatgong-ju/</a></p>

<h1>3.查看swap占用</h1>

<p>free命令, 参考:
<a href="http://xiaobaoqiu.github.io/blog/2014/09/04/linux-memory-usage/">http://xiaobaoqiu.github.io/blog/2014/09/04/linux-memory-usage/</a></p>

<h1>4.找到swap占用元凶</h1>

<p>Linux系统中有一个文件smaps文件，记录了当前进程所对应的内存映像信息，路径为/proc/$pid/smaps.以本机的一个线程为例子:</p>

<pre><code>xiaobaoqiu@xiaobaoqiu:~/octopress$ sudo cat /proc/3555/smaps | head -16
00400000-00401000 r-xp 00000000 08:13 3444936                            /usr/local/jdk1.7.0_72/bin/java
Size:                  4 kB
Rss:                   4 kB
Pss:                   4 kB
Shared_Clean:          0 kB
Shared_Dirty:          0 kB
Private_Clean:         4 kB
Private_Dirty:         0 kB
Referenced:            4 kB
Anonymous:             0 kB
AnonHugePages:         0 kB
Swap:                  0 kB
KernelPageSize:        4 kB
MMUPageSize:           4 kB
Locked:                0 kB
VmFlags: rd ex mr mw me dw
</code></pre>

<p>其中Swap表示这个线程占有Swap的情况.</p>

<p>查看swap的占有情况的脚本,按照占用swap的占用多少从高到底排序:</p>

<pre><code>#!/bin/bash

function getswap {
SUM=0
OVERALL=0
for DIR in `find /proc/ -maxdepth 1 -type d | egrep "^/proc/[0-9]"` ; do
PID=`echo $DIR | cut -d / -f 3`
PROGNAME=`ps -p $PID -o comm --no-headers`
for SWAP in `grep Swap $DIR/smaps 2&gt;/dev/null| awk '{ print $2 }'`
do
let SUM=$SUM+$SWAP
done
echo "PID=$PID    Swap used(KB): $SUM    ($PROGNAME )"
let OVERALL=$OVERALL+$SUM
SUM=0

done
echo "Overall swap used: $OVERALL"
}

getswap|sort -k4nr
</code></pre>

<p>然后运行:</p>

<pre><code>sudo ~/check_swap.sh
</code></pre>

<h1>5.清除被占用的swap</h1>

<p>在我们明确知道哪些进程吃swap以后，接下来的问题就是我们如何释放这些swap，释放swap的意思就是把交换到swap中的数据swap in到物理内存页中。</p>

<pre><code>1.重启吃swap的服务，比如重启一下我们的java进程;
2.swapoff + swapon
这个方法的好处是，不用重启服务，但是需要确保现在有足够的物理内存可以容下从swap中释放出来的数据。下面给出了swapoff和swapon的具体做法，注意看swapoff后和swapon后，free的输出有什么异同;

sudo /sbin/swapoff -a
sudo /sbin/swapon -a

swapoff后，free的输出里，swap分区的大小变为0，占用变为0,也就是说swap分区中的数据已经释放到物理内存中，同时swap分区被禁用。swapon后，free的输出里，swap分区的容量又恢复了
，也就是说swap分区重新被启用了。当然我们可以把这两个命令写到一起：

sudo /sbin/swapoff -a &amp;&amp; sudo /sbin/swapon -a
</code></pre>
]]></content>
  </entry>
  
</feed>
