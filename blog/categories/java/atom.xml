<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | xiaobaoqiu Blog]]></title>
  <link href="http://xiaobaoqiu.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://xiaobaoqiu.github.io/"/>
  <updated>2015-08-08T14:42:02+08:00</updated>
  <id>http://xiaobaoqiu.github.io/</id>
  <author>
    <name><![CDATA[xiaobaoqiu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[反射的效率]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/08/03/fan-she-de-xiao-lu/"/>
    <updated>2015-08-03T20:54:57+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/08/03/fan-she-de-xiao-lu</id>
    <content type="html"><![CDATA[<h1>1.toString实现</h1>

<p>测试不同的toString实现方式的效率，目前包括的case：</p>

<pre><code>1.String的+连接生成；
2.StringBuilder生成；
3.StringBuffer生成；
4.Guava的ToStringHelper生成；
5.Apache.commons.lang3的lang3的ToStringBuilder生成;
6.Apache.commons.lang3的ReflectionToStringBuilder生成;
</code></pre>

<p>toString的对象包含各种类型的属性：</p>

<pre><code>    private int age;

    private String name;

    private String address;

    private List&lt;String&gt; phone;

    private BigDecimal salary;

    private Map&lt;String, Object&gt; attrs;
</code></pre>

<p>各个toString的实现版本，其中ReflectionToStringBuilder是我们项目中使用最多的，因为它最简单：</p>

<pre><code>    /**
     * 使用字符串+
     * @return
     */
    public String concatToString() {
        return "Person{" +
                "age=" + age +
                ", name='" + name + '\'' +
                ", address='" + address + '\'' +
                ", phone=" + phone +
                ", salary=" + salary +
                ", attrs=" + attrs +
                '}';
    }

    /**
     * 使用StringBuilder
     * @return
     */
    public String stringBuilderToString() {
        StringBuilder builder = new StringBuilder("Person{");
        builder.append("age=").append(age)
                .append(", name='").append(name).append("'")
                .append(", address='").append(address).append("'")
                .append(", phone=").append(phone)
                .append(", salary=").append(salary)
                .append(", attrs=").append(attrs)
                .append("}");
        return builder.toString();
    }

    /**
     * 使用StringBuffer
     * @return
     */
    public String stringBufferToString() {
        StringBuffer buffer = new StringBuffer("Person{");
        buffer.append("age=").append(age)
                .append(", name='").append(name).append("'")
                .append(", address='").append(address).append("'")
                .append(", phone=").append(phone)
                .append(", salary=").append(salary)
                .append(", attrs=").append(attrs)
                .append("}");
        return buffer.toString();
    }

    /**
     * Guava的Objects,即ToStringHelper
     * @return
     */
    public String toStringHelperToString() {
        return Objects.toStringHelper(this)
                .add("age", age)
                .add("name", name)
                .add("address", address)
                .add("phone", phone)
                .add("salary", salary)
                .add("attrs", attrs)
                .toString();
    }

    /**
     * apache.commons.lang3的ToStringBuilder
     * @return
     */
    public String toStringBuilderToString() {
        return new ToStringBuilder(this)
                .append("age", age)
                .append("name", name)
                .append("address", address)
                .append("phone", phone)
                .append("salary", salary)
                .append("attrs", attrs)
                .toString();
    }

    /**
     * apache.commons.lang3的ReflectionToStringBuilder
     * @return
     */
    public String reflectionToStringBuilderToString() {
        return ReflectionToStringBuilder.reflectionToString(this, ToStringStyle.SIMPLE_STYLE);
    }
</code></pre>

<p>OS是Ubuntu 14.04 LTS版本，Java版本是1.7.0_80。跑1000次，记录最大最小平均时间:</p>

<pre><code>Concat Min(微秒)=25.385
Concat Max(微秒)=2218.851
Concat Avg(微秒)=56.728432999999995

StringBuilder Min(微秒)=22.501
StringBuilder Max(微秒)=6934.066
StringBuilder Avg(微秒)=50.724183

StringBuffer Min(微秒)=29.553
StringBuffer Max(微秒)=3159.808
StringBuffer Avg(微秒)=64.113464

ToStringHelper Min(微秒)=44.893
ToStringHelper Max(微秒)=9503.836
ToStringHelper Avg(微秒)=112.351293

ToStringBuilder Min(微秒)=62.806
ToStringBuilder Max(微秒)=20228.186
ToStringBuilder Avg(微秒)=194.728656

ReflectionToStringBuilder Min(微秒)=37.057
ReflectionToStringBuilder Max(微秒)=11402.172
ReflectionToStringBuilder Avg(微秒)=219.219879
</code></pre>

<p>整理成表格，数据如下：</p>

<table>
<thead>
<tr>
<th style="text-align:center;">toString策略 </th>
<th style="text-align:center;"> 平均(微秒) </th>
<th style="text-align:center;"> 最大(微秒) </th>
<th style="text-align:center;"> 最小(微秒)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">Concat </td>
<td style="text-align:center;">56.728433  </td>
<td style="text-align:center;">2218.851 </td>
<td style="text-align:center;"> 25.385</td>
</tr>
<tr>
<td style="text-align:center;">StringBuilder </td>
<td style="text-align:center;">50.724183  </td>
<td style="text-align:center;">6934.066 </td>
<td style="text-align:center;"> 22.501</td>
</tr>
<tr>
<td style="text-align:center;">StringBuffer </td>
<td style="text-align:center;">64.113464  </td>
<td style="text-align:center;">3159.808 </td>
<td style="text-align:center;"> 29.553</td>
</tr>
<tr>
<td style="text-align:center;">ToStringHelper </td>
<td style="text-align:center;">112.351293  </td>
<td style="text-align:center;">9503.836 </td>
<td style="text-align:center;"> 44.893</td>
</tr>
<tr>
<td style="text-align:center;">ToStringBuilder </td>
<td style="text-align:center;">194.728656  </td>
<td style="text-align:center;">20228.186 </td>
<td style="text-align:center;"> 62.806</td>
</tr>
<tr>
<td style="text-align:center;">ReflectionToStringBuilder </td>
<td style="text-align:center;">219.219879  </td>
<td style="text-align:center;">11402.172 </td>
<td style="text-align:center;"> 37.057</td>
</tr>
</tbody>
</table>


<p>通过上面的数据，concat和StringBuilder及StringBuffer的速度差不多。其他集中语法糖普遍慢一些，我们最常用的ReflectionToStringBuilder实际上是最慢的一个版本。</p>

<h3>1.1 实现原理</h3>

<p>简单分析一下各个toString方式的实现原理。</p>

<ul>
<li>1.Concat</li>
</ul>


<p>没什么说的，使用的是字符串的拼接。</p>

<ul>
<li>2.StringBuilder</li>
</ul>


<p>内部使用char数组，每次append都会先检查数组空间释放足够，不够的话先申请一块临时数组，大小是原来的两倍大小，再用Arrays.copyOf将数据拷贝。</p>

<ul>
<li>3.StringBuffer</li>
</ul>


<p>和StringBuilder一样，也是继承自AbstractStringBuilder类，唯一区别是为了保证线程安全，变更数据的方法都加上了synchronized关键字。</p>

<ul>
<li>4.ToStringHelper</li>
</ul>


<p>Guava的ToStringHelper内部实现是一个简单链表，每个链表节点包含name，value以及下一个节点的指针。</p>

<pre><code>private static final class ValueHolder {
        String name;
        Object value;
        Objects.ToStringHelper.ValueHolder next;

        private ValueHolder() {
        }
}
</code></pre>

<p>ToStringHelper类持有链表头节点和尾节点。每次调用add都是在链表尾部加一个节点，toString() 的时候遍历整个链表讲内容加到一个StringBuilder中。</p>

<pre><code>public static final class ToStringHelper {
    private final String className;
    private Objects.ToStringHelper.ValueHolder holderHead;
    private Objects.ToStringHelper.ValueHolder holderTail;

    public Objects.ToStringHelper add(String name, long value) {
        return this.addHolder(name, String.valueOf(value));
    }

    private Objects.ToStringHelper addHolder(String name, @Nullable Object value) {
        Objects.ToStringHelper.ValueHolder valueHolder = this.addHolder();
        valueHolder.value = value;
        valueHolder.name = (String)Preconditions.checkNotNull(name);
        return this;
    }

    private Objects.ToStringHelper.ValueHolder addHolder() {
        Objects.ToStringHelper.ValueHolder valueHolder = new Objects.ToStringHelper.ValueHolder();
        this.holderTail = this.holderTail.next = valueHolder;
        return valueHolder;
    }
</code></pre>

<ul>
<li>5.ToStringBuilder</li>
</ul>


<p>ToStringBuilder内部使用一个StringBuffer，默认大小为512.另外一个style设定来toString的样式，每次执行append都跳转到对应的ToStringStyle的append函数实现上，并将当前的StringBuffer带过去(StringBuffer来存储数据，ToStringStyle来保证格式)：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class ToStringBuilder implements Builder&lt;String&gt; {
</span><span class='line'>    private static volatile ToStringStyle defaultStyle;
</span><span class='line'>    private final StringBuffer buffer;
</span><span class='line'>    private final Object object;
</span><span class='line'>    private final ToStringStyle style;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static {
</span><span class='line'>defaultStyle = ToStringStyle.DEFAULT_STYLE;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public ToStringBuilder append(String fieldName, int value) {
</span><span class='line'>    this.style.append(this.buffer, fieldName, value);
</span><span class='line'>    return this;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;ToStringStyle的append实现，每个append都很简单，就是往StringBuffer中append数据：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;public void append(StringBuffer buffer, String fieldName, int value) {
</span><span class='line'>    this.appendFieldStart(buffer, fieldName);
</span><span class='line'>    this.appendDetail(buffer, fieldName, value);
</span><span class='line'>    this.appendFieldEnd(buffer, fieldName);
</span><span class='line'>}&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;protected void appendDetail(StringBuffer buffer, String fieldName, int value) {
</span><span class='line'>    buffer.append(value);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure></p>

<ul>
<li>6.ReflectionToStringBuilder</li>
</ul>


<p>ReflectionToStringBuilder实际上是继承自ToStringBuilder，每次都构建一个ReflectionToStringBuilder对象，toString的实现是使用反射完成，首先反射当前类的所以属性，再逐级往上获取父类并反射获取其属性,每拿到一个属性，调用一次ToStringBuilder的append方法：</p>

<pre><code>public static &lt;T&gt; String toString(
        final T object, final ToStringStyle style, final boolean outputTransients,
        final boolean outputStatics, final Class&lt;? super T&gt; reflectUpToClass) {
    return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)
            .toString();
    }

    public String toString() {
        if (this.getObject() == null) {
            return this.getStyle().getNullText();
        }
        Class&lt;?&gt; clazz = this.getObject().getClass();
        this.appendFieldsIn(clazz);
        while (clazz.getSuperclass() != null &amp;&amp; clazz != this.getUpToClass()) {
            clazz = clazz.getSuperclass();
            this.appendFieldsIn(clazz);
        }
        return super.toString();
    }

    protected void appendFieldsIn(final Class&lt;?&gt; clazz) {
        if (clazz.isArray()) {
            this.reflectionAppendArray(this.getObject());
            return;
        }
        final Field[] fields = clazz.getDeclaredFields();
        AccessibleObject.setAccessible(fields, true);
        for (final Field field : fields) {
            final String fieldName = field.getName();
            if (this.accept(field)) {
                try {
                    // Warning: Field.get(Object) creates wrappers objects
                    // for primitive types.
                    final Object fieldValue = this.getValue(field);
                    this.append(fieldName, fieldValue);
                } catch (final IllegalAccessException ex) {
                    //this can't happen. Would get a Security exception
                    // instead
                    //throw a runtime exception in case the impossible
                    // happens.
                    throw new InternalError("Unexpected IllegalAccessException: " + ex.getMessage());
                }
            }
        }
    }
</code></pre>

<h1>2.beanCopy</h1>

<p>beanCopy由很多种方式，Spring和Apache都有实现版本，这里测试各个版本的性能.包括：</p>

<pre><code>1.原始的get/set
2.Spring的BeanUtils
3.cglib的BeanCopier
4.apache的BeanUtils
5.apache的PropertyUtils
</code></pre>

<p>原因是前段时间项目上很简单的接口时间很慢，最后同事跟到的问题是使用Spring的beanCopy方式，因为接口涉及上百个bean的属性拷贝，因此比较明显的反应了各种beancopy实现方式的差异；我们最常用的应该是Spring版本的BeanUtils。apache的BeanUtils的设计有点反人类(第一个参数是dest，第二个参数是source)。</p>

<p>各个包的版本：</p>

<pre><code>1.Spring : 3.2.1
2.cglib : 3.1
3.commons-beanutils : 1.9.2
</code></pre>

<p>各种方式的实现很简单：</p>

<pre><code>public class GetSetCopy {
    public static HotelVo copy(HotelEntity entity) {
        HotelVo vo = new HotelVo();
        vo.setId(entity.getId());
        vo.setName(entity.getName());
        vo.setAddress(entity.getAddress());
        vo.setPhone(entity.getPhone());
        vo.setCreateTime(entity.getCreateTime());
        vo.setUpdateTime(entity.getUpdateTime());
        vo.setPrice(entity.getPrice());
        vo.setKp(entity.getKp());

        return vo;
    }
}

public class ApacheBeanUtilsCopy {
    public static HotelVo copy(HotelEntity entity) throws Exception {
        HotelVo vo = new HotelVo();
        BeanUtils.copyProperties(vo, entity);
        return vo;
    }
}

public class ApachePropertyUtilsCopy {
    public static HotelVo copy(HotelEntity entity) throws Exception {
        HotelVo vo = new HotelVo();
        PropertyUtils.copyProperties(vo, entity);
        return vo;
    }
}

public class CglibBeanCopy {
    public static HotelVo copy(HotelEntity entity) {
        HotelVo vo = new HotelVo();
        BeanCopier copier = BeanCopier.create(entity.getClass(), HotelVo.class, false);
        copier.copy(entity, vo, null);
        return vo;
    }
}

public class SpringBeanUtilsCopy {
    public static HotelVo copy(HotelEntity entity) {
        HotelVo vo = new HotelVo();
        BeanUtils.copyProperties(entity, vo);
        return vo;
    }
}
</code></pre>

<p>测试的一个结果，每个copy运行10000次(各个Copy的第一次copy都很慢，跑10000次基本可以抹平这些差异)：</p>

<pre><code>GetSetCopy Min(微秒)=1.466
GetSetCopy Max(微秒)=804.236
GetSetCopy Avg(微秒)=1.7923529

Spring-BeanUtils Min(微秒)=3.339
Spring-BeanUtils Max(微秒)=99795.719
Spring-BeanUtils Avg(微秒)=28.2915534

Apache-BeanUtils Min(微秒)=9.812
Apache-BeanUtils Max(微秒)=92416.696
Apache-BeanUtils Avg(微秒)=79.0868131

Apache-PropertyUtils Min(微秒)=7.083
Apache-PropertyUtils Max(微秒)=6405.457
Apache-PropertyUtils Avg(微秒)=22.114272

Cglib-BeanCopy Min(微秒)=7.707
Cglib-BeanCopy Max(微秒)=156932.173
Cglib-BeanCopy Avg(微秒)=33.135989
</code></pre>

<table>
<thead>
<tr>
<th style="text-align:center;">copy策略 </th>
<th style="text-align:center;"> 平均(微秒) </th>
<th style="text-align:center;"> 最大(微秒) </th>
<th style="text-align:center;"> 最小(微秒)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">GetSet </td>
<td style="text-align:center;">1.7923529  </td>
<td style="text-align:center;">804.236 </td>
<td style="text-align:center;"> 1.466</td>
</tr>
<tr>
<td style="text-align:center;">Spring-BeanUtils </td>
<td style="text-align:center;">28.2915534  </td>
<td style="text-align:center;">99795.719</td>
<td style="text-align:center;"> 3.339</td>
</tr>
<tr>
<td style="text-align:center;">Apache-BeanUtils </td>
<td style="text-align:center;">79.0868131 </td>
<td style="text-align:center;">6405.457 </td>
<td style="text-align:center;"> 9.812</td>
</tr>
<tr>
<td style="text-align:center;">Apache-PropertyUtils </td>
<td style="text-align:center;">22.114272  </td>
<td style="text-align:center;">9503.836 </td>
<td style="text-align:center;"> 7.083</td>
</tr>
<tr>
<td style="text-align:center;">Cglib-BeanCopy </td>
<td style="text-align:center;">33.135989  </td>
<td style="text-align:center;">156932.173</td>
<td style="text-align:center;"> 7.707</td>
</tr>
</tbody>
</table>


<p>原始的get/set是最快的，而且是快一个数量级。Apache-BeanUtils是最慢的。Spring-BeanUtils的性能还是比其他几个强一些（这是个错觉，其实Cglib-BeanCopy比Spring-BeanUtils快，见下面的分析）。</p>

<h3>2.1 实现原理</h3>

<p>简单分析一下各个bean copy方式的实现原理。</p>

<ul>
<li>1.原始的get/set</li>
</ul>


<p>没什么好说的，最原始。</p>

<ul>
<li>2.Spring的BeanUtils</li>
</ul>


<p>Spring的BeanUtils可以使用String [] ignoreProperties 指定忽略某些属性的复制，当我们需要手动处理一些特定属性的时候挺有用。</p>

<p>copyProperties的原理很我们想想的一样：</p>

<pre><code>1.获取target类的属性列表；
2.循环遍历target属性，对每个属性，如果由write方法并且不在ignoreProperties里面，调用soure对应属性的read方法获取属性值，再调用target的write方法；
</code></pre>

<p>细节：</p>

<pre><code>1.缓存
获取target类的属性列表的时候有缓存，见CachedIntrospectionResults类。这也再一定成都上解释了为什么第一次调用会慢一些。
2.Accessible
注意，source的read和target的write方法可以不是Accessible的，即可以是private等修饰的方法；
3.浅拷贝
注意其拷贝是浅拷贝。
</code></pre>

<p>大致的代码(精简了一些)：</p>

<pre><code>private static void copyProperties(Object source, Object target, Class&lt;?&gt; editable, String[] ignoreProperties) throws BeansException {

        PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable);    //获取target的属性描述符，有缓存
        List ignoreList = ignoreProperties != null?Arrays.asList(ignoreProperties):null;
        PropertyDescriptor[] arr$ = targetPds;
        int len$ = targetPds.length;

        for(int i$ = 0; i$ &lt; len$; ++i$) {
            PropertyDescriptor targetPd = arr$[i$];
            if(targetPd.getWriteMethod() != null &amp;&amp; (ignoreProperties == null || !ignoreList.contains(targetPd.getName()))) {   //有write方法并且不在ignoreProperties中
                PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName());
                if(sourcePd != null &amp;&amp; sourcePd.getReadMethod() != null) {
                    try {
                        Method ex = sourcePd.getReadMethod();   //获取source的read方法
                        if(!Modifier.isPublic(ex.getDeclaringClass().getModifiers())) {
                            ex.setAccessible(true);
                        }

                        Object value = ex.invoke(source, new Object[0]);    //调用source的read方法获取属性对应的value
                        Method writeMethod = targetPd.getWriteMethod();
                        if(!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {
                            writeMethod.setAccessible(true);
                        }

                        writeMethod.invoke(target, new Object[]{value});    //调用target的write方法
                    } catch (Throwable var15) {
                        throw new FatalBeanException("Could not copy properties from source to target", var15);
                    }
                }
            }
        }
    }
</code></pre>

<ul>
<li>3.cglib的BeanCopier</li>
</ul>


<p>BeanCopier是CGLIB包中的一个工具类，使用基于动态代理机制的方式进行Bean Copy。因为使用生成的子类中的方法进行属性复制，所以会比使用反射机制的复制在效率上会高出很多。前面一直想写一片代理方面的Blog，一直没完成，尽量他会补上，到时候会分析CGLIB的原理。</p>

<p>我们这里的测试结果显示BeanCopier还不如Spring的BeanUtils，原因说BeanCopier.create的创建效率会比较低，所以在使用过程中建议将 BeanCopier.create 创建的对象声明为 static，避免使用中每次都去创建新的 BeanCopier 对象。我测试中发现，如果我们只显示的调用一次create方法，发现起速度明显快于Spring的BeanUtils(起最小值甚至小于get/set方式的最小值)：</p>

<pre><code>GetSetCopy Min(微秒)=1.46
GetSetCopy Max(微秒)=2149.855
GetSetCopy Avg(微秒)=2.0715596

Spring-BeanUtils Min(微秒)=3.669
Spring-BeanUtils Max(微秒)=101262.127
Spring-BeanUtils Avg(微秒)=29.613658

Apache-BeanUtils Min(微秒)=10.174
Apache-BeanUtils Max(微秒)=80342.749
Apache-BeanUtils Avg(微秒)=82.383995

Apache-PropertyUtils Min(微秒)=5.468
Apache-PropertyUtils Max(微秒)=17185.561
Apache-PropertyUtils Avg(微秒)=26.5104518

Cglib-BeanCopy Min(微秒)=0.745
Cglib-BeanCopy Max(微秒)=130832.581
Cglib-BeanCopy Avg(微秒)=14.6252958
</code></pre>

<ul>
<li>4.apache的BeanUtils</li>
</ul>


<p>主要代码大致如下：</p>

<pre><code>    public static void copyProperties(Object dest, Object orig) throws IllegalAccessException, InvocationTargetException {
        BeanUtilsBean.getInstance().copyProperties(dest, orig);
    }

    public void copyProperties(Object dest, Object orig) throws IllegalAccessException, InvocationTargetException {
            int i;
            String name;
            Object e;
            if(orig instanceof DynaBean) {  //DynaBean ？？
                DynaProperty[] origDescriptors = ((DynaBean)orig).getDynaClass().getDynaProperties(); 

                for(i = 0; i &lt; origDescriptors.length; ++i) {
                    name = origDescriptors[i].getName();
                    if(this.getPropertyUtils().isReadable(orig, name) &amp;&amp; this.getPropertyUtils().isWriteable(dest, name)) {
                        e = ((DynaBean)orig).get(name);
                        this.copyProperty(dest, name, e);
                    }
                }
            } else if(orig instanceof Map) {    //原始数据是一个Map，即支持从一个Map到target属性的拷贝
                Map var8 = (Map)orig;
                Iterator var10 = var8.entrySet().iterator();

                while(var10.hasNext()) {
                    Entry var11 = (Entry)var10.next();
                    String var12 = (String)var11.getKey();
                    if(this.getPropertyUtils().isWriteable(dest, var12)) {
                        this.copyProperty(dest, var12, var11.getValue());
                    }
                }
            } else { 
                PropertyDescriptor[] var9 = this.getPropertyUtils().getPropertyDescriptors(orig);   //获取target的属性描述符，有缓存

                for(i = 0; i &lt; var9.length; ++i) {
                    name = var9[i].getName();
                    //要求source的read方法是Accessible，target的write方法是Accessible
                    if(!"class".equals(name) &amp;&amp; this.getPropertyUtils().isReadable(orig, name) &amp;&amp; this.getPropertyUtils().isWriteable(dest, name)) {
                        try {
                            e = this.getPropertyUtils().getSimpleProperty(orig, name);  //获取source对应属性的value
                            this.copyProperty(dest, name, e);   //设置target对应属性
                        } catch (NoSuchMethodException var7) {
                            ;
                        }
                    }
                }
            }
    }
</code></pre>

<p>细节：</p>

<pre><code>1.BeanUtilsBean实例
BeanUtilsBean需要第一次new实例，因此第一次调用会慢一些。
2.缓存
获取target类的属性列表的时候有缓存，见BeanIntrospectionData类。这也再一定成都上解释了为什么第一次调用会慢一些。
3.Accessible
注意，source的read和target的write方法要求都是Accessible的；
4.浅拷贝
其拷贝是浅拷贝。
</code></pre>

<ul>
<li>5.apache的PropertyUtils
PropertyUtils的实现和BeanUtils的实现基本一致。</li>
</ul>


<pre><code>    public static void copyProperties(Object dest, Object orig) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException {
        PropertyUtilsBean.getInstance().copyProperties(dest, orig);
    }

    public void copyProperties(Object dest, Object orig) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException {
            int i;
            String name;
            Object e;
            if(orig instanceof DynaBean) {
                DynaProperty[] origDescriptors = ((DynaBean)orig).getDynaClass().getDynaProperties();

                for(i = 0; i &lt; origDescriptors.length; ++i) {
                    name = origDescriptors[i].getName();
                    if(this.isReadable(orig, name) &amp;&amp; this.isWriteable(dest, name)) {
                        try {
                            e = ((DynaBean)orig).get(name);
                            if(dest instanceof DynaBean) {
                                ((DynaBean)dest).set(name, e);
                            } else {
                                this.setSimpleProperty(dest, name, e);
                            }
                        } catch (NoSuchMethodException var9) {
                            if(this.log.isDebugEnabled()) {
                                this.log.debug("Error writing to \'" + name + "\' on class \'" + dest.getClass() + "\'", var9);
                            }
                        }
                    }
                }
            } else if(orig instanceof Map) {    //sorcce是一个Map
                Iterator var10 = ((Map)orig).entrySet().iterator();

                while(true) {
                    Entry var12;
                    do {
                        if(!var10.hasNext()) {
                            return;
                        }

                        var12 = (Entry)var10.next();
                        name = (String)var12.getKey();
                    } while(!this.isWriteable(dest, name)); //要求target对应属性是Accessible的

                    try {
                        if(dest instanceof DynaBean) {
                            ((DynaBean)dest).set(name, var12.getValue());
                        } else {
                            this.setSimpleProperty(dest, name, var12.getValue());
                        }
                    } catch (NoSuchMethodException var8) {
                        if(this.log.isDebugEnabled()) {
                            this.log.debug("Error writing to \'" + name + "\' on class \'" + dest.getClass() + "\'", var8);
                        }
                    }
                }
            } else {
                PropertyDescriptor[] var11 = this.getPropertyDescriptors(orig); //获取target对象属性的描述符，有缓存

                for(i = 0; i &lt; var11.length; ++i) {
                    name = var11[i].getName();
                    if(this.isReadable(orig, name) &amp;&amp; this.isWriteable(dest, name)) {   //要求source的read方法是Accessible，target的write方法是Accessible
                        try {
                            e = this.getSimpleProperty(orig, name); //获取source对应属性的值
                            if(dest instanceof DynaBean) {
                                ((DynaBean)dest).set(name, e);
                            } else {
                                this.setSimpleProperty(dest, name, e);  //设置target对应属性的值
                            }
                        } catch (NoSuchMethodException var7) {
                            if(this.log.isDebugEnabled()) {
                                this.log.debug("Error writing to \'" + name + "\' on class \'" + dest.getClass() + "\'", var7);
                            }
                        }
                    }
                }
            }

        }
</code></pre>

<h1>3.问题</h1>

<p>碰到一个小问题，因为涉及到同一个方法的多次调用，发现第一次调用的时间远大于后面的调用：</p>

<pre><code>GetSetCopy-1(微秒) : 1114.744
GetSetCopy-2(微秒) : 2.087
GetSetCopy-3(微秒) : 1.684
GetSetCopy-4(微秒) : 1.694
GetSetCopy-5(微秒) : 1.828
GetSetCopy-6(微秒) : 1.742
GetSetCopy-7(微秒) : 1.705
GetSetCopy-8(微秒) : 1.68
GetSetCopy-9(微秒) : 1.669
GetSetCopy-10(微秒) : 1.693
</code></pre>

<p>怀疑：</p>

<pre><code>1.GetSetCopy类的初始化；
2.拷贝的目标对象类(这里即HotelVo)初始化；
3.方法调用的缓存；
</code></pre>

<p>尝试发现如果调用前先显示的new一个GetSetCopy对象和一个HotelVo对象，可以将第一次的时间下降到50微妙左右。如果再外面显示的调用一次copy方法，则循环内的第一次copy会降到和其他次的拷贝时间一样。</p>

<h3>3.1 原理</h3>

<p>待补充，会涉及到JVM一些JIT的优化等问题，自己也很期待到底什么原因&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Enum反序列化问题]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/04/01/enumfan-xu-lie-hua-wen-ti/"/>
    <updated>2015-04-01T23:01:25+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/04/01/enumfan-xu-lie-hua-wen-ti</id>
    <content type="html"><![CDATA[<h1>1.Enum原理</h1>

<p>定义一个Enum，通过编译之后的字节码，我们可以发现其实现原理：
<code>
public enum FruitEnum {  
    APPLE, ORAGE  
}
</code>
编译器是在为我们创建一个类，这个类继承自 java.lang.Enum，有两个公共的、静态的、被声明成final的属性，它们的类型就是我们定义的FruitEnum。</p>

<p>编译器还生成了一个静态初始话器，就是字节码中static{};这一行下面的代码，其中的字节码创建了两个FruitEnum对象，同时分别赋值给APPLE和ORANGE这两个属性，调用的构造函数是定义在java.lang.Enum中的protected Enum(String name, int ordinal)方法。</p>

<p>在创建完成两个FruitEnum对象并且分别赋值给APPLE和ORIGIN之后，还创建了一个名叫ENUM$VALUES的数组，然后把APPLE和ORIGIN按照定义的顺序放如这个数组中。</p>

<p>除了这个静态初始化器之外，编译器还为我们生成了两个静态方法，values()和 valueOf(java.lang.String)方法。其中values()方法将ENUM$VALUES数组拷贝一份然后返回，而valueOf(java.lang.String)方法则会调用java.lang.Enum类中的valueOf方法，其作用是根据参数名找到对应的具体的枚举对象，如果找不到的话会抛出一个IllegalArgumentException异常。</p>

<h1>2.Enum序列化反序列化原理及问题</h1>

<h3>2.1原理</h3>

<p>序列化的时候Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过java.lang.Enum的valueOf方法来根据名字查找枚举对象。</p>

<p>同时，编译器是不允许任何对这种序列化机制的定制的，因此禁用了writeObject、readObject、readObjectNoData、writeReplace和readResolve等方法。</p>

<h3>2.2问题</h3>

<p>在系统或者类库升级时，对其中定义的枚举类型多加注意，为了保持代码上的兼容性，如果我们定义的枚举类型有可能会被序列化保存(放到文件中、保存到数据库中，进入分布式内存缓存中)，那么我们是不能够删除原来枚举类型中定义的任何枚举对象的，否则程序在运行过程中，JVM就会抱怨找不到与某个名字对应的枚举对象了。</p>

<p>另外，在远程方法调用过程中，如果我们发布的客户端接口返回值中使用了枚举类型，那么服务端在升级过程中就需要特别注意。如果在接口的返回结果的枚举类型中添加了新的枚举值，那就会导致仍然在使用老的客户端的那些应用出现调用失败的情况。</p>

<h1>3.Enum序列化反序列化问题解决</h1>

<p>使用class代替Enum,原来的枚举使用static对象替换，valueOf()方法使用一个Map实现，示例代码如下：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public final class FruitEnum implements Serializable {&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;private static final long serialVersionUID = -7230925342774763449L;
</span><span class='line'>
</span><span class='line'>private static final Map&lt;Integer, FruitEnum&gt; MAP = new HashMap&lt;Integer, FruitEnum&gt;();
</span><span class='line'>
</span><span class='line'>public static final FruitEnum APPLE = new FruitEnum("Apple", 0);
</span><span class='line'>public static final FruitEnum ORAGE = new FruitEnum("Orige", 1);
</span><span class='line'>
</span><span class='line'>private String text;
</span><span class='line'>private int code;
</span><span class='line'>
</span><span class='line'>private FruitEnum(String text, int code) {
</span><span class='line'>    this.text = text;
</span><span class='line'>    this.code = code;
</span><span class='line'>
</span><span class='line'>    MAP.put(code, this);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public String getText() {
</span><span class='line'>    return text;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public void setText(String text) {
</span><span class='line'>    this.text = text;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@Override
</span><span class='line'>public int getCode() {
</span><span class='line'>    return code;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/**
</span><span class='line'> * 根据code获取FruitEnum
</span><span class='line'> *
</span><span class='line'> * @param code
</span><span class='line'> * @return
</span><span class='line'> */
</span><span class='line'>public static FruitEnum valueOf(int code) {
</span><span class='line'>    return MAP.get(code);
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;}</span></code></pre></td></tr></table></div></figure></p>

<p>参考：<a href="http://mysun.iteye.com/blog/1581119">http://mysun.iteye.com/blog/1581119</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java中MessageDigest计算MD5]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/02/05/java-md5/"/>
    <updated>2015-02-05T21:40:13+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/02/05/java-md5</id>
    <content type="html"><![CDATA[<p>最近项目的图片处理的系统出问题比较多，典型的一个问题就是因为计算md5出现的问题。</p>

<h1>1.问题</h1>

<p>问题的现象很简单，使用这套代码批量切图，会出现一张灵异图片，灵异之处在于，很多人批量切图都会出现这张图片，且这张图片不在他们的原始图片中。</p>

<h1>2.原因</h1>

<p>最后分析的原因是计算图片md5的代码，使用的是Java自带的MessageDigest，大致使用如下
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//声明
</span><span class='line'>private static MessageDigest md = null;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//初始化
</span><span class='line'>static {
</span><span class='line'>    md = MessageDigest.getInstance(&ldquo;MD5&rdquo;);
</span><span class='line'>}&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//使用
</span><span class='line'>public static byte[] getMD5(byte[] bytes) {
</span><span class='line'>    md.update(bytes);   //&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;A
</span><span class='line'>    return md.digest(); //&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;B
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>
问题的原因就是多线程计算md5的时候getMD5这个函数有问题。</p>

<h3>2.1 问题md5</h3>

<p>最后定位发现重复出现的md5是</p>

<pre><code>d41d8cd98f00b204e9800998ecf8427e
</code></pre>

<p>这是一个特殊的md5，即其是空字符串的md5：
<code>
MD5("") = d41d8cd98f00b204e9800998ecf8427e
</code>
参考： <a href="http://zh.wikipedia.org/wiki/MD5">http://zh.wikipedia.org/wiki/MD5</a></p>

<h3>2.1 代码问题</h3>

<p>在MessageDigest类的源代码注释有这样一段话：
<code>
 * &lt;p&gt;A MessageDigest object starts out initialized. The data is
 * processed through it using the {@link #update(byte) update}
 * methods. At any point {@link #reset() reset} can be called
 * to reset the digest. Once all the data to be updated has been
 * updated, one of the {@link #digest() digest} methods should
 * be called to complete the hash computation.
 *
 * &lt;p&gt;The &lt;code&gt;digest&lt;/code&gt; method can be called once for a given number
 * of updates. After &lt;code&gt;digest&lt;/code&gt; has been called, the MessageDigest
 * object is reset to its initialized state.
</code>
上面这段话第二部分的意思是说，digest()这个方法只能被调用一次，一旦调用MessageDigest对象会被重置到初始状态。</p>

<p>根据这个逻辑，getMD5这个函数的代码，多个线程进入这段代码的时候（这里假设两个线程），线程A执行完步骤1，在执行步骤2之前，线程B也执行完步骤1，之后线程B调用了步骤2得到正确的md5,之后线程A再调用步骤2的时候得到的md5就是d41d8cd98f00b204e9800998ecf8427e。</p>

<p>本地验证：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void main(String[] args) {
</span><span class='line'>    String src = &ldquo;HelloWorld&rdquo;;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    messageDigest.update(src.getBytes());
</span><span class='line'>
</span><span class='line'>String md5 = bytesToHex(messageDigest.digest());
</span><span class='line'>System.out.println("md5 = " + md5.toLowerCase());
</span><span class='line'>
</span><span class='line'>String md5Again = bytesToHex(messageDigest.digest());
</span><span class='line'>System.out.println("md5Again = " + md5Again.toLowerCase());
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>得到的结果：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;md5 = 68e109f0f40ca72a15e05cc22786f8e6
</span><span class='line'>md5Again = d41d8cd98f00b204e9800998ecf8427e</span></code></pre></td></tr></table></div></figure></p>

<h1>3.解决</h1>

<h3>3.1 MessageDigest正确用法</h3>

<p>MessageDigest类的注释里面其实给出了正确的用法，注意其md.clone()的调用：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> MessageDigest md = MessageDigest.getInstance(&ldquo;MD5&rdquo;);&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt; try {
</span><span class='line'>     md.update(toChapter1);
</span><span class='line'>     MessageDigest tc1 = md.clone();
</span><span class='line'>     byte[] toChapter1Digest = tc1.digest();
</span><span class='line'>     md.update(toChapter2);
</span><span class='line'>     &hellip;etc.
</span><span class='line'> } catch (CloneNotSupportedException cnse) {
</span><span class='line'>     throw new DigestException(&ldquo;couldn&rsquo;t make digest of partial content&rdquo;);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure></p>

<h3>3.1 Apache的DigestUtils</h3>

<p>Apache的DigestUtils是一个线程安全的类，是对MessageDigest的封装，使用很简单，首先加入依赖：
<code>
&lt;dependency&gt;
    &lt;groupId&gt;commons-codec&lt;/groupId&gt;
    &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;
    &lt;version&gt;1.9&lt;/version&gt;
&lt;/dependency&gt;
</code>
然后就可以使用DigestUtils计算md5：
<code>
DigestUtils.md5(bytes)
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM内存DUMP参数配置]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/01/23/jvmnei-cun-dumpcan-shu-pei-zhi/"/>
    <updated>2015-01-23T23:04:31+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/01/23/jvmnei-cun-dumpcan-shu-pei-zhi</id>
    <content type="html"><![CDATA[<p>在JVM出现内存溢出或泄露时，为便于排查和定位，需要JVM的启动上增加相应的参数。主要是GC日志和内存DUMP参数.</p>

<h1>1.GC日志</h1>

<pre><code>-Xloggc:$CATALINA_BASE/logs/gc.log
</code></pre>

<h1>2.内存DUMP</h1>

<pre><code>-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=$CATALINA_BASE/logs/heapDump.log
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Read Files Quickly]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/01/16/how-to-read-files-quickly/"/>
    <updated>2015-01-16T01:00:42+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/01/16/how-to-read-files-quickly</id>
    <content type="html"><![CDATA[<p>Java中有很多读写文件或者网络流的方法，特别是Java7中加入了AIO之后，可选择的方法更多，本文的目的是想比较一下各种方式的优劣。</p>

<p>本文基本是参考这篇英文：<a href="http://nadeausoftware.com/articles/2008/02/java_tip_how_read_files_quikcly">http://nadeausoftware.com/articles/2008/02/java_tip_how_read_files_quikcly</a></p>

<h1>1.方法List</h1>

<p>这里涉及的读文件的方法包括：</p>

<h3>1.1 FileInputStreamOneByte</h3>

<pre><code>    @Override
    public long doRead() throws IOException {
        long checkSum = 0L;
        FileInputStream fis = new FileInputStream(filePath);
        int b;
        while ((b = fis.read()) != -1)
            checkSum += b;
        Closeables.close(fis, false);
        return checkSum;
    }
</code></pre>

<h3>1.2 FileInputStreamBytes</h3>

<pre><code>@Override
    public long doRead() throws IOException {
        long checkSum = 0L;
        FileInputStream fis = new FileInputStream(filePath);
        byte[] array = new byte[BUF_SIZE];
        int nRead;
        while ((nRead = fis.read(array, 0, BUF_SIZE)) != -1) {
            for (int i = 0; i &lt; nRead; i++)
                checkSum += array[i];
        }
        Closeables.close(fis, false);
        return checkSum;
    }
</code></pre>

<h3>1.3 BufferedInputStreamOneByte</h3>

<pre><code>@Override
    public long doRead() throws IOException {
        long checkSum = 0L;
        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(filePath), BUF_SIZE);
        int b;
        while ((b = bis.read()) != -1)
            checkSum += b;
        Closeables.close(bis, false);
        return checkSum;
    }
</code></pre>

<h3>1.4 BufferedInputStreamBytes</h3>

<pre><code>@Override
    public long doRead() throws IOException {
        long checkSum = 0L;
        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(filePath), BUF_SIZE);
        byte[] array = new byte[BUF_SIZE];
        int nRead;
        while ((nRead = bis.read(array, 0, BUF_SIZE)) != -1) {
            for (int i = 0; i &lt; nRead; i++)
                checkSum += array[i];
        }
        Closeables.close(bis, false);
        return checkSum;
    }
</code></pre>

<h3>1.5 RandomAccessOneByte</h3>

<pre><code>public long doRead() throws IOException {
        long checkSum = 0L;
        RandomAccessFile raf = new RandomAccessFile(filePath, READ_MODE);
        int b;
        while ((b = raf.read()) != -1) {
            checkSum += b;
        }
        Closeables.close(raf, false);
        return checkSum;
    }
</code></pre>

<h3>1.6 RandomAccessBytes</h3>

<pre><code>public long doRead() throws IOException {
        long checkSum = 0L;
        RandomAccessFile raf = new RandomAccessFile(filePath, READ_MODE);
        byte[] array = new byte[BUF_SIZE];
        int nRead;
        while ((nRead = raf.read(array, 0, BUF_SIZE)) != -1) {
            for (int i = 0; i &lt; nRead; i++)
                checkSum += array[i];
        }
        Closeables.close(raf, false);
        return checkSum;
    }
</code></pre>

<h3>1.7 FileChannelByteBufferOneByte</h3>

<pre><code>public long doRead() throws IOException {
        long checkSum = 0L;
        FileInputStream fis = new FileInputStream(filePath);
        FileChannel ch = fis.getChannel();
        ByteBuffer bb = ByteBuffer.allocate(BUF_SIZE);
        int nRead;
        while ((nRead = ch.read(bb)) != -1) {
            if (nRead == 0)
                continue;
            bb.position(0);
            bb.limit(nRead);
            while (bb.hasRemaining())
                checkSum += bb.get(); // 从ByteBuffer读一个字节
            bb.clear();
        }
        Closeables.close(fis, false);
        return checkSum;
    }
</code></pre>

<h3>1.8 FileChannelByteBufferBytes</h3>

<pre><code>public long doRead() throws IOException {
        long checkSum = 0L;
        FileInputStream fis = new FileInputStream(filePath);
        FileChannel ch = fis.getChannel();
        ByteBuffer bb = ByteBuffer.allocate(BIG_BUF_SIZE);
        byte[] array = new byte[BUF_SIZE];
        int nRead, nGet;
        while ((nRead = ch.read(bb)) != -1) {
            if (nRead == 0)
                continue;
            bb.position(0);
            bb.limit(nRead);
            while (bb.hasRemaining()) {
                nGet = Math.min(bb.remaining(), BUF_SIZE);
                bb.get(array, 0, nGet);
                for (int i = 0; i &lt; nGet; i++)
                    checkSum += array[i];
            }
            bb.clear();
        }
        Closeables.close(fis, false);
        return checkSum;
    }
</code></pre>

<h3>1.9 FileChannelByteBufferWrap</h3>

<pre><code>public long doRead() throws IOException {
        long checkSum = 0L;
        FileInputStream fis = new FileInputStream(filePath);
        FileChannel ch = fis.getChannel();
        byte[] barray = new byte[BUF_SIZE];
        ByteBuffer bb = ByteBuffer.wrap(barray); // ByteBuffer包装本地array
        int nRead;
        while ((nRead = ch.read(bb)) != -1) {
            for (int i = 0; i &lt; nRead; i++)
                checkSum += barray[i];
            bb.clear();
        }
        Closeables.close(fis, false);
        return checkSum;
    }
</code></pre>

<h3>1.10 FileChannelMappedByteBufferOneByte</h3>

<pre><code>public long doRead() throws IOException {
        long checkSum = 0L;
        FileInputStream fis = new FileInputStream(filePath);
        FileChannel ch = fis.getChannel();
        MappedByteBuffer mb = ch.map(FileChannel.MapMode.READ_ONLY, 0L, ch.size());
        while (mb.hasRemaining())
            checkSum += mb.get();
        Closeables.close(fis, false);
        return checkSum;
    }
</code></pre>

<h3>1.11 FileChannelMappedByteBufferBytes</h3>

<pre><code>public long doRead() throws IOException {
        long checkSum = 0L;
        FileInputStream fis = new FileInputStream(filePath);
        FileChannel ch = fis.getChannel();
        MappedByteBuffer mb = ch.map(FileChannel.MapMode.READ_ONLY, 0L, ch.size());
        byte[] barray = new byte[BUF_SIZE];
        int nGet;
        while (mb.hasRemaining()) {
            nGet = Math.min(mb.remaining(), BUF_SIZE);
            mb.get(barray, 0, nGet);
            for (int i = 0; i &lt; nGet; i++)
                checkSum += barray[i];
        }
        Closeables.close(fis, false);
        return checkSum;
    }
</code></pre>

<h3>1.12 FileChannelDirectByteBufferOneByte</h3>

<pre><code>public long doRead() throws IOException {
        long checkSum = 0L;
        FileInputStream fis = new FileInputStream(filePath);
        FileChannel ch = fis.getChannel();
        ByteBuffer bb = ByteBuffer.allocateDirect(BUF_SIZE);
        int nRead;
        while ((nRead = ch.read(bb)) != -1) {
            bb.position(0);
            bb.limit(nRead);
            while (bb.hasRemaining())
                checkSum += bb.get();
            bb.clear();
        }
        Closeables.close(fis, false);
        return checkSum;
    }
</code></pre>

<h3>1.13 FileChannelDirectByteBufferBytes</h3>

<pre><code>public long doRead() throws IOException {
        long checkSum = 0L;
        FileInputStream fis = new FileInputStream(filePath);
        FileChannel ch = fis.getChannel();
        ByteBuffer bb = ByteBuffer.allocateDirect(BIG_BUF_SIZE);
        byte[] barray = new byte[BUF_SIZE];
        int nRead, nGet;
        while ((nRead = ch.read(bb)) != -1) {
            if (nRead == 0)
                continue;
            bb.position(0);
            bb.limit(nRead);
            while (bb.hasRemaining()) {
                nGet = Math.min(bb.remaining(), BUF_SIZE);
                bb.get(barray, 0, nGet);
                for (int i = 0; i &lt; nGet; i++)
                    checkSum += barray[i];
            }
            bb.clear();
        }
        Closeables.close(fis, false);
        return checkSum;
    }
</code></pre>

<h1>2.测试</h1>

<p>测试文件的大小为83M：
<code>
xiaobaoqiu@xiaobaoqiu:~/Documents/TestData$ ll -h BXBooks.sql
-rw------- 1 xiaobaoqiu xiaobaoqiu 83M 10月  8  2004 BXBooks.sql
</code></p>

<h1>3.结论</h1>

<p>得到测试数据之后，为了直观展示代码的速度，用ECharts展示，对应的js代码如下(可以在<a href="http://echarts.baidu.com/doc/example/line1.html#helianthus%E4%B8%AD%E4%BD%BF%E7%94%A8">http://echarts.baidu.com/doc/example/line1.html#helianthus%E4%B8%AD%E4%BD%BF%E7%94%A8</a>)：
<code>
option = {
    title : {
        text: 'how_to_read_file_quickly',
        subtext: 'baoqiu.xiao'
    },
    tooltip : {
        trigger: 'axis'
    },
    legend: {
        data:['FileInputStreamOneByte','FileInputStreamBytes','BufferedInputStreamOneByte','BufferedInputStreamBytes','RandomAccessOneByte','RandomAccessBytes','FileChannelByteBufferOneByte','FileChannelByteBufferBytes','FileChannelByteBufferWrap','FileChannelMappedByteBufferOneByte','FileChannelMappedByteBufferBytes','FileChannelDirectByteBufferOneByte','FileChannelDirectByteBufferBytes']
    },
    dataZoom : {
        show : true,
        realtime: true,
        start : 0,
        end : 30
    },
    toolbox: {
        show : true,
        feature : {
            saveAsImage : {show: true}
        }
    },
    calculable : true,
    xAxis : [
        {
            type : 'category',
            boundaryGap : false,
            data : ['1','2','4','8','16','32','64','128','256','512','1K','2K','4K','8K','16K','32K','64K','128K']
        }
    ],
    yAxis : [
        {
            type : 'value',
            axisLabel : {
                formatter: '{value} 毫秒'
            }
        }
    ],
    series : [
        {
            name:'FileInputStreamOneByte',
            type:'line',
            data:[29119,28353,27872,27950,32035,40377,34904,36804,36835,33177,32252,37362,32359,31892,32621,32312,32943,33369]
        },
        {
            name:'FileInputStreamBytes',
            type:'line',
            data:[38182,20208,10194,4768,2616,1551,645,471,262,183,150,100,118,125,96,83,124,110]
        },
        {
            name:'BufferedInputStreamOneByte',
            type:'line',
            data:[33404,16966,8613,4718,2525,1491,980,728,677,681,558,608,557,615,505,606,656,693]
        },
        {
            name:'BufferedInputStreamBytes',
            type:'line',
            data:[33880,17333,8487,4851,2293,1632,627,358,242,147,129,113,89,92,107,88,100,95]
        },
        {
            name:'RandomAccessOneByte',
            type:'line',
            data:[28430,27445,26794,27053,28929,28633,29509,28870,28195,27376,28236,27444,28061,28889,27423,28064,28481,28084]
        },
        {
            name:'RandomAccessBytes',
            type:'line',
            data:[31497,16162,8135,4365,2131,1117,561,321,193,146,110,101,109,87,89,91,102,96]
        },
        {
            name:'FileChannelByteBufferOneByte',
            type:'line',
            data:[38778,18325,9447,5344,2430,1413,779,507,380,310,298,259,267,263,249,264,260,258]
        },
        {
            name:'FileChannelByteBufferBytes',
            type:'line',
            data:[19279,9823,5090,2605,1407,854,577,380,333,272,272,239,237,241,237,234,249,270]
        },
        {
            name:'FileChannelByteBufferWrap',
            type:'line',
            data:[38382,17636,9094,4608,2327,1198,646,355,249,151,108,100,92,90,88,103,85,92]
        },
        {
            name:'FileChannelMappedByteBufferOneByte',
            type:'line',
            data:[913,240,92,83,82,87,85,88,83,94,87,90,81,124,81,84,83,120]
        },
        {
            name:'FileChannelMappedByteBufferBytes',
            type:'line',
            data:[731,447,305,332,225,164,139,110,98,88,87,140,97,86,93,92,92,92]
        },
        {
            name:'FileChannelDirectByteBufferOneByte',
            type:'line',
            data:[31287,14473,7296,3815,1919,1001,547,319,200,135,109,98,84,77,80,82,77,86]
        },
        {
            name:'FileChannelDirectByteBufferBytes',
            type:'line',
            data:[14945,8060,4107,2174,1120,580,334,206,149,110,96,95,79,89,81,81,86,84]
        }       
    ]
};
</code></p>

<p>整体展示图如下：
<img src="/images/iospeed/read_file_speed.png"></p>

<h3>3.1 最快的三种方法</h3>

<p>为了展示更细节的地方，设置了y区间范围，在yAxis上设置min和max属性：
<code>
yAxis : [
        {
            type : 'value',
            min:0,
            max:200,
            axisLabel : {
                formatter: '{value} 毫秒'
            }
        }
    ],
</code>
得到如下展示图：
<img src="/images/iospeed/read_file_speed_small.png"></p>

<p>从上面这个图可以大致看出，最快的三种方法（PS，这里只做了一次实验，不是多次实验的平均值，所有数据可能不一定准确）：</p>

<pre><code>1.FileChannelMappedByteBufferBytes
2.FileChannelMappedByteBufferOneByte
3.FileChannelDirectByteBufferBytes
</code></pre>

<h1>4.解析</h1>

<p>下面解析一下代码中之前接触较少的东东。</p>

<h3>4.1 RandomAccessFile</h3>

<p>支持对文件的随机读取和写入。随机存取文件的行为类似存储在文件系统中的一个大型字节数组。存在指向该隐含数组的光标或索引，称为文件指针。</p>

<p>读取操作从文件指针开始读取字节，并随着对字节的读取而前移此文件指针。如果随机存取文件以读取/写入模式创建，则写入操作也可用；写入操作从文件指针开始写入字节，并随着对字节的写入而前移此文件指针。该文件指针可以通过 getFilePointer 方法读取，并通过 seek 方法设置。</p>

<p>提供了boolean，byte，char, short, int, long, float, double这些基本类型的read和write方法。</p>

<h3>4.2 FileChannel</h3>

<p>FileChannel是一个连接到文件的通道。可以通过文件通道读写文件。FileChannel无法设置为非阻塞模式，它总是运行在阻塞模式下。</p>

<p>在使用FileChannel之前，必须先打开它。但是，我们无法直接打开一个FileChannel，需要通过使用一个InputStream、OutputStream或RandomAccessFile来获取一个FileChannel实例。
<code>
FileInputStream fis = new FileInputStream(filePath);
FileChannel ch = fis.getChannel();
</code></p>

<p>有时可能需要在FileChannel的某个特定位置进行数据的读/写操作。可以通过调用position()方法获取FileChannel的当前位置。也可以通过调用position(long pos)方法设置FileChannel的当前位置。</p>

<p>FileChannel实例的size()方法将返回该实例所关联文件的大小。</p>

<p>FileChannel.force()方法将通道里尚未写入磁盘的数据强制写到磁盘上。出于性能方面的考虑，操作系统会将数据缓存在内存中，所以无法保证写入到FileChannel里的数据一定会即时写到磁盘上。要保证这一点，需要调用force()方法。</p>

<h3>4.3 ByteBuffer</h3>

<p>ByteBuffer知识下一次单独讲。</p>

<h1>5.BufferedInputStream的defaultBufferSize</h1>

<p>BufferedInputStream默认buffer大小为8K：
<code>
public class BufferedInputStream extends FilterInputStream {
    private static int defaultBufferSize = 8192;
}
</code></p>

<p>这个从图上也可以比较直观的看到，在缓存为8K左右的时候，性能最好：
<img src="/images/iospeed/BufferedInputStream_buffer.png"></p>

<h1>5.参考：</h1>

<p><a href="http://nadeausoftware.com/articles/2008/02/java_tip_how_read_files_quickly">http://nadeausoftware.com/articles/2008/02/java_tip_how_read_files_quickly</a></p>

<p><a href="http://colobu.com/2014/10/20/java-buffer-basic/">http://colobu.com/2014/10/20/java-buffer-basic/</a></p>
]]></content>
  </entry>
  
</feed>
