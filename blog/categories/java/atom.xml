<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | xiaobaoqiu Blog]]></title>
  <link href="http://xiaobaoqiu.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://xiaobaoqiu.github.io/"/>
  <updated>2016-04-20T10:35:04+08:00</updated>
  <id>http://xiaobaoqiu.github.io/</id>
  <author>
    <name><![CDATA[xiaobaoqiu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Who Eats JVM's Memory]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2016/01/28/who-eat-jvms-memory/"/>
    <updated>2016-01-28T13:40:27+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2016/01/28/who-eat-jvms-memory</id>
    <content type="html"><![CDATA[<ul>
<li><a href="#1.JVM%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E4%B8%8A%E9%99%90">1.JVM内存占用上限</a></li>
<li><a href="#2.JVM%20RES%E6%95%B0%E6%8D%AE%E6%9D%A5%E6%BA%90">2.JVM RES数据来源</a>

<ul>
<li><a href="#2.1%20/proc/pid%E5%86%85%E5%AE%B9">2.1 /proc/pid内容</a></li>
<li><a href="#2.2%20/proc/pid%E4%B8%8B%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6">2.2 /proc/pid下内存相关文件</a></li>
<li><a href="#2.3%20top%E5%91%BD%E4%BB%A4RES%E6%95%B0%E6%8D%AE%E6%9D%A5%E6%BA%90">2.3 top命令RES数据来源</a></li>
</ul>
</li>
<li><a href="#3.%E8%B0%81%E5%90%83%E4%BA%86JVM%E5%86%85%E5%AD%98">3.谁吃了JVM内存</a></li>
</ul>


<h2 id="1.JVM内存占用上限">1.JVM内存占用上限</h2>


<p>关于JVM的一些基础知识,可以看 <a href="http://blog.jamesdbloom.com/JVMInternals.html">JVM Internals</a>,曾经我尝试翻译过,地址:<a href="http://xiaobaoqiu.github.io/blog/2014/09/11/internal-jvm/">http://xiaobaoqiu.github.io/blog/2014/09/11/internal-jvm/</a></p>

<p>这里要说的是,那些参数决定了JVM内存上限,比如常用的内存配置如下:</p>

<pre><code>-Xms1024m -Xmx1024m -XX:PermSize=256m
</code></pre>

<p>说明堆(Heap)的大小1G,永久代大小256M.</p>

<p>另外,64位的操作系统(Linux服务器),线程的栈空间大小最大为1M:</p>

<pre><code>[baoqiu.xiao@Xxx ...]$ java -XX:+PrintFlagsFinal -version | grep ThreadStackSize
     intx CompilerThreadStackSize                   = 0               {pd product}        
     intx ThreadStackSize                           = 1024            {pd product}        
     intx VMThreadStackSize                         = 1024            {pd product}        
java version "1.7.0_45"
Java(TM) SE Runtime Environment (build 1.7.0_45-b18)
Java HotSpot(TM) 64-Bit Server VM (build 24.45-b08, mixed mode)
</code></pre>

<p>JVM的占用上限由一下几个因素决定:</p>

<pre><code>1. 堆内存
2. 持久代
3. 线程栈空间
4. 堆外内存
</code></pre>

<p>堆外内存参考: <a href="http://www.infoq.com/cn/news/2014/12/external-memory-heap-memory">http://www.infoq.com/cn/news/2014/12/external-memory-heap-memory</a></p>

<p>线程数可以如下得到:</p>

<pre><code>[baoqiu.xiao@Xxx ~]$ ps -m 1381 | wc -l
176
</code></pre>

<p>通常而言,我们只需要计算堆内存,持久代再加上线程栈空间.比如我们的本地一个小服务:</p>

<pre><code>Max Memory = Heap(1G) + Perm(256M) + 176 * Thread stack (1M)
</code></pre>

<h2 id="2.JVM RES数据来源">2.JVM RES数据来源</h2>


<p>首先得知道top命令中RES数据从哪里来的.再Linux上,万物皆文件,因此RES的数据也是来源于文件.</p>

<h4 id="2.1 /proc/pid内容">2.1 /proc/pid内容</h4>


<p>下面是一个典型的Tomcat应用的线程下的内容,进程号为1381,简单说描述每个文件的内容或者作用:</p>

<pre><code>attr            进程的属性
autogroup
auxv
cgroup
clear_refs
cmdline     启动进程时执行的命令
coredump_filter
cpuset
cwd         指向进程当前工作目录的软链
environ         进程执行时使用的环境变量
exe             这个就是起这个进程的执行文件
fd          进程打开的文件描述符,可以知道具体的文件路径
fdinfo
io          进程的io统计信息
limits          进程的软限制，硬限制等信息
loginuid
maps            进程相关的内存映射信息
mem             代进程持有的内存,不可读
mountinfo
mounts
mountstats
net
numa_maps
oom_adj         调节oom-killer的参数
oom_score       oom-killer打分,当需要是,oom-killer会根据各个进程的分数,kill掉某个进程
oom_score_adj       调节oom-killer的参数
pagemap         进程的虚拟页和物理内存页或者swap区的映射关系
personality
root            指向进程根目录的软链
sched
schedstat
sessionid
smaps           This file shows memory consumption for each of the process's mappings.
stack           This file provides a symbolic trace of the function calls in this process's kernel stack
stat            进程的状态
statm           进程使用的内存的状态
status          进程状态信息,比stat/statm更具可读性
syscall
task            进程包含的线程，子目录名是线程的ID
wchan
</code></pre>

<p>参考: <a href="http://man7.org/linux/man-pages/man5/proc.5.html">http://man7.org/linux/man-pages/man5/proc.5.html</a></p>

<h4 id="2.2 /proc/pid下内存相关文件">2.2 /proc/pid下内存相关文件</h4>


<p>和内存相关的文件主要包括(解析各个文件的时间不同,可能内容上存在对不上的情况):</p>

<pre><code>1. statm: 
2. stat:    
3. status
4. maps
5. smaps
</code></pre>

<p><em>1. statm</em></p>

<p>进程的内存使用,注意单位是page,内容的解析参考2.3节的内容.</p>

<p><em>2. stat</em></p>

<p>1381这个进程的stat文件及各个字段的含义(含义参见proc命令手册: man proc &ndash;> 搜stat, 见/proc/[pid]/stat):</p>

<pre><code>1381    pid             进程号
(java)  comm            应用程序或命令的名字
S   state           任务的状态(RSDZTW中一个字符),R:runnign, S:sleeping in an interruptible wait, D:waiting in uninterruptible disk sleep, Z:zombie, T is  traced  or  stopped, W is paging
1   ppid            父进程ID
1374    pgrp            线程组号
1374    session         该任务所在的会话组ID
0   tty_nr          进程的控制终端设备号
-1  tpgid           进程控制终端的前台任务id
4202496 flags           进程内核标志位
988135  minflt          任务不需要从硬盘拷数据而发生的缺页(minor faults)的次数
191 cminflt         任务的所有的waited-for子进程曾经发生的次缺页的次数累计值
252944  majflt          任务需要从硬盘拷数据而发生的缺页(minor faults)的次数
5   cmajflt             任务的所有的waited-for子进程需要从硬盘拷数据而发生的缺页(minor faults)的次数
229942  utime           任务在用户态(User mode)运行的时间，单位为时钟周期(clock ticks)
102219  stime           任务在内核态(kernel mode)运行的时间，单位为时钟周期(clock ticks)
0   cutime          任务的所有的waited-for子进程曾经在用户态运行的时间累计值，单位为时钟周期(clock ticks)
0   cstime          任务的所有的waited-for子进程曾经在核心态运行的时间累计值，单位为时钟周期(clock ticks)
20  priority            任务的动态优先级
0   nice            任务的静态优先级
179 num_threads     进程的线程数
0   itrealvalue     由于计时间隔导致的下一个 SIGALRM 发送进程的时延,单位jiffies
2107287914  starttime       任务启动的时间,单位为jiffies
3968053248  vsize           该任务的虚拟地址空间大小,单位byte
122542  rss             任务当前驻留物理地址空间的大小,单位page
18446744073709551615    rsslim          任务能驻留物理地址空间的最大值,单位byte
4194304 startcode       任务在虚拟地址空间的代码段的起始地址
4196452 endcode     任务在虚拟地址空间的代码段的结束地址
140734635670848 startstack      任务在虚拟地址空间的栈的结束地址
140734635653408 kstkesp         ESP(stack pointer, 栈指针)的当前值
250460799149    kstkeip         EIP(instruction pointer, 指令指针)的当前值
0   signal          pending信号的位图(bitmap),十进制数显示
0   blocked         blocked信号的位图(bitmap),十进制数显示
2   sigignore       ignored信号的位图(bitmap),十进制数显示
16800973    sigcatch        caught信号的位图(bitmap),十进制数显示
18446744073709551615    wchan           进程等待的channel.是系统调用地址
0   nswap           被swapped的页数(当前不用)
0   cnswap      所有子进程被swapped的页数的和(当前不用)
17  exit_signal     该进程结束时,向父进程所发送的信号
3   processor       进程最后一次执行的CPU号
0   rt_priority     实时调度优先级
0   policy          调度策略
4   delayacct_blkio_ticks   IO阻塞延迟汇总,单位时钟周期(clock ticks)
0   guest_time      进程的guest time(指费再运行guest操作系统上的时间),单位时钟周期(clock ticks)
0   cguest_time     子进程guest time
</code></pre>

<p>里面包含我们熟悉的RSS数据,注意其单位是page.</p>

<p><em>3. status</em></p>

<pre><code>[baoqiu.xiao@Xxx /proc/1381]$ sudo cat status
Name:   Java                                        /*当前进程的命令*/
State:  S (sleeping)                           /*当前进程状态: "R (running)", "S (sleeping)", "D (disk sleep)", "T (stopped)", "T (tracing stop)", "Z (zombie)", or "X (dead)"*/
Tgid:   1381                                      /*线程组号*/
Pid:    1381                                             /*线程id*/
PPid:   1                                            /*父进程的pid*/
TracerPid:  0                                     /*跟踪进程的pid,如果没有就是0*/
Uid:    40001   40001   40001   40001      /*uid euid suid fsuid*/
Gid:    40001   40001   40001   40001      /*gid egid sgid fsgid*/
Utrace: 0
FDSize: 512                                        /*FDSize是当前分配的文件描述符*/
Groups: 40001                             /*这里的groups表示启动这个进程的用户所在的组*/
VmPeak:  3880116 kB                   /*当前进程运行过程中占用内存的峰值*/
VmSize:  3875052 kB                         /*进程现在正在占用的内存*/
VmLck:         0 kB                               /*进程已经锁住的物理内存的大小.锁住的物理内存不能交换到硬盘*/
VmHWM:    766000 kB                    /*程序得到分配到物理内存的峰值*/
VmRSS:    490168 kB                          /*程序现在使用的物理内存*/
VmData:  3718132 kB                   /*进程数据段的大小*/
VmStk:        88 kB                              /*进程堆栈段的大小*/
VmExe:         4 kB                              /*进程代码的大小*/
VmLib:     15720 kB                          /*进程所使用LIB库的大小*/
VmPTE:      2280 kB                           /*进程所使用LIB库的大小*/
VmSwap:   303616 kB                   /*进程占用Swap的大小*/
Threads:    179                                /*当前进程组线程数*/
SigQ:   0/62812                               /*表示当前待处理信号的个数*/
SigPnd: 0000000000000000             /*屏蔽位,存储了该线程的待处理信号,等同于线程的PENDING信号*/
ShdPnd: 0000000000000000      /*屏蔽位,存储了该线程组的待处理信号.等同于进程组的PENDING信号*/
SigBlk: 0000000000000000             /*放被阻塞的信号,等同于BLOCKED信号*/
SigIgn: 0000000000000002            /*存放被忽略的信号,等同于IGNORED信号*/
SigCgt: 2000000181005ccd            /*存放捕获的信号,等同于CAUGHT信号*/
CapInh: 0000000000000000
CapPrm: 0000000000000000
CapEff: 0000000000000000
CapBnd: ffffffffffffffff
Cpus_allowed:   f
Cpus_allowed_list:  0-3
Mems_allowed:   00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000001
Mems_allowed_list:  0
voluntary_ctxt_switches:    35
nonvoluntary_ctxt_switches: 9
</code></pre>

<p>关于其中的TracerPid,在Linux下,我们可以使用strace来跟踪命令的运行.</p>

<p>参考: <a href="http://blog.csdn.net/zjl410091917/article/details/8075691">http://blog.csdn.net/zjl410091917/article/details/8075691</a></p>

<p><em>4. maps</em></p>

<p>maps内容如下:</p>

<pre><code>[baoqiu.xiao@l-crm3.des.dev.cn0 ~]$ head -30 maps
00400000-00401000 r-xp 00000000 fc:07 1179664                            /home/q/java/jdk1.7.0_45/bin/java
00600000-00601000 rw-p 00000000 fc:07 1179664                            /home/q/java/jdk1.7.0_45/bin/java
00b78000-00bed000 rw-p 00000000 00:00 0                                  [heap]
aff80000-100000000 rw-p 00000000 00:00 0 
3a4fe00000-3a4fe20000 r-xp 00000000 fc:02 2613                           /lib64/ld-2.12.so
3a5001f000-3a50020000 r--p 0001f000 fc:02 2613                           /lib64/ld-2.12.so
3a50020000-3a50021000 rw-p 00020000 fc:02 2613                           /lib64/ld-2.12.so
3a50021000-3a50022000 rw-p 00000000 00:00 0 
3a50200000-3a5038a000 r-xp 00000000 fc:02 25297                          /lib64/libc-2.12.so
3a5038a000-3a50589000 ---p 0018a000 fc:02 25297                          /lib64/libc-2.12.so
3a50589000-3a5058d000 r--p 00189000 fc:02 25297                          /lib64/libc-2.12.so
3a5058d000-3a5058e000 rw-p 0018d000 fc:02 25297                          /lib64/libc-2.12.so
</code></pre>

<p>第一列代表内存段的虚拟地址
第二列代表执行权限虚拟内存的权限,r=读,w=写,x=,s=共享,p=私有
第三列代表在进程地址里的偏移量
第四列映射文件的主设备号和次设备号
第五列映像文件的节点号,即inode
第六列是映像文件的路径</p>

<p>参考: <a href="http://stackoverflow.com/questions/1401359/understanding-linux-proc-id-maps">http://stackoverflow.com/questions/1401359/understanding-linux-proc-id-maps</a></p>

<p><em>5. smaps</em></p>

<p>smaps代表进程的各个线程的内存消耗</p>

<pre><code>[baoqiu.xiao@Xxx /proc/1381]$ sudo cat smaps
在smaps文件中,每一条记录(每块)表示进程虚拟内存空间中一块连续的区域.

...
00b78000-00bed000 rw-p 00000000 00:00 0                                  [heap]       /*和maps中的内容相同*/
Size:                468 kB                   /*表示该映射区域在虚拟内存空间中的大小*/
Rss:                  76 kB                    /*表示该映射区域当前在物理内存中实际占用了多少空间*/
Pss:                  76 kB                    /*该虚拟内存区域平摊计算后使用的物理内存大小*/
Shared_Clean:          0 kB             /*和其他进程共享的未被改写的page的大小*/
Shared_Dirty:          0 kB              /*和其他进程共享的被改写的page的大小*/
Private_Clean:         0 kB              /*未被改写的私有页面的大小*/
Private_Dirty:        76 kB
Referenced:           76 kB
Anonymous:            76 kB
AnonHugePages:         0 kB
Swap:                144 kB                 /*由于物理内存不足被swap到交换空间的大小*/
KernelPageSize:        4 kB             /*操作系统一个页面大小*/
MMUPageSize:           4 kB           /*CPU页面大小, MMU表示内存管理单元(Memory Management Unit)*/
...
</code></pre>

<p>关于其中的Pss,因为进程之间存在内存共享,比如该区域所映射的物理内存部分同时也被另一个进程映射了,且该部分物理内存的大小为1000KB(Rss会是1000KB),那么该进程分摊其中一半的内存,即Pss=500KB。</p>

<p>内存页引用计数>1,则表示是shared,否则是private.</p>

<p>参考: <a href="http://stackoverflow.com/questions/9922928/what-does-pss-mean-in-proc-pid-smaps">stackoverflow: what does pss mean in /proc/pid/smaps</a></p>

<p><a href="http://unix.stackexchange.com/questions/33381/getting-information-about-a-process-memory-usage-from-proc-pid-smaps">Getting information about a process' memory usage from /proc/pid/smaps</a></p>

<p>另外,当前系统的page大小可以通过getconf命令获取,比如我当前的服务器page大小为4k:</p>

<pre><code>[baoqiu.xiao@Xxx ~]$ getconf PAGESIZE
4096
</code></pre>

<h4 id="2.3 top命令RES数据来源">2.3 top命令RES数据来源</h4>


<p>top命令RES数据来源于/proc/PID/statm中的第二个字段.还是1381这个进程的statm文件内容和对应的top信息如下:</p>

<pre><code>[baoqiu.xiao@Xxx /proc/1381]$ sudo cat statm
968763 122480 558 1 0 929555 0

[baoqiu.xiao@Xxx ~]$ top -p 1381
  PID  USER      PR   NI  VIRT     RES     SHR  S  %CPU  %MEM    TIME+       COMMAND                                                                                                                             
 1381 tomcat    20   0   3784m  478m 2228  S  2.0       6.1           54:53.36    java
</code></pre>

<p>/proc/[pid]/statm文件的几个字段的具体意义如下(注意单位是page):</p>

<pre><code>size        (1) total program size(same as VmSize in /proc/[pid]/status)
resident    (2) (resident set size)(same as VmRSS in /proc/[pid]/status),即RSS
share       (3) shared pages (i.e., backed by a file)
text        (4) text (code)
lib             (5) library (unused in Linux 2.6)
data        (6) data + stack
dt              (7) dirty pages (unused in Linux 2.6)
</code></pre>

<p>可以验证,1381这个进程的RES大小来源, 和top命令中RES的数字是吻合的:</p>

<pre><code>122480 * 4096 / (1024 * 1024) = 478.4375 MB
</code></pre>

<h2 id="3.谁吃了JVM内存">3.谁吃了JVM内存</h2>


<p>写到这发现谢步下去了,因为我一开始就写错了.</p>

<p>想知道谁吃了我们JVM的内存,可以jmap dump下来,用MAT分析一下.</p>

<p>想知道谁吃了服务器的内存,建议看看参考里面的<a href="http://blog.yufeng.info/archives/2456">Linux Used内存到底哪里去了</a>这篇文章.</p>

<p>参考:
<a href="http://tldp.org/LDP/khg/HyperNews/get/memory/linuxmm.html">Linux Memory Management Overview</a></p>

<p><a href="https://techtalk.intersec.com/2013/07/memory-part-2-understanding-process-memory/">Understanding Process memory</a></p>

<p><a href="http://lwn.net/Articles/230975/">How much memory are applications really using</a></p>

<p><a href="http://tldp.org/LDP/tlk/mm/memory.html">Memory Management</a></p>

<p><a href="http://blog.yufeng.info/archives/2456">Linux Used内存到底哪里去了</a></p>

<p><a href="http://www.361way.com/whereis-the-memory/4036.html">也看linux内存去哪儿了</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在线诊断工具]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/08/27/zai-xian-zhen-duan-gong-ju/"/>
    <updated>2015-08-27T19:54:38+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/08/27/zai-xian-zhen-duan-gong-ju</id>
    <content type="html"><![CDATA[<p>Java诊断我相信再日常开发中都十分需要.相信大家都使用过以下几种诊断方式:</p>

<pre><code>1.肉眼诊断
就是出现问题时候企图通过肉眼来发现代码问题.通常很明显的问题有效;
2.日志诊断
通过给出问题的代码入参或者上下游加上日志,或者出问题的时候加上日志来诊断;这种方式的问题就是出现问题你需要重新拉分支,加日志,本地测试再上限这一系列流程.另外一个问题是过多的日志会影响应用性能;
3.监控诊断
通过完善的监控,通常包括完善且精确的异常划分.对不同的异常情况有独立的监控.加上完善的报警机制.这是最理想的情况.其优势是能快速定位问题点,问题是建立这一套完善的机制需要很长时间.并且监控只能发现问题类型,比如监控发现是数据错误,但是到底那条数据错误还是需要日志等手段来定位.
4.在线诊断工具
在不需要重新发布的情况下,在线诊断应用的问题所在.通常还可以用于定位接口瓶颈等问题;
</code></pre>

<p>这里简单介绍一下最近找到的几个在线诊断工具.它们都是非侵入式的,即不需要修改原始应用的代码再重新发布上线这个过程.</p>

<p>常用包括几个诊断工具包括,这里做一个简单的介绍:</p>

<pre><code>1.BTrace
2.HouseMD
3.Greys-Anatomy
</code></pre>

<p>参考: <a href="http://www.infoq.com/cn/articles/java-profiling-with-open-source/">http://www.infoq.com/cn/articles/java-profiling-with-open-source/</a></p>

<h2>. 1.BTrace</h2>

<p>Btrace(bytecode trace)是Kenai在2009年开发的一个开源项目(<a href="https://kenai.com/projects/btrace/">https://kenai.com/projects/btrace/</a>)，是一个动态跟踪分析JAVA源代码的工具。
它可以用来帮我们做运行时的JAVA程序分析，追踪，监控等.</p>

<p>官网: <a href="https://kenai.com/projects/btrace/">https://kenai.com/projects/btrace/</a></p>

<p>用户手册: <a href="https://kenai.com/projects/btrace/pages/UserGuide">https://kenai.com/projects/btrace/pages/UserGuide</a></p>

<p>samples下有很多使用例子.参考网上的一个例子:
<a href="http://mgoann.iteye.com/blog/1409685">http://mgoann.iteye.com/blog/1409685</a></p>

<p>参考: <a href="http://wiki.corp.qunar.com/pages/viewpage.action?pageId=56198121">http://wiki.corp.qunar.com/pages/viewpage.action?pageId=56198121</a></p>

<h4>1.1使用场景:</h4>

<p>1.数据采样
比如我们要优化某块代码，就可以先写一个btrace脚本，丢到线上服务器上跑一段时间；
这样可以收集到最真实的数据，而且不用发布之类的；
然后根据收集到的数据，做有目的的优化，优化之后，还可以对比出优化的效果。
2.排查问题
3.性能监控</p>

<h4>1.2优点</h4>

<p>1.跟踪任何java代码的调用（包括第三方类库中的，甚至jdk中的），比如统计某方法的调用次数，耗时。
2.可以监控的维度有很多，比如异常，同步块，内存申请，数组声明，甚至可以精确到行
3.完全不侵入业务代码，不需要重启服务
4.安全，对于应用内的数据来说是只读的。</p>

<h4>1.3缺点</h4>

<ol>
<li>有较多的使用限制，如只能调用用BtraceUtils中的方法、不能写实例变量；
（见docs/usersguide.html中的BTrace Restrictions条目）
所以刚编写脚本的时候，可能会有各种不习惯，但其实大多会用到的方法，BtraceUtils里都有封装
（其实个人感觉这个不算缺点，只是这个工具定位在追踪和监控，所以出于安全考虑，做了这个限制）</li>
<li>监控基本上只能单点，集群环境没法玩</li>
<li>被监控的服务重启，btrace也需要跟着重启
4.有影响原始应用的风险,严重可能导致JVM Crash.</li>
</ol>


<h4>1.4使用方式</h4>

<ul>
<li><p>Boot方式启动
追踪已启动的jvm进程
命令：btrace/bin/btrace 12345 SomeScript.java
注意，下载下来后bin下的文件都不可执行，需要chmod u+x，并且需要和目标进程是同一个用户来启动</p></li>
<li><p>Agent方式启动
与目标jvm同时启动
配置jvm参数：-javaagent:btrace-agent.jar=script=SqlMapTracer.class
注意：agent方式启动只能使用编译过的脚本
使用btrace/bin/btracec SqlMapTracer.java 编译
agent方式启动的btrace的标准输出位于你的SqlMapTracer.class所在目录下的SqlMapTracer.class.btrace文件</p></li>
</ul>


<p>boot方式灵活，但是当要求追踪结果精确时，就不太好用了。因为不知道btrace启动之前，目标进程已经执行了多少代码。agent方式是和目标进程同时启动的，可以保证结果精确。</p>

<h4>1.5原理</h4>

<p>主要就是使用ASM来实现对类的修改,再使用Instumentation实现类的内存替换.</p>

<p>btrace原理: <a href="http://victorzhzh.iteye.com/blog/965789">http://victorzhzh.iteye.com/blog/965789</a></p>

<p>btrace源码分析: <a href="http://agapple.iteye.com/blog/1005918">http://agapple.iteye.com/blog/1005918</a></p>

<h2>. 2.HouseMD</h2>

<p>高负载服务器端Java程序 诊断工具的特性要求有:</p>

<pre><code>1.命令行接口, 能够方便在服务器环境中运行;
2.支持常用诊断调式手段, 能够在其中快速来回切换;
3.容易定位跟踪目标, 且不易出错;
4.弱侵入, 目标Java程序无需任何修改, 不用重新部署或重启;
5.有效控制给目标进程带来的资源消耗;
6.不遗留任何"代码垃圾"等后遗症.
</code></pre>

<p>使用手册: <a href="https://github.com/CSUG/HouseMD/wiki/UserGuideCN">https://github.com/CSUG/HouseMD/wiki/UserGuideCN</a></p>

<h4>. 2.1安装</h4>

<p>首先安装jenv:</p>

<pre><code>xiaobaoqiu@xiaobaoqiu:~/Tools/HouseMD$ curl -L -s get.jenv.io | bash
...
xiaobaoqiu@xiaobaoqiu:~/Tools/HouseMD$ source /home/xiaobaoqiu/.jenv/bin/jenv-init.sh
...
xiaobaoqiu@xiaobaoqiu:~/Tools/HouseMD$ jenv help
...
</code></pre>

<p>再安装HouseMD就很简单:</p>

<pre><code>xiaobaoqiu@xiaobaoqiu:~/Tools/HouseMD$ jenv install housemd
Installing: housemd 0.2.7
Parsing http://jenv.mvnsearch.org/candidate/housemd/download/0.2.7/Linux/x86_64

Downloading: housemd 0.2.7
...
</code></pre>

<h2>. 3.Greys-Anatomy</h2>

<p>Greys是一个java进程执行过程中的异常诊断工具。 在不中断程序执行的情况下轻松完成问题排查工作.</p>

<p>源码: <a href="https://github.com/oldmanpushcart/greys-anatomy">https://github.com/oldmanpushcart/greys-anatomy</a></p>

<p>使用范例: <a href="https://github.com/oldmanpushcart/greys-anatomy/wiki/Getting-Start">https://github.com/oldmanpushcart/greys-anatomy/wiki/Getting-Start</a></p>

<p>交互方式: 命令行交互</p>

<p>功能:</p>

<pre><code>1.查看加载类，方法信息
2.方法执行监控（调用量，成功失败率，响应时间）
3.方法执行数据观测（参数，返回结果，异常信息等）
4.方法执行数据记录
5.性能开销渲染
6.方法执行数据自定义观测（js脚本）
7.查看方法调用堆栈
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[反射的效率]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/08/03/fan-she-de-xiao-lu/"/>
    <updated>2015-08-03T20:54:57+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/08/03/fan-she-de-xiao-lu</id>
    <content type="html"><![CDATA[<h1>1.toString实现</h1>

<p>测试不同的toString实现方式的效率，目前包括的case：</p>

<pre><code>1.String的+连接生成；
2.StringBuilder生成；
3.StringBuffer生成；
4.Guava的ToStringHelper生成；
5.Apache.commons.lang3的lang3的ToStringBuilder生成;
6.Apache.commons.lang3的ReflectionToStringBuilder生成;
</code></pre>

<p>toString的对象包含各种类型的属性：</p>

<pre><code>    private int age;

    private String name;

    private String address;

    private List&lt;String&gt; phone;

    private BigDecimal salary;

    private Map&lt;String, Object&gt; attrs;
</code></pre>

<p>各个toString的实现版本，其中ReflectionToStringBuilder是我们项目中使用最多的，因为它最简单：</p>

<pre><code>    /**
     * 使用字符串+
     * @return
     */
    public String concatToString() {
        return "Person{" +
                "age=" + age +
                ", name='" + name + '\'' +
                ", address='" + address + '\'' +
                ", phone=" + phone +
                ", salary=" + salary +
                ", attrs=" + attrs +
                '}';
    }

    /**
     * 使用StringBuilder
     * @return
     */
    public String stringBuilderToString() {
        StringBuilder builder = new StringBuilder("Person{");
        builder.append("age=").append(age)
                .append(", name='").append(name).append("'")
                .append(", address='").append(address).append("'")
                .append(", phone=").append(phone)
                .append(", salary=").append(salary)
                .append(", attrs=").append(attrs)
                .append("}");
        return builder.toString();
    }

    /**
     * 使用StringBuffer
     * @return
     */
    public String stringBufferToString() {
        StringBuffer buffer = new StringBuffer("Person{");
        buffer.append("age=").append(age)
                .append(", name='").append(name).append("'")
                .append(", address='").append(address).append("'")
                .append(", phone=").append(phone)
                .append(", salary=").append(salary)
                .append(", attrs=").append(attrs)
                .append("}");
        return buffer.toString();
    }

    /**
     * Guava的Objects,即ToStringHelper
     * @return
     */
    public String toStringHelperToString() {
        return Objects.toStringHelper(this)
                .add("age", age)
                .add("name", name)
                .add("address", address)
                .add("phone", phone)
                .add("salary", salary)
                .add("attrs", attrs)
                .toString();
    }

    /**
     * apache.commons.lang3的ToStringBuilder
     * @return
     */
    public String toStringBuilderToString() {
        return new ToStringBuilder(this)
                .append("age", age)
                .append("name", name)
                .append("address", address)
                .append("phone", phone)
                .append("salary", salary)
                .append("attrs", attrs)
                .toString();
    }

    /**
     * apache.commons.lang3的ReflectionToStringBuilder
     * @return
     */
    public String reflectionToStringBuilderToString() {
        return ReflectionToStringBuilder.reflectionToString(this, ToStringStyle.SIMPLE_STYLE);
    }
</code></pre>

<p>OS是Ubuntu 14.04 LTS版本，Java版本是1.7.0_80。跑1000次，记录最大最小平均时间:</p>

<pre><code>Concat Min(微秒)=25.385
Concat Max(微秒)=2218.851
Concat Avg(微秒)=56.728432999999995

StringBuilder Min(微秒)=22.501
StringBuilder Max(微秒)=6934.066
StringBuilder Avg(微秒)=50.724183

StringBuffer Min(微秒)=29.553
StringBuffer Max(微秒)=3159.808
StringBuffer Avg(微秒)=64.113464

ToStringHelper Min(微秒)=44.893
ToStringHelper Max(微秒)=9503.836
ToStringHelper Avg(微秒)=112.351293

ToStringBuilder Min(微秒)=62.806
ToStringBuilder Max(微秒)=20228.186
ToStringBuilder Avg(微秒)=194.728656

ReflectionToStringBuilder Min(微秒)=37.057
ReflectionToStringBuilder Max(微秒)=11402.172
ReflectionToStringBuilder Avg(微秒)=219.219879
</code></pre>

<p>整理成表格，数据如下：</p>

<table>
<thead>
<tr>
<th style="text-align:center;">toString策略 </th>
<th style="text-align:center;"> 平均(微秒) </th>
<th style="text-align:center;"> 最大(微秒) </th>
<th style="text-align:center;"> 最小(微秒)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">Concat </td>
<td style="text-align:center;">56.728433  </td>
<td style="text-align:center;">2218.851 </td>
<td style="text-align:center;"> 25.385</td>
</tr>
<tr>
<td style="text-align:center;">StringBuilder </td>
<td style="text-align:center;">50.724183  </td>
<td style="text-align:center;">6934.066 </td>
<td style="text-align:center;"> 22.501</td>
</tr>
<tr>
<td style="text-align:center;">StringBuffer </td>
<td style="text-align:center;">64.113464  </td>
<td style="text-align:center;">3159.808 </td>
<td style="text-align:center;"> 29.553</td>
</tr>
<tr>
<td style="text-align:center;">ToStringHelper </td>
<td style="text-align:center;">112.351293  </td>
<td style="text-align:center;">9503.836 </td>
<td style="text-align:center;"> 44.893</td>
</tr>
<tr>
<td style="text-align:center;">ToStringBuilder </td>
<td style="text-align:center;">194.728656  </td>
<td style="text-align:center;">20228.186 </td>
<td style="text-align:center;"> 62.806</td>
</tr>
<tr>
<td style="text-align:center;">ReflectionToStringBuilder </td>
<td style="text-align:center;">219.219879  </td>
<td style="text-align:center;">11402.172 </td>
<td style="text-align:center;"> 37.057</td>
</tr>
</tbody>
</table>


<p>通过上面的数据，concat和StringBuilder及StringBuffer的速度差不多。其他集中语法糖普遍慢一些，我们最常用的ReflectionToStringBuilder实际上是最慢的一个版本。</p>

<h3>1.1 实现原理</h3>

<p>简单分析一下各个toString方式的实现原理。</p>

<ul>
<li>1.Concat</li>
</ul>


<p>没什么说的，使用的是字符串的拼接。</p>

<ul>
<li>2.StringBuilder</li>
</ul>


<p>内部使用char数组，每次append都会先检查数组空间释放足够，不够的话先申请一块临时数组，大小是原来的两倍大小，再用Arrays.copyOf将数据拷贝。</p>

<ul>
<li>3.StringBuffer</li>
</ul>


<p>和StringBuilder一样，也是继承自AbstractStringBuilder类，唯一区别是为了保证线程安全，变更数据的方法都加上了synchronized关键字。</p>

<ul>
<li>4.ToStringHelper</li>
</ul>


<p>Guava的ToStringHelper内部实现是一个简单链表，每个链表节点包含name，value以及下一个节点的指针。</p>

<pre><code>private static final class ValueHolder {
        String name;
        Object value;
        Objects.ToStringHelper.ValueHolder next;

        private ValueHolder() {
        }
}
</code></pre>

<p>ToStringHelper类持有链表头节点和尾节点。每次调用add都是在链表尾部加一个节点，toString() 的时候遍历整个链表讲内容加到一个StringBuilder中。</p>

<pre><code>public static final class ToStringHelper {
    private final String className;
    private Objects.ToStringHelper.ValueHolder holderHead;
    private Objects.ToStringHelper.ValueHolder holderTail;

    public Objects.ToStringHelper add(String name, long value) {
        return this.addHolder(name, String.valueOf(value));
    }

    private Objects.ToStringHelper addHolder(String name, @Nullable Object value) {
        Objects.ToStringHelper.ValueHolder valueHolder = this.addHolder();
        valueHolder.value = value;
        valueHolder.name = (String)Preconditions.checkNotNull(name);
        return this;
    }

    private Objects.ToStringHelper.ValueHolder addHolder() {
        Objects.ToStringHelper.ValueHolder valueHolder = new Objects.ToStringHelper.ValueHolder();
        this.holderTail = this.holderTail.next = valueHolder;
        return valueHolder;
    }
</code></pre>

<ul>
<li>5.ToStringBuilder</li>
</ul>


<p>ToStringBuilder内部使用一个StringBuffer，默认大小为512.另外一个style设定来toString的样式，每次执行append都跳转到对应的ToStringStyle的append函数实现上，并将当前的StringBuffer带过去(StringBuffer来存储数据，ToStringStyle来保证格式)：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class ToStringBuilder implements Builder&lt;String&gt; {
</span><span class='line'>    private static volatile ToStringStyle defaultStyle;
</span><span class='line'>    private final StringBuffer buffer;
</span><span class='line'>    private final Object object;
</span><span class='line'>    private final ToStringStyle style;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static {
</span><span class='line'>defaultStyle = ToStringStyle.DEFAULT_STYLE;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public ToStringBuilder append(String fieldName, int value) {
</span><span class='line'>    this.style.append(this.buffer, fieldName, value);
</span><span class='line'>    return this;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;ToStringStyle的append实现，每个append都很简单，就是往StringBuffer中append数据：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;public void append(StringBuffer buffer, String fieldName, int value) {
</span><span class='line'>    this.appendFieldStart(buffer, fieldName);
</span><span class='line'>    this.appendDetail(buffer, fieldName, value);
</span><span class='line'>    this.appendFieldEnd(buffer, fieldName);
</span><span class='line'>}&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;protected void appendDetail(StringBuffer buffer, String fieldName, int value) {
</span><span class='line'>    buffer.append(value);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure></p>

<ul>
<li>6.ReflectionToStringBuilder</li>
</ul>


<p>ReflectionToStringBuilder实际上是继承自ToStringBuilder，每次都构建一个ReflectionToStringBuilder对象，toString的实现是使用反射完成，首先反射当前类的所以属性，再逐级往上获取父类并反射获取其属性,每拿到一个属性，调用一次ToStringBuilder的append方法：</p>

<pre><code>public static &lt;T&gt; String toString(
        final T object, final ToStringStyle style, final boolean outputTransients,
        final boolean outputStatics, final Class&lt;? super T&gt; reflectUpToClass) {
    return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)
            .toString();
    }

    public String toString() {
        if (this.getObject() == null) {
            return this.getStyle().getNullText();
        }
        Class&lt;?&gt; clazz = this.getObject().getClass();
        this.appendFieldsIn(clazz);
        while (clazz.getSuperclass() != null &amp;&amp; clazz != this.getUpToClass()) {
            clazz = clazz.getSuperclass();
            this.appendFieldsIn(clazz);
        }
        return super.toString();
    }

    protected void appendFieldsIn(final Class&lt;?&gt; clazz) {
        if (clazz.isArray()) {
            this.reflectionAppendArray(this.getObject());
            return;
        }
        final Field[] fields = clazz.getDeclaredFields();
        AccessibleObject.setAccessible(fields, true);
        for (final Field field : fields) {
            final String fieldName = field.getName();
            if (this.accept(field)) {
                try {
                    // Warning: Field.get(Object) creates wrappers objects
                    // for primitive types.
                    final Object fieldValue = this.getValue(field);
                    this.append(fieldName, fieldValue);
                } catch (final IllegalAccessException ex) {
                    //this can't happen. Would get a Security exception
                    // instead
                    //throw a runtime exception in case the impossible
                    // happens.
                    throw new InternalError("Unexpected IllegalAccessException: " + ex.getMessage());
                }
            }
        }
    }
</code></pre>

<h1>2.beanCopy</h1>

<p>beanCopy由很多种方式，Spring和Apache都有实现版本，这里测试各个版本的性能.包括：</p>

<pre><code>1.原始的get/set
2.Spring的BeanUtils
3.cglib的BeanCopier
4.apache的BeanUtils
5.apache的PropertyUtils
</code></pre>

<p>原因是前段时间项目上很简单的接口时间很慢，最后同事跟到的问题是使用Spring的beanCopy方式，因为接口涉及上百个bean的属性拷贝，因此比较明显的反应了各种beancopy实现方式的差异；我们最常用的应该是Spring版本的BeanUtils。apache的BeanUtils的设计有点反人类(第一个参数是dest，第二个参数是source)。</p>

<p>各个包的版本：</p>

<pre><code>1.Spring : 3.2.1
2.cglib : 3.1
3.commons-beanutils : 1.9.2
</code></pre>

<p>各种方式的实现很简单：</p>

<pre><code>public class GetSetCopy {
    public static HotelVo copy(HotelEntity entity) {
        HotelVo vo = new HotelVo();
        vo.setId(entity.getId());
        vo.setName(entity.getName());
        vo.setAddress(entity.getAddress());
        vo.setPhone(entity.getPhone());
        vo.setCreateTime(entity.getCreateTime());
        vo.setUpdateTime(entity.getUpdateTime());
        vo.setPrice(entity.getPrice());
        vo.setKp(entity.getKp());

        return vo;
    }
}

public class ApacheBeanUtilsCopy {
    public static HotelVo copy(HotelEntity entity) throws Exception {
        HotelVo vo = new HotelVo();
        BeanUtils.copyProperties(vo, entity);
        return vo;
    }
}

public class ApachePropertyUtilsCopy {
    public static HotelVo copy(HotelEntity entity) throws Exception {
        HotelVo vo = new HotelVo();
        PropertyUtils.copyProperties(vo, entity);
        return vo;
    }
}

public class CglibBeanCopy {
    public static HotelVo copy(HotelEntity entity) {
        HotelVo vo = new HotelVo();
        BeanCopier copier = BeanCopier.create(entity.getClass(), HotelVo.class, false);
        copier.copy(entity, vo, null);
        return vo;
    }
}

public class SpringBeanUtilsCopy {
    public static HotelVo copy(HotelEntity entity) {
        HotelVo vo = new HotelVo();
        BeanUtils.copyProperties(entity, vo);
        return vo;
    }
}
</code></pre>

<p>测试的一个结果，每个copy运行10000次(各个Copy的第一次copy都很慢，跑10000次基本可以抹平这些差异)：</p>

<pre><code>GetSetCopy Min(微秒)=1.466
GetSetCopy Max(微秒)=804.236
GetSetCopy Avg(微秒)=1.7923529

Spring-BeanUtils Min(微秒)=3.339
Spring-BeanUtils Max(微秒)=99795.719
Spring-BeanUtils Avg(微秒)=28.2915534

Apache-BeanUtils Min(微秒)=9.812
Apache-BeanUtils Max(微秒)=92416.696
Apache-BeanUtils Avg(微秒)=79.0868131

Apache-PropertyUtils Min(微秒)=7.083
Apache-PropertyUtils Max(微秒)=6405.457
Apache-PropertyUtils Avg(微秒)=22.114272

Cglib-BeanCopy Min(微秒)=7.707
Cglib-BeanCopy Max(微秒)=156932.173
Cglib-BeanCopy Avg(微秒)=33.135989
</code></pre>

<table>
<thead>
<tr>
<th style="text-align:center;">copy策略 </th>
<th style="text-align:center;"> 平均(微秒) </th>
<th style="text-align:center;"> 最大(微秒) </th>
<th style="text-align:center;"> 最小(微秒)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">GetSet </td>
<td style="text-align:center;">1.7923529  </td>
<td style="text-align:center;">804.236 </td>
<td style="text-align:center;"> 1.466</td>
</tr>
<tr>
<td style="text-align:center;">Spring-BeanUtils </td>
<td style="text-align:center;">28.2915534  </td>
<td style="text-align:center;">99795.719</td>
<td style="text-align:center;"> 3.339</td>
</tr>
<tr>
<td style="text-align:center;">Apache-BeanUtils </td>
<td style="text-align:center;">79.0868131 </td>
<td style="text-align:center;">6405.457 </td>
<td style="text-align:center;"> 9.812</td>
</tr>
<tr>
<td style="text-align:center;">Apache-PropertyUtils </td>
<td style="text-align:center;">22.114272  </td>
<td style="text-align:center;">9503.836 </td>
<td style="text-align:center;"> 7.083</td>
</tr>
<tr>
<td style="text-align:center;">Cglib-BeanCopy </td>
<td style="text-align:center;">33.135989  </td>
<td style="text-align:center;">156932.173</td>
<td style="text-align:center;"> 7.707</td>
</tr>
</tbody>
</table>


<p>原始的get/set是最快的，而且是快一个数量级。Apache-BeanUtils是最慢的。Spring-BeanUtils的性能还是比其他几个强一些（这是个错觉，其实Cglib-BeanCopy比Spring-BeanUtils快，见下面的分析）。</p>

<h3>2.1 实现原理</h3>

<p>简单分析一下各个bean copy方式的实现原理。</p>

<ul>
<li>1.原始的get/set</li>
</ul>


<p>没什么好说的，最原始。</p>

<ul>
<li>2.Spring的BeanUtils</li>
</ul>


<p>Spring的BeanUtils可以使用String [] ignoreProperties 指定忽略某些属性的复制，当我们需要手动处理一些特定属性的时候挺有用。</p>

<p>copyProperties的原理很我们想想的一样：</p>

<pre><code>1.获取target类的属性列表；
2.循环遍历target属性，对每个属性，如果由write方法并且不在ignoreProperties里面，调用soure对应属性的read方法获取属性值，再调用target的write方法；
</code></pre>

<p>细节：</p>

<pre><code>1.缓存
获取target类的属性列表的时候有缓存，见CachedIntrospectionResults类。这也再一定成都上解释了为什么第一次调用会慢一些。
2.Accessible
注意，source的read和target的write方法可以不是Accessible的，即可以是private等修饰的方法；
3.浅拷贝
注意其拷贝是浅拷贝。
</code></pre>

<p>大致的代码(精简了一些)：</p>

<pre><code>private static void copyProperties(Object source, Object target, Class&lt;?&gt; editable, String[] ignoreProperties) throws BeansException {

        PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable);    //获取target的属性描述符，有缓存
        List ignoreList = ignoreProperties != null?Arrays.asList(ignoreProperties):null;
        PropertyDescriptor[] arr$ = targetPds;
        int len$ = targetPds.length;

        for(int i$ = 0; i$ &lt; len$; ++i$) {
            PropertyDescriptor targetPd = arr$[i$];
            if(targetPd.getWriteMethod() != null &amp;&amp; (ignoreProperties == null || !ignoreList.contains(targetPd.getName()))) {   //有write方法并且不在ignoreProperties中
                PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName());
                if(sourcePd != null &amp;&amp; sourcePd.getReadMethod() != null) {
                    try {
                        Method ex = sourcePd.getReadMethod();   //获取source的read方法
                        if(!Modifier.isPublic(ex.getDeclaringClass().getModifiers())) {
                            ex.setAccessible(true);
                        }

                        Object value = ex.invoke(source, new Object[0]);    //调用source的read方法获取属性对应的value
                        Method writeMethod = targetPd.getWriteMethod();
                        if(!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {
                            writeMethod.setAccessible(true);
                        }

                        writeMethod.invoke(target, new Object[]{value});    //调用target的write方法
                    } catch (Throwable var15) {
                        throw new FatalBeanException("Could not copy properties from source to target", var15);
                    }
                }
            }
        }
    }
</code></pre>

<ul>
<li>3.cglib的BeanCopier</li>
</ul>


<p>BeanCopier是CGLIB包中的一个工具类，使用基于动态代理机制的方式进行Bean Copy。因为使用生成的子类中的方法进行属性复制，所以会比使用反射机制的复制在效率上会高出很多。前面一直想写一片代理方面的Blog，一直没完成，尽量他会补上，到时候会分析CGLIB的原理。</p>

<p>我们这里的测试结果显示BeanCopier还不如Spring的BeanUtils，原因说BeanCopier.create的创建效率会比较低，所以在使用过程中建议将 BeanCopier.create 创建的对象声明为 static，避免使用中每次都去创建新的 BeanCopier 对象。我测试中发现，如果我们只显示的调用一次create方法，发现起速度明显快于Spring的BeanUtils(起最小值甚至小于get/set方式的最小值)：</p>

<pre><code>GetSetCopy Min(微秒)=1.46
GetSetCopy Max(微秒)=2149.855
GetSetCopy Avg(微秒)=2.0715596

Spring-BeanUtils Min(微秒)=3.669
Spring-BeanUtils Max(微秒)=101262.127
Spring-BeanUtils Avg(微秒)=29.613658

Apache-BeanUtils Min(微秒)=10.174
Apache-BeanUtils Max(微秒)=80342.749
Apache-BeanUtils Avg(微秒)=82.383995

Apache-PropertyUtils Min(微秒)=5.468
Apache-PropertyUtils Max(微秒)=17185.561
Apache-PropertyUtils Avg(微秒)=26.5104518

Cglib-BeanCopy Min(微秒)=0.745
Cglib-BeanCopy Max(微秒)=130832.581
Cglib-BeanCopy Avg(微秒)=14.6252958
</code></pre>

<ul>
<li>4.apache的BeanUtils</li>
</ul>


<p>主要代码大致如下：</p>

<pre><code>    public static void copyProperties(Object dest, Object orig) throws IllegalAccessException, InvocationTargetException {
        BeanUtilsBean.getInstance().copyProperties(dest, orig);
    }

    public void copyProperties(Object dest, Object orig) throws IllegalAccessException, InvocationTargetException {
            int i;
            String name;
            Object e;
            if(orig instanceof DynaBean) {  //DynaBean ？？
                DynaProperty[] origDescriptors = ((DynaBean)orig).getDynaClass().getDynaProperties(); 

                for(i = 0; i &lt; origDescriptors.length; ++i) {
                    name = origDescriptors[i].getName();
                    if(this.getPropertyUtils().isReadable(orig, name) &amp;&amp; this.getPropertyUtils().isWriteable(dest, name)) {
                        e = ((DynaBean)orig).get(name);
                        this.copyProperty(dest, name, e);
                    }
                }
            } else if(orig instanceof Map) {    //原始数据是一个Map，即支持从一个Map到target属性的拷贝
                Map var8 = (Map)orig;
                Iterator var10 = var8.entrySet().iterator();

                while(var10.hasNext()) {
                    Entry var11 = (Entry)var10.next();
                    String var12 = (String)var11.getKey();
                    if(this.getPropertyUtils().isWriteable(dest, var12)) {
                        this.copyProperty(dest, var12, var11.getValue());
                    }
                }
            } else { 
                PropertyDescriptor[] var9 = this.getPropertyUtils().getPropertyDescriptors(orig);   //获取target的属性描述符，有缓存

                for(i = 0; i &lt; var9.length; ++i) {
                    name = var9[i].getName();
                    //要求source的read方法是Accessible，target的write方法是Accessible
                    if(!"class".equals(name) &amp;&amp; this.getPropertyUtils().isReadable(orig, name) &amp;&amp; this.getPropertyUtils().isWriteable(dest, name)) {
                        try {
                            e = this.getPropertyUtils().getSimpleProperty(orig, name);  //获取source对应属性的value
                            this.copyProperty(dest, name, e);   //设置target对应属性
                        } catch (NoSuchMethodException var7) {
                            ;
                        }
                    }
                }
            }
    }
</code></pre>

<p>细节：</p>

<pre><code>1.BeanUtilsBean实例
BeanUtilsBean需要第一次new实例，因此第一次调用会慢一些。
2.缓存
获取target类的属性列表的时候有缓存，见BeanIntrospectionData类。这也再一定成都上解释了为什么第一次调用会慢一些。
3.Accessible
注意，source的read和target的write方法要求都是Accessible的；
4.浅拷贝
其拷贝是浅拷贝。
</code></pre>

<ul>
<li>5.apache的PropertyUtils
PropertyUtils的实现和BeanUtils的实现基本一致。</li>
</ul>


<pre><code>    public static void copyProperties(Object dest, Object orig) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException {
        PropertyUtilsBean.getInstance().copyProperties(dest, orig);
    }

    public void copyProperties(Object dest, Object orig) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException {
            int i;
            String name;
            Object e;
            if(orig instanceof DynaBean) {
                DynaProperty[] origDescriptors = ((DynaBean)orig).getDynaClass().getDynaProperties();

                for(i = 0; i &lt; origDescriptors.length; ++i) {
                    name = origDescriptors[i].getName();
                    if(this.isReadable(orig, name) &amp;&amp; this.isWriteable(dest, name)) {
                        try {
                            e = ((DynaBean)orig).get(name);
                            if(dest instanceof DynaBean) {
                                ((DynaBean)dest).set(name, e);
                            } else {
                                this.setSimpleProperty(dest, name, e);
                            }
                        } catch (NoSuchMethodException var9) {
                            if(this.log.isDebugEnabled()) {
                                this.log.debug("Error writing to \'" + name + "\' on class \'" + dest.getClass() + "\'", var9);
                            }
                        }
                    }
                }
            } else if(orig instanceof Map) {    //sorcce是一个Map
                Iterator var10 = ((Map)orig).entrySet().iterator();

                while(true) {
                    Entry var12;
                    do {
                        if(!var10.hasNext()) {
                            return;
                        }

                        var12 = (Entry)var10.next();
                        name = (String)var12.getKey();
                    } while(!this.isWriteable(dest, name)); //要求target对应属性是Accessible的

                    try {
                        if(dest instanceof DynaBean) {
                            ((DynaBean)dest).set(name, var12.getValue());
                        } else {
                            this.setSimpleProperty(dest, name, var12.getValue());
                        }
                    } catch (NoSuchMethodException var8) {
                        if(this.log.isDebugEnabled()) {
                            this.log.debug("Error writing to \'" + name + "\' on class \'" + dest.getClass() + "\'", var8);
                        }
                    }
                }
            } else {
                PropertyDescriptor[] var11 = this.getPropertyDescriptors(orig); //获取target对象属性的描述符，有缓存

                for(i = 0; i &lt; var11.length; ++i) {
                    name = var11[i].getName();
                    if(this.isReadable(orig, name) &amp;&amp; this.isWriteable(dest, name)) {   //要求source的read方法是Accessible，target的write方法是Accessible
                        try {
                            e = this.getSimpleProperty(orig, name); //获取source对应属性的值
                            if(dest instanceof DynaBean) {
                                ((DynaBean)dest).set(name, e);
                            } else {
                                this.setSimpleProperty(dest, name, e);  //设置target对应属性的值
                            }
                        } catch (NoSuchMethodException var7) {
                            if(this.log.isDebugEnabled()) {
                                this.log.debug("Error writing to \'" + name + "\' on class \'" + dest.getClass() + "\'", var7);
                            }
                        }
                    }
                }
            }

        }
</code></pre>

<h1>3.问题</h1>

<p>碰到一个小问题，因为涉及到同一个方法的多次调用，发现第一次调用的时间远大于后面的调用：</p>

<pre><code>GetSetCopy-1(微秒) : 1114.744
GetSetCopy-2(微秒) : 2.087
GetSetCopy-3(微秒) : 1.684
GetSetCopy-4(微秒) : 1.694
GetSetCopy-5(微秒) : 1.828
GetSetCopy-6(微秒) : 1.742
GetSetCopy-7(微秒) : 1.705
GetSetCopy-8(微秒) : 1.68
GetSetCopy-9(微秒) : 1.669
GetSetCopy-10(微秒) : 1.693
</code></pre>

<p>怀疑：</p>

<pre><code>1.GetSetCopy类的初始化；
2.拷贝的目标对象类(这里即HotelVo)初始化；
3.方法调用的缓存；
</code></pre>

<p>尝试发现如果调用前先显示的new一个GetSetCopy对象和一个HotelVo对象，可以将第一次的时间下降到50微妙左右。如果再外面显示的调用一次copy方法，则循环内的第一次copy会降到和其他次的拷贝时间一样。</p>

<h3>3.1 原理</h3>

<p>待补充，会涉及到JVM一些JIT的优化等问题，自己也很期待到底什么原因&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Enum反序列化问题]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/04/01/enumfan-xu-lie-hua-wen-ti/"/>
    <updated>2015-04-01T23:01:25+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/04/01/enumfan-xu-lie-hua-wen-ti</id>
    <content type="html"><![CDATA[<h1>1.Enum原理</h1>

<p>定义一个Enum，通过编译之后的字节码，我们可以发现其实现原理：
<code>
public enum FruitEnum {  
    APPLE, ORAGE  
}
</code>
编译器是在为我们创建一个类，这个类继承自 java.lang.Enum，有两个公共的、静态的、被声明成final的属性，它们的类型就是我们定义的FruitEnum。</p>

<p>编译器还生成了一个静态初始话器，就是字节码中static{};这一行下面的代码，其中的字节码创建了两个FruitEnum对象，同时分别赋值给APPLE和ORANGE这两个属性，调用的构造函数是定义在java.lang.Enum中的protected Enum(String name, int ordinal)方法。</p>

<p>在创建完成两个FruitEnum对象并且分别赋值给APPLE和ORIGIN之后，还创建了一个名叫ENUM$VALUES的数组，然后把APPLE和ORIGIN按照定义的顺序放如这个数组中。</p>

<p>除了这个静态初始化器之外，编译器还为我们生成了两个静态方法，values()和 valueOf(java.lang.String)方法。其中values()方法将ENUM$VALUES数组拷贝一份然后返回，而valueOf(java.lang.String)方法则会调用java.lang.Enum类中的valueOf方法，其作用是根据参数名找到对应的具体的枚举对象，如果找不到的话会抛出一个IllegalArgumentException异常。</p>

<h1>2.Enum序列化反序列化原理及问题</h1>

<h3>2.1原理</h3>

<p>序列化的时候Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过java.lang.Enum的valueOf方法来根据名字查找枚举对象。</p>

<p>同时，编译器是不允许任何对这种序列化机制的定制的，因此禁用了writeObject、readObject、readObjectNoData、writeReplace和readResolve等方法。</p>

<h3>2.2问题</h3>

<p>在系统或者类库升级时，对其中定义的枚举类型多加注意，为了保持代码上的兼容性，如果我们定义的枚举类型有可能会被序列化保存(放到文件中、保存到数据库中，进入分布式内存缓存中)，那么我们是不能够删除原来枚举类型中定义的任何枚举对象的，否则程序在运行过程中，JVM就会抱怨找不到与某个名字对应的枚举对象了。</p>

<p>另外，在远程方法调用过程中，如果我们发布的客户端接口返回值中使用了枚举类型，那么服务端在升级过程中就需要特别注意。如果在接口的返回结果的枚举类型中添加了新的枚举值，那就会导致仍然在使用老的客户端的那些应用出现调用失败的情况。</p>

<h1>3.Enum序列化反序列化问题解决</h1>

<p>使用class代替Enum,原来的枚举使用static对象替换，valueOf()方法使用一个Map实现，示例代码如下：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public final class FruitEnum implements Serializable {&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;private static final long serialVersionUID = -7230925342774763449L;
</span><span class='line'>
</span><span class='line'>private static final Map&lt;Integer, FruitEnum&gt; MAP = new HashMap&lt;Integer, FruitEnum&gt;();
</span><span class='line'>
</span><span class='line'>public static final FruitEnum APPLE = new FruitEnum("Apple", 0);
</span><span class='line'>public static final FruitEnum ORAGE = new FruitEnum("Orige", 1);
</span><span class='line'>
</span><span class='line'>private String text;
</span><span class='line'>private int code;
</span><span class='line'>
</span><span class='line'>private FruitEnum(String text, int code) {
</span><span class='line'>    this.text = text;
</span><span class='line'>    this.code = code;
</span><span class='line'>
</span><span class='line'>    MAP.put(code, this);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public String getText() {
</span><span class='line'>    return text;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public void setText(String text) {
</span><span class='line'>    this.text = text;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@Override
</span><span class='line'>public int getCode() {
</span><span class='line'>    return code;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/**
</span><span class='line'> * 根据code获取FruitEnum
</span><span class='line'> *
</span><span class='line'> * @param code
</span><span class='line'> * @return
</span><span class='line'> */
</span><span class='line'>public static FruitEnum valueOf(int code) {
</span><span class='line'>    return MAP.get(code);
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;}</span></code></pre></td></tr></table></div></figure></p>

<p>参考：<a href="http://mysun.iteye.com/blog/1581119">http://mysun.iteye.com/blog/1581119</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java中MessageDigest计算MD5]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/02/05/java-md5/"/>
    <updated>2015-02-05T21:40:13+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/02/05/java-md5</id>
    <content type="html"><![CDATA[<p>最近项目的图片处理的系统出问题比较多，典型的一个问题就是因为计算md5出现的问题。</p>

<h1>1.问题</h1>

<p>问题的现象很简单，使用这套代码批量切图，会出现一张灵异图片，灵异之处在于，很多人批量切图都会出现这张图片，且这张图片不在他们的原始图片中。</p>

<h1>2.原因</h1>

<p>最后分析的原因是计算图片md5的代码，使用的是Java自带的MessageDigest，大致使用如下
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//声明
</span><span class='line'>private static MessageDigest md = null;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//初始化
</span><span class='line'>static {
</span><span class='line'>    md = MessageDigest.getInstance(&ldquo;MD5&rdquo;);
</span><span class='line'>}&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//使用
</span><span class='line'>public static byte[] getMD5(byte[] bytes) {
</span><span class='line'>    md.update(bytes);   //&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;A
</span><span class='line'>    return md.digest(); //&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;B
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>
问题的原因就是多线程计算md5的时候getMD5这个函数有问题。</p>

<h3>2.1 问题md5</h3>

<p>最后定位发现重复出现的md5是</p>

<pre><code>d41d8cd98f00b204e9800998ecf8427e
</code></pre>

<p>这是一个特殊的md5，即其是空字符串的md5：
<code>
MD5("") = d41d8cd98f00b204e9800998ecf8427e
</code>
参考： <a href="http://zh.wikipedia.org/wiki/MD5">http://zh.wikipedia.org/wiki/MD5</a></p>

<h3>2.1 代码问题</h3>

<p>在MessageDigest类的源代码注释有这样一段话：
<code>
 * &lt;p&gt;A MessageDigest object starts out initialized. The data is
 * processed through it using the {@link #update(byte) update}
 * methods. At any point {@link #reset() reset} can be called
 * to reset the digest. Once all the data to be updated has been
 * updated, one of the {@link #digest() digest} methods should
 * be called to complete the hash computation.
 *
 * &lt;p&gt;The &lt;code&gt;digest&lt;/code&gt; method can be called once for a given number
 * of updates. After &lt;code&gt;digest&lt;/code&gt; has been called, the MessageDigest
 * object is reset to its initialized state.
</code>
上面这段话第二部分的意思是说，digest()这个方法只能被调用一次，一旦调用MessageDigest对象会被重置到初始状态。</p>

<p>根据这个逻辑，getMD5这个函数的代码，多个线程进入这段代码的时候（这里假设两个线程），线程A执行完步骤1，在执行步骤2之前，线程B也执行完步骤1，之后线程B调用了步骤2得到正确的md5,之后线程A再调用步骤2的时候得到的md5就是d41d8cd98f00b204e9800998ecf8427e。</p>

<p>本地验证：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void main(String[] args) {
</span><span class='line'>    String src = &ldquo;HelloWorld&rdquo;;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    messageDigest.update(src.getBytes());
</span><span class='line'>
</span><span class='line'>String md5 = bytesToHex(messageDigest.digest());
</span><span class='line'>System.out.println("md5 = " + md5.toLowerCase());
</span><span class='line'>
</span><span class='line'>String md5Again = bytesToHex(messageDigest.digest());
</span><span class='line'>System.out.println("md5Again = " + md5Again.toLowerCase());
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>得到的结果：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;md5 = 68e109f0f40ca72a15e05cc22786f8e6
</span><span class='line'>md5Again = d41d8cd98f00b204e9800998ecf8427e</span></code></pre></td></tr></table></div></figure></p>

<h1>3.解决</h1>

<h3>3.1 MessageDigest正确用法</h3>

<p>MessageDigest类的注释里面其实给出了正确的用法，注意其md.clone()的调用：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> MessageDigest md = MessageDigest.getInstance(&ldquo;MD5&rdquo;);&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt; try {
</span><span class='line'>     md.update(toChapter1);
</span><span class='line'>     MessageDigest tc1 = md.clone();
</span><span class='line'>     byte[] toChapter1Digest = tc1.digest();
</span><span class='line'>     md.update(toChapter2);
</span><span class='line'>     &hellip;etc.
</span><span class='line'> } catch (CloneNotSupportedException cnse) {
</span><span class='line'>     throw new DigestException(&ldquo;couldn&rsquo;t make digest of partial content&rdquo;);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure></p>

<h3>3.1 Apache的DigestUtils</h3>

<p>Apache的DigestUtils是一个线程安全的类，是对MessageDigest的封装，使用很简单，首先加入依赖：
<code>
&lt;dependency&gt;
    &lt;groupId&gt;commons-codec&lt;/groupId&gt;
    &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;
    &lt;version&gt;1.9&lt;/version&gt;
&lt;/dependency&gt;
</code>
然后就可以使用DigestUtils计算md5：
<code>
DigestUtils.md5(bytes)
</code></p>
]]></content>
  </entry>
  
</feed>
