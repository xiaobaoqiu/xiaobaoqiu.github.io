<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Structure | xiaobaoqiu Blog]]></title>
  <link href="http://xiaobaoqiu.github.io/blog/categories/structure/atom.xml" rel="self"/>
  <link href="http://xiaobaoqiu.github.io/"/>
  <updated>2015-08-01T11:57:33+08:00</updated>
  <id>http://xiaobaoqiu.github.io/</id>
  <author>
    <name><![CDATA[xiaobaoqiu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[并查集]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2014/08/13/bing-cha-ji/"/>
    <updated>2014-08-13T23:49:17+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2014/08/13/bing-cha-ji</id>
    <content type="html"><![CDATA[<h1>简介</h1>

<p>并查集是一种非常简单的数据结构，它主要涉及两个基本操作，分别为：</p>

<pre><code>1. 合并两个不相交集合;
2. 判断两个元素是否属于同一个集合;
</code></pre>

<h1>实现</h1>

<p>实现上,通常用一个数组实现,如100个元素可以用大小为100的数组, 数组的内容存储节点的父亲节点的下标.</p>

<h3>1.朴素实现</h3>

<pre><code class="java">public class UnionFind extends AbstractUnionFind {

    /**
     * ctor
     * @param size
     */
    public UnionFind(int size) {
        assert(size &gt; 0);

        value = new int[size];
        init();
    }

    /**
     * 初始化数据
     */
    private void init() {
        assert (value != null &amp;&amp; value.length &gt; 0);
        for (int i = 0; i &lt; value.length; i++) {
            value[i] = DEFAULT_PARENT;  //DEFAULT_PARENT为-1
        }
    }

    /**
     * 合并根节点为rx 和 根节点为ry的树
     * 这里rx 和 ry为下标
     *
     * @param rx
     * @param ry
     */
    @Override
    public void Union(int rx, int ry) {
        assert (rx &gt;= 0 &amp;&amp; rx &lt; value.length);
        assert (ry &gt;= 0 &amp;&amp; ry &lt; value.length);

        //找到两个节点的根节点
        int px = Find(rx);
        int py = Find(ry);

        //将px设置为py的子树
        value[px] = py;
    }

    /**
     * 查找节点x的根节点
     *
     * @param x
     * @return
     */
    @Override
    public int Find(int x) {
        while(isRoot(x) == false) {
            x = value[x];
        }

        return x;
    }

    /**
     * 判断节点是否为根节点
     *
     * @param rx
     * @return
     */
    private boolean isRoot(int rx) {
        assert (rx &gt;= 0 &amp;&amp; rx &lt; value.length);

        return value[rx] == DEFAULT_PARENT; //DEFAULT_PARENT为-1
    }
}
</code></pre>

<p>Find的时间复杂度和树的高度成正比,最坏的情况下为所有节点形成一个链表, 这时候的复杂度为O(N);</p>

<p>Unoin时间需要调用Find,所以Union的最坏时间复杂度也为O(N);</p>

<h3>2.优化1:根据树高度Union</h3>

<p>朴素实现的容易出现所有节点(或者很多节点)形成一个链表,导致树的高度很大,进而导致Find的效率低.</p>

<p>我们可以简单的改变Union的策略,将小数(高度小)合并作为大树(高度大)的子树,高度也称之为树的秩.</p>

<p>实现这个策略,通常实现都是使用额外的一个数组来保存树的秩,在&lt;数据结构与算法分析:C语言描述>这本书给出了一个巧妙的实现,我们value[rx]之前是用-1表示其为跟节点,这个-1完全是无意义的,我们可以用这个空间来保存树的高度,同时为了避免和下表混淆,我们保存高度的负值.</p>

<p>{% img /images/unionfinddepth.png %}</p>

<p>实现和朴实并查集的不同的地方:</p>

<pre><code class="java">    /**
     * 合并根节点为rx 和 根节点为ry的树
     * 这里rx 和 ry为下标
     *
     * @param rx
     * @param ry
     */
    @Override
    public void Union(int rx, int ry) {
        assert (rx &gt;= 0 &amp;&amp; rx &lt; value.length);
        assert (ry &gt;= 0 &amp;&amp; ry &lt; value.length);

        //找到两个节点的根节点
        int px = Find(rx);
        int py = Find(ry);

        // 将px设置为py的子树
        if (value[px] &lt; value[py]) { // px为根节点的树高度更大, 应该将py树作为px的子树
            value[py] = px;
        } else if (value[py] &lt; value[px]) {
            value[px] = py;
        } else { // 高度相同, 最终树的高度+1
            value[py] = px;
            value[px]--; // 数的高度+1
        }
    }

    /**
     * 判断节点是否为根节点
     *
     * @param rx
     * @return
     */
    private boolean isRoot(int rx) {
        assert (rx &gt;= 0 &amp;&amp; rx &lt; value.length);

        return value[rx] &lt; 0;   //小于0的都表示是跟节点
    }
</code></pre>

<p>根据树高度Union基本能够使得树的高度维持在log(n)的级别,因此Find和Union的时间复杂度均为log(n);</p>

<h3>3.优化2:路径压缩</h3>

<p>路径压缩是指,我们在Find的过程中,从最底层节点依次遍历到根节点,期间我们可以将路径上的所以节点的父亲节点设置为根节点.</p>

<p>{% img /images/unionfindcompress.png %}</p>

<p>和2的不同之处:</p>

<p>```java
/<em>*
 * 查找节点x的根节点
 * 从最底端往上便利的时候, 可以顺带更改每个节点的父亲节点为跟节点, 使得树的高度降低
 *
 * @param x
 * @return
 </em>/
@Override
public int Find(int x) {
    while(value[x] >= 0) {    //非根节点
        value[x] = Find(value[x]);  //设置当前节点的父亲节点为根节点
    }</p>

<pre><code>return x;
</code></pre>

<p>}
不用担心递归的深度,因为从最开始就执行路径压缩的话,我们可以认为数的高度一直是1.</p>

<p>这是的树的高度基本为1,因此Unoin和Find的时间复杂度都接近O(1);</p>

<h1>典型应用</h1>

<p>并查集是高效简洁数据结构的典型代表.其典型应用包括:</p>

<h3>无向图的连通分量个数</h3>

<h3>Kruskar算法求最小生成树</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[二叉堆]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2014/07/18/er-cha-dui/"/>
    <updated>2014-07-18T18:03:19+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2014/07/18/er-cha-dui</id>
    <content type="html"><![CDATA[<p>二叉堆(小顶堆)保证孩子节点大于等于父亲节点,同时它又具有完全二叉树(除了底层,其他层是满的)的性质.</p>

<p>一个小顶堆如下:
<code>
        1
      /   \
     2     3
    / \   / \
   4   5  6  7
  / \ / \
 8  9 10 11    
</code>
二叉堆是专门为取出最大或最小节点而设计点数据结构，这种数据结构在查找一般元素方面性能和一般数组是没有多大区别的。</p>

<p>二叉堆在取出最大或最最小值的性能表现是O(1),取出操作完成之后，二叉堆需要一次整形操作，以便得到下一个最值，这个操作复杂度O(logn)。</p>

<p>但是二叉堆也有一个缺点，就是二叉堆对存储在内存中的数据操作太过分散，这导致了二叉堆在cpu高速缓存的利用与内存击中率上面表现不是很好，这也是一个二叉堆理想操作时间所需要付出的代价。</p>

<p>二叉堆用用数组实现很方便,比较经典的讲解见&lt;算法导论>,这里以小顶堆为例子.
数组实现时候的一些属性,便于代码实现:
    (1).父亲节点的下标为i,则左孩子节点下标2*i+1, 右孩子节点下标2*i+2;同理,下标为i的节点的父亲节点下标为(i-1)/2.
    (2).n个节点的二叉堆,非叶子节点的数目为floor(n/2),如7个节点,则有3个非叶子节点.
    (3).高度为h的完全二叉树,包含2<sup>h</sup>到2<sup>h+1</sup>-1个节点,即n个节点的二叉堆,高度为logn;</p>

<h3>实现</h3>

<p>二叉堆的实现主要涉及到两个操作,siftUp和siftDown,siftUp表示将第i个位置的元素向上调整,保证到达根节点的路径上都满足二叉堆的性质;siftDown将第i个位置的元素向下调整,保证i为根节点的子树为一个二叉堆.</p>

<p>下面是我的一个简单实现:
```java
import java.util.Arrays;</p>

<p>/<em><em>
 * 二叉堆 这里数据类型为Integer, 且堆为小顶堆
 * 几个重要的性质(具有完全二叉树的性质):
 * (1).父亲节点的下标为i,则左孩子节点下标2</em>i+1, 右孩子节点下标2</em>i+2;同理,下标为i的节点的父亲节点下标为(i-1)/2;
 * (2).n个节点的二叉堆,非叶子节点的数目为floor(n/2),如7个节点,则有3个非叶子节点;
 * (3).高度为h的完全二叉树,包含2<sup>h</sup>到2<sup>h+1</sup>-1个节点,即n个节点的二叉堆,高度为logn
 *
 * @Author: <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#x61;&#111;&#113;&#x69;&#117;&#46;&#120;&#105;&#x61;&#111;&#64;&#113;&#x75;&#x6e;&#x61;&#114;&#46;&#x63;&#111;&#x6d;">&#98;&#97;&#x6f;&#113;&#x69;&#x75;&#46;&#x78;&#105;&#97;&#x6f;&#x40;&#x71;&#x75;&#110;&#x61;&#x72;&#x2e;&#x63;&#111;&#x6d;</a> Date: 14-7-17 Time: 下午3:45
 * @Version: \$Id$
 */
public class PQueue {</p>

<pre><code>/**
 * 默认大小
 */
private static final int DEFAULT_CAPACITY = 16;

/**
 * 数据
 */
private transient Integer[] queue;

/**
 * 大小
 */
private int size = 0;

/**
 * ctor
 */
public PQueue() {
    this(DEFAULT_CAPACITY);
}

public PQueue(int initialCapacity) {
    if (initialCapacity &lt; 1)
        throw new IllegalArgumentException();
    this.queue = new Integer[initialCapacity];
}

public PQueue(Integer[] array) {
    this(array.length);
    queue = Arrays.copyOf(array, array.length);
    size = array.length;

    heapify();
}

/**
 * 堆内元素个数, O(1)
 * 
 * @return
 */
public int size() {
    return size;
}

public boolean isEmpty() {
    return size == 0;
}

/**
 * 取堆顶元素(这里为最小元素),但不移除堆顶元素, O(1)
 * 
 * @return
 */
public Integer peek() {
    if (size == 0)
        return null;

    return queue[0];
}

/**
 * 弹出堆顶元素并返回, O(logn)
 * 
 * @return
 */
public Integer pop() {
    if (size == 0)
        return null;

    Integer result = queue[0];
    queue[0] = queue[--size]; // 数组尾部元素放到堆顶
    queue[size] = null;
    if (size &gt; 0) {
        shiftDown(0);
    }

    return result;
}

/**
 * 往堆里面插入一个元素, O(logn)
 * 
 * @param newValue
 */
public boolean add(Integer newValue) {
    if (newValue == null)
        throw new NullPointerException();

    // 需要增长内存
    int oldSize = size;
    if (oldSize &gt;= queue.length) {
        grow(oldSize + 1);
    }

    size = oldSize + 1;
    queue[oldSize] = newValue;
    if (oldSize &gt; 0) {
        shiftUp(oldSize);
    }

    return true;
}

/**
 * 内存增长,保证能容纳 minCapacity 个元素
 * 
 * @param minCapacity
 */
private void grow(int minCapacity) {
    if (minCapacity &lt; 0)
        throw new OutOfMemoryError();

    // 这里成倍增长
    int oldCapacity = queue.length;
    int newCapacity = oldCapacity &lt;&lt; 1;

    // 校验
    if (newCapacity &lt; 0)
        newCapacity = Integer.MAX_VALUE;
    if (newCapacity &lt; minCapacity)
        newCapacity = minCapacity;

    // 数据拷贝
    queue = Arrays.copyOf(this.queue, newCapacity);
}

/**
 * 将数组最小堆化 从最后一个非叶子节点,依次往前调整,使得每个子树都满足堆的性质
 * 根据下标为i的节点的父亲节点下标为(i-1)/2, 最大下标为size-1, 因此非根节点的最大下标为(size-2)/2, 即size/2 -1
 *
 * 直观是O(nlogn), 记得算法导论分析的均摊时间应该是O(n), 忘了怎么分析的
 */
private void heapify() {
    for (int i = (size &gt;&gt;&gt; 1) - 1; i &gt;= 0; i--)
        shiftDown(i);
}

/**
 * 向下调整下标为index的节点为根节点的子树, 使其满足堆的性质
 * 父亲节点的下标为i,则左孩子节点下标2*i+1, 右孩子节点下标2*i+2
 * O(logn)
 * 
 * @param index
 */
private void shiftDown(int index) {
    //到达叶子节点了
    if(index &gt; ((size &gt;&gt;&gt; 1) - 1) )
        return;

    //左右孩子中较小的节点candidate
    int left = (index &lt;&lt; 1) + 1, right = left + 1;
    int candidate = left;
    if(right &lt; size &amp;&amp; queue[right] &lt; queue[left]){
        candidate = right;
    }

    //父节点大于子节点, 则交换父子节点, 并递归调整candide为根节点的子树
    if (queue[index] &gt; queue[candidate]) {
        swap(index, candidate);
        shiftDown(candidate);
    }
}

/**
 * 向上调整下标为index的节点的数据, 保证其到根节点的路径上都满足堆的性质
 * 节点下标为i, 则父节点下标为(i-1)/2
 * O(logn)
 *
 * @param index
 */
private void shiftUp(int index) {
    //达到根节点了
    if(index &lt;= 0)
        return;

    int parent = (index-1)&gt;&gt;&gt;1;

    //父亲节点 &gt; 当前节点,需要交换
    if(parent &gt;= 0 &amp;&amp; queue[parent] &gt; queue[index]) {
        swap(parent, index);
        shiftUp(parent);
    }
}

/**
 * 交换数组中 i 和 j 的元素
 * 
 * @param i
 * @param j
 */
private void swap(int i, int j) {
    Integer tmp = queue[i];
    queue[i] = queue[j];
    queue[j] = tmp;
}

public static void main(String[] args) {
    PQueue queue = new PQueue();
    queue.add(6);
    queue.add(8);
    queue.add(2);
    queue.add(4);
    queue.add(5);
    queue.add(7);
    queue.add(1);

    while (!queue.isEmpty()) {
        System.out.println(queue.pop());    //1 2 4 5 6 7 8
    }
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[R Tree]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2014/06/17/r-tree/"/>
    <updated>2014-06-17T20:46:37+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2014/06/17/r-tree</id>
    <content type="html"><![CDATA[<h3>1.R-Tree简介</h3>

<p>Btree以及它的变体B+tree对数据库的发展可谓是功不可没,但是，Btree良好的性能却仅仅只能在一维数据上产生效果，如果涉及到二维数据甚至多维数据，那么Btree也无能为力了。然而随着GIS（地理信息系统）和CAD（计算机辅助设计）的广泛应用，多维空间数据(spatial data)的处理变得相当普遍，因此必须在二维和多维数据上找到一种有效的索引方法，于是Rtree就出现了.</p>

<p>1984年，加州大学伯克利分校的Guttman发表了一篇题为“<a href="http://www.sai.msu.su/~megera/postgres/gist/papers/gutman-rtree.pdf">R-trees: a dynamic index structure for spatial searching</a>”的论文，向世人介绍了R树这种处理高维空间存储问题的数据结构。</p>

<p>简单的说，就是将空间对象按某种空间关系进行划分，以后对空间对象的存取都基于划分块进行。</p>

<h3>2.R-Tree原理</h3>

<p>R树是一种多级平衡树,它是B树在多维空间上的扩展。在R树中存放的数据并不是原始数据，而是这些数据的最小边界矩形（Minimal-Bounding-Box, MBR），空间对象的MBR被包含于R树的叶结点中。从叶子结点开始用矩形（rectangle）将空间框起来，父节点的矩形需要包含字节点的矩形,结点越往上框住的空间就越大，以此对空间进行分割。</p>

<p>下图展示了一些列对象的边界矩形:</p>

<p>{% img /images/rtree.png %}</p>

<p>一个矩形框住一个或者多个节点,比如矩形R8框的是一个不规则对象,而矩形R6包含了矩形R15和R16;</p>

<h4>R-Tee满足以下属性:</h4>

<ol>
<li>每个叶子节点包含m到M个索引记录,除非它是根节点;</li>
<li>每个叶子节点的索引记录(I, tuple-identifier),I是最小的可以在空间中完全覆盖这些记录所代表的点的矩形(高维空间矩形).</li>
<li>每个非叶子节点包含m到M个子节点,除非它是根节点;</li>
<li>对于在非叶子结点上的每一个条目(Entry),I是最小的可以在空间中完全包含所有子节点矩形的最小矩形;</li>
<li>根节点至少有两个孩子节点,除非它是叶子节点;</li>
<li>所有的叶子节点在同一层;</li>
</ol>


<p>需要保证,m &lt;= M/2;</p>

<h4>叶子节点:</h4>

<p>叶子结点所保存的数据形式为：(I, tuple-identifier),其中，tuple-identifier表示的是一个存放于数据库中的tuple，也就是一条记录，它是n维的。I是一个n维空间的矩形，它可以恰好框住这个叶子结点中所有记录代表的n维空间中的点。</p>

<h4>非叶子节点</h4>

<p>叶子结点所保存的数据形式为：(I, child-pointer),其中child-pointer是子节点指针,I是可以覆盖所有子节点的最小n维空间的矩形;</p>

<h3>3.R-Tree应用</h3>

<p>典型的PostGis,这使得Postgresql支持空间索引.</p>

<h3>4.R-Tree实现</h3>

<p>一个网络上的<a href="https://github.com/rweeks/util">实现</a>:
```java
public class RTree<T> {</p>

<pre><code>public enum SeedPicker {
    LINEAR, QUADRATIC
}

/**
 * 每个节点包含的最大entry数目
 */
private final int M;

/**
 * 每个节点包含的最小entry数目
 */
private final int m;

/**
 * 空间的维度,如平面则为2,空间点则为3
 */
private final int D;

private final float[] pointDims;

private final SeedPicker seedPicker;

/**
 * 根节点
 */
private Node root;

private volatile int size;

/**
 * 构造默认R-Tree的参数
 * DEFAULT_M : M
 * DEFAULT_m : m
 * DEFAULT_D : D
 */
private static final int DEFAULT_M = 50;
private static final int DEFAULT_m = 2;
private static final int DEFAULT_D = 2;

/**
 * 创建一颗新的R-Tree
 * 
 * @param M maximum number of entries per node
 * @param m minimum number of entries per node (except for the root node)
 * @param D the number of dimensions of the RTree.
 */
public RTree(int M, int m, int D, SeedPicker seedPicker) {
    assert (m &lt;= (M / 2));
    this.D = D;
    this.M = M;
    this.m = m;
    this.seedPicker = seedPicker;
    pointDims = new float[D];
    root = buildRoot(true);
}

public RTree(int M, int m, int D) {
    this(M, m, D, SeedPicker.LINEAR);
}

/**
 * 使用默认参数构造一个R-Tree
 */
public RTree() {
    this(DEFAULT_M, DEFAULT_m, DEFAULT_D, SeedPicker.LINEAR);
}

/**
 * 构造根节点
 *
 * @param asLeaf : 根节点是否为叶子节点
 * @return
 */
private Node buildRoot(boolean asLeaf) {
    float[] initCoords = new float[D];
    float[] initDimensions = new float[D];
    for (int i = 0; i &lt; this.D; i++) {
        initCoords[i] = (float) Math.sqrt(Float.MAX_VALUE);
        initDimensions[i] = -2.0f * (float) Math.sqrt(Float.MAX_VALUE);
    }
    return new Node(initCoords, initDimensions, asLeaf);
}

/**
 * getter
 */
public int getMaxEntries() {
    return M;
}

public int getMinEntries() {
    return m;
}

public int getNumDims() {
    return D;
}

public int size() {
    return size;
}

/**
 * 在R-Tee中搜索和给定矩形有重叠(overlapping)的对象
 * 
 * @param coords 矩形的一个顶点(比如左上角)
 * @param dimensions 矩形长度.
 * 返回对象List,这些对象的最小边界矩形(MBR)和给定矩形重叠
 */
public List&lt;T&gt; search(float[] coords, float[] dimensions) {
    assert (coords.length == D);
    assert (dimensions.length == D);

    LinkedList&lt;T&gt; results = new LinkedList&lt;T&gt;();
    search(coords, dimensions, root, results);

    return results;
}

private void search(float[] coords, float[] dimensions, Node n, LinkedList&lt;T&gt; results) {
    if (n.leaf) {
        for (Node e : n.children) {
            if (isOverlap(coords, dimensions, e.coords, e.dimensions)) {
                results.add(((Entry) e).entry);
            }
        }
    } else {
        for (Node c : n.children) {
            if (isOverlap(coords, dimensions, c.coords, c.dimensions)) {
                search(coords, dimensions, c, results); //继续在孩子节点中搜索
            }
        }
    }
}

/**
 * 删除R-Tree中在矩形rect内的数据entry
 * 
 * @param coords : 矩形的一个顶点(比如左上角)
 * @param dimensions : 矩形长度
 * @param entry : 待删除数据
 * 删除成功返回true
 */
public boolean delete(float[] coords, float[] dimensions, T entry) {
    assert (coords.length == D);
    assert (dimensions.length == D);
    Node l = findLeaf(root, coords, dimensions, entry);
    if (l == null) {
        System.out.println("WTF?");
        findLeaf(root, coords, dimensions, entry);
    }
    assert (l != null) : "Could not find leaf for entry to delete";
    assert (l.leaf) : "Entry is not found at leaf?!?";
    ListIterator&lt;Node&gt; li = l.children.listIterator();
    T removed = null;
    while (li.hasNext()) {
        @SuppressWarnings("unchecked")
        Entry e = (Entry) li.next();
        if (e.entry.equals(entry)) {
            removed = e.entry;
            li.remove();
            break;
        }
    }
    if (removed != null) {
        condenseTree(l);
        size--;
    }
    if (size == 0) {
        root = buildRoot(true);
    }
    return (removed != null);
}

public boolean delete(float[] coords, T entry) {
    return delete(coords, pointDims, entry);
}

/**
 * 查找数据 entry 对应的叶子节点
 * @param n
 * @param coords
 * @param dimensions
 * @param entry
 * @return
 */
private Node findLeaf(Node n, float[] coords, float[] dimensions, T entry) {
    if (n.leaf) {
        for (Node c : n.children) {
            if (((Entry) c).entry.equals(entry)) {
                return n;
            }
        }
        return null;
    } else {
        for (Node c : n.children) {
            if (isOverlap(c.coords, c.dimensions, coords, dimensions)) {
                Node result = findLeaf(c, coords, dimensions, entry);
                if (result != null) {
                    return result;
                }
            }
        }
        return null;
    }
}

/**
 * 压缩树
 * @param n
 */
private void condenseTree(Node n) {
    Set&lt;Node&gt; q = new HashSet&lt;Node&gt;();
    while (n != root) {
        if (n.leaf &amp;&amp; (n.children.size() &lt; m)) {
            q.addAll(n.children);
            n.parent.children.remove(n);
        } else if (!n.leaf &amp;&amp; (n.children.size() &lt; m)) {
            // probably a more efficient way to do this...
            LinkedList&lt;Node&gt; toVisit = new LinkedList&lt;Node&gt;(n.children);
            while (!toVisit.isEmpty()) {
                Node c = toVisit.pop();
                if (c.leaf) {
                    q.addAll(c.children);
                } else {
                    toVisit.addAll(c.children);
                }
            }
            n.parent.children.remove(n);
        } else {
            tighten(n);
        }
        n = n.parent;
    }
    if (root.children.size() == 0) {
        root = buildRoot(true);
    } else if ((root.children.size() == 1) &amp;&amp; (!root.leaf)) {
        root = root.children.get(0);
        root.parent = null;
    } else {
        tighten(root);
    }
    for (Node ne : q) {
        @SuppressWarnings("unchecked")
        Entry e = (Entry) ne;
        insert(e.coords, e.dimensions, e.entry);
    }
    size -= q.size();
}

/**
 * 清空整个R-Tree
 */
public void clear() {
    root = buildRoot(true);
    //让GC做剩余的事情...
}

/**
 * 在RTree中插入数据entry, 和矩形匹配.
 * 
 * @param coords : 矩形的一个顶点(比如左上角)
 * @param dimensions : 矩形长度
 * @param entry : 待出入数据
 */
public void insert(float[] coords, float[] dimensions, T entry) {
    assert (coords.length == D);
    assert (dimensions.length == D);
    Entry e = new Entry(coords, dimensions, entry);
    Node l = chooseLeaf(root, e);
    l.children.add(e);
    size++;
    e.parent = l;
    if (l.children.size() &gt; M) {
        Node[] splits = splitNode(l);
        adjustTree(splits[0], splits[1]);
    } else {
        adjustTree(l, null);
    }
}

/**
 * Convenience method for inserting a point
 * 
 * @param coords
 * @param entry
 */
public void insert(float[] coords, T entry) {
    insert(coords, pointDims, entry);
}

private void adjustTree(Node n, Node nn) {
    if (n == root) {
        if (nn != null) {
            // build new root and add children.
            root = buildRoot(false);
            root.children.add(n);
            n.parent = root;
            root.children.add(nn);
            nn.parent = root;
        }
        tighten(root);
        return;
    }
    tighten(n);
    if (nn != null) {
        tighten(nn);
        if (n.parent.children.size() &gt; M) {
            Node[] splits = splitNode(n.parent);
            adjustTree(splits[0], splits[1]);
        }
    }
    if (n.parent != null) {
        adjustTree(n.parent, null);
    }
}

private Node[] splitNode(Node n) {
    // TODO: this class probably calls "tighten" a little too often.
    // For instance the call at the end of the "while (!cc.isEmpty())" loop
    // could be modified and inlined because it's only adjusting for the addition
    // of a single node. Left as-is for now for readability.
    @SuppressWarnings("unchecked")
    Node[] nn = new RTree.Node[] { n, new Node(n.coords, n.dimensions, n.leaf) };
    nn[1].parent = n.parent;
    if (nn[1].parent != null) {
        nn[1].parent.children.add(nn[1]);
    }
    LinkedList&lt;Node&gt; cc = new LinkedList&lt;Node&gt;(n.children);
    n.children.clear();
    Node[] ss = seedPicker == SeedPicker.LINEAR ? lPickSeeds(cc) : qPickSeeds(cc);
    nn[0].children.add(ss[0]);
    nn[1].children.add(ss[1]);
    tighten(nn);
    while (!cc.isEmpty()) {
        if ((nn[0].children.size() &gt;= m) &amp;&amp; (nn[1].children.size() + cc.size() == m)) {
            nn[1].children.addAll(cc);
            cc.clear();
            tighten(nn); // Not sure this is required.
            return nn;
        } else if ((nn[1].children.size() &gt;= m) &amp;&amp; (nn[0].children.size() + cc.size() == m)) {
            nn[0].children.addAll(cc);
            cc.clear();
            tighten(nn); // Not sure this is required.
            return nn;
        }
        Node c = seedPicker == SeedPicker.LINEAR ? lPickNext(cc) : qPickNext(cc, nn);
        Node preferred;
        float e0 = getRequiredExpansion(nn[0].coords, nn[0].dimensions, c);
        float e1 = getRequiredExpansion(nn[1].coords, nn[1].dimensions, c);
        if (e0 &lt; e1) {
            preferred = nn[0];
        } else if (e0 &gt; e1) {
            preferred = nn[1];
        } else {
            float a0 = getArea(nn[0].dimensions);
            float a1 = getArea(nn[1].dimensions);
            if (a0 &lt; a1) {
                preferred = nn[0];
            } else if (e0 &gt; a1) {
                preferred = nn[1];
            } else {
                if (nn[0].children.size() &lt; nn[1].children.size()) {
                    preferred = nn[0];
                } else if (nn[0].children.size() &gt; nn[1].children.size()) {
                    preferred = nn[1];
                } else {
                    preferred = nn[(int) Math.round(Math.random())];
                }
            }
        }
        preferred.children.add(c);
        tighten(preferred);
    }
    return nn;
}

// Implementation of Quadratic PickSeeds
private RTree&lt;T&gt;.Node[] qPickSeeds(LinkedList&lt;Node&gt; nn) {
    @SuppressWarnings("unchecked")
    RTree&lt;T&gt;.Node[] bestPair = new RTree.Node[2];
    float maxWaste = -1.0f * Float.MAX_VALUE;
    for (Node n1 : nn) {
        for (Node n2 : nn) {
            if (n1 == n2)
                continue;
            float n1a = getArea(n1.dimensions);
            float n2a = getArea(n2.dimensions);
            float ja = 1.0f;
            for (int i = 0; i &lt; D; i++) {
                float jc0 = Math.min(n1.coords[i], n2.coords[i]);
                float jc1 = Math.max(n1.coords[i] + n1.dimensions[i], n2.coords[i] + n2.dimensions[i]);
                ja *= (jc1 - jc0);
            }
            float waste = ja - n1a - n2a;
            if (waste &gt; maxWaste) {
                maxWaste = waste;
                bestPair[0] = n1;
                bestPair[1] = n2;
            }
        }
    }
    nn.remove(bestPair[0]);
    nn.remove(bestPair[1]);
    return bestPair;
}

/**
 * Implementation of QuadraticPickNext
 * 
 * @param cc the children to be divided between the new nodes, one item will be removed from this list.
 * @param nn the candidate nodes for the children to be added to.
 */
private Node qPickNext(LinkedList&lt;Node&gt; cc, Node[] nn) {
    float maxDiff = -1.0f * Float.MAX_VALUE;
    Node nextC = null;
    for (Node c : cc) {
        float n0Exp = getRequiredExpansion(nn[0].coords, nn[0].dimensions, c);
        float n1Exp = getRequiredExpansion(nn[1].coords, nn[1].dimensions, c);
        float diff = Math.abs(n1Exp - n0Exp);
        if (diff &gt; maxDiff) {
            maxDiff = diff;
            nextC = c;
        }
    }
    assert (nextC != null) : "No node selected from qPickNext";
    cc.remove(nextC);
    return nextC;
}

// Implementation of LinearPickSeeds
private RTree&lt;T&gt;.Node[] lPickSeeds(LinkedList&lt;Node&gt; nn) {
    @SuppressWarnings("unchecked")
    RTree&lt;T&gt;.Node[] bestPair = new RTree.Node[2];
    boolean foundBestPair = false;
    float bestSep = 0.0f;
    for (int i = 0; i &lt; D; i++) {
        float dimLb = Float.MAX_VALUE, dimMinUb = Float.MAX_VALUE;
        float dimUb = -1.0f * Float.MAX_VALUE, dimMaxLb = -1.0f * Float.MAX_VALUE;
        Node nMaxLb = null, nMinUb = null;
        for (Node n : nn) {
            if (n.coords[i] &lt; dimLb) {
                dimLb = n.coords[i];
            }
            if (n.dimensions[i] + n.coords[i] &gt; dimUb) {
                dimUb = n.dimensions[i] + n.coords[i];
            }
            if (n.coords[i] &gt; dimMaxLb) {
                dimMaxLb = n.coords[i];
                nMaxLb = n;
            }
            if (n.dimensions[i] + n.coords[i] &lt; dimMinUb) {
                dimMinUb = n.dimensions[i] + n.coords[i];
                nMinUb = n;
            }
        }
        float sep = (nMaxLb == nMinUb) ? -1.0f : Math.abs((dimMinUb - dimMaxLb) / (dimUb - dimLb));
        if (sep &gt;= bestSep) {
            bestPair[0] = nMaxLb;
            bestPair[1] = nMinUb;
            bestSep = sep;
            foundBestPair = true;
        }
    }
    // In the degenerate case where all points are the same, the above
    // algorithm does not find a best pair. Just pick the first 2
    // children.
    if (!foundBestPair) {
        bestPair = new RTree.Node[] { nn.get(0), nn.get(1) };
    }
    nn.remove(bestPair[0]);
    nn.remove(bestPair[1]);
    return bestPair;
}

/**
 * Implementation of LinearPickNext
 * 
 * @param cc the children to be divided between the new nodes, one item will be removed from this list.
 */
private Node lPickNext(LinkedList&lt;Node&gt; cc) {
    return cc.pop();
}

private void tighten(Node... nodes) {
    assert (nodes.length &gt;= 1) : "Pass some nodes to tighten!";
    for (Node n : nodes) {
        assert (n.children.size() &gt; 0) : "tighten() called on empty node!";
        float[] minCoords = new float[D];
        float[] maxCoords = new float[D];
        for (int i = 0; i &lt; D; i++) {
            minCoords[i] = Float.MAX_VALUE;
            maxCoords[i] = Float.MIN_VALUE;

            for (Node c : n.children) {
                // we may have bulk-added a bunch of children to a node (eg. in
                // splitNode)
                // so here we just enforce the child-&gt;parent relationship.
                c.parent = n;
                if (c.coords[i] &lt; minCoords[i]) {
                    minCoords[i] = c.coords[i];
                }
                if ((c.coords[i] + c.dimensions[i]) &gt; maxCoords[i]) {
                    maxCoords[i] = (c.coords[i] + c.dimensions[i]);
                }
            }
        }
        for (int i = 0; i &lt; D; i++) {
            // Convert max coords to dimensions
            maxCoords[i] -= minCoords[i];
        }
        System.arraycopy(minCoords, 0, n.coords, 0, D);
        System.arraycopy(maxCoords, 0, n.dimensions, 0, D);
    }
}

private RTree&lt;T&gt;.Node chooseLeaf(RTree&lt;T&gt;.Node n, RTree&lt;T&gt;.Entry e) {
    if (n.leaf) {
        return n;
    }
    float minInc = Float.MAX_VALUE;
    Node next = null;
    for (RTree&lt;T&gt;.Node c : n.children) {
        float inc = getRequiredExpansion(c.coords, c.dimensions, e);
        if (inc &lt; minInc) {
            minInc = inc;
            next = c;
        } else if (inc == minInc) {
            float curArea = 1.0f;
            float thisArea = 1.0f;
            for (int i = 0; i &lt; c.dimensions.length; i++) {
                curArea *= next.dimensions[i];
                thisArea *= c.dimensions[i];
            }
            if (thisArea &lt; curArea) {
                next = c;
            }
        }
    }
    return chooseLeaf(next, e);
}

/**
 * Returns the increase in area necessary for the given rectangle to cover the given entry.
 */
private float getRequiredExpansion(float[] coords, float[] dimensions, Node e) {
    float area = getArea(dimensions);
    float[] deltas = new float[dimensions.length];
    for (int i = 0; i &lt; deltas.length; i++) {
        if (coords[i] + dimensions[i] &lt; e.coords[i] + e.dimensions[i]) {
            deltas[i] = e.coords[i] + e.dimensions[i] - coords[i] - dimensions[i];
        } else if (coords[i] + dimensions[i] &gt; e.coords[i] + e.dimensions[i]) {
            deltas[i] = coords[i] - e.coords[i];
        }
    }
    float expanded = 1.0f;
    for (int i = 0; i &lt; dimensions.length; i++) {
        expanded *= dimensions[i] + deltas[i];
    }
    return (expanded - area);
}

private float getArea(float[] dimensions) {
    float area = 1.0f;
    for (int i = 0; i &lt; dimensions.length; i++) {
        area *= dimensions[i];
    }
    return area;
}

private boolean isOverlap(float[] scoords, float[] sdimensions, float[] coords, float[] dimensions) {
    final float FUDGE_FACTOR = 1.001f;
    for (int i = 0; i &lt; scoords.length; i++) {
        boolean overlapInThisDimension = false;
        if (scoords[i] == coords[i]) {
            overlapInThisDimension = true;
        } else if (scoords[i] &lt; coords[i]) {
            if (scoords[i] + FUDGE_FACTOR * sdimensions[i] &gt;= coords[i]) {
                overlapInThisDimension = true;
            }
        } else if (scoords[i] &gt; coords[i]) {
            if (coords[i] + FUDGE_FACTOR * dimensions[i] &gt;= scoords[i]) {
                overlapInThisDimension = true;
            }
        }
        if (!overlapInThisDimension) {
            return false;
        }
    }
    return true;
}

/**
 * 节点
 */
private class Node {
    /**
     * 高维矩形的一个定点,如左下角
     */
    final float[] coords;

    /**
     * 矩形的长度
     */
    final float[] dimensions;

    /**
     * 孩子节点
     */
    final LinkedList&lt;Node&gt; children;

    /**
     * 是否为叶子节点
     */
    final boolean leaf;

    /**
     * 父亲节点
     */
    Node parent;

    private Node(float[] coords, float[] dimensions, boolean leaf) {
        this.coords = new float[coords.length];
        this.dimensions = new float[dimensions.length];
        System.arraycopy(coords, 0, this.coords, 0, coords.length);
        System.arraycopy(dimensions, 0, this.dimensions, 0, dimensions.length);
        this.leaf = leaf;
        children = new LinkedList&lt;Node&gt;();
    }
}

/**
 * 实体,代表一个数据项
 * 注意:不是叶子节点,其父亲才是叶子节点
 */
private class Entry extends Node {
    /**
     * 数据
     */
    final T entry;

    public Entry(float[] coords, float[] dimensions, T entry) {
        super(coords, dimensions, true);
        this.entry = entry;
    }

    public String toString() {
        return "Entry: " + entry;
    }
}
</code></pre>

<p>}
```</p>

<h3>参考</h3>

<p><a href="http://publib.boulder.ibm.com/infocenter/idshelp/v10/index.jsp?topic=/com.ibm.rtree.doc/rtree29.htm">http://publib.boulder.ibm.com/infocenter/idshelp/v10/index.jsp?topic=/com.ibm.rtree.doc/rtree29.htm</a></p>
]]></content>
  </entry>
  
</feed>
