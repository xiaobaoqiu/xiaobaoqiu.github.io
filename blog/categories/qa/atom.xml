<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Qa | xiaobaoqiu Blog]]></title>
  <link href="http://xiaobaoqiu.github.io/blog/categories/qa/atom.xml" rel="self"/>
  <link href="http://xiaobaoqiu.github.io/"/>
  <updated>2015-08-01T11:57:33+08:00</updated>
  <id>http://xiaobaoqiu.github.io/</id>
  <author>
    <name><![CDATA[xiaobaoqiu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AB简单使用]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/01/15/abjian-dan-shi-yong/"/>
    <updated>2015-01-15T22:04:47+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/01/15/abjian-dan-shi-yong</id>
    <content type="html"><![CDATA[<p>简单熟悉Apache附带的压测工具ab，它非常容易使用，ab可以直接在Web服务器本地发起测试请求。</p>

<p>需要清楚的是，ab进行一切测试的本质都是基于HTTP，所以可以说它是对于Web服务器软件的黑盒性能测试，它获得的一切数据和计算结果，都可以通过HTTP来解释。</p>

<p>本文的ab版本信息：
<code>
xiaobaoqiu@xiaobaoqiu:~/octopress/source/images/io$ ab -V
This is ApacheBench, Version 2.3 &lt;$Revision: 1430300 $&gt;
Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/
Licensed to The Apache Software Foundation, http://www.apache.org/
</code></p>

<h1>1.参数</h1>

<p>所有的参数及意义如下：
<code>
Usage: ab [options] [http[s]://]hostname[:port]/path
Options are:
    -n requests     总请求数目，要访问页面的次数，默认为1
    -c concurrency  同一时刻的并发请求数目，默认1
    -t timelimit    测试进行的最大秒数，内部隐含值为50000，默认无时间限制
    -s timeout      response超时时间，默认30秒
    -b windowsize   TCP buffer的大小，单位是bytes
    -B address      指定发出请求的本地ip地址
    -p postfile     包含待POST的数据的文件，需要设置参数-T
    -u putfile      包含待PUT的数据的文件，需要设置参数-T
    -T content-type POST/PUT 数据的Content-type header信息, 比如.
                    'application/x-www-form-urlencoded'
                    默认是'text/plain'
    -v verbosity    设置显示信息的详细程度，-
                    4或者更大的值会显示头信息，3或者更大的值可以显示响应代码(200等)，2或者更大可以显示警告和其他信息。
    -w              已html表格的形式输出结果
    -i              执行HEAD请求，而不是GET
    -x attributes   设置&lt;table&gt;属性的字符串,此属性被填入&lt;table 这里&gt;
    -y attributes   设置&lt;tr&gt;属性的字符串
    -z attributes   设置&lt;td&gt;或者&lt;th&gt;属性的字符串
    -C attribute    对请求附加一个Cookie行，其典型形式是name=value的一个参数对，  
                    此参数可以重复。
    -H attribute    对请求附加额外的头信息。此参数的典型形式是一个有效的头信息行，其中包含
                    了以冒号分隔的字段和值的对 (如, "Accept-Encoding: zip/zop;8bit")
    -A attribute    对服务器提供BASIC认证信任。用户名和密码由一个:隔开，并以base64编码形
                    式发送。无论服务器是否需要(即, 是否发送了401认证需求代码)，此字符串都会被发送。
    -P attribute    对一个中转代理提供BASIC认证信任。用户名和密码由一个:隔开，并以base64
                    编码形式发送。无论服务器是否需要(即, 是否发送了401认证需求代码)，此字符串都会被发送。
    -X proxy:port   对请求使用代理服务器
    -V              版本信息
    -k              启用HTTP KeepAlive功能，即在一个HTTP会话中执行多个请求。
                    默认时，不启用KeepAlive功能Use HTTP KeepAlive feature
    -d              不显示"percentage served within XX [ms] table"的消息.
    -S              Do not show confidence estimators and warnings.
    -q              如果处理的请求数大于150，  
                    ab每处理大约10%或者100个请求时，会在stderr输出一个进度计数。 此-q标记可以抑制这些信息。
    -g filename     Output collected data to gnuplot format file.
    -e filename     产生一个以逗号分隔的(CSV)文件，其中包含了处理每个相应百分比的请求
                    所需要(从1%到100%)的相应百分比的(以微妙为单位)时间。由于这种格式已经“二进制化”，所以比'gnuplot'格式更有用。
    -r              socket接收错误的时候也不退出
    -h              显示usage信息
</code></p>

<h1>2.简单使用及结果解析</h1>

<p>就对我的博客进行压测，结果如下，简单加入了一些我的注释：
```
xiaobaoqiu@xiaobaoqiu:~/octopress/source/images/io$ ab -n 10 -c 2 -s 10 <a href="http://xiaobaoqiu.github.io/">http://xiaobaoqiu.github.io/</a>
This is ApacheBench, Version 2.3 &lt;$Revision: 1430300 $>
Copyright 1996 Adam Twiss, Zeus Technology Ltd, <a href="http://www.zeustech.net/">http://www.zeustech.net/</a>
Licensed to The Apache Software Foundation, <a href="http://www.apache.org/">http://www.apache.org/</a></p>

<p>Benchmarking xiaobaoqiu.github.io (be patient)&hellip;..done</p>

<p>Server Software:        GitHub.com
Server Hostname:        xiaobaoqiu.github.io
Server Port:            80</p>

<p>Document Path:          /
Document Length:        287269 bytes</p>

<p>Concurrency Level:      2
Time taken for tests:   20.788 seconds
Complete requests:      10
Failed requests:        0
Write errors:           0
Total transferred:      2877109 bytes
HTML transferred:       2872690 bytes
Requests per second:    0.48 [#/sec] (mean)
Time per request:       4157.564 [ms] (mean)    #每个请求的时间
Time per request:       2078.782 [ms] (mean, across all concurrent requests)
Transfer rate:          135.16 [Kbytes/sec] received</p>

<p>Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:       59  402 717.5     94    2234
Processing:   362 3674 3112.7   3479    8508
Waiting:       60  164 132.8    100     407
Total:        422 4076 3420.4   3558    8602</p>

<p>Percentage of the requests served within a certain time (ms)
  50%   3558        #50%的请求响应时间小于3558毫秒
  66%   7110
  75%   7312
  80%   8544
  90%   8602
  95%   8602
  98%   8602
  99%   8602
 100%   8602 (longest request)  #请求的最长响应时间为8602毫秒
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Selenium]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2014/12/15/selenium/"/>
    <updated>2014-12-15T17:45:32+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2014/12/15/selenium</id>
    <content type="html"><![CDATA[<h1>1.什么是Selenium</h1>

<p>Selenium 是一种 Web 应用的自动测试工具，通过模拟用户对 Web 页面的各种操作，可以精确重现软件测试人员编写的 Test Cases 步骤。它所采用的原理是通过录制应用程序产生的线性脚本进行回放从而达到自动化测试的目的。其优点是简单，通过录制就可以得到所需脚本。类似于录制/回放测试工具有很多，我们之所以选择它的原因是它是开源的，而且它测试直接在浏览器中运行，就像真实用户所做的一样。Selenium测试可以在 Windows、Linux上的 Internet Explorer、Mozilla和 Firefox 中运行。其他测试工具都不能覆盖如此多的平台，更重要的是Selenium支持多种语言、JAVA、Ruby、Python等。</p>

<p>Selenium的核心，也称browser bot,是用JavaScript编写的。这使得测试脚本可以在受支持的浏览器中运行。browser bot负责执行从测试脚本接收到的命令，测试脚本要么是用 HTML的表布局编写的，要么是使用一种受支持的编程语言编写的。</p>

<h3>1.1 Selenium名字的来源</h3>

<p>Selenium的中文名为“硒”，是一种化学元素的名字，它对汞（Mercury）有天然的解毒作用，实验表明汞暴露水平越高，硒对汞毒性的拮抗作用越明显，所以说硒是汞的克星。大家应该知道Mercury测试工具系 列吧（QTP，QC，LR，WR&hellip;），他们功能强大，但却价格不菲，大家对此又爱又恨！故thoughtworks特意把他们的Web开源测试工具命 名为Selenium，以此帮助大家脱离汞毒。</p>

<p>Selenium 是thoughtworks所做的，用于Web应用程序测试的工具。Selenium测试直接运行在浏览器中，就像真正的用户在操作一样。支持的浏览器包括IE、Mozilla Firefox、Mozilla Suite等。</p>

<p>在selenium2.0中，包含2个部分 selenium ide 和 selenium webdriver.</p>

<h3>1.2 优势</h3>

<p>使用 Selenium 和在浏览器中运行测试还有很多其他好处。下面是主要的两大好处：</p>

<pre><code>(1).通过编写模仿用户操作的 Selenium 测试脚本，可以从终端用户的角度来测试应用程序;
(2).通过在不同浏览器中运行测试，更容易发现浏览器的不兼容性;
</code></pre>

<h3>1.3 Selenium 模式</h3>

<p>可以按两种模式来使用test runner 和 driven,这两种模式在复杂性和编写方式方面有所不同。driven 测试脚本编写起来往往要更复杂一些，因为它们是用编程语言编写的。</p>

<p>两种模式之间最大的不同点在于:如果使用 driven 脚本，测试有一部分在浏览器之外运行，而如果使用 test runner 脚本的话，测试是完全在浏览器中运行的。</p>

<p>不管是 test runner 还是 driven 测试用例，都可以与持续集成工具集成。</p>

<p>本文这里只简单介绍了 driven 模式。</p>

<h1>2.driven 模式</h1>

<p>driven Selenium 脚本是用多种受支持的编程语言中的一种编写的,目前可用的有 Java、Ruby 和 Python 等驱动程序。这些脚本在浏览器之外的一个单独的进程中运行。驱动程序的任务是执行测试脚本，并通过与运行在浏览器中的 browser bot 进行通信来驱动浏览器。驱动程序与 browser bot 之间的通信使用一种简单的特定于 Selenium 的连接语言 Selenese。</p>

<p>driven 脚本比 test runner 脚本更强大、更灵活，可以将它们与 xUnit (比如JUnit)框架集成。driven 脚本的缺点（与 test runner 脚本相比）是，这种脚本编写和部署起来更复杂。这是因为驱动程序必须执行以下任务：</p>

<pre><code>(1).启动服务器;
(2).部署所测试的应用程序;
(3).部署测试脚本;
(4).启动浏览器;
(5).发送命令到 browser bot;
(6).验证 browser bot 执行的命令的结果;
</code></pre>

<h1>3.简单case</h1>

<p>这里用Java实现一个简单的使用Selenium的case</p>

<h3>3.1 Maven包</h3>

<p>使用现有的maven包：
<code>java
&lt;dependency&gt;
    &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;
    &lt;artifactId&gt;selenium-java&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></p>

<h3>3.2 简单case</h3>

<p>下面结合JUnit以打开google为例子：
```java
import com.google.common.collect.Lists;
import com.qunar.scm.common.BrowserDriver;
import org.apache.commons.collections.CollectionUtils;
import org.junit.Assert;
import org.junit.Test;
import org.openqa.selenium.By;
import org.openqa.selenium.Keys;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;</p>

<p>import java.util.List;</p>

<p>/<em>*
 * 测试Google
 *
 * @author <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#58;&#x62;&#x61;&#x6f;&#x71;&#x69;&#117;&#x2e;&#120;&#105;&#x61;&#111;&#64;&#x71;&#x75;&#x6e;&#97;&#x72;&#46;&#x63;&#111;&#x6d;">&#98;&#x61;&#111;&#x71;&#x69;&#117;&#x2e;&#x78;&#105;&#97;&#111;&#x40;&#x71;&#x75;&#x6e;&#97;&#114;&#x2e;&#99;&#x6f;&#x6d;</a>  Date: 14-12-31 Time: 下午1:42
 * @version \$Id$
 </em>/
public class GoogleTest extends AbstractBaseTest {</p>

<pre><code>private static final Logger logger = LoggerFactory.getLogger(GoogleTest.class);

private static final String GOOGLE_URL = "https://www.google.com.hk";

@Test
public void testGoogle() {
    //当前测试case名称
    caseName = Thread.currentThread().getStackTrace()[1].getMethodName();

    boolean flag = testCommonProcess(currentDriverList(), new BrowserVisiter() {
        @Override
        public boolean visit(BrowserDriver browserDriver) {
            return doTestGoogle(browserDriver);
        }
    });

    Assert.assertTrue(flag);
}

/**
 * 实际的测试逻辑
 *
 * @param browserDriver
 */
private boolean doTestGoogle(final BrowserDriver browserDriver) {
    if(browserDriver == null) {
        logger.error("browserDriver is null");
        return false;
    }

    WebDriver driver = browserDriver.getWebDriver();

    //1.打开页面
    driver.get(GOOGLE_URL);
    driver.manage().window().maximize();
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }

    //2.在搜索框内输入关键字,输入回车
    WebElement keyWord = driver.findElement(By.name("q"));
    keyWord.sendKeys("xiaobaoqiu");
    keyWord.sendKeys(Keys.RETURN);

    return true;
}



/**
 * 当前需要测试的浏览器列表，这里只使用了firefox
 *
 * @return
 */
@Override
protected List&lt;BrowserDriver&gt; currentDriverList() {
    return Lists.newArrayList(BrowserDriver.FIREFOX_DRIVER);
}

/**
 * 生成测试报告
 *
 * @param driverList
 * @param result
 */
@Override
protected void doReportResult(List&lt;BrowserDriver&gt; driverList, List&lt;Boolean&gt; result) {
    if (CollectionUtils.isEmpty(driverList) || CollectionUtils.isEmpty(result)) {
        logger.error("isEmpty(driverList) or isEmpty(result)");
        return;
    }

    if (driverList.size() != result.size()) {
        logger.error("driverList.size() != result.size()");
        return;
    }

    logger.info("BEG====================================={}=====================================BEG", caseName);
    for (int i = 0; i &lt; driverList.size(); i++) {
        logger.info("{} = {}", driverList.get(i).getBrowser().getName(), resultString(result.get(i)));
    }
    logger.info("END====================================={}=====================================END", caseName);
}
</code></pre>

<p>}
```
结果：</p>

<p>{% img /images/selenium/selenium_page_result.png %}</p>

<p>{% img /images/selenium/selenium_code_result.png %}</p>

<h3>3.3 注意点</h3>

<p>一些Selenuim的注意点，持续补充中：</p>

<pre><code>(1).Selenium默认状态下只支持Firefox，支持Chrome和IE需要安装插件;
</code></pre>

<h1>4.参考</h1>

<p><a href="http://code.google.com/p/selenium/">http://code.google.com/p/selenium/</a></p>

<p><a href="https://www.ibm.com/developerworks/cn/java/wa-selenium-ajax/">https://www.ibm.com/developerworks/cn/java/wa-selenium-ajax/</a></p>
]]></content>
  </entry>
  
</feed>
