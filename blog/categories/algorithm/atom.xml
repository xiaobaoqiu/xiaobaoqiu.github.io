<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | xiaobaoqiu Blog]]></title>
  <link href="http://xiaobaoqiu.github.io/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://xiaobaoqiu.github.io/"/>
  <updated>2016-04-20T10:35:04+08:00</updated>
  <id>http://xiaobaoqiu.github.io/</id>
  <author>
    <name><![CDATA[xiaobaoqiu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[局部敏感Hash]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/11/21/ju-bu-min-gan-hash/"/>
    <updated>2015-11-21T12:05:25+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/11/21/ju-bu-min-gan-hash</id>
    <content type="html"><![CDATA[<ul>
<li><a href="#1.LSH%E7%AE%80%E4%BB%8B">1.LSH简介</a></li>
<li><a href="#2.%E6%99%AE%E9%80%9AHash">2.普通Hash</a></li>
<li><a href="#3.LSH">3.LSH</a></li>
</ul>


<h2 id="1.LSH简介">1.LSH简介</h2>


<p>之前在项目中做数据聚合去重的逻辑的时候简单看过局部敏感Hash(Locality Sensitive Hashing,简称LSH)这个东东。今天整理一下个人的理解。</p>

<p>LSH可以理解为一种衡量文本相似度的算法，特点是散列前的相似点经过哈希之后，也能够在一定程度上相似，并且具有一定的概率保证。其有坚实的理论依据(98年左右理论就提出来了，99年有第一版实现)并且在高维数据空间中表现优异。简单的价格实验场景：</p>

<ol>
<li>近似检测(Near-duplicate detection): 通常运用在网页去重方面。在搜索中往往会遇到内容相似的重复页面，它们中大多是由于网站之间转载造成的。可以对页面计算LSH，通过查找相等或相近的LSH值找到Near-duplicate。</li>
<li>图像、音频检索: 通常图像、音频文件都比较大，并且比较起来相对麻烦，我们可以事先对其计算LSH，用作信息指纹，这样可以给定一个文件的LSH值，快速找到与其相等或相近的图像和文件。</li>
<li>聚类: 将LSH值作为样本特征，将相同或相近的LSH值的样本合并在一起作为一个类别。</li>
<li>指纹匹配: 一个手指指纹通常由一些细节来表征，通过对比较两个手指指纹的细节的相似度就可以确定两个指纹是否相同或相似。</li>
</ol>


<p>LSH的发展历史可以参考： <a href="http://jacoxu.com/?p=496">http://jacoxu.com/?p=496</a></p>

<h2 id="2.普通Hash">2.普通Hash</h2>


<p>说到Hash，大家都很熟悉，是一种典型的Key-Value结构，最常见的算法莫过于MD5。其设计思想是使Key集合中的任意关键字能够尽可能均匀的变换到Value空间中，不同的Key对应不同的Value。通过建立Hash的方式我们能够得到O(1)的查找时间性能，其中关键在于选取一个hash function(md5就是一致hash function)。</p>

<p>md5这种hash函数通常情况下，Key值只有轻微变化，Value值也会发生很大地变化。比如下面实验中用到的文本，仅仅是邮箱号少了个.，其md5完全不同：</p>

<pre><code>xiaobaoqiu@xiaobaoqiu:~/temp/md5$ cat 1.dat 
xiaobaoqiu@qunar.com
xiaobaoqiu@xiaobaoqiu:~/temp/md5$ cat 2.dat 
xiaobaoqiu@qunarcom
xiaobaoqiu@xiaobaoqiu:~/temp/md5$ md5sum 1.dat 
ca201d44a9bb6f8e0ca761cdeb678948  1.dat
xiaobaoqiu@xiaobaoqiu:~/temp/md5$ md5sum 2.dat 
f585aa440eb3b8bbc46f1184e2944fb9  2.dat
</code></pre>

<p>原始文本是极其相似的，但是hash之后这种相似性就丢失了。</p>

<h2 id="3.LSH">3.LSH</h2>


<p>局部敏感哈希的最大特点就在于保持数据的相似性。需要注意的是这里说的保持数据的相似度不是说保持100%的相似度，而是保持最大可能的相似度。换个角度来看，可以将LSH理解为数据降维的方法。</p>

<p>数据对应的维度越高，信息量也就越大，相反，如果数据进行了降维，那么毫无疑问数据所反映的信息必然会有损失。哈希函数从本质上来看就是一直在扮演数据降维的角色。</p>

<p>LSH的基本思想是：将原始数据空间中的两个相邻数据点通过相同的映射或投影变换后，这两个数据点在新的数据空间中仍然相邻的概率很大，而不相邻的数据点被映射到同一个桶的概率很小。</p>

<p>参考：
<a href="https://en.wikipedia.org/wiki/Locality-sensitive_hashing">https://en.wikipedia.org/wiki/Locality-sensitive_hashing</a>
<a href="http://www.cnblogs.com/maybe2030/p/4953039.html">http://www.cnblogs.com/maybe2030/p/4953039.html</a>
<a href="http://blog.csdn.net/weiyuweizhi/article/details/8921973">http://blog.csdn.net/weiyuweizhi/article/details/8921973</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据结构与算法分析第二章]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2014/06/29/shu-ju-jie-gou-yu-suan-fa-fen-xi-di-er-zhang/"/>
    <updated>2014-06-29T14:43:21+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2014/06/29/shu-ju-jie-gou-yu-suan-fa-fen-xi-di-er-zhang</id>
    <content type="html"><![CDATA[<p>&lt;&lt;数据结构与算法分析-C语言描述>></p>

<h1>1.最大子序列和</h1>

<h3>O(n<sup>3</sup>)</h3>

<pre><code class="c++">/**
* 时间复杂度O(n^3)
*/
int Chapter2::maxSubSeqSum1(const int A[], int N)
{
    int maxSum = 0;
    for(int i=0; i&lt;N; i++)
        for(int j=i; j&lt;N; j++)
        {
            int thisSum = 0;
            for(int k=i; k&lt;=j; k++)
                thisSum += A[k];
            if(thisSum &gt; maxSum) maxSum = thisSum;
        }

        return maxSum;
}
</code></pre>

<h3>O(n<sup>2</sup>)</h3>

<pre><code class="c">/**
*   算法1的最里层循环不是必须的
*   时间复杂度:O(n^2)
*/
int Chapter2::maxSubSeqSum2(const int A[], int N)
{
        int maxSum = 0;
        for(int i=0; i&lt;N; i++)
        {
                int thisSum = 0;
                for(int j=i; j&lt;N; j++)
                {
                        thisSum +=A[j];
                        if(thisSum &gt; maxSum)    maxSum = thisSum;
                }
        }

        return maxSum;
}
</code></pre>

<h3>分治,O(nlogn)</h3>

<pre><code class="c">/**
* 分治,划分为作用两个字数组
* A[l,...,M], A[M+1,...,R]
* 则最大子序列和来自三部分:左侧的最大子序列和,右侧的最大子序列和,跨越A[M]和A[M+1]的最大子序列号
* 1,2情况递归可以完成,情况三其实就是求最测以A[M]结尾的最大和,右侧就是以A[M+1]开头的最大和
*
* 时间复杂度:T(n) = 2T(n/2) + O(n)
* 即 O(nlogn)
*/
int Chapter2::maxSubSeqSum3(const int A[], int L, int R)
{
        if(L == R) return A[L] &lt; 0 ?0 : A[L];
        int M = (L + R) &gt;&gt; 1;
        int maxSumL = maxSubSeqSum3(A, L, M);
        int maxSumR = maxSubSeqSum3(A, M+1, R);
        int maxL = 0, sumL = 0;
        for(int i = M; i&gt;=L; i--)
        {
                sumL += A[i];
                if(sumL &gt; maxL) maxL = sumL;
        }
        int maxR = 0, sumR = 0;
        for(int i = M+1; i&lt;=R; i++)
        {
                sumR += A[i];
                if(sumR &gt; maxR) maxR = sumR;
        }

        return max(max(maxSumL, maxSumR), maxL+maxR);
}
</code></pre>

<h3>O(n)</h3>

<pre><code class="c">/**
* 时间复杂度 O(n)
*/
int Chapter2::maxSubSeqSum4(const int A[], int N)
{
        int maxSum = 0, thisSum = 0;
        for(int i=0; i&lt;N; i++)
        {
                thisSum += A[i];
                if(thisSum &gt; maxSum) maxSum = thisSum;
                else if(thisSum &lt; 0) thisSum = 0;
        }

        return maxSum;
}
</code></pre>

<h1>2.gcd</h1>

<pre><code class="c">unsigned int Chapter2::gcd(unsigned int L, unsigned int R)
{
        unsigned rem;
        while(R &gt; 0)
        {
                rem = L % R;
                L = R;
                R = rem;
        }
        return L;
}
</code></pre>

<h1>3.快速幂</h1>

<h3>递归</h3>

<pre><code class="c">long Chapter2::pow1(long x, unsigned n)
{
        if(n == 0) return 1;
        if(n == 1) return x;
        if(isEven((n))) return pow(x*x, n&gt;&gt;1);
        else return pow(x*x, n&gt;&gt;1) * x;
}
</code></pre>

<h3>非递归</h3>

<pre><code class="c">long Chapter2::pow2(long x, unsigned n)
{
        long base = x, ret = 1L;
        while(n &gt; 0)
        {
                if(isEven(n)) {base *= base; n&gt;&gt;=1;}
                else {ret *= base; n-=1;}
        }
        return ret;
}
</code></pre>

<h1>4.随机置换</h1>

<pre><code class="c">/**
* 生成前N个数的随机置换
* 如 N = 3, 生成 [2 1 3]
*/
void Chapter2::randomSeq(int* A, int N)
{
        for(int i=0; i&lt;N; i++)
                A[i] = i+1;
        for(int i=1; i&lt;N; i++)
        {
                swap(A[i], A[random(N)]);
        }
}
</code></pre>

<h1>5.出现次数超过一半的数</h1>

<pre><code class="c">/**
* 寻找数组的主要元素:即一个N个元素的数组中,某一个元素出现次数 &gt;= N/2次
* 如 [6, 8, 8, 2, 3, 4, 8, 8, 8]中8是主要元素
* 思路:比较A1和A2,相等则将A1放入一个新的数组B,不想等则放弃;同样比较A3,A4...
* 递归处理数组B
*
* 注意这里只是返回了一个候选解,如果存在,则一定是这个元素
* 不存在的情况需要再扫描一遍数组
*/
 int Chapter2::mainElement(const int* A, int N)
 {
    int Candidata, nTimes = 0, i=0;
    while(i &lt; N)
    {
        if(nTimes==0) { Candidata = A[i]; nTimes = 1; }
        else
        {
            if(A[i] != Candidata) --nTimes;
            else ++nTimes;
        }
        ++i;
    }
    return Candidata;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Closest Pair]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2014/06/04/closest-pair/"/>
    <updated>2014-06-04T10:42:08+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2014/06/04/closest-pair</id>
    <content type="html"><![CDATA[<h2>Problem:</h2>

<p>Given a set of points in a two dimensional space, you will have to find the distance between the closest two points.</p>

<p>示例:</p>

<h4>input</h4>

<pre><code>0 2
6 67
43 71
39 107
189 140
</code></pre>

<h4>output</h4>

<pre><code>36.2215
</code></pre>

<h2>Solutions:</h2>

<h3>1. Brute force</h3>

<p>计算全部n(n-1)/2对点对,找到最近的点对.</p>

<p>时间复杂度:O(n2)</p>

<p>空间复杂度:O(1)</p>

<h3>2. Divide and conquer</h3>

<p>步骤如下:
1. sort
按照x坐标(y坐标也可以)从小达到排序,时间复杂度O(nlogn);
2. divide
找到中间点q,用q将所有点P所有的点划分为左右两个部分PL和PR;
3. conquer
递归计算PL和PR这两个点集的最近距离,二者中的较小值记为d;
4. combine
取PL和PR中x坐标与点q的x坐标距离小于d的所有点(记为PM,即为一个宽度为2d的竖条带),将PM按照y坐标排序;遍历PM,在y坐标差值小于d的情况下计算距离;</p>

<p>其中1 2 3步骤很明显,步骤4技巧比较多:</p>

<ol>
<li>最多6个点满足y坐标差值小于d,就是说我们的遍历PM在O(k)时间内搞定(k为PM点的数目),证明见
 参考:<a href="http://www.cs.mcgill.ca/~cs251/ClosestPair/proofbox.html">http://www.cs.mcgill.ca/~cs251/ClosestPair/proofbox.html</a></li>
<li>计算距离,不用计算sqrt((x1-x2)<em>(x1-x2) + (y1-y2)</em>(y1-y2)),取sqrt内的值比较就可以;</li>
<li>按照y值排序PM,这是combine的性能瓶颈,我们可以在递归时候做merge排序,避免每次combine时候都重新排序的代价,因此combine的代价为O(n);</li>
</ol>


<p>总的时间代价:
<code>
T(n) = 2T(n/2) + O(n),即T(n)=O(nlogn)
</code>
参考代码如下:
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kn">import</span> <span class="nn">com.google.common.primitives.Doubles</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">java.awt.*</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">java.awt.geom.Point2D</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">java.util.Comparator</span><span class="o">;&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ClosestPair</span> <span class="o">{&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">// 最近的点对及其距离</span>
</span><span class='line'><span class="kd">private</span> <span class="n">Point2D</span> <span class="n">best1</span><span class="o">,</span> <span class="n">best2</span><span class="o">;</span>
</span><span class='line'><span class="kd">private</span> <span class="kt">double</span> <span class="n">bestDistance</span> <span class="o">=</span> <span class="n">Double</span><span class="o">.</span><span class="na">POSITIVE_INFINITY</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//x排序器</span>
</span><span class='line'><span class="kd">private</span> <span class="n">Comparator</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">Point2D</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">X_ORDER</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Comparator</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">Point2D</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;()</span> <span class="o">{</span>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">Point2D</span> <span class="n">o1</span><span class="o">,</span> <span class="n">Point2D</span> <span class="n">o2</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">Doubles</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">o1</span><span class="o">.</span><span class="na">getX</span><span class="o">(),</span> <span class="n">o2</span><span class="o">.</span><span class="na">getX</span><span class="o">());</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">};</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="nf">ClosestPair</span><span class="o">(</span><span class="n">Point2D</span><span class="o">[]</span> <span class="n">points</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">N</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;=</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//按照x排序</span>
</span><span class='line'>    <span class="n">Point2D</span><span class="o">[]</span> <span class="n">pointsByX</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">points</span><span class="o">,</span> <span class="n">N</span><span class="o">);</span>
</span><span class='line'>    <span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">pointsByX</span><span class="o">,</span> <span class="n">X_ORDER</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 检查重合的点</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">pointsByX</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="n">pointsByX</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]))</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">bestDistance</span> <span class="o">=</span> <span class="mf">0.0</span><span class="o">;</span>
</span><span class='line'>            <span class="n">best1</span> <span class="o">=</span> <span class="n">pointsByX</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span><span class='line'>            <span class="n">best2</span> <span class="o">=</span> <span class="n">pointsByX</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
</span><span class='line'>            <span class="k">return</span> <span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 用于按照y排序(这里还没排序)</span>
</span><span class='line'>    <span class="n">Point2D</span><span class="o">[]</span> <span class="n">pointsByY</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">pointsByX</span><span class="o">,</span> <span class="n">N</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 辅助数组</span>
</span><span class='line'>    <span class="n">Point2D</span><span class="o">[]</span> <span class="n">aux</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point2D</span><span class="o">[</span><span class="n">N</span><span class="o">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">closest</span><span class="o">(</span><span class="n">pointsByX</span><span class="o">,</span> <span class="n">pointsByY</span><span class="o">,</span> <span class="n">aux</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * 找pointsByX[lo..hi]中的最近点对</span>
</span><span class='line'><span class="cm"> * @param pointsByX : 按照x坐标排序好的点</span>
</span><span class='line'><span class="cm"> * @param pointsByY</span>
</span><span class='line'><span class="cm"> * @param aux : 辅助数组</span>
</span><span class='line'><span class="cm"> * @param lo : 最小下标</span>
</span><span class='line'><span class="cm"> * @param hi : 最大下标</span>
</span><span class='line'><span class="cm"> * @return</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kd">private</span> <span class="kt">double</span> <span class="nf">closest</span><span class="o">(</span><span class="n">Point2D</span><span class="o">[]</span> <span class="n">pointsByX</span><span class="o">,</span> <span class="n">Point2D</span><span class="o">[]</span> <span class="n">pointsByY</span><span class="o">,</span> <span class="n">Point2D</span><span class="o">[]</span> <span class="n">aux</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">hi</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;=</span> <span class="n">lo</span><span class="o">)</span> <span class="k">return</span> <span class="n">Double</span><span class="o">.</span><span class="na">POSITIVE_INFINITY</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 中间点</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">lo</span> <span class="o">+</span> <span class="n">hi</span><span class="o">)</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>    <span class="n">Point2D</span> <span class="n">median</span> <span class="o">=</span> <span class="n">pointsByX</span><span class="o">[</span><span class="n">mid</span><span class="o">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 递归求解左右子数组的最近点对</span>
</span><span class='line'>    <span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">closest</span><span class="o">(</span><span class="n">pointsByX</span><span class="o">,</span> <span class="n">pointsByY</span><span class="o">,</span> <span class="n">aux</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">mid</span><span class="o">),</span>
</span><span class='line'>            <span class="n">closest</span><span class="o">(</span><span class="n">pointsByX</span><span class="o">,</span> <span class="n">pointsByY</span><span class="o">,</span> <span class="n">aux</span><span class="o">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">hi</span><span class="o">));</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// merge pointsByY[lo,mid]和pointsByY[mid+1, hi], 实现按照y坐标排序</span>
</span><span class='line'>    <span class="n">merge</span><span class="o">(</span><span class="n">pointsByY</span><span class="o">,</span> <span class="n">aux</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 将按照y排序好的点, 和中间点距离小于d的存在辅助数组中,即为宽度2d的中间条带</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">M</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="o">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;=</span> <span class="n">hi</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">pointsByY</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">getX</span><span class="o">()</span> <span class="o">-</span> <span class="n">median</span><span class="o">.</span><span class="na">getX</span><span class="o">())</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">d</span><span class="o">)</span>
</span><span class='line'>            <span class="n">aux</span><span class="o">[</span><span class="n">M</span><span class="o">++]</span> <span class="o">=</span> <span class="n">pointsByY</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 比较中间条带内的点</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">M</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">// a geometric packing argument shows that this loop iterates at most 7 times</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="o">(</span><span class="n">j</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">M</span><span class="o">)</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="o">(</span><span class="n">aux</span><span class="o">[</span><span class="n">j</span><span class="o">].</span><span class="na">getY</span><span class="o">()</span> <span class="o">-</span> <span class="n">aux</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">getY</span><span class="o">()</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">d</span><span class="o">);</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="kt">double</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">aux</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">distance</span><span class="o">(</span><span class="n">aux</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">distance</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">d</span> <span class="o">=</span> <span class="n">distance</span><span class="o">;</span>
</span><span class='line'>                <span class="k">if</span> <span class="o">(</span><span class="n">distance</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">bestDistance</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                    <span class="n">bestDistance</span> <span class="o">=</span> <span class="n">d</span><span class="o">;</span>
</span><span class='line'>                    <span class="n">best1</span> <span class="o">=</span> <span class="n">aux</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span><span class='line'>                    <span class="n">best2</span> <span class="o">=</span> <span class="n">aux</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">d</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * 利用辅助数组aux[lo .. hi]将a[lo .. mid] 和 a[mid+1 ..hi]合并,</span>
</span><span class='line'><span class="cm"> * 保证字数组a[lo .. mid]和a[mid+1 ..hi]都是有序</span>
</span><span class='line'><span class="cm"> * 排序准则为y坐标,稳定</span>
</span><span class='line'><span class="cm"> * @param a : 待合并数组</span>
</span><span class='line'><span class="cm"> * @param aux : 辅助数组</span>
</span><span class='line'><span class="cm"> * @param lo</span>
</span><span class='line'><span class="cm"> * @param mid</span>
</span><span class='line'><span class="cm"> * @param hi</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">merge</span><span class="o">(</span><span class="n">Point2D</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="n">Point2D</span><span class="o">[]</span> <span class="n">aux</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">mid</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">// 复制到辅助数组</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">lo</span><span class="o">;</span> <span class="n">k</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;=</span> <span class="n">hi</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">aux</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// merge 回 a[]</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">lo</span><span class="o">;</span> <span class="n">k</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;=</span> <span class="n">hi</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span>      <span class="o">(</span><span class="n">i</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">mid</span><span class="o">)</span>              <span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">aux</span><span class="o">[</span><span class="n">j</span><span class="o">++];</span>
</span><span class='line'>        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">hi</span><span class="o">)</span>               <span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">aux</span><span class="o">[</span><span class="n">i</span><span class="o">++];</span>
</span><span class='line'>        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">aux</span><span class="o">[</span><span class="n">j</span><span class="o">].</span><span class="na">getY</span><span class="o">()</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">aux</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">getY</span><span class="o">())</span> <span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">aux</span><span class="o">[</span><span class="n">j</span><span class="o">++];</span>
</span><span class='line'>        <span class="k">else</span>                           <span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">aux</span><span class="o">[</span><span class="n">i</span><span class="o">++];</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="n">Point2D</span> <span class="nf">either</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">best1</span><span class="o">;</span> <span class="o">}</span>
</span><span class='line'><span class="kd">public</span> <span class="n">Point2D</span> <span class="nf">other</span><span class="o">()</span>  <span class="o">{</span> <span class="k">return</span> <span class="n">best2</span><span class="o">;</span> <span class="o">}</span>
</span><span class='line'><span class="kd">public</span> <span class="kt">double</span> <span class="nf">distance</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">bestDistance</span><span class="o">;</span> <span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
</span><span class='line'>    <span class="n">Point2D</span><span class="o">[]</span> <span class="n">points</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point2D</span><span class="o">[]{</span>
</span><span class='line'>            <span class="k">new</span> <span class="nf">Point</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span>
</span><span class='line'>            <span class="k">new</span> <span class="nf">Point</span><span class="o">(</span><span class="mi">6</span><span class="o">,</span> <span class="mi">67</span><span class="o">),</span>
</span><span class='line'>            <span class="k">new</span> <span class="nf">Point</span><span class="o">(</span><span class="mi">43</span><span class="o">,</span> <span class="mi">71</span><span class="o">),</span>
</span><span class='line'>            <span class="k">new</span> <span class="nf">Point</span><span class="o">(</span><span class="mi">39</span><span class="o">,</span> <span class="mi">107</span><span class="o">),</span>
</span><span class='line'>            <span class="k">new</span> <span class="nf">Point</span><span class="o">(</span><span class="mi">189</span><span class="o">,</span> <span class="mi">140</span><span class="o">)</span>
</span><span class='line'>    <span class="o">};</span>
</span><span class='line'>    <span class="n">ClosestPair</span> <span class="n">closest</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ClosestPair</span><span class="o">(</span><span class="n">points</span><span class="o">);</span>
</span><span class='line'>    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">closest</span><span class="o">.</span><span class="na">distance</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot; from &quot;</span> <span class="o">+</span> <span class="n">closest</span><span class="o">.</span><span class="na">either</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot; to &quot;</span> <span class="o">+</span> <span class="n">closest</span><span class="o">.</span><span class="na">other</span><span class="o">());</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</span></code></pre></td></tr></table></div></figure></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[两个已序数组的第k小元素]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2014/05/30/k-th-smallest-element-in-the-union-of-two-sorted-arrays/"/>
    <updated>2014-05-30T10:44:06+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2014/05/30/k-th-smallest-element-in-the-union-of-two-sorted-arrays</id>
    <content type="html"><![CDATA[<h2>Problem:</h2>

<p>两个已序数组(从小到大)的第k小元素.数组分别记为A(长度m)和B(长度n).</p>

<h2>Solutions</h2>

<h3>方法1</h3>

<p>将两个数组merge成一个有序数组(m+n大小),再直接取第k个元素.</p>

<p>时间复杂度:O(m+n).</p>

<p>空间复杂度:O(m+n).</p>

<h3>方法2</h3>

<p>两个指针i和j分别从小到大遍历两个数组,代码大致如下:
<code>
i=0, j=0
while((i+j)&lt;k &amp;&amp; (i&lt;m || j&lt;n)){
    if(A[i] &lt; B[j]) i++;
    else j++;
}
</code>
时间复杂度:O(k).</p>

<p>空间复杂度:O(1).</p>

<h3>方法3</h3>

<p>利用方法2,我们发现,如果
<code>
B[j-1] &lt; A[i] &lt; B[j]
</code>
则,A[i]为第i+j+1小的元素,同理,如果
<code>
A[i-1] &lt; B[j] &lt; A[i]
</code>
则B[j]是第i+j+1小的元素.令
<code>
i+j+1 = k
即
i+j=k-1
</code>
则找到了我们需要的第k小元素.</p>

<p>下面是我们的方法:</p>

<ol>
<li><p>二分搜索数组A,i的初值:
<code>
i = (int)((double)m / (m+n) * (k-1));
</code>
令j = k-1-i;</p></li>
<li><p>比较,如果
<code>
B[j-1] &lt; A[i] &lt; B[j]
</code>
则返回A[i]. 如果
<code>
A[i-1] &lt; B[j] &lt; A[i]
</code>
则返回B[j];</p></li>
<li><p>步骤2未结束,则比较A[i]和B[j]</p>

<p>如果A[i]&lt;B[j],则我们可以排除比A[i]小的元素和比B[j]大的元素,即</p>

<p>在A[i+1, m]和B[0, j]中查找第k-i小的元素</p>

<p>否在,可以排除比B[j]小的元素和比A[i]大的元素,即</p>

<p>在A[0, i]和B[j+1, n]中查找第k-j小的元素</p></li>
</ol>


<p>简单示例代码(不完整):
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kt">int</span> <span class="nf">kthSmallest</span><span class="o">(</span><span class="kt">int</span> <span class="n">A</span><span class="o">[],</span> <span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">B</span><span class="o">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)((</span><span class="kt">double</span><span class="o">)</span><span class="n">m</span> <span class="o">/</span> <span class="o">(</span><span class="n">m</span><span class="o">+</span><span class="n">n</span><span class="o">)</span> <span class="o">*</span> <span class="o">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">));</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="o">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="n">i</span><span class="o">;&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="kt">int</span> <span class="n">Ai_1</span> <span class="o">=</span> <span class="o">((</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">?</span> <span class="n">INT_MIN</span> <span class="o">:</span> <span class="n">A</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]);</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">Bj_1</span> <span class="o">=</span> <span class="o">((</span><span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">?</span> <span class="n">INT_MIN</span> <span class="o">:</span> <span class="n">B</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]);</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">Ai</span>   <span class="o">=</span> <span class="o">((</span><span class="n">i</span> <span class="o">==</span> <span class="n">m</span><span class="o">)</span> <span class="o">?</span> <span class="n">INT_MAX</span> <span class="o">:</span> <span class="n">A</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">Bj</span>   <span class="o">=</span> <span class="o">((</span><span class="n">j</span> <span class="o">==</span> <span class="n">n</span><span class="o">)</span> <span class="o">?</span> <span class="n">INT_MAX</span> <span class="o">:</span> <span class="n">B</span><span class="o">[</span><span class="n">j</span><span class="o">]);&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="nf">if</span> <span class="o">(</span><span class="n">Bj_1</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">Ai</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="n">Ai</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">Bj</span><span class="o">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">Ai</span><span class="o">;</span>
</span><span class='line'>  <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">Ai_1</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">Bj</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="n">Bj</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">Ai</span><span class="o">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">Bj</span><span class="o">;&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="nf">if</span> <span class="o">(</span><span class="n">Ai</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">Bj</span><span class="o">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="nf">kthSmallest</span><span class="o">(</span><span class="n">A</span><span class="o">+</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">m</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">B</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">k</span><span class="o">-</span><span class="n">i</span><span class="o">);</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>    <span class="k">return</span> <span class="nf">kthSmallest</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">B</span><span class="o">+</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">n</span><span class="o">-</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">k</span><span class="o">-</span><span class="n">j</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>
时间复杂度:O(logm + logn)</p>

<p>空间复杂度:O(1)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Numberical Algorithm]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2014/05/21/numberical-algorithm/"/>
    <updated>2014-05-21T00:20:34+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2014/05/21/numberical-algorithm</id>
    <content type="html"><![CDATA[<h1>数论算法</h1>

<h2>1. x*y</h2>

<pre><code class="java">    /**
     * x乘以y
     * 限制：y &gt;= 0
     *
     * 原理:         | (x*(y&gt;&gt;1))&lt;&lt;1      y偶数
     *      x * y = | x + (x*(y&gt;&gt;1))&lt;&lt;1  y奇数
     *              | 0                  y == 0
     * @param x
     * @param y
     * @return
     */
    private static int doMuliply(int x, int y) {
        if (y == 0) return 0;

        int z = doMuliply(x, y &gt;&gt; 1);
        return NumberUtils.isEven(y) ? z &lt;&lt; 1 : x + (z &lt;&lt; 1);
    }
</code></pre>

<h2>2. x/y</h2>

<pre><code class="java">    /**
     * x除以y
     * 限制：x &gt; 0 ，y &gt; 0
     *
     *              | ArithmeticException                     y == 0
     * 原理          | (0, 0)                                  x == 0
     *      x / y = | (q'&lt;&lt;1, r'&lt;&lt;1) 其中(q',r')=(x&gt;&gt;1)/y      x偶数
     *              | (q'&lt;&lt;1, r'&lt;&lt;1 + 1) 其中(q',r')=(x&gt;&gt;1)/y  x奇数
     * @param x
     * @param y
     * @return : 商，余
     */
    public static Pair&lt;Integer, Integer&gt; doDivide(int x, int y) {
        if (y == 0) throw new ArithmeticException();

        if (x == 0) return Pair.build(0, 0);

        Pair&lt;Integer, Integer&gt; half = doDivide(x &gt;&gt; 1, y);
        int left = half.getLeft() &lt;&lt; 1;
        int right = half.getRight() &lt;&lt; 1;
        if (NumberUtils.isOdd(x)) right += 1;

        return (right &lt; y) ? Pair.build(left, right) : Pair.build(left+1, right-y);
    }
</code></pre>

<h2>3. pow(x, y) % N</h2>

<pre><code class="java">    /**
     * pow(x, y) % N
     * 限制：x &gt; 0, y &gt; 0, N &gt; 1
     *
     * 原理:                  | (pow(x, y&gt;&gt;1) &lt;&lt; 1) % N       y是偶数
     *        pow(x, y) % N =|
     *                       | x * (pow(x, y&gt;&gt;1) &lt;&lt; 1) % N   y是奇数
     * @param x
     * @param y
     * @param N
     * @return
     */
    public static int powerMod(int x, int y, int N){
        if(y == 0) return 1;

        int half = powerMod(x, y&gt;&gt;1, N);

        return NumberUtils.isEven(y) ? (half * half) % N : (x *half * half) % N;
    }
</code></pre>

<h2>4. 欧几里德GCD算法</h2>

<pre><code class="java">    /**
     * GCD(x, y)
     * 限制：x &gt; y &gt; 0
     *
     * 原理：
     *       GCD(x, y) = GCD(y, x%y)
     *
     * @param x
     * @param y
     * @return
     */
    public static int gcd(int x, int y){
        if(y == 0) return x;
        return gcd(y, x % y);
    }
</code></pre>

<h2>5. 素数测试</h2>

<pre><code class="java">    /**
     * 素数测试
     * 限制：x &gt; 0, K &gt; 0
     *
     * 原理：
     * 费马定理：如果p是素数，则对任意的 1 &lt;= a &lt; x,有 pow(a, x-1) = 1 (mod x)
     * 这是素数的必要条件，但不是充分条件。
     * 随机选k个a，分别用费马定理去测试。
     *
     * @param x
     * @return
     */
    public static boolean isPrime(int x, int K) {
        for (int i = 0; i &lt; K; i++) {
            int a = (int)(Math.random() * x);
            if(powerMod(a, x-1, x) != 1){
                return false;
            }
        }
        return true;
    }
</code></pre>

<p>总结：
《Algorithm》这本书我的理解，关注更多的是工业级别（或者说实用级别）的算法，这一点和算法导论不同，算法导论可以说是学院派，这个是工程师派。
比如上面的素数测试，这本书利用多次费马定理，从而降低误判概率（理论上还是存在误判的情况），但是正像作者说的，很多伟大的算法，都是很大概率正确的算法（而不是完全正确）。</p>
]]></content>
  </entry>
  
</feed>
