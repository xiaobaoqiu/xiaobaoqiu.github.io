<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | xiaobaoqiu Blog]]></title>
  <link href="http://xiaobaoqiu.github.io/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://xiaobaoqiu.github.io/"/>
  <updated>2015-08-01T11:57:33+08:00</updated>
  <id>http://xiaobaoqiu.github.io/</id>
  <author>
    <name><![CDATA[xiaobaoqiu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[数据结构与算法分析第二章]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2014/06/29/shu-ju-jie-gou-yu-suan-fa-fen-xi-di-er-zhang/"/>
    <updated>2014-06-29T14:43:21+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2014/06/29/shu-ju-jie-gou-yu-suan-fa-fen-xi-di-er-zhang</id>
    <content type="html"><![CDATA[<p>&lt;&lt;数据结构与算法分析-C语言描述>></p>

<h1>1.最大子序列和</h1>

<h3>O(n<sup>3</sup>)</h3>

<pre><code class="c++">/**
* 时间复杂度O(n^3)
*/
int Chapter2::maxSubSeqSum1(const int A[], int N)
{
    int maxSum = 0;
    for(int i=0; i&lt;N; i++)
        for(int j=i; j&lt;N; j++)
        {
            int thisSum = 0;
            for(int k=i; k&lt;=j; k++)
                thisSum += A[k];
            if(thisSum &gt; maxSum) maxSum = thisSum;
        }

        return maxSum;
}
</code></pre>

<h3>O(n<sup>2</sup>)</h3>

<pre><code class="c">/**
*   算法1的最里层循环不是必须的
*   时间复杂度:O(n^2)
*/
int Chapter2::maxSubSeqSum2(const int A[], int N)
{
        int maxSum = 0;
        for(int i=0; i&lt;N; i++)
        {
                int thisSum = 0;
                for(int j=i; j&lt;N; j++)
                {
                        thisSum +=A[j];
                        if(thisSum &gt; maxSum)    maxSum = thisSum;
                }
        }

        return maxSum;
}
</code></pre>

<h3>分治,O(nlogn)</h3>

<pre><code class="c">/**
* 分治,划分为作用两个字数组
* A[l,...,M], A[M+1,...,R]
* 则最大子序列和来自三部分:左侧的最大子序列和,右侧的最大子序列和,跨越A[M]和A[M+1]的最大子序列号
* 1,2情况递归可以完成,情况三其实就是求最测以A[M]结尾的最大和,右侧就是以A[M+1]开头的最大和
*
* 时间复杂度:T(n) = 2T(n/2) + O(n)
* 即 O(nlogn)
*/
int Chapter2::maxSubSeqSum3(const int A[], int L, int R)
{
        if(L == R) return A[L] &lt; 0 ?0 : A[L];
        int M = (L + R) &gt;&gt; 1;
        int maxSumL = maxSubSeqSum3(A, L, M);
        int maxSumR = maxSubSeqSum3(A, M+1, R);
        int maxL = 0, sumL = 0;
        for(int i = M; i&gt;=L; i--)
        {
                sumL += A[i];
                if(sumL &gt; maxL) maxL = sumL;
        }
        int maxR = 0, sumR = 0;
        for(int i = M+1; i&lt;=R; i++)
        {
                sumR += A[i];
                if(sumR &gt; maxR) maxR = sumR;
        }

        return max(max(maxSumL, maxSumR), maxL+maxR);
}
</code></pre>

<h3>O(n)</h3>

<pre><code class="c">/**
* 时间复杂度 O(n)
*/
int Chapter2::maxSubSeqSum4(const int A[], int N)
{
        int maxSum = 0, thisSum = 0;
        for(int i=0; i&lt;N; i++)
        {
                thisSum += A[i];
                if(thisSum &gt; maxSum) maxSum = thisSum;
                else if(thisSum &lt; 0) thisSum = 0;
        }

        return maxSum;
}
</code></pre>

<h1>2.gcd</h1>

<pre><code class="c">unsigned int Chapter2::gcd(unsigned int L, unsigned int R)
{
        unsigned rem;
        while(R &gt; 0)
        {
                rem = L % R;
                L = R;
                R = rem;
        }
        return L;
}
</code></pre>

<h1>3.快速幂</h1>

<h3>递归</h3>

<pre><code class="c">long Chapter2::pow1(long x, unsigned n)
{
        if(n == 0) return 1;
        if(n == 1) return x;
        if(isEven((n))) return pow(x*x, n&gt;&gt;1);
        else return pow(x*x, n&gt;&gt;1) * x;
}
</code></pre>

<h3>非递归</h3>

<pre><code class="c">long Chapter2::pow2(long x, unsigned n)
{
        long base = x, ret = 1L;
        while(n &gt; 0)
        {
                if(isEven(n)) {base *= base; n&gt;&gt;=1;}
                else {ret *= base; n-=1;}
        }
        return ret;
}
</code></pre>

<h1>4.随机置换</h1>

<pre><code class="c">/**
* 生成前N个数的随机置换
* 如 N = 3, 生成 [2 1 3]
*/
void Chapter2::randomSeq(int* A, int N)
{
        for(int i=0; i&lt;N; i++)
                A[i] = i+1;
        for(int i=1; i&lt;N; i++)
        {
                swap(A[i], A[random(N)]);
        }
}
</code></pre>

<h1>5.出现次数超过一半的数</h1>

<pre><code class="c">/**
* 寻找数组的主要元素:即一个N个元素的数组中,某一个元素出现次数 &gt;= N/2次
* 如 [6, 8, 8, 2, 3, 4, 8, 8, 8]中8是主要元素
* 思路:比较A1和A2,相等则将A1放入一个新的数组B,不想等则放弃;同样比较A3,A4...
* 递归处理数组B
*
* 注意这里只是返回了一个候选解,如果存在,则一定是这个元素
* 不存在的情况需要再扫描一遍数组
*/
 int Chapter2::mainElement(const int* A, int N)
 {
    int Candidata, nTimes = 0, i=0;
    while(i &lt; N)
    {
        if(nTimes==0) { Candidata = A[i]; nTimes = 1; }
        else
        {
            if(A[i] != Candidata) --nTimes;
            else ++nTimes;
        }
        ++i;
    }
    return Candidata;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Closest Pair]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2014/06/04/closest-pair/"/>
    <updated>2014-06-04T10:42:08+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2014/06/04/closest-pair</id>
    <content type="html"><![CDATA[<h2>Problem:</h2>

<p>Given a set of points in a two dimensional space, you will have to find the distance between the closest two points.</p>

<p>示例:</p>

<h4>input</h4>

<pre><code>0 2
6 67
43 71
39 107
189 140
</code></pre>

<h4>output</h4>

<pre><code>36.2215
</code></pre>

<h2>Solutions:</h2>

<h3>1. Brute force</h3>

<p>计算全部n(n-1)/2对点对,找到最近的点对.</p>

<p>时间复杂度:O(n2)</p>

<p>空间复杂度:O(1)</p>

<h3>2. Divide and conquer</h3>

<p>步骤如下:
1. sort
按照x坐标(y坐标也可以)从小达到排序,时间复杂度O(nlogn);
2. divide
找到中间点q,用q将所有点P所有的点划分为左右两个部分PL和PR;
3. conquer
递归计算PL和PR这两个点集的最近距离,二者中的较小值记为d;
4. combine
取PL和PR中x坐标与点q的x坐标距离小于d的所有点(记为PM,即为一个宽度为2d的竖条带),将PM按照y坐标排序;遍历PM,在y坐标差值小于d的情况下计算距离;</p>

<p>其中1 2 3步骤很明显,步骤4技巧比较多:</p>

<ol>
<li>最多6个点满足y坐标差值小于d,就是说我们的遍历PM在O(k)时间内搞定(k为PM点的数目),证明见
 参考:<a href="http://www.cs.mcgill.ca/~cs251/ClosestPair/proofbox.html">http://www.cs.mcgill.ca/~cs251/ClosestPair/proofbox.html</a></li>
<li>计算距离,不用计算sqrt((x1-x2)<em>(x1-x2) + (y1-y2)</em>(y1-y2)),取sqrt内的值比较就可以;</li>
<li>按照y值排序PM,这是combine的性能瓶颈,我们可以在递归时候做merge排序,避免每次combine时候都重新排序的代价,因此combine的代价为O(n);</li>
</ol>


<p>总的时间代价:
<code>
T(n) = 2T(n/2) + O(n),即T(n)=O(nlogn)
</code>
参考代码如下:
```java
import com.google.common.primitives.Doubles;
import java.awt.*;
import java.awt.geom.Point2D;
import java.util.Arrays;
import java.util.Comparator;</p>

<p>public class ClosestPair {</p>

<pre><code>// 最近的点对及其距离
private Point2D best1, best2;
private double bestDistance = Double.POSITIVE_INFINITY;

//x排序器
private Comparator&lt;Point2D&gt; X_ORDER = new Comparator&lt;Point2D&gt;() {
    @Override
    public int compare(Point2D o1, Point2D o2) {
        return Doubles.compare(o1.getX(), o2.getX());
    }
};

public ClosestPair(Point2D[] points) {
    int N = points.length;
    if (N &lt;= 1) return;

    //按照x排序
    Point2D[] pointsByX = Arrays.copyOf(points, N);
    Arrays.sort(pointsByX, X_ORDER);

    // 检查重合的点
    for (int i = 0; i &lt; N-1; i++) {
        if (pointsByX[i].equals(pointsByX[i+1])) {
            bestDistance = 0.0;
            best1 = pointsByX[i];
            best2 = pointsByX[i+1];
            return ;
        }
    }

    // 用于按照y排序(这里还没排序)
    Point2D[] pointsByY = Arrays.copyOf(pointsByX, N);

    // 辅助数组
    Point2D[] aux = new Point2D[N];

    closest(pointsByX, pointsByY, aux, 0, N-1);
}

/**
 * 找pointsByX[lo..hi]中的最近点对
 * @param pointsByX : 按照x坐标排序好的点
 * @param pointsByY
 * @param aux : 辅助数组
 * @param lo : 最小下标
 * @param hi : 最大下标
 * @return
 */
private double closest(Point2D[] pointsByX, Point2D[] pointsByY, Point2D[] aux, int lo, int hi) {
    if (hi &lt;= lo) return Double.POSITIVE_INFINITY;

    // 中间点
    int mid = (lo + hi) &gt;&gt; 1;
    Point2D median = pointsByX[mid];

    // 递归求解左右子数组的最近点对
    double d = Math.min(closest(pointsByX, pointsByY, aux, lo, mid),
            closest(pointsByX, pointsByY, aux, mid+1, hi));

    // merge pointsByY[lo,mid]和pointsByY[mid+1, hi], 实现按照y坐标排序
    merge(pointsByY, aux, lo, mid, hi);

    // 将按照y排序好的点, 和中间点距离小于d的存在辅助数组中,即为宽度2d的中间条带
    int M = 0;
    for (int i = lo; i &lt;= hi; i++) {
        if (Math.abs(pointsByY[i].getX() - median.getX()) &lt; d)
            aux[M++] = pointsByY[i];
    }

    // 比较中间条带内的点
    for (int i = 0; i &lt; M; i++) {
        // a geometric packing argument shows that this loop iterates at most 7 times
        for (int j = i+1; (j &lt; M) &amp;&amp; (aux[j].getY() - aux[i].getY() &lt; d); j++) {
            double distance = aux[i].distance(aux[j]);
            if (distance &lt; d) {
                d = distance;
                if (distance &lt; bestDistance) {
                    bestDistance = d;
                    best1 = aux[i];
                    best2 = aux[j];
                }
            }
        }
    }
    return d;
}

/**
 * 利用辅助数组aux[lo .. hi]将a[lo .. mid] 和 a[mid+1 ..hi]合并,
 * 保证字数组a[lo .. mid]和a[mid+1 ..hi]都是有序
 * 排序准则为y坐标,稳定
 * @param a : 待合并数组
 * @param aux : 辅助数组
 * @param lo
 * @param mid
 * @param hi
 */
private static void merge(Point2D[] a, Point2D[] aux, int lo, int mid, int hi) {
    // 复制到辅助数组
    for (int k = lo; k &lt;= hi; k++) {
        aux[k] = a[k];
    }

    // merge 回 a[]
    int i = lo, j = mid+1;
    for (int k = lo; k &lt;= hi; k++) {
        if      (i &gt; mid)              a[k] = aux[j++];
        else if (j &gt; hi)               a[k] = aux[i++];
        else if (aux[j].getY() &lt; aux[i].getY()) a[k] = aux[j++];
        else                           a[k] = aux[i++];
    }
}

public Point2D either() { return best1; }
public Point2D other()  { return best2; }
public double distance() { return bestDistance; }

public static void main(String[] args) {
    int N = 5;
    Point2D[] points = new Point2D[]{
            new Point(0, 2),
            new Point(6, 67),
            new Point(43, 71),
            new Point(39, 107),
            new Point(189, 140)
    };
    ClosestPair closest = new ClosestPair(points);
    System.out.println(closest.distance() + " from " + closest.either() + " to " + closest.other());
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[两个已序数组的第k小元素]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2014/05/30/k-th-smallest-element-in-the-union-of-two-sorted-arrays/"/>
    <updated>2014-05-30T10:44:06+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2014/05/30/k-th-smallest-element-in-the-union-of-two-sorted-arrays</id>
    <content type="html"><![CDATA[<h2>Problem:</h2>

<p>两个已序数组(从小到大)的第k小元素.数组分别记为A(长度m)和B(长度n).</p>

<h2>Solutions</h2>

<h3>方法1</h3>

<p>将两个数组merge成一个有序数组(m+n大小),再直接取第k个元素.</p>

<p>时间复杂度:O(m+n).</p>

<p>空间复杂度:O(m+n).</p>

<h3>方法2</h3>

<p>两个指针i和j分别从小到大遍历两个数组,代码大致如下:
<code>
i=0, j=0
while((i+j)&lt;k &amp;&amp; (i&lt;m || j&lt;n)){
    if(A[i] &lt; B[j]) i++;
    else j++;
}
</code>
时间复杂度:O(k).</p>

<p>空间复杂度:O(1).</p>

<h3>方法3</h3>

<p>利用方法2,我们发现,如果
<code>
B[j-1] &lt; A[i] &lt; B[j]
</code>
则,A[i]为第i+j+1小的元素,同理,如果
<code>
A[i-1] &lt; B[j] &lt; A[i]
</code>
则B[j]是第i+j+1小的元素.令
<code>
i+j+1 = k
即
i+j=k-1
</code>
则找到了我们需要的第k小元素.</p>

<p>下面是我们的方法:</p>

<ol>
<li><p>二分搜索数组A,i的初值:
<code>
i = (int)((double)m / (m+n) * (k-1));
</code>
令j = k-1-i;</p></li>
<li><p>比较,如果
<code>
B[j-1] &lt; A[i] &lt; B[j]
</code>
则返回A[i]. 如果
<code>
A[i-1] &lt; B[j] &lt; A[i]
</code>
则返回B[j];</p></li>
<li><p>步骤2未结束,则比较A[i]和B[j]</p>

<p>如果A[i]&lt;B[j],则我们可以排除比A[i]小的元素和比B[j]大的元素,即</p>

<p>在A[i+1, m]和B[0, j]中查找第k-i小的元素</p>

<p>否在,可以排除比B[j]小的元素和比A[i]大的元素,即</p>

<p>在A[0, i]和B[j+1, n]中查找第k-j小的元素</p></li>
</ol>


<p>简单示例代码(不完整):
```
int kthSmallest(int A[], int m, int B[], int n, int k) {</p>

<p>  int i = (int)((double)m / (m+n) * (k-1));
  int j = (k-1) - i;</p>

<p>  int Ai_1 = ((i == 0) ? INT_MIN : A[i-1]);
  int Bj_1 = ((j == 0) ? INT_MIN : B[j-1]);
  int Ai   = ((i == m) ? INT_MAX : A[i]);
  int Bj   = ((j == n) ? INT_MAX : B[j]);</p>

<p>  if (Bj_1 &lt; Ai &amp;&amp; Ai &lt; Bj)
    return Ai;
  else if (Ai_1 &lt; Bj &amp;&amp; Bj &lt; Ai)
    return Bj;</p>

<p>  if (Ai &lt; Bj)
    return kthSmallest(A+i+1, m-i-1, B, j, k-i);
  else
    return kthSmallest(A, i, B+j+1, n-j-1, k-j);
}
```
时间复杂度:O(logm + logn)</p>

<p>空间复杂度:O(1)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Numberical Algorithm]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2014/05/21/numberical-algorithm/"/>
    <updated>2014-05-21T00:20:34+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2014/05/21/numberical-algorithm</id>
    <content type="html"><![CDATA[<h1>数论算法</h1>

<h2>1. x*y</h2>

<pre><code class="java">    /**
     * x乘以y
     * 限制：y &gt;= 0
     *
     * 原理:         | (x*(y&gt;&gt;1))&lt;&lt;1      y偶数
     *      x * y = | x + (x*(y&gt;&gt;1))&lt;&lt;1  y奇数
     *              | 0                  y == 0
     * @param x
     * @param y
     * @return
     */
    private static int doMuliply(int x, int y) {
        if (y == 0) return 0;

        int z = doMuliply(x, y &gt;&gt; 1);
        return NumberUtils.isEven(y) ? z &lt;&lt; 1 : x + (z &lt;&lt; 1);
    }
</code></pre>

<h2>2. x/y</h2>

<pre><code class="java">    /**
     * x除以y
     * 限制：x &gt; 0 ，y &gt; 0
     *
     *              | ArithmeticException                     y == 0
     * 原理          | (0, 0)                                  x == 0
     *      x / y = | (q'&lt;&lt;1, r'&lt;&lt;1) 其中(q',r')=(x&gt;&gt;1)/y      x偶数
     *              | (q'&lt;&lt;1, r'&lt;&lt;1 + 1) 其中(q',r')=(x&gt;&gt;1)/y  x奇数
     * @param x
     * @param y
     * @return : 商，余
     */
    public static Pair&lt;Integer, Integer&gt; doDivide(int x, int y) {
        if (y == 0) throw new ArithmeticException();

        if (x == 0) return Pair.build(0, 0);

        Pair&lt;Integer, Integer&gt; half = doDivide(x &gt;&gt; 1, y);
        int left = half.getLeft() &lt;&lt; 1;
        int right = half.getRight() &lt;&lt; 1;
        if (NumberUtils.isOdd(x)) right += 1;

        return (right &lt; y) ? Pair.build(left, right) : Pair.build(left+1, right-y);
    }
</code></pre>

<h2>3. pow(x, y) % N</h2>

<pre><code class="java">    /**
     * pow(x, y) % N
     * 限制：x &gt; 0, y &gt; 0, N &gt; 1
     *
     * 原理:                  | (pow(x, y&gt;&gt;1) &lt;&lt; 1) % N       y是偶数
     *        pow(x, y) % N =|
     *                       | x * (pow(x, y&gt;&gt;1) &lt;&lt; 1) % N   y是奇数
     * @param x
     * @param y
     * @param N
     * @return
     */
    public static int powerMod(int x, int y, int N){
        if(y == 0) return 1;

        int half = powerMod(x, y&gt;&gt;1, N);

        return NumberUtils.isEven(y) ? (half * half) % N : (x *half * half) % N;
    }
</code></pre>

<h2>4. 欧几里德GCD算法</h2>

<pre><code class="java">    /**
     * GCD(x, y)
     * 限制：x &gt; y &gt; 0
     *
     * 原理：
     *       GCD(x, y) = GCD(y, x%y)
     *
     * @param x
     * @param y
     * @return
     */
    public static int gcd(int x, int y){
        if(y == 0) return x;
        return gcd(y, x % y);
    }
</code></pre>

<h2>5. 素数测试</h2>

<pre><code class="java">    /**
     * 素数测试
     * 限制：x &gt; 0, K &gt; 0
     *
     * 原理：
     * 费马定理：如果p是素数，则对任意的 1 &lt;= a &lt; x,有 pow(a, x-1) = 1 (mod x)
     * 这是素数的必要条件，但不是充分条件。
     * 随机选k个a，分别用费马定理去测试。
     *
     * @param x
     * @return
     */
    public static boolean isPrime(int x, int K) {
        for (int i = 0; i &lt; K; i++) {
            int a = (int)(Math.random() * x);
            if(powerMod(a, x-1, x) != 1){
                return false;
            }
        }
        return true;
    }
</code></pre>

<p>总结：
《Algorithm》这本书我的理解，关注更多的是工业级别（或者说实用级别）的算法，这一点和算法导论不同，算法导论可以说是学院派，这个是工程师派。
比如上面的素数测试，这本书利用多次费马定理，从而降低误判概率（理论上还是存在误判的情况），但是正像作者说的，很多伟大的算法，都是很大概率正确的算法（而不是完全正确）。</p>
]]></content>
  </entry>
  
</feed>
