<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Mysql | xiaobaoqiu Blog]]></title>
  <link href="http://xiaobaoqiu.github.io/blog/categories/mysql/atom.xml" rel="self"/>
  <link href="http://xiaobaoqiu.github.io/"/>
  <updated>2017-02-04T17:21:43+08:00</updated>
  <id>http://xiaobaoqiu.github.io/</id>
  <author>
    <name><![CDATA[xiaobaoqiu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[一个死锁问题]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2016/07/22/%5B%3F%5D-ge-si-suo-wen-ti/"/>
    <updated>2016-07-22T14:33:14+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2016/07/22/[?]-ge-si-suo-wen-ti</id>
    <content type="html"><![CDATA[<ul>
<li><a href="#1.%E8%83%8C%E6%99%AF">1.背景</a></li>
<li><a href="#2.%E9%97%AE%E9%A2%98%E9%87%8D%E7%8E%B0">2.问题重现</a></li>
<li><a href="#3.%E6%AD%BB%E9%94%81%E5%88%86%E6%9E%90">3.死锁分析</a>

<ul>
<li><a href="#3.1%20SQL%E5%8A%A0%E9%94%81">3.1 SQL加锁</a></li>
<li><a href="#3.2%20%E9%94%81%E5%86%B2%E7%AA%81">3.2 锁冲突</a></li>
</ul>
</li>
<li><a href="#4.%E8%A7%A3%E5%86%B3">4.解决</a></li>
<li><a href="#5.%E9%94%81%E7%AD%89%E5%BE%85">5.锁等待</a></li>
</ul>


<p>最近线上业务报了几次死锁问题，决定跟进。</p>

<h2 id="1.背景">1.背景</h2>


<p>有一个业务数据表business，维护了一个名为c_id的外键，一个c_id对应多个business数据。</p>

<p>在业务数据新增或者修改的时候，需要同步的维护 business 的数据，这时候正确的做法是diff新旧数据，得到需要删除的一部分数据，需要新增的一部分数据以及需要更新的一部分数据，这种实现有点麻烦(其实也不麻烦，使用Guava的集合操作)，因此工程师们的通常做法是先根据c_id删除现有数据，再插入新数据。这个时候很容易出现死锁。</p>

<p>这里也解释一下外键，在业务DB中，出于性能考虑，通常禁止使用外键，通常的做法是，外键这种关系的维护都体现在表中手动维护一个外键。</p>

<p>在交代一下数据库相关的背景：</p>

<pre><code>DB：Mysql 5.6
tx_isolation：REPEATABLE-READ
</code></pre>

<h2 id="2.问题重现">2.问题重现</h2>


<p>我们在本地重现死锁信息。</p>

<p>建表语句已经初始化的数据如下：</p>

<pre><code>CREATE TABLE `business` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '',
  `c_id` int(11) NOT NULL DEFAULT '0' COMMENT '',
  `business_id` tinyint(3) unsigned NOT NULL DEFAULT '0' COMMENT '',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uniq_idx_c_id_business_id` (`c_id`,`business_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='';

mysql&gt; select * from business;
+----+-------------+-------------+
| id | c_id | business_id |
+----+-------------+-------------+
| 20 |           1 |           2 |
| 21 |           1 |           3 |
| 23 |           1 |           4 |
| 22 |           1 |           5 |
| 10 |           2 |           1 |
| 11 |           2 |           2 |
|  5 |           3 |           1 |
|  6 |           4 |           1 |
|  7 |           5 |           1 |
+----+-------------+-------------+
</code></pre>

<p>我们模拟同时两个新数据的插入过程：</p>

<table>
<thead>
<tr>
<th style="text-align:center;">步骤 </th>
<th style="text-align:left;"> 事务1 </th>
<th style="text-align:left;"> 事务2 </th>
<th style="text-align:left;"> 备注 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">1 </td>
<td style="text-align:left;"> begin </td>
<td style="text-align:left;">  </td>
<td style="text-align:left;">  </td>
</tr>
<tr>
<td style="text-align:center;">2 </td>
<td style="text-align:left;"> </td>
<td style="text-align:left;"> begin </td>
<td style="text-align:left;">  </td>
</tr>
<tr>
<td style="text-align:center;">3 </td>
<td style="text-align:left;"> mysql> delete from business where c_id = 6;<br><br>Query OK, 0 rows affected (0.00 sec) </td>
<td style="text-align:left;">  </td>
<td style="text-align:left;"> 事务1：Gap锁，锁住区域(5, +∞) </td>
</tr>
<tr>
<td style="text-align:center;">4 </td>
<td style="text-align:left;">  </td>
<td style="text-align:left;"> mysql> delete from business where c_id = 7;<br><br>Query OK, 0 rows affected (0.00 sec) </td>
<td style="text-align:left;"> 事务2：Gap锁，锁住区域(5, +∞)  </td>
</tr>
<tr>
<td style="text-align:center;">5 </td>
<td style="text-align:left;"> mysql> insert into business (c_id, business_id) values (6, 1);<br><br>等待&hellip; </td>
<td style="text-align:left;">  </td>
<td style="text-align:left;"> 事务1：插入意向锁(Insert Intention Lock)，期望获取(5, 6)这个Gap锁和一个c_id=6的Recored锁。<br>但是因为 事务2 已经锁住了区域(5, +∞)因此这时候，事务1只能等待 事务2 释放锁. </td>
</tr>
<tr>
<td style="text-align:center;">6 </td>
<td style="text-align:left;">  </td>
<td style="text-align:left;"> mysql> insert into business (c_id, business_id) values (7, 1); <br><br>ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction </td>
<td style="text-align:left;"> 和上面第5步类似， 事务2：等待获取事务1的锁<br><br>出现循环等待，死锁(roll back这个事务，事务2的锁释放) </td>
</tr>
<tr>
<td style="text-align:center;">7 </td>
<td style="text-align:left;"> Query OK, 2 rows affected (2.89 sec)<br>Records: 2  Duplicates: 0  Warnings: 0<br><br>事务2 rollback了，事务1的insert成功 </td>
<td style="text-align:left;">  </td>
<td style="text-align:left;"> 事务1等待的锁得到，事务1成功。</td>
</tr>
</tbody>
</table>


<p>第 5 步的锁信息如下：</p>

<pre><code>// 锁信息
// 事务1( 即这里的事务id：203797) 持有一个Gap锁，事务2( 即这里的事务id：203798) 持有一个Gap锁
mysql&gt; select * from INNODB_LOCKS;
+---------------+-------------+-----------+-----------+-------------------------------+----------------------------------+------------+-----------+----------+------------------------+
| lock_id       | lock_trx_id | lock_mode | lock_type | lock_table                    | lock_index                       | lock_space | lock_page | lock_rec | lock_data              |
+---------------+-------------+-----------+-----------+-------------------------------+----------------------------------+------------+-----------+----------+------------------------+
| 203797:20:4:1 | 203797      | X         | RECORD    | `test`.`business` | uniq_idx_c_id_business_id |         20 |         4 |        1 | supremum pseudo-record |
| 203798:20:4:1 | 203798      | X         | RECORD    | `test`.`business` | uniq_idx_c_id_business_id |         20 |         4 |        1 | supremum pseudo-record |
+---------------+-------------+-----------+-----------+-------------------------------+----------------------------------+------------+-----------+----------+------------------------+

// 锁等待信息
// 事务1( 即这里的事务id：203797) 等待事务2(即这里的事务id：203798 )的锁
mysql&gt; select * from INNODB_LOCK_WAITS;
+-------------------+-------------------+-----------------+------------------+
| requesting_trx_id | requested_lock_id | blocking_trx_id | blocking_lock_id |
+-------------------+-------------------+-----------------+------------------+
| 203797            | 203797:20:4:1     | 203798          | 203798:20:4:1    |
+-------------------+-------------------+-----------------+------------------+
</code></pre>

<p>有些人可能迷惑 lock_data 的 supremum pseudo-record 是什么东西，我们先看看 lock_data 的解释，这里面解释了 supremum pseudo-record，简单说就是正无穷。</p>

<pre><code>Primary key value(s) of the locked record if LOCK_TYPE='RECORD', otherwise NULL. 
This column contains the value(s) of the primary key column(s) in the locked row, formatted as a valid SQL string (ready to be copied to SQL commands). 
If there is no primary key then the InnoDB internal unique row ID number is used. 
If a gap lock is taken for key values or ranges above the largest value in the index, LOCK_DATA reports “supremum pseudo-record”. 
When the page containing the locked record is not in the buffer pool (in the case that it was paged out to disk while the lock was held), InnoDB does not fetch the page from disk, to avoid unnecessary disk operations. Instead, LOCK_DATA is set to NULL.
</code></pre>

<p>死锁信息：</p>

<pre><code>mysql&gt; show engine innodb status \G
...
------------------------
LATEST DETECTED DEADLOCK
------------------------
2016-07-21 19:11:05 7f6b90de8700
*** (1) TRANSACTION:
TRANSACTION 203797, ACTIVE 42 sec inserting
mysql tables in use 1, locked 1
LOCK WAIT 3 lock struct(s), heap size 360, 2 row lock(s), undo log entries 1
MySQL thread id 9, OS thread handle 0x7f6b90db7700, query id 144 localhost root update
insert into business (c_id, business_id) values (6, 1)
*** (1) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 20 page no 4 n bits 80 index `uniq_idx_c_id_business_id` of table `test`.`business` trx id 203797 lock_mode X insert intention waiting
Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0
 0: len 8; hex 73757072656d756d; asc supremum;;

*** (2) TRANSACTION:
TRANSACTION 203798, ACTIVE 38 sec inserting
mysql tables in use 1, locked 1
3 lock struct(s), heap size 360, 2 row lock(s), undo log entries 1
MySQL thread id 10, OS thread handle 0x7f6b90de8700, query id 147 localhost root update
insert into business (c_id, business_id) values (7, 1)
*** (2) HOLDS THE LOCK(S):
RECORD LOCKS space id 20 page no 4 n bits 80 index `uniq_idx_c_id_business_id` of table `test`.`business` trx id 203798 lock_mode X
Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0
 0: len 8; hex 73757072656d756d; asc supremum;;

*** (2) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 20 page no 4 n bits 80 index `uniq_idx_c_id_business_id` of table `test`.`business` trx id 203798 lock_mode X insert intention waiting
Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0
 0: len 8; hex 73757072656d756d; asc supremum;;

*** WE ROLL BACK TRANSACTION (2)
------------
TRANSACTIONS
------------
</code></pre>

<p>从死锁信息中，我们也可以看到事务1(事务id：203797) 和 事务2(事务id：203798) 持有的锁是锁住相同的一块区域：</p>

<pre><code> 0: len 8; hex 73757072656d756d; asc supremum;;
</code></pre>

<p>参考：<a href="http://blog.itpub.net/29819001/viewspace-1440895/">mysql InnoDB锁等待的查看及分析</a></p>

<h2 id="3.死锁分析">3.死锁分析</h2>


<p>有两个点需要我们知道的信息：各种SQL语句都加什么锁，为什么这里的两个delete的锁没有冲突。</p>

<h4 id="3.1 SQL加锁">3.1 SQL加锁</h4>


<p>关于各种SQL语句加什么锁，参见Mysql官方文档：<a href="http://dev.mysql.com/doc/refman/5.6/en/innodb-locks-set.html">Locks Set by Different SQL Statements in InnoDB</a></p>

<p>我们这里来说涉及的删除和插入，先说删除：</p>

<pre><code>//删除，会在满足条件的记录上加一个next-key锁，也就是锁住之前的Gap和待删除的记录。
DELETE FROM ... WHERE ... sets an exclusive next-key lock on every record the search encounters.

//显然，如果删除的数据比现有最大数据max还大，就会锁(max, +∞)这个Gap
//同理，如果删除的数据比现有最小数据min还小，就会锁(-∞, min)这个Gap
</code></pre>

<p>再说插入，插入比较麻烦，因为涉及到插入意向锁(Insert Intention Lock)，还是参考Mysql官方文档：<a href="http://dev.mysql.com/doc/refman/5.6/en/innodb-locking.html">InnoDB Locking</a></p>

<pre><code>An insert intention lock is a type of gap lock set by INSERT operations prior to row insertion. 
This lock signals the intent to insert in such a way that multiple transactions inserting into the same index gap need not wait for each other if they are not inserting at the same position within the gap. 
Suppose that there are index records with values of 4 and 7. Separate transactions that attempt to insert values of 5 and 6, respectively, each lock the gap between 4 and 7 with insert intention locks prior to obtaining the exclusive lock on the inserted row, but do not block each other because the rows are nonconflicting.
</code></pre>

<p>简单的是说，插入意向锁可以归结为如下：
<code>
锁的类型：Gap Lock
加锁时间：插入之前
锁的区域：待插入的区域，比如已有数据4,7，想要插入5，就会锁住(4, 7)这个区域
锁的冲突：只要两个插入的数据不在同一个位置(其实可以理解为同一个数据)，插入意向锁之间就不会冲突
</code></p>

<p>插入的锁如下：</p>

<pre><code>INSERT sets an exclusive lock on the inserted row. This lock is an index-record lock, not a next-key lock (that is, there is no gap lock) and does not prevent other sessions from inserting into the gap before the inserted row.

Prior to inserting the row, a type of gap lock called an insert intention gap lock is set. This lock signals the intent to insert in such a way that multiple transactions inserting into the same index gap need not wait for each other if they are not inserting at the same position within the gap. 
</code></pre>

<p>就是说插入之前会加一把插入意向锁，除此之外，会在插入的记录上加一把锁。</p>

<h4 id="3.2 锁冲突">3.2 锁冲突</h4>


<p>关于锁冲突，我们熟知的肯定是S和S兼容，X和其他所有都不兼容。事实上并没有这么简单。比如我们这里前面的例子，两个delete都加了X型的Gap锁，应该排斥才对，但事实上是兼容的。这里参考了<a href="http://narcissusoyf.iteye.com/blog/1637309">从一个死锁看mysql innodb的锁机制</a>这篇文章的结论(准备读源码验证)：</p>

<pre><code>下面这个是 precise mode 的兼容矩阵：（这个兼容矩阵发生在X与X，S与X不兼容的情况下再进行比对的）

    G    I     R    N (已经存在的锁,包括等待的锁)
G   +     +    +     + 
I    -      +    +     -
R   +     +     -     -
N   +     +     -     -

+ 代表兼容， -代表不兼容. I代表插入意图锁,
G代表Gap锁，I代表插入意图锁,R代表记录锁，N代表Next-Key锁.
</code></pre>

<p>其实仔细读<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-locking.html">Mysql官方文档</a>，我们也能发现上面的两个delete的Gap锁是兼容的：</p>

<pre><code>Gap locks in InnoDB are “purely inhibitive”, which means they only stop other transactions from inserting to the gap. 
They do not prevent different transactions from taking gap locks on the same gap. Thus, a gap X-lock has the same effect as a gap S-lock.
</code></pre>

<p>意思就是说Gap锁的作用是只防止其他事务在这个Gap内的插入，而不排斥其他事务在同一个Gap加上Gap锁。因此Gap X锁和Gap S锁效果相同。
(真心文档每句话都需要仔细理解哈。)</p>

<h2 id="4.解决">4.解决</h2>


<p>DBA的建议：先根据 c_id 查询id，根据 id 删除;</p>

<p>其实只要保证数据存在再区删除就没问题，我们假设我们执行两个以存在数据的先删除再插入。</p>

<p>一个辅助的示意图如下：</p>

<p><img src="/images/mysql/lock.png"></p>

<h2 id="5.锁等待">5.锁等待</h2>


<p>其实上面的例子中会出现一个因为 UNIQUE KEY 导致的锁等待问题，我们可以重现，现有数据如下：</p>

<pre><code>mysql&gt; select * from business;
+----+-------------+-------------+
| id | c_id | business_id |
+----+-------------+-------------+
| 20 |           1 |           2 |
| 21 |           1 |           3 |
| 23 |           1 |           4 |
| 22 |           1 |           5 |
| 10 |           2 |           1 |
| 11 |           2 |           2 |
|  5 |           3 |           1 |
| 30 |           4 |           1 |
|  7 |           5 |           1 |
+----+-------------+-------------+
</code></pre>

<p>过程如下：</p>

<table>
<thead>
<tr>
<th style="text-align:center;">步骤 </th>
<th style="text-align:left;"> 事务1 </th>
<th style="text-align:left;"> 事务2 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">1 </td>
<td style="text-align:left;"> begin </td>
<td style="text-align:left;">  |  </td>
</tr>
<tr>
<td style="text-align:center;">2 </td>
<td style="text-align:left;"> </td>
<td style="text-align:left;"> begin |  </td>
</tr>
<tr>
<td style="text-align:center;">3 </td>
<td style="text-align:left;"> mysql> delete from business where c_id = 3;<br><br>Query OK, 0 rows affected (0.00 sec) </td>
<td style="text-align:left;">  </td>
</tr>
<tr>
<td style="text-align:center;">4 </td>
<td style="text-align:left;">  </td>
<td style="text-align:left;"> mysql> delete from business where c_id = 4;<br><br>Query OK, 0 rows affected (0.00 sec) </td>
</tr>
<tr>
<td style="text-align:center;">5 </td>
<td style="text-align:left;"> mysql> insert into business (c_id, business_id) values (3, 1);<br><br>等待&hellip;</td>
<td style="text-align:left;">  </td>
</tr>
</tbody>
</table>


<p>INNODB_LOCKS信息及INNODB_LOCK_WAITS信息如下：</p>

<pre><code>mysql&gt; select * from INNODB_LOCK_WAITS;
+-------------------+-------------------+-----------------+------------------+
| requesting_trx_id | requested_lock_id | blocking_trx_id | blocking_lock_id |
+-------------------+-------------------+-----------------+------------------+
| 204349            | 204349:20:4:12    | 204350          | 204350:20:4:12   |
+-------------------+-------------------+-----------------+------------------+
1 row in set (0.00 sec)

mysql&gt; select * from INNODB_LOCKS;
+----------------+-------------+-----------+-----------+-------------------------------+----------------------------------+------------+-----------+----------+-----------+
| lock_id        | lock_trx_id | lock_mode | lock_type | lock_table                    | lock_index                       | lock_space | lock_page | lock_rec | lock_data |
+----------------+-------------+-----------+-----------+-------------------------------+----------------------------------+------------+-----------+----------+-----------+
| 204349:20:4:12 | 204349      | S         | RECORD    | `test`.`business` | uniq_idx_c_id_business_id |         20 |         4 |       12 | 4, 1      |
| 204350:20:4:12 | 204350      | X         | RECORD    | `test`.`business` | uniq_idx_c_id_business_id |         20 |         4 |       12 | 4, 1      |
+----------------+-------------+-----------+-----------+-------------------------------+----------------------------------+------------+-----------+----------+-----------+
</code></pre>

<p>show engine innodb status信息如下：</p>

<pre><code>---TRANSACTION 204350, ACTIVE 24 sec
4 lock struct(s), heap size 1184, 3 row lock(s), undo log entries 1
MySQL thread id 22, OS thread handle 0x7fd7ee4f0700, query id 245 localhost root cleaning up
---TRANSACTION 204349, ACTIVE 31 sec inserting
mysql tables in use 1, locked 1
LOCK WAIT 5 lock struct(s), heap size 1184, 4 row lock(s), undo log entries 2
MySQL thread id 20, OS thread handle 0x7fd7ee4bf700, query id 250 localhost root update
insert into business (c_id, business_id) values (3, 1)
------- TRX HAS BEEN WAITING 6 SEC FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 20 page no 4 n bits 80 index `uniq_idx_c_id_business_id` of table `test`.`business` trx id 204349 lock mode S waiting
Record lock, heap no 12 PHYSICAL RECORD: n_fields 3; compact format; info bits 32
 0: len 4; hex 80000004; asc     ;;
 1: len 1; hex 01; asc  ;;
 2: len 4; hex 0000001e; asc     ;;
</code></pre>

<p>这里没明白的一点好事务1(事务id:204349)的insert一个(3, 1)的数据为什么会在(4, 1)上加一个S锁?</p>

<p>不过实验了一下，去掉UNIQUE KEY，使用普通的key，就没有这个锁等到问题，所以这个锁是因为UNIQUE KEY引发的。
这个问题有待进一步深入查资料。</p>

<p><a href="http://songuooo.com/2015/1/7/deadlock-detected-on-concurrent-insert">http://songuooo.com/2015/1/7/deadlock-detected-on-concurrent-insert</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mysql Join]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/09/03/mysql-join/"/>
    <updated>2015-09-03T11:42:33+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/09/03/mysql-join</id>
    <content type="html"><![CDATA[<p>join 用于多表中字段之间的关联,语法如下:</p>

<pre><code>... FROM table1 INNER|LEFT|RIGHT JOIN table2 ON conditiona
</code></pre>

<p>JOIN实际上是两个表的的乘积(即笛卡尔积).假设集合A={a,b}，集合B={0,1,2}，则两个集合的笛卡尔积为{(a,0),(a,1),(a,2),(b,0),(b,1), (b,2)}.</p>

<p>JOIN按照功能大致分为如下三类:</p>

<pre><code>INNER JOIN: 取得两个表中存在连接匹配关系的记录;
LEFT JOIN: 取得左表完全记录，即使右表并无对应匹配记录,如果没有匹配,右侧将包含null;
RIGHT JOIN: 与 LEFT JOIN 相反，取得右表完全记录，即使左表并无匹配对应记录;
</code></pre>

<h2>. 1.显示join和隐式join</h2>

<p>另外,写join语句有所谓的显示join和隐式join的写法:</p>

<pre><code>-- 显示join
select * from
table1 inner join table2
on table1.name = table2.name;

-- 隐式join
select table1.*, table2.*
from table1, table2
where table1.name = table2.name;
</code></pre>

<p>这两种写法性能上基本没有差异,参考stackoverflow: <a href="http://stackoverflow.com/questions/44917/explicit-vs-implicit-sql-joins">http://stackoverflow.com/questions/44917/explicit-vs-implicit-sql-joins</a></p>

<h2>. 2.ON条件和WHERE条件</h2>

<p>在执行顺序上需要注意的是on条件和where条件执行顺序: 首先使用on条件产生初始笛卡尔积集合,再在这个集合上使用where条件筛选.所以join的时候应该首先好的on条件保证笛卡尔积集合尽可能小,从而减少Where的执行.</p>

<p>比如下面两种写法,方案2写法保证产生的笛卡尔积集合很小,因而从执行性能来看第二个显然更加省时。
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&ndash; 方案1
</span><span class='line'>select * from A
</span><span class='line'>inner join B on B.name = A.name
</span><span class='line'>left join C on C.name = B.name
</span><span class='line'>left join D on D.id = C.id
</span><span class='line'>where C.status&gt;1 and D.status=1;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&ndash; 方案2
</span><span class='line'>select * from A
</span><span class='line'>inner join B on B.name = A.name
</span><span class='line'>left join C on C.name = B.name and C.status&gt;1
</span><span class='line'>left join D on D.id = C.id and D.status=1</span></code></pre></td></tr></table></div></figure></p>

<h2>. 3.STRAIGHT_JOIN和NATURAL JOIN</h2>

<h4>. 3.1 STRAIGHT_JOIN</h4>

<p>再Join的时候,MySQL优化器要确定以谁为驱动表，也就是说以哪个表为基准，在处理此类问题时，MySQL优化器采用了简单粗暴的解决方法：哪个表的结果集小，就以哪个表为驱动表，当然MySQL优化器实际的处理方式会复杂许多，具体可以参考：<a href="http://www.orczhou.com/index.php/2013/04/how-mysql-choose-index-in-a-join/">http://www.orczhou.com/index.php/2013/04/how-mysql-choose-index-in-a-join/</a></p>

<p>说明：在EXPLAIN结果中，第一行出现的表就是驱动表。</p>

<p>但是这个由的时候比较愚蠢,比如我们order by的字段在大结果集的表上,也就是说排序字段不在驱动表里，于是乎不可避免的出现了Using filesort和Using temporary.</p>

<p>上面这种场景,我们就可以通过使用STRAIGHT_JOIN显示的指定驱动表</p>

<p>参考: <a href="http://huoding.com/2013/06/04/261">http://huoding.com/2013/06/04/261</a></p>

<h4>. 3.2 NATURAL</h4>

<p>MySQL将表中具有相同名称的字段自动进行记录匹配，而这些同名字段类型可以不同。因此，NATURAL JOIN 不用指定匹配条件。</p>

<p>同样包含NATURAL LEFT JOIN和NATURAL RIGHT JOIN.</p>

<pre><code>SELECT article.aid,article.title,user.username FROM article NATURAL JOIN user
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mysql PacketTooBigException]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/08/12/mysql-packettoobigexception/"/>
    <updated>2015-08-12T16:44:38+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/08/12/mysql-packettoobigexception</id>
    <content type="html"><![CDATA[<p>最近做一个同步线上数据导dev或者beta环境的小工具.今天遇到一个小异常:</p>

<pre><code>Caused by: com.mysql.jdbc.PacketTooBigException: Packet for query is too large (17610152 &gt; 16777216). You can change this value on the server by setting the max_allowed_packet' variable.
</code></pre>

<p>原因就是一次插入的数据太大了.Mysql存在数据包最大大小的配置,默认是1M,这里我们的dev环境是16M,但是我这里出现了大于16M的数据packet:</p>

<pre><code>mysql&gt; show VARIABLES like '%max_allowed_packet%';
+--------------------------+------------+
| Variable_name            | Value      |
+--------------------------+------------+
| max_allowed_packet       | 16777216   |
| slave_max_allowed_packet | 1073741824 |
+--------------------------+------------+
</code></pre>

<p>修改max_allowed_packet:</p>

<ul>
<li>1.set global max_allowed_packet = 2<em>1024</em>1024*10</li>
<li>2.修改my.conf文件(windows为my.ini)</li>
</ul>


<pre><code>max_allowed_packet      = 16M
</code></pre>

<p>注意点:</p>

<ul>
<li>1.保证Master和Slave的max_allowed_packet参数一致(一般都要求所以参数一致);</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mycli]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/08/01/mycli/"/>
    <updated>2015-08-01T10:37:00+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/08/01/mycli</id>
    <content type="html"><![CDATA[<p>相信很多同学都喜欢使用命令行和Mysql交互而不喜欢各种图形化的客户端，我也是其中之一。</p>

<p>使用命令行交互的一个缺点就是没有自动补全等功能，很多时候忘记字段叫什么，不得不去看一下见表语句。</p>

<p>现在Mycli帮我们搞定这个问题了。Mycli是一个自带自动补全和语法高亮的Mysql客户端，也适用于MariaDB和Percona。赶紧使用Mycli替换你所以的alias吧。</p>

<p>Mycli官网：<a href="http://mycli.net/">http://mycli.net/</a></p>

<h1>1.安装</h1>

<p>Linux下可以使用Python的包管理器pip安装，首先你得有pip，我使用的是Ubuntu：</p>

<pre><code>sudo apt-get install python-pip
</code></pre>

<p>之后就可以安装Mycli了，可能需要sudo权限，因为它会往python的lib目录下加一些包
<code>
pip install mycli
</code></p>

<p>高端的Mac同学使用brew就可以了。</p>

<p>感觉Windows被抛弃，更详细的安装见：<a href="http://mycli.net/install">http://mycli.net/install</a></p>

<p>源代码github地址：<a href="https://github.com/dbcli/mycli">https://github.com/dbcli/mycli</a></p>

<p>使用pg数据库的同学可以使用类似的工具：pgcli</p>

<h1>2.使用</h1>

<p>使用上没啥特别，看看Mycli的手册就可以了，这里将英文简单翻译一下：</p>

<pre><code>xiaobaoqiu@xiaobaoqiu:~/Sublime/Sublime2$ mycli --help
Usage: mycli [OPTIONS] [DATABASE]

Options:
  -h, --host TEXT           数据库host
  -P, --port TEXT           数据库端口. Honors $MYSQL_TCP_PORT
  -u, --user TEXT           用户名
  -S, --socket TEXT         链接数据库使用的socket文件
  -p, --password            密码
  --pass TEXT               密码
  -v, --version                 版本
  -D, --database TEXT       数据库名字
  -R, --prompt TEXT         提示格式(默认: "\t \u@\h:\d&gt; ")
  -l, --logfile FILENAME    将每个查询和查询的结构记录到文件
  --help                    帮助文档
</code></pre>

<p>一个本机的截图如下：
<img src="/images/mysql/Mycli_usage.png"></p>

<h1>3.配置</h1>

<p>配置文件默认为：~/.myclirc，我们可以简单的看一下配置,都比较简单：</p>

<pre><code># vi: ft=dosini
[main]

# Enables context sensitive auto-completion. If this is disabled the all
# possible completions will be listed.
smart_completion = True

# Multi-line mode allows breaking up the sql statements into multiple lines. If
# this is set to True, then the end of the statements must have a semi-colon.
# If this is set to False then sql statements can't be split into multiple
# lines. End of line (return) is considered as the end of the statement.
multi_line = False

# log_file location.
log_file = ~/.mycli.log

# Default log level. Possible values: "CRITICAL", "ERROR", "WARNING", "INFO"
# and "DEBUG".
log_level = INFO

# Timing of sql statments and table rendering.
timing = True

# Table format. Possible values: psql, plain, simple, grid, fancy_grid, pipe,
# orgtbl, rst, mediawiki, html, latex, latex_booktabs.
# Recommended: psql, fancy_grid and grid.
table_format = psql

# Syntax Style. Possible values: manni, igor, xcode, vim, autumn, vs, rrt,
# native, perldoc, borland, tango, emacs, friendly, monokai, paraiso-dark,
# colorful, murphy, bw, pastie, paraiso-light, trac, default, fruity
syntax_style = default

# Keybindings: Possible values: emacs, vi
key_bindings = emacs

# MySQL prompt
# \t - Product type (Percona, MySQL, Mariadb)
# \u - Username
# \h - Hostname of the server
# \d - Database name
prompt = '\t \u@\h:\d&gt; '
</code></pre>

<h1>4.源码</h1>

<p>Mycli是python开发的，原因是起基于的prompt_toolkit正是python开发的。</p>

<p>prompt_toolkit的git地址：<a href="https://github.com/jonathanslenders/python-prompt-toolkit.git">https://github.com/jonathanslenders/python-prompt-toolkit.git</a></p>

<p>prompt_toolkit使用著名的Pygments来做语法高亮。相信很多博客系统(包括我使用的octopress)也是使用这个来做语法高亮，突然发现世界这么小&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mysql InnoDB锁和死锁]]></title>
    <link href="http://xiaobaoqiu.github.io/blog/2015/06/03/mysql-innodbsi-suo/"/>
    <updated>2015-06-03T01:09:23+08:00</updated>
    <id>http://xiaobaoqiu.github.io/blog/2015/06/03/mysql-innodbsi-suo</id>
    <content type="html"><![CDATA[<p>在使用Mysql的业务中,经常会碰到各种Mysql的死锁.一直以来,都对Mysql的死锁不甚了解,这次我们的发布中也出现了一次死锁,趁这次机会,好好学习一下Mysql的死锁.我们的死锁的讨论是在InnoDB引擎基础上的.</p>

<h1>1.MySQL索引</h1>

<h3>1.1 聚簇索引(Clustered Indexes)</h3>

<p>InnoDB存储引擎的数据组织方式,是聚簇索引表：完整的记录,存储在主键索引中,通过主键索引,就可以获取记录所有的列.</p>

<p>每个InnoDB的表有一个特殊的索引称之为聚簇索引,每行的数据就是存储在聚簇索引中.通常,聚簇索引和主键同义.</p>

<p>当你在你的表上面定义一个主键时,InnoDB将其作为聚簇索引.建议为你的表都创建一个主键.如果没有唯一并且非空的一列或者多列(用来做你的主键),那么可以创建一个自动填充的自增列(比如ID)</p>

<p>如果你的表没有定义主键,MySQL会将第一个所有列都非空的UNIQUE索引作为聚簇索引.</p>

<p>如果你的表不存在这样的UNIQUE索引(见上),InnoDB内部会自动隐式生成一个包含行ID的列并在其上面建立聚簇索引.这一列按行ID排序.行ID是一个6-byte的严格单调自增的字段.因此,按照行在物理上是按照插入顺序排序的.</p>

<p>聚簇所有是如何加速查询的呢?通过聚簇所有访问一行非常快,这是因为在聚簇索引上搜索会直接定位到包含你需要的行的数据所在的页上(page).</p>

<p>参考: <a href="http://dev.mysql.com/doc/refman/5.6/en/innodb-index-types.html">http://dev.mysql.com/doc/refman/5.6/en/innodb-index-types.html</a></p>

<h3>1.2 二级索引(Secondary Indexes)</h3>

<p>除了聚簇索引其他索引都是二级索引.在InnoDB中每个二级索引记录都包含了这一行的主键列和当前这个二级索引包含的列.InnoDB使用二级索引中包含的主键取索引这一行对应的聚簇索引,进而找到这一行完整的数据.</p>

<p>如果主键很长,则二级索引会占有更多的空间,因此建议使用短的列做主键.</p>

<h1>2.MySQL锁</h1>

<p>Innodb具备表锁和行锁,其中表锁是MySQL提供的,跟存储引擎无关;行锁是Innodb存储引擎实现.</p>

<h3>2.1 共享锁和排他锁</h3>

<pre><code>1.共享锁(S)
允许一个事务去读一行,阻止其他事务获得相同数据集的排他锁.
2.排他锁(X)
允许获得排他锁的事务更新数据,阻止其他事务取得相同数据集的共享读锁和排他写锁.
</code></pre>

<p>另外,为了允许行锁和表锁共存,实现多粒度锁机制,InnoDB还有两种内部使用的意向锁(Intention Locks),这两种意向锁都是表锁.</p>

<pre><code>1.意向共享锁(IS)
事务打算给数据行加行共享锁,事务在给一个数据行加共享锁前必须先取得该表的IS锁.
2.意向排他锁(IX)
事务打算给数据行加行排他锁,事务在给一个数据行加排他锁前必须先取得该表的IX锁.
</code></pre>

<p>上面这四种锁的兼容性Conflict表示冲突不能共存,Compatible表示可以共存:</p>

<pre><code>   |     X     |      IX     |      S     |  IS
X  | Conflict  |  Conflict   | Conflict   | Conflict
IX | Conflict  |  Compatible | Conflict   | Compatible
S  | Conflict  |  Conflict   | Compatible | Compatible
IS | Conflict  |  Compatible | Compatible | Compatible
</code></pre>

<h3>2.2 什么时候会加锁</h3>

<pre><code>1.共享锁(S)
    SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE
2.排他锁(X)
    SELECT * FROM table_name WHERE ... FOR UPDATE
</code></pre>

<p>参考: <a href="http://dev.mysql.com/doc/refman/5.6/en/innodb-lock-modes.html">http://dev.mysql.com/doc/refman/5.6/en/innodb-lock-modes.html</a></p>

<h3>2.3 当前请求锁</h3>

<p>使用show engine innodb status命令查看当前请求锁的信息.</p>

<pre><code>mysql&gt; show engine innodb status \G;
</code></pre>

<p>可以从information_schema.INNODB_LOCKS表中查看锁的信息.
比如事物A:</p>

<pre><code>mysql&gt; select * from t;
+----+------+
| id | num  |
+----+------+
| 10 |    0 |
|  1 |    1 |
|  3 |    4 |
|  2 |    7 |
| 11 |    8 |
|  4 |    9 |
+----+------+
6 rows in set (0.00 sec)

mysql&gt; select * from t where num &lt; 4 lock in share mode;
+----+------+
| id | num  |
+----+------+
| 10 |    0 |
|  1 |    1 |
+----+------+
2 rows in set (0.00 sec)
</code></pre>

<p>然后事物B去做插入就可能被阻塞:</p>

<pre><code>mysql&gt; insert into t(num) values(4);
</code></pre>

<p>这是很可以查询锁信息:</p>

<pre><code>mysql&gt; select * from information_schema.INNODB_LOCKS \G;
*************************** 1. row ***************************
    lock_id: 5E05:0:138228:3
lock_trx_id: 5E05
  lock_mode: X,GAP
  lock_type: RECORD
 lock_table: `test`.`t`
 lock_index: `n`
 lock_space: 0
  lock_page: 138228
   lock_rec: 3
  lock_data: 7, 2
*************************** 2. row ***************************
    lock_id: 5E02:0:138228:3
lock_trx_id: 5E02
  lock_mode: S
  lock_type: RECORD
 lock_table: `test`.`t`
 lock_index: `n`
 lock_space: 0
  lock_page: 138228
   lock_rec: 3
  lock_data: 7, 2
</code></pre>

<h3>2.2 锁的算法(Record Lock,Gap Lock,Next-Key Lock)</h3>

<p>InnoDB有三种类型的行锁:record locks,gap locks和next-key locks:索引锁是在单个索引记录上的锁;区间锁是两个索引记录之间的锁,或者第一个索引之前的锁,或者最后一个索引之后的锁;Next-Key锁是索引锁和该索引之前的gap锁的结合.</p>

<pre><code>1.索引锁(Record Lock)
索引锁总是锁定索引(可能多条),即使表上面没有索引(这种情况,InnoDB会隐式的用自增id创建一个聚簇索引).一级索引只对一级索引加锁,二级索引对二级索引和对应的一级索引加锁.注意记录锁锁的是索引记录,不是具体的数据记录.

2.区间锁(Gap Lock)
锁定索引记录间隙的锁,确保索引记录的间隙不变,间隙锁是针对事务隔离等级是可重复读(Repeatable Read)或以上级别而言的.

间隙锁一般是针对非唯一索引而言的

3.Next-Key Lock
默认情况,InnoDB使用REPEATABLE READ事物隔离级别,并且innodb_locks_unsafe_for_binlog这个系统设置无效.这时InnoDB使用next-key锁来做搜索(searches)和索引扫描(index scans),以此来防止幻读(参考:http://dev.mysql.com/doc/refman/5.6/en/innodb-next-key-locking.html).
</code></pre>

<h3>2.3 区间锁</h3>

<p>区间锁的一个简单例子:</p>

<pre><code>CREATE TABLE `t` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '自增主键',
  `num` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `n` (`num`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8

insert into t(`num`) values(1, 7, 4, 9);

mysql&gt; select * from t;
+----+------+
| id | num  |
+----+------+
|  1 |    1 |
|  3 |    4 |
|  2 |    7 |
|  4 |    9 |
+----+------+
4 rows in set (0.01 sec)
</code></pre>

<p>表中现在有4条记录,其中普通索引(二级索引n)生成了5个Gap:</p>

<pre><code>(负无穷, 1), (1, 4), (4, 7), (7, 9), (9, 正无穷)
</code></pre>

<p>现在Session A以共享锁获取num=4的数据,Session B想要插入数据,就有可能造成锁等待导致超时从而重启事务,因为Session A以共享锁获取num=4的数据,会产生gap锁将区间(1, 4)和区间(4, 7)锁住,因此这两个区间的插入会失败:</p>

<p><img src="/images/mysql/gap_lock.png"></p>

<p>间隙锁在InnoDB的作用就是防止其它事务的插入操作，以此来达到防止幻读的发生。另外，在上面的例子中，我们选择的是一个普通（非唯一）索引字段来测试的，这不是随便选的，因为如果InnoDB扫描的是一个主键、或是一个唯一索引的话，那InnoDB只会采用行锁方式来加锁，而不会使用Next-Key Lock的方式，也就是说不会对索引之间的间隙加锁.</p>

<p>要禁止间隙锁的话，可以把隔离级别降为读已提交，或者开启参数innodb_locks_unsafe_for_binlog.</p>

<p>参考:
<a href="http://www.cnblogs.com/sliverdang/p/3163455.html">http://www.cnblogs.com/sliverdang/p/3163455.html</a></p>

<p><a href="http://ouyanggod.iteye.com/blog/2166215">http://ouyanggod.iteye.com/blog/2166215</a></p>

<p><a href="http://dev.mysql.com/doc/refman/5.6/en/innodb-record-level-locks.html">http://dev.mysql.com/doc/refman/5.6/en/innodb-record-level-locks.html</a></p>

<h1>3.snapshot read和current read</h1>

<p>MySQL的两种read方式:</p>

<pre><code>1.快照读(snapshot read或者consistent read)
快照读,读取的是记录的可见版本(有可能是历史版本),不用加锁;

通常,简单的select操作,属于快照读,不加锁,比如:
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>select * from table where ?</span></code></pre></td></tr></table></div></figure>
2.当前读(current read或者lock read)
当前读,读取的是记录的最新版本,并且,当前读返回的记录,都会加上锁,保证其他事务不会再并发修改这条记录.

特殊的读操作,插入/更新/删除操作,属于当前读,需要加锁.比如:
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>select * from table where ? lock in share mode
</span><span class='line'>select * from table where ? for update
</span><span class='line'>insert into table values (…)
</span><span class='line'>update table set ? where ?
</span><span class='line'>delete from table where ?</span></code></pre></td></tr></table></div></figure>
所有以上的语句,都属于当前读,读取记录的最新版本.并且,读取之后,还需要保证其他并发事务不能修改当前记录,对读取记录加锁.其中,除了第一条语句,对读取记录加S锁 (共享锁)外,其他的操作,都加的是X锁(排它锁).
</code></pre>

<p>总之一句话:有加锁的查询都认为是当前读.</p>

<p>快照读大大的提高了数据读取的并发.快照读的一个简单示意图,快照数据就是当前数据之前的版本数据,可能有多个版本的快照数据,每个快照数据中包含了版本信息(如时间戳等):</p>

<p><img src="/images/mysql/snapshot_read.png"></p>

<p>为什么将插入/更新/删除操作,都归为当前读?可以看看下面这个更新操作,在数据库中的执行流程：</p>

<p><img src="/images/mysql/update-lock.jpg"></p>

<p>从图中,可以看到,一个Update操作的具体流程.当Update SQL被发给MySQL后,MySQL Server会根据where条件,读取第一条满足条件的记录,然后InnoDB引擎会将第一条记录返回,并加锁(current read).待MySQL Server收到这条加锁的记录之后,会再发起一个Update请求,更新这条记录.一条记录操作完成,再读取下一条记录,直至没有满足条件的记录为止.因此,Update操作内部,就包含了一个当前读.同理,Delete操作也一样.Insert操作会稍微有些不同,简单来说,就是Insert操作可能会触发Unique Key的冲突检查,也会进行一个当前读.</p>

<p>注：根据上图的交互,针对一条当前读的SQL语句,InnoDB与MySQL Server的交互,是一条一条进行的,因此,加锁也是一条一条进行的.先对一条满足条件的记录加锁,返回给MySQL Server,做一些DML操作；然后在读取下一条加锁,直至读取完毕.</p>

<h3>3.1不同隔离界别下的snapshot read</h3>

<p>在Read Committed级别下,快照读总是读取被锁定行的最新的快照数据.而在Repeatable Read和Serializable级别,快照读读取的是事物开始时候的行数据版本.</p>

<p>下面是一个简单的例子,一个很简单的表,插入一条数据:</p>

<pre><code>CREATE TABLE `parent` (   `id` int(10) NOT NULL,   PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8;

insert into parent (id) values(1);
</code></pre>

<p>我们起两个事务,一个读取(Session A),一个更新(Session B),用来验证不同事务隔离级别下快照读的差异:</p>

<pre><code>1.Session A中首先开始事物,查询id=1的数据,这时候,无论在Read Committed还是Repeatable Read级别,结果都是1;
2.Session B然后开始事物,并执行update操作,没有commit;
3.这时候Session A再查询id=1的数据,显然Read Committed还是Repeatable Read级别,结果都是1;(在Read Uncommited灰度到未提交的脏数据).
4.Session B提交事物;
5.这时候Session A再查询id=1的数据,就发现差异:Read Committed级别下读取到被修改的数据,而Repeatable Read读取的还是老数据.因为Read Committed只读取最新的快照数据,而Repeatable Read是参考当前事物开始时间来读取快照数据.
</code></pre>

<p>首先是Repeatable Read的结果:</p>

<pre><code>mysql&gt; SELECT @@session.tx_isolation;
+------------------------+
| @@session.tx_isolation |
+------------------------+
| REPEATABLE-READ        |
+------------------------+

mysql&gt; select * from parent where id = 1;
+----+
| id |
+----+
|  1 |
+----+
</code></pre>

<p><img src="/images/mysql/snapshot_read_RR.png"></p>

<p>下面是Read Committed的结果(Session B一旦提交,Session A未commit的情况下就能读到Session B提交的数据.):</p>

<pre><code>mysql&gt; SELECT @@session.tx_isolation;
+------------------------+
| @@session.tx_isolation |
+------------------------+
| READ-COMMITTED         |
+------------------------+

mysql&gt; select * from parent where id = 1;
+----+
| id |
+----+
|  1 |
+----+
</code></pre>

<p><img src="/images/mysql/snapshot_read_RC.png"></p>

<h1>4.InnoDB MVCC</h1>

<p>InnoDB是一种多版本存储引擎,它必须保存各行老版本信息,这个信息存在一个称之为回滚段(rollback segment)的数据结构中.</p>

<p>在Mysql内部,InnoDB为每行数据额外增加三个字段:</p>

<pre><code>1.一个6-byte的名为DB_TRX_ID字段,用来表示最后一个插入(insert)或者更新(update)这行记录的事物的标记.注意,删除(delete)也被当成一种更新,只是标记这一行的一个额外的bit位来表征这个数据被删除.
2.一个7-byte的名为DB_ROLL_PTR字段,称之为回滚指针(roll pointer).这个指针指向写在rollback segment中的undo log记录.如果这一行被更新了,undo log就包含了能够将这一行完全恢复到修改之前的信息.
3.一个6-byte的DB_ROW_ID字段,用来存行id(row ID),行id是插入数据的时候自动严格递增生成的.如果InnoDB自动产生了一个聚簇索引(clustered index),这个索引就包含行id.否在行id就不会在任何索引中出现.
</code></pre>

<p>InnoDB使用存储在rollback segment中的信息(undo log)去实现事物回滚时候的undo操作.另外,InnoDB也是使用这个信息构建快照读(consistent read或者snapshot read)时候的行数据.</p>

<p>rollback segment中的Undo logs分为插入(insert)和更新(update)的undo logs.</p>

<p>经常提交你的事物,包括那些只是consistent reads的事物.否则(长时间不提事物)会导致InnoDB不能及时废弃update undo logs中的数据,进而导致rollback segment中数据太大挤占你的表空间(tablespace).</p>

<p>rollback segment中undo log记录的物理大小(physical size)通常小于对应的插入或者更新的行数.你可以使用这个信息取计算你的rollback segment需要的空间.</p>

<p>在InnoDB多版本方案中,当你删除一行记录,实际上行不会立即被物理删除.只有当这个删除对应的update undo log被废弃的时候这行记录才会真正被物理删除.此删除操作被称为清除(purge)是通过Purge后台进程实现的,这个过程非常的快,通常其顺序和SQL语句执行删除的顺序一致.Purge进程定期扫描InnoDB的undo,按照先读老undo,再读新undo的顺序,读取每条undo record.</p>

<p>参考:
<a href="http://hedengcheng.com/?p=148">http://hedengcheng.com/?p=148</a>
<a href="https://dev.mysql.com/doc/refman/5.0/en/innodb-multi-versioning.html">https://dev.mysql.com/doc/refman/5.0/en/innodb-multi-versioning.html</a></p>

<h1>5.隔离级别(Isolation Level)</h1>

<h3>5.1 InnoDB的4种隔离级别</h3>

<p>MySQL InnoDB定义的4种隔离级别：</p>

<pre><code>1.Read Uncommited
2.Read Committed (RC)
3.Repeatable Read (RR)
4.Serializable
</code></pre>

<p>Read Uncommited安全级别比较低,因此很少使用.Serializable隔离级别读写冲突,因此并发度急剧下降,在MySQL/InnoDB下不建议使用.
Repeatable Read是InnoDB默认的事物级别.Oracle和MS SQL的默认级别是Read Committed.</p>

<h3>5.2脏读,不可重复读,幻读</h3>

<p>在事务并行下出现的几个问题:</p>

<pre><code>1.脏读
可能读取到其他会话中未提交事务修改的数据,在Read Uncommited级别下可能出现.
2.不可重复读
同一个事物中前后两次读取的内容不一致,在Read Uncommited和Read Committed会出现.
3.幻读
如果另一个事务同时提交了新数据(本事务查询时候感知不到这个变更),本事务再更新时,就会惊奇的发现了这些新数据(比如触发违反了uniq key等),就好像之前读到的数据是鬼影一样的幻觉.这种情况就是上述说的,快照读和当前读一起存在的情况,会出现幻读的场景.必须使用当前读,才能避免幻读.比如：select ...lock in share mode和select ...for update.
</code></pre>

<p>各个事物界别下可能出现的问题:</p>

<table>
<thead>
<tr>
<th>隔离级别</th>
<th style="text-align:center;">脏读(Dirty Read)</th>
<th style="text-align:center;">不可重复读(NonRepeatable Read)</th>
<th style="text-align:center;">幻读(Phantom Read)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Read Uncommited</td>
<td style="text-align:center;">可能</td>
<td style="text-align:center;">可能</td>
<td style="text-align:center;">可能</td>
</tr>
<tr>
<td>Read Committed</td>
<td style="text-align:center;">不可能</td>
<td style="text-align:center;">可能</td>
<td style="text-align:center;">可能</td>
</tr>
<tr>
<td>Repeatable Read</td>
<td style="text-align:center;">不可能</td>
<td style="text-align:center;">不可能</td>
<td style="text-align:center;">可能</td>
</tr>
<tr>
<td>Serializable</td>
<td style="text-align:center;">不可能</td>
<td style="text-align:center;">不可能</td>
<td style="text-align:center;">不可能</td>
</tr>
</tbody>
</table>


<p>幻读的一个示例,Session A在insert之前先select查看数据是否存在,结果告知可以插入,这时候Session B变更数据并提交.Session A再插入会因为主键冲突失败:</p>

<pre><code>mysql&gt; SELECT @@session.tx_isolation;
+------------------------+
| @@session.tx_isolation |
+------------------------+
| READ-COMMITTED         |
+------------------------+

mysql&gt; select * from parent where id = 1;
+----+
| id |
+----+
|  1 |
+----+
</code></pre>

<p><img src="/images/mysql/phantom_read.png"></p>

<p>那么，InnoDB指出的可以避免幻读是怎么回事呢?</p>

<pre><code>http://dev.mysql.com/doc/refman/5.6/en/innodb-record-level-locks.html

By default, InnoDB operates in REPEATABLE READ transaction isolation level and with the innodb_locks_unsafe_for_binlog system variable disabled. In this case, InnoDB uses next-key locks for searches and index scans, which prevents phantom rows (see Section 13.6.8.5, “Avoiding the Phantom Problem Using Next-Key Locking”).
</code></pre>

<p>简单翻译就是，当隔离级别是可重复读，且禁用innodb_locks_unsafe_for_binlog的情况下，在搜索和扫描index的时候使用的next-key locks可以避免幻读.</p>

<p>关键点在于，是InnoDB默认对一个普通的查询也会加next-key locks，还是说需要应用自己来加锁呢？如果单看这一句，可能会以为InnoDB对普通的查询也加了锁，如果是，那和序列化（SERIALIZABLE）的区别又在哪里呢?</p>

<p>MySQL manual里还有一段:</p>

<pre><code>http://dev.mysql.com/doc/refman/5.6/en/innodb-next-key-locking.html
Avoiding the Phantom Problem Using Next-Key Locking

To prevent phantoms, InnoDB uses an algorithm called next-key locking that combines index-row locking with gap locking.

You can use next-key locking to implement a uniqueness check in your application: If you read your data in share mode and do not see a duplicate for a row you are going to insert, then you can safely insert your row and know that the next-key lock set on the successor of your row during the read prevents anyone meanwhile inserting a duplicate for your row. Thus, the next-key locking enables you to “lock” the nonexistence of something in your table.
</code></pre>

<p>根据这一段,我们可以理解为,InnoDB提供了next-key locks，但需要应用程序自己去加锁,才能防止幻读.manual里提供一个例子:</p>

<pre><code>SELECT * FROM child WHERE id &gt; 100 FOR UPDATE;
</code></pre>

<p>这样,InnoDB会给id大于100的行(假如child表里有一行id为102),以及100-102,102+的gap都加上锁.可以使用show innodb status来查看是否给表加上了锁.</p>

<p>结论就是:MySQL InnoDB的REPEATABLE READ并不保证避免幻读,需要应用使用加锁读来保证.而这个加锁度使用到的机制就是next-key locks.</p>

<h3>5.3 修改隔离级别</h3>

<p>InnoDB默认是可重复读的(REPEATABLE READ).可以在命令行用&ndash;transaction-isolation选项,或在选项文件里,为所有连接设置默认隔离级别.</p>

<p>在my.inf文件的[mysqld]节里类似如下设置该选项:</p>

<pre><code>transaction-isolation = {READ-UNCOMMITTED | READ-COMMITTED | REPEATABLE-READ | SERIALIZABLE}
</code></pre>

<p>用户可以用SET TRANSACTION语句改变单个会话或者所有新进连接的隔离级别:</p>

<pre><code>SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE}
</code></pre>

<h1>6.死锁</h1>

<pre><code>1.死锁发生的条件
互斥条件：一个资源每次只能被一个进程使用；
请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放；
不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺；
循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。
</code></pre>

<p>系统检测到死锁后,会自动回滚其中事务较小的一个(记得好像根据undo日志的大小来决定).</p>

<p>对于DB而言，导致死锁意味着发生了循环等待，在InnoDB中由于行锁的引入，比较容易发生死锁，下面总结一些发生死锁的情况（不全）：
    1. 同一索引上,两个session相反的顺序加锁多行记录;
    2. Primary key和Secondary index，通过primary key找到记录，更新Secondary index字段与通过Secondary index更新记录;
    3. UPDATE/DELETE通过不同的二级索引更新多条记录,可能造成在Primary key上不同的加锁顺序,可以参考之前一篇博客:<a href="http://www.gpfeng.com/?p=406">http://www.gpfeng.com/?p=406</a></p>

<h3>6.1死锁实例</h3>

<h3>6.2查看死锁信息</h3>

<h3>6.3解决死锁</h3>

<p>参考:</p>

<p><a href="http://hedengcheng.com/?p=771">http://hedengcheng.com/?p=771</a></p>

<p><a href="http://dev.mysql.com/doc/refman/5.6/en/innodb-record-level-locks.html">http://dev.mysql.com/doc/refman/5.6/en/innodb-record-level-locks.html</a></p>

<p><a href="http://novoland.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/2014/07/26/MySQL%E6%80%BB%E7%BB%93.html">http://novoland.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/2014/07/26/MySQL%E6%80%BB%E7%BB%93.html</a></p>

<p><a href="http://wiki.corp.qunar.com/pages/viewpage.action?pageId=76820049">http://wiki.corp.qunar.com/pages/viewpage.action?pageId=76820049</a>
<a href="http://wiki.corp.qunar.com/pages/viewpage.action?pageId=50520113">http://wiki.corp.qunar.com/pages/viewpage.action?pageId=50520113</a></p>

<p>Mysql锁基础知识 <a href="http://wiki.corp.qunar.com/pages/viewpage.action?pageId=64807317">http://wiki.corp.qunar.com/pages/viewpage.action?pageId=64807317</a></p>
]]></content>
  </entry>
  
</feed>
