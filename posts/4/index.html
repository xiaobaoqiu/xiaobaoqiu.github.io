
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>xiaobaoqiu Blog</title>
  <meta name="author" content="xiaobaoqiu">

  
  <meta name="description" content="1.数据库层面的动态数据源 比如多个读库(Read),可以配置一个虚拟IP,每次读数据库的请求被均衡的分配到各个读库(使用Keepalived等). 这中方式对应用程序是透明的. 2.数据库Proxy 很多现成的数据库Proxy,在Proxy中可以做负载均衡(一般使用LVS, &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://xiaobaoqiu.github.io/posts/4/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  

  <link href="/atom.xml" rel="alternate" title="xiaobaoqiu Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

  
  <meta name="baidu-site-verification" content="5oIt2xaFFz" />
  <meta name="google-site-verification" content="U9Avd5Yqzpetvn_zxo1KaK2iqYNwSlLon27veprwBRY" />
</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">xiaobaoqiu Blog</a></h1>
  
    <h2>Keep Runnnnnnnnnning...</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss email">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
    <li><a href="xiaobaoqiu@163.com" rel="subscribe-email" title="subscribe via email">Email</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="xiaobaoqiu.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">所有博文</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/06/02/dong-tai-shu-ju-yuan/">动态数据源</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-02T02:42:35+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>2</span><span class='date-suffix'>nd</span>, <span class='date-year'>2015</span></span> <span class='time'>2:42 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>1.数据库层面的动态数据源</h1>

<p>比如多个读库(Read),可以配置一个虚拟IP,每次读数据库的请求被均衡的分配到各个读库(使用Keepalived等).</p>

<p>这中方式对应用程序是透明的.</p>

<h1>2.数据库Proxy</h1>

<p>很多现成的数据库Proxy,在Proxy中可以做负载均衡(一般使用LVS,Keepalived等现成应用),权限验证,过滤,业务缓存等控制逻辑.比如:</p>

<pre><code>1.360基于mysql-proxy的Atlas
Atlas是由 Qihoo 360,Web平台部基础架构团队开发维护的一个基于MySQL协议的数据中间层项目。它是在mysql-proxy 0.8.2版本的基础上，对其进行了优化，增加了一些新的功能特性。360内部使用Atlas运行的mysql业务，每天承载的读写请求数达几十亿条。
github:https://github.com/Qihoo360/Atlas
参考:https://github.com/Qihoo360/Atlas/wiki/Atlas%E7%9A%84%E6%9E%B6%E6%9E%84

2.阿里的DRDS
分布式关系型数据库服务（Distribute Relational Database Service，简称DRDS）是一种水平拆分、可平滑扩缩容、读写分离的在线分布式数据库服务。前身为淘宝开源的TDDL，是近千个应用首选组件，已稳定服务了七年以上。已经商业化.
参考:http://docs.aliyun.com/?spm=5176.7622920.9.2.qGx2nq#/pub/drds/brief-manual/summary&amp;summary

3.网易的分布式数据库中间件DDB
DDB（Distributed database）是网易杭研院立项最早，应用最为广泛的后台产品之一，也是国内最早出现的基于现有database之上开发的分布式数据库中间件，目前依然在为网易易信，云音乐，云阅读等大型互联网产品提供稳定的数据库服务。
参考:http://www.majin163.com/2014/09/24/ddb-introduce/

4.百度DDBS
</code></pre>

<h1>3.代码层面</h1>

<p>使用Spring实现数据源动态配置,可以在代码层面达到Master-Slave数据库分离的效果.</p>

<p>其实原理很简单,需要做两个工作:</p>

<pre><code>1.实现一个根据不同key使用不同实际DataSource的自定义DataSource;
2.在请求的ThreadLocal中保存当前请求需要使用的数据库的key;
</code></pre>

<p>其中第一个工作Spring已经帮我们做了,见类org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource.</p>

<h3>3.1 AbstractRoutingDataSource简介</h3>

<p>下面简单介绍这个类:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> * 抽象的javax.sql.DataSource实现，可以完成基于一个查找key来路由 #getConnection()到某些特性目标DataSourcesd的一个。一般通过绑定线程上下文来决定。
</span><span class='line'> */
</span><span class='line'>public abstract class AbstractRoutingDataSource extends AbstractDataSource implements InitializingBean {
</span><span class='line'>private Map&lt;Object, Object&gt; targetDataSources;
</span><span class='line'>
</span><span class='line'>    private Object defaultTargetDataSource;
</span><span class='line'>
</span><span class='line'>    private boolean lenientFallback = true;
</span><span class='line'>
</span><span class='line'>    private DataSourceLookup dataSourceLookup = new JndiDataSourceLookup();
</span><span class='line'>
</span><span class='line'>    private Map&lt;Object, DataSource&gt; resolvedDataSources;
</span><span class='line'>
</span><span class='line'>    private DataSource resolvedDefaultDataSource;
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 设置目标DataSources的map映射，其中查找key作为 map的key。
</span><span class='line'>     * 这个映射的value可以是对象的DataSource实例，或者是一个数据源name的字符串（可以被DataSourceLookup解析）。
</span><span class='line'>     *
</span><span class='line'>     * key可以是任意的类型，只要实现了普通的查找处理。
</span><span class='line'>     * 具体的key表示形式，将会被resolveSpecifiedLookupKey和determineCurrentLookupKey处理
</span><span class='line'>     *
</span><span class='line'>     */
</span><span class='line'>    public void setTargetDataSources(Map&lt;Object, Object&gt; targetDataSources) {
</span><span class='line'>        this.targetDataSources = targetDataSources;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 设置默认目标数据源。如果我们在map中找不到对应的key时，则会使用这里设置的默认数据源
</span><span class='line'>     */
</span><span class='line'>    public void setDefaultTargetDataSource(Object defaultTargetDataSource) {
</span><span class='line'>        this.defaultTargetDataSource = defaultTargetDataSource;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 指定默认的DataSource，当通过指定的查找key不能找到对应的DataSource。
</span><span class='line'>     * 如果为false，则直接返回失败，如果为true，则使用默认的数据源。默认为true
</span><span class='line'>     */
</span><span class='line'>    public void setLenientFallback(boolean lenientFallback) {
</span><span class='line'>        this.lenientFallback = lenientFallback;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 设置DataSourceLookup的实现类，该实现类可以把字符串配置的数据源，解析成我们需要的DataSource类.默认使用JndiDataSourceLookup。
</span><span class='line'>     *
</span><span class='line'>     * JndiDataSourceLookup方法使用ref bean方式获取配置文件中配置的dataSource数据源，也就是我们一般使用xml中配置datasource的方式就是jndi。
</span><span class='line'>     */
</span><span class='line'>    public void setDataSourceLookup(DataSourceLookup dataSourceLookup) {
</span><span class='line'>        this.dataSourceLookup = (dataSourceLookup != null ? dataSourceLookup : new JndiDataSourceLookup());
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>    * 初始化,将targetDataSources转换成resolvedDataSources
</span><span class='line'>    */
</span><span class='line'>    public void afterPropertiesSet() {
</span><span class='line'>        if (this.targetDataSources == null) {
</span><span class='line'>            throw new IllegalArgumentException("Property 'targetDataSources' is required");
</span><span class='line'>        }
</span><span class='line'>        this.resolvedDataSources = new HashMap&lt;Object, DataSource&gt;(this.targetDataSources.size());
</span><span class='line'>        for (Map.Entry entry : this.targetDataSources.entrySet()) {
</span><span class='line'>            Object lookupKey = resolveSpecifiedLookupKey(entry.getKey());
</span><span class='line'>            DataSource dataSource = resolveSpecifiedDataSource(entry.getValue());
</span><span class='line'>            this.resolvedDataSources.put(lookupKey, dataSource);
</span><span class='line'>        }
</span><span class='line'>        if (this.defaultTargetDataSource != null) {
</span><span class='line'>            this.resolvedDefaultDataSource = resolveSpecifiedDataSource(this.defaultTargetDataSource);
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 根据lookupKey获取map中存放的key值，默认两者是一样的
</span><span class='line'>     */
</span><span class='line'>    protected Object resolveSpecifiedLookupKey(Object lookupKey) {
</span><span class='line'>        return lookupKey;
</span><span class='line'>    }
</span><span class='line'>    /**
</span><span class='line'>     * 转换从获取map中存放的dataSource
</span><span class='line'>     */
</span><span class='line'>    protected DataSource resolveSpecifiedDataSource(Object dataSource) throws IllegalArgumentException {
</span><span class='line'>        if (dataSource instanceof DataSource) {
</span><span class='line'>            return (DataSource) dataSource;
</span><span class='line'>        }
</span><span class='line'>        else if (dataSource instanceof String) {
</span><span class='line'>            return this.dataSourceLookup.getDataSource((String) dataSource);
</span><span class='line'>        }
</span><span class='line'>        else {
</span><span class='line'>            throw new IllegalArgumentException(
</span><span class='line'>                    "Illegal data source value - only [javax.sql.DataSource] and String supported: " + dataSource);
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>    * 这里就是抽象类给我们实现的接口方法，根据我们的配置上下文，抽象类决定实现哪个连接
</span><span class='line'>    */
</span><span class='line'>    public Connection getConnection() throws SQLException {
</span><span class='line'>        return determineTargetDataSource().getConnection();
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public Connection getConnection(String username, String password) throws SQLException {
</span><span class='line'>        return determineTargetDataSource().getConnection(username, password);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    protected DataSource determineTargetDataSource() {
</span><span class='line'>        Assert.notNull(this.resolvedDataSources, "DataSource router not initialized");
</span><span class='line'>        Object lookupKey = determineCurrentLookupKey();
</span><span class='line'>        DataSource dataSource = this.resolvedDataSources.get(lookupKey);
</span><span class='line'>        if (dataSource == null && (this.lenientFallback || lookupKey == null)) {
</span><span class='line'>            dataSource = this.resolvedDefaultDataSource;
</span><span class='line'>        }
</span><span class='line'>        if (dataSource == null) {
</span><span class='line'>            throw new IllegalStateException("Cannot determine target DataSource for lookup key [" + lookupKey + "]");
</span><span class='line'>        }
</span><span class='line'>        return dataSource;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>    * 这里是我们使用这个抽象类需要实现的方法，主要就是告诉该抽象类，当前需要使用的数据源的key是什么，这样抽象类就可以知道使用哪个数据库连接
</span><span class='line'>    */
</span><span class='line'>    protected abstract Object determineCurrentLookupKey();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>我们可以继承这个类实现自己的RoutingDataSource,只需要实现determineCurrentLookupKey()方法.下面是一个实现示例,其中DataSourceKeyHolder用来在ThreadLocal中保存key,而我们的RoutingDataSource就可以从ThreadLocal中获取key来决定使用那个具体的数据源:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class RoutingDataSource extends AbstractRoutingDataSource {
</span><span class='line'>    @Override
</span><span class='line'>    protected Object determineCurrentLookupKey() {
</span><span class='line'>        return DataSourceKeyHolder.getDataSource();
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public class DataSourceKeyHolder {
</span><span class='line'>    private static final ThreadLocal&lt;String&gt; holder = new ThreadLocal&lt;String&gt;();
</span><span class='line'>
</span><span class='line'>    public static String getDataSource() {
</span><span class='line'>        return holder.get();
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public static void putDataSource(String value) {
</span><span class='line'>        holder.set(value);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public static void clear(){
</span><span class='line'>        holder.remove();
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>3.2 自己实现RoutingDataSource</h3>

<p>Spring自带的AbstractRoutingDataSource功能强大,但是略先麻烦(最终使用的其实只有resolvedDataSources这个Map).我们完全可以自己实现一个简单的RoutingDataSource,比如我们要实现读写分离的动态数据库,一个简单实现如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class RoutingDataSource extends AbstractDataSource implements InitializingBean {
</span><span class='line'>    /**
</span><span class='line'>     * 写库, key是String
</span><span class='line'>     */
</span><span class='line'>    private Map&lt;String, DataSource&gt; writeDataSourceMap;
</span><span class='line'>    /**
</span><span class='line'>     * 读库, key是String
</span><span class='line'>     */
</span><span class='line'>    private Map&lt;String, DataSource&gt; readDataSourceMap;
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    public Connection getConnection() throws SQLException {
</span><span class='line'>        //从上下文中获取key
</span><span class='line'>        ConnectionKey connectionKey = ConnectionKeyHolder.get();
</span><span class='line'>        try {
</span><span class='line'>            //默认情况,返回随机一个写库
</span><span class='line'>            if (connectionKey == null) {
</span><span class='line'>                return fetchConnection(writeDataSourceMap, null);
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>            //只读
</span><span class='line'>            if (connectionKey.getType().equals(ConnectionKey.READ)) {
</span><span class='line'>                return fetchConnection(readDataSourceMap, connectionKey.getKey());
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>            //可读可写
</span><span class='line'>            if (connectionKey.getType().equals(ConnectionKey.READ_WRITE)) {
</span><span class='line'>                return fetchConnection(writeDataSourceMap, connectionKey.getKey());
</span><span class='line'>            }
</span><span class='line'>        } catch (Exception e) {
</span><span class='line'>            logger.error("getConnectionError", e);
</span><span class='line'>            if (e instanceof SQLException) {
</span><span class='line'>                throw (SQLException) e;
</span><span class='line'>            } else {
</span><span class='line'>                throw new SQLException(e);
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        // impossible code
</span><span class='line'>        throw new IllegalArgumentException("invalid connection type: " + connectionKey.getType() + ", key: "
</span><span class='line'>                + connectionKey.getKey());
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 根据key从对应的Map中获取数据库连接
</span><span class='line'>     *
</span><span class='line'>     * @param dbSourceMap
</span><span class='line'>     * @param key
</span><span class='line'>     * @return
</span><span class='line'>     * @throws SQLException
</span><span class='line'>     */
</span><span class='line'>    private Connection fetchConnection(final Map&lt;String, DataSource&gt; dbSourceMap, String key) throws SQLException {
</span><span class='line'>        if (key == null || key.length() == 0) { // null key, return a random read connection
</span><span class='line'>            key = randomKey(dbSourceMap);
</span><span class='line'>        }
</span><span class='line'>        if (dbSourceMap.get(key) == null) {
</span><span class='line'>            key = randomKey(dbSourceMap);
</span><span class='line'>        }
</span><span class='line'>        return dbSourceMap.get(key).getConnection();
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 随机获取一个Key
</span><span class='line'>     * @return
</span><span class='line'>     */
</span><span class='line'>    private String randomKey(final Map&lt;String, DataSource&gt; dbSourceMap) {
</span><span class='line'>        String[] keys = dbSourceMap.keySet().toArray(new String[0]);
</span><span class='line'>        int size = dbSourceMap.size();
</span><span class='line'>        int rand = new Random().nextInt(size);
</span><span class='line'>        return keys[rand];
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    public Connection getConnection(String username, String password) throws SQLException {
</span><span class='line'>        throw new UnsupportedOperationException();
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    public void afterPropertiesSet() throws Exception {
</span><span class='line'>        Preconditions.checkArgument(MapUtils.isNotEmpty(writeDataSourceMap));
</span><span class='line'>        Preconditions.checkArgument(MapUtils.isNotEmpty(readDataSourceMap));
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public void setWriteDataSource(Map&lt;String, DataSource&gt; writeDataSourceMap) {
</span><span class='line'>        this.writeDataSourceMap = writeDataSourceMap;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public void setReadDataSourceMap(Map&lt;String, DataSource&gt; readDataSourceMap) {
</span><span class='line'>        this.readDataSourceMap = readDataSourceMap;
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public class ConnectionKey {
</span><span class='line'>    /**
</span><span class='line'>     * 读库,只读
</span><span class='line'>     */
</span><span class='line'>    public static final String READ = "R";
</span><span class='line'>    /**
</span><span class='line'>     * 写库,可读可写
</span><span class='line'>     */
</span><span class='line'>    public static final String READ_WRITE = "RW";
</span><span class='line'>
</span><span class='line'>    private String type;
</span><span class='line'>    private String key;
</span><span class='line'>
</span><span class='line'>    public ConnectionKey() {
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public ConnectionKey(String type, String key) {
</span><span class='line'>        this.type = type;
</span><span class='line'>        this.key = key;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public String getType() {
</span><span class='line'>        return type;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public String getKey() {
</span><span class='line'>        return key;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public void setType(String type) {
</span><span class='line'>        this.type = type;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public void setKey(String key) {
</span><span class='line'>        this.key = key;
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public class ConnectionKeyHolder {
</span><span class='line'>    private static ThreadLocal&lt;ConnectionKey&gt; connType = new ThreadLocal&lt;ConnectionKey&gt;();
</span><span class='line'>
</span><span class='line'>    public static void set(ConnectionKey type) {
</span><span class='line'>        connType.set(type);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public static ConnectionKey get() {
</span><span class='line'>        return connType.get();
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public static void release() {
</span><span class='line'>        connType.remove();
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>3.3 使用实现动态数据源</h3>

<p>以我们自己实现的为例子,我们简单展示一下如何使用Spring加上AOP使用我们的动态数据源.</p>

<p>首先定义使用读库和使用写库的注解:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'>* 使用读库的注解,value()代表key
</span><span class='line'>*/
</span><span class='line'>@Target({ ElementType.TYPE, ElementType.METHOD })
</span><span class='line'>@Retention(RetentionPolicy.RUNTIME)
</span><span class='line'>@Documented
</span><span class='line'>public @interface Read {
</span><span class='line'>    String value() default "";
</span><span class='line'>}
</span><span class='line'>/**
</span><span class='line'>* 使用写库的注解,value()代表key
</span><span class='line'>*/
</span><span class='line'>@Target({ ElementType.TYPE, ElementType.METHOD })
</span><span class='line'>@Retention(RetentionPolicy.RUNTIME)
</span><span class='line'>@Documented
</span><span class='line'>public @interface Write {
</span><span class='line'>    String value() default "";
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后定义Aspect,逻辑很简单,只是在执行我们的业务逻辑之前给线程上文写入ConnectionKey信息:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class RoutingAop {
</span><span class='line'>
</span><span class='line'>    protected Logger log = LoggerFactory.getLogger(getClass());
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 解析读库的注解
</span><span class='line'>     *
</span><span class='line'>     * @param pjp
</span><span class='line'>     * @param read
</span><span class='line'>     * @return
</span><span class='line'>     * @throws Throwable
</span><span class='line'>     */
</span><span class='line'>    public Object aroundRead(ProceedingJoinPoint pjp, Read read) throws Throwable {
</span><span class='line'>        ConnectionKey origType = ConnectionKeyHolder.get();
</span><span class='line'>        try {
</span><span class='line'>            ConnectionKey newType = ConnectionKey.buildReadConnectionKey(read.value());
</span><span class='line'>            ConnectionKeyHolder.set(newType);
</span><span class='line'>            return pjp.proceed();
</span><span class='line'>        } catch (Throwable throwable) {
</span><span class='line'>            log.warn("error while processing read method", throwable);
</span><span class='line'>            throw throwable;
</span><span class='line'>        } finally {
</span><span class='line'>            if (origType != null) {
</span><span class='line'>                ConnectionKeyHolder.set(origType);
</span><span class='line'>            } else {
</span><span class='line'>                ConnectionKeyHolder.release();
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 解析写库的注解
</span><span class='line'>     *
</span><span class='line'>     * @param pjp
</span><span class='line'>     * @param write
</span><span class='line'>     * @return
</span><span class='line'>     * @throws Throwable
</span><span class='line'>     */
</span><span class='line'>    public Object aroundWrite(ProceedingJoinPoint pjp, Write write) throws Throwable {
</span><span class='line'>        ConnectionKey origType = ConnectionKeyHolder.get();
</span><span class='line'>        try {
</span><span class='line'>            ConnectionKey newType = ConnectionKey.buildWriteConnectionKey(write.value());
</span><span class='line'>            ConnectionKeyHolder.set(newType);
</span><span class='line'>            return pjp.proceed();
</span><span class='line'>        } catch (Throwable throwable) {
</span><span class='line'>            log.warn("error while processing write method", throwable);
</span><span class='line'>            throw throwable;
</span><span class='line'>        } finally {
</span><span class='line'>            if (origType != null) {
</span><span class='line'>                ConnectionKeyHolder.set(origType);
</span><span class='line'>            } else {
</span><span class='line'>                ConnectionKeyHolder.release();
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在Spring配置文件中定义好各个读库和各个写库,定义我们的RoutingDataSource的bean,之后扫描注解就可以了:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;!-- DataSource 写库  --&gt;
</span><span class='line'>&lt;bean id="writeDataSource" class="..."&gt;
</span><span class='line'>
</span><span class='line'>&lt;!-- DataSource 读库  --&gt;
</span><span class='line'>&lt;bean id="readDataSource" class="..."&gt;
</span><span class='line'>
</span><span class='line'>&lt;bean id="routingDataSource" class="com.Xxx.RoutingDataSource"&gt;
</span><span class='line'>    &lt;property name="writeDataSourceMap"&gt;
</span><span class='line'>        &lt;map key-type="java.lang.String" value-type="javax.sql.DataSource"&gt;
</span><span class='line'>            &lt;entry key="write1" value-ref="writeDataSource"/&gt;
</span><span class='line'>        &lt;/map&gt;
</span><span class='line'>    &lt;/property&gt;
</span><span class='line'>    &lt;property name="readDataSourceMap"&gt;
</span><span class='line'>        &lt;map key-type="java.lang.String" value-type="javax.sql.DataSource"&gt;
</span><span class='line'>            &lt;entry key="read1" value-ref="readDataSource"/&gt;
</span><span class='line'>        &lt;/map&gt;
</span><span class='line'>    &lt;/property&gt;
</span><span class='line'>&lt;/bean&gt;
</span><span class='line'>
</span><span class='line'>&lt;bean id="routingAop" class="com.Xxx.RoutingAop"/&gt;
</span><span class='line'>&lt;!-- 定义Read Write注解扫描  --&gt;
</span><span class='line'>&lt;aop:config&gt;
</span><span class='line'>    &lt;aop:aspect ref="routingAop"&gt;
</span><span class='line'>        &lt;aop:around method="aroundRead" arg-names="read" pointcut="@annotation(read) &amp;&amp; execution(public * com.Xxx.controller.*.*(..))" /&gt;
</span><span class='line'>    &lt;/aop:aspect&gt;
</span><span class='line'>
</span><span class='line'>    &lt;aop:aspect ref="routingAop"&gt;
</span><span class='line'>        &lt;aop:around method="aroundWrite" arg-names="write" pointcut="@annotation(write) &amp;&amp; execution(public * com.Xxx.controller.*.*(..)) " /&gt;
</span><span class='line'>    &lt;/aop:aspect&gt;
</span><span class='line'>&lt;/aop:config&gt;
</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/05/21/elasticsearchpei-zhi-jie-xi/">Elasticsearch配置解析</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-05-21T04:31:05+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>21</span><span class='date-suffix'>st</span>, <span class='date-year'>2015</span></span> <span class='time'>4:31 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>可以使用正则grep出各个配置项:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>grep '^#\w' elasticsearch.yml</span></code></pre></td></tr></table></div></figure>


<p>解析Elasticsearch的配置文件elasticsearch.yml中各个关键参数的意义:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>################################### Cluster ###################################
</span><span class='line'>elasticsearch的config文件夹里面有两个配置文件：elasticsearch.yml和logging.yml，第一个是es的基本配置文件，第二个是日志配置文件，es也是使用log4j来记录日志的，所以logging.yml里的设置按普通log4j配置文件来设置就行了。下面主要讲解下elasticsearch.yml这个文件中可配置的东西。
</span><span class='line'>
</span><span class='line'>cluster.name: elasticsearch
</span><span class='line'>配置es的集群名称，默认是elasticsearch，es会自动发现在同一网段下的es，如果在同一网段下有多个集群，就可以用这个属性来区分不同的集群。
</span><span class='line'>
</span><span class='line'>node.name: "Franz Kafka"
</span><span class='line'>节点名，默认随机指定一个name列表中名字，该列表在es的jar包中config文件夹里name.txt文件中，其中有很多作者添加的有趣名字。
</span><span class='line'>
</span><span class='line'>node.master: true
</span><span class='line'>指定该节点是否有资格被选举成为node，默认是true，es是默认集群中的第一台机器为master，如果这台机挂了就会重新选举master。
</span><span class='line'>
</span><span class='line'>node.data: true
</span><span class='line'>指定该节点是否存储索引数据，默认为true。
</span><span class='line'>
</span><span class='line'>index.number_of_shards: 5
</span><span class='line'>设置默认索引分片个数，默认为5片。
</span><span class='line'>
</span><span class='line'>index.number_of_replicas: 1
</span><span class='line'>设置默认索引副本个数，默认为1个副本。
</span><span class='line'>
</span><span class='line'>path.conf: /path/to/conf
</span><span class='line'>设置配置文件的存储路径，默认是es根目录下的config文件夹。
</span><span class='line'>
</span><span class='line'>path.data: /path/to/data
</span><span class='line'>设置索引数据的存储路径，默认是es根目录下的data文件夹，可以设置多个存储路径，用逗号隔开，例：
</span><span class='line'>path.data: /path/to/data1,/path/to/data2
</span><span class='line'>
</span><span class='line'>path.work: /path/to/work
</span><span class='line'>设置临时文件的存储路径，默认是es根目录下的work文件夹。
</span><span class='line'>
</span><span class='line'>path.logs: /path/to/logs
</span><span class='line'>设置日志文件的存储路径，默认是es根目录下的logs文件夹
</span><span class='line'>
</span><span class='line'>path.plugins: /path/to/plugins
</span><span class='line'>设置插件的存放路径，默认是es根目录下的plugins文件夹
</span><span class='line'>
</span><span class='line'>bootstrap.mlockall: true
</span><span class='line'>设置为true来锁住内存。因为当jvm开始swapping时es的效率会降低，所以要保证它不swap，可以把ES_MIN_MEM和ES_MAX_MEM两个环境变量设置成同一个值，并且保证机器有足够的内存分配给es。同时也要允许elasticsearch的进程可以锁住内存，linux下可以通过`ulimit -l unlimited`命令。设置ES_HEAP_SIZE表示ES_MIN_MEM和ES_MAX_MEM相同且为ES_HEAP_SIZE的值.
</span><span class='line'>
</span><span class='line'>network.bind_host: 192.168.0.1
</span><span class='line'>设置绑定的ip地址，可以是ipv4或ipv6的，默认为0.0.0.0。
</span><span class='line'>
</span><span class='line'>network.publish_host: 192.168.0.1
</span><span class='line'>设置其它节点和该节点交互的ip地址，如果不设置它会自动判断，值必须是个真实的ip地址。
</span><span class='line'>
</span><span class='line'>network.host: 192.168.0.1
</span><span class='line'>这个参数是用来同时设置bind_host和publish_host上面两个参数。
</span><span class='line'>
</span><span class='line'>transport.tcp.port: 9300
</span><span class='line'>设置节点间交互的tcp端口，默认是9300。
</span><span class='line'>
</span><span class='line'>transport.tcp.compress: true
</span><span class='line'>设置是否压缩tcp传输时的数据，默认为false，不压缩。
</span><span class='line'>
</span><span class='line'>http.port: 9200
</span><span class='line'>设置对外服务的http端口，默认为9200。
</span><span class='line'>
</span><span class='line'>http.max_content_length: 100mb
</span><span class='line'>设置内容的最大容量，默认100mb
</span><span class='line'>
</span><span class='line'>http.enabled: false
</span><span class='line'>是否使用http协议对外提供服务，默认为true，开启。
</span><span class='line'>
</span><span class='line'>gateway.type: local
</span><span class='line'>gateway的类型，默认为local即为本地文件系统，可以设置为本地文件系统，分布式文件系统，hadoop的HDFS，和amazon的s3服务器，其它文件系统的设置方法下次再详细说。
</span><span class='line'>
</span><span class='line'>gateway.recover_after_nodes: 1
</span><span class='line'>设置集群中N个节点启动时进行数据恢复，默认为1。
</span><span class='line'>
</span><span class='line'>gateway.recover_after_time: 5m
</span><span class='line'>设置初始化数据恢复进程的超时时间，默认是5分钟。
</span><span class='line'>
</span><span class='line'>gateway.expected_nodes: 2
</span><span class='line'>设置这个集群中节点的数量，默认为2.一旦一旦这N个节点启动(并且数字和recover_after_nodes相同),就会立即开始数据恢复而不用等待gateway.recover_after_time时间之后再开始.
</span><span class='line'>
</span><span class='line'>cluster.routing.allocation.node_initial_primaries_recoveries: 4
</span><span class='line'>初始化数据恢复时，并发恢复线程的个数，默认为4。
</span><span class='line'>
</span><span class='line'>cluster.routing.allocation.node_concurrent_recoveries: 2
</span><span class='line'>添加删除节点或负载均衡时并发恢复线程的个数，默认为4。
</span><span class='line'>
</span><span class='line'>indices.recovery.max_size_per_sec: 0
</span><span class='line'>设置数据恢复时限制的带宽，如入100mb，默认为0，即无限制。
</span><span class='line'>
</span><span class='line'>indices.recovery.concurrent_streams: 5
</span><span class='line'>设置这个参数来限制从其它分片恢复数据时最大同时打开并发流的个数，默认为5。
</span><span class='line'>
</span><span class='line'>discovery.zen.minimum_master_nodes: 1
</span><span class='line'>设置这个参数来保证集群中的节点可以知道其它N个有master资格的节点。默认为1，对于大的集群来说，可以设置大一点的值(2-4).
</span><span class='line'>
</span><span class='line'>discovery.zen.ping.timeout: 3s
</span><span class='line'>设置集群中自动发现其它节点时ping连接超时时间，默认为3秒，对于比较差的网络环境可以高点的值来防止自动发现时出错。
</span><span class='line'>
</span><span class='line'>discovery.zen.ping.multicast.enabled: false
</span><span class='line'>设置是否打开多播发现节点，默认是true。使用单播发现节点策略(Unicast discovery)允许显示的控制使用哪个节点去发现集群.
</span><span class='line'>
</span><span class='line'>discovery.zen.ping.unicast.hosts: ["host1", "host2:port", "host3[portX-portY]"]
</span><span class='line'>设置集群中master节点的初始列表，可以通过这些节点来自动发现新加入集群的节点。
</span><span class='line'>
</span><span class='line'>下面是一些查询时的慢日志参数设置,默认日志级别为TRACE.
</span><span class='line'>超过10秒的查询打印warn日志,超过5秒的查询打印info日志,超过2秒的查询打印debug日志,超过0.5秒的查询打印trace日志
</span><span class='line'>index.search.slowlog.level: TRACE
</span><span class='line'>index.search.slowlog.threshold.query.warn: 10s
</span><span class='line'>index.search.slowlog.threshold.query.info: 5s
</span><span class='line'>index.search.slowlog.threshold.query.debug: 2s
</span><span class='line'>index.search.slowlog.threshold.query.trace: 500ms
</span><span class='line'>
</span><span class='line'>index.search.slowlog.threshold.fetch.warn: 1s
</span><span class='line'>index.search.slowlog.threshold.fetch.info: 800ms
</span><span class='line'>index.search.slowlog.threshold.fetch.debug:500ms
</span><span class='line'>index.search.slowlog.threshold.fetch.trace: 200ms
</span><span class='line'>
</span><span class='line'>超过10秒的查检索引打印warn日志,超过5秒的查检索引打印info日志,超过2秒的查检索引打印debug日志,超过0.5秒的查检索引打印trace日志
</span><span class='line'>index.indexing.slowlog.threshold.index.warn: 10s
</span><span class='line'>index.indexing.slowlog.threshold.index.info: 5s
</span><span class='line'>index.indexing.slowlog.threshold.index.debug: 2s
</span><span class='line'>index.indexing.slowlog.threshold.index.trace: 500ms
</span><span class='line'>
</span><span class='line'>下面是GC日志相关的配置,young GC超过1000ms打印warn日志,超过700ms打印info日志,超过400ms打印的debug日志
</span><span class='line'>monitor.jvm.gc.young.warn: 1000ms
</span><span class='line'>monitor.jvm.gc.young.info: 700ms
</span><span class='line'>monitor.jvm.gc.young.debug: 400ms
</span><span class='line'>
</span><span class='line'>full GC超过10s打印warn日志,超过5s打印info日志,超过2s打印的debug日志
</span><span class='line'>monitor.jvm.gc.old.warn: 10s
</span><span class='line'>monitor.jvm.gc.old.info: 5s
</span><span class='line'>monitor.jvm.gc.old.debug: 2s</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/05/20/elasticsearch/">Elasticsearch</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-05-20T22:14:33+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>20</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>10:14 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>1.简介</h1>

<p>Elasticsearch 是一个建立在全文搜索引擎 Apache Lucene&trade; 基础上的分布式的，高可用的，基于json格式的数据构建索引，准实时查询的搜索引擎。Lucene 是当今最先进最高效的全功能开源搜索引擎框架,但是Lucene使用非常复杂。</p>

<p>Elasticsearch使用 Lucene 作为内部引擎，但是在你使用它做全文搜索时，只需要使用统一开发好的API即可，而并不需要了解其背后复杂的 Lucene 的运行原理。</p>

<p>Elasticsearch是一种准实时搜索，其实是可以做到实时的，因为lucene是可以做到实时的，但是这样做，要么是牺牲索引的效率（每次都索引之后刷新），要么就是牺牲查询的效率（每次查询之前都进行刷新），所以
采取一种折中的方案，每隔n秒自动刷新，这样你创建索引之后，最多在ns之内肯定能查到，这就是所谓的准实时(near real-time)查询，缺省是刷新间隔时间是1秒，可以通过index.refresh_interval参数修改间隔.</p>

<p>刷新是为了让文档可以搜索到，但是不保证这些数据被写入disk进入一个永久的存储状态，数据会被先被写入一个事务日志，然后在适当的时候持久化到磁盘中.</p>

<p>官网:<a href="https://www.elastic.co/products/elasticsearch">https://www.elastic.co/products/elasticsearch</a></p>

<p>文档:<a href="https://www.elastic.co/guide/index.html">https://www.elastic.co/guide/index.html</a></p>

<p>github地址:<a href="https://github.com/elastic/elasticsearch">https://github.com/elastic/elasticsearch</a></p>

<p>博客地址:<a href="https://www.elastic.co/blog">https://www.elastic.co/blog</a></p>

<p>其优点很吸引人:</p>

<pre><code>1.分布式,可扩展,高科用(Distributed, scalable, and highly available);
2.提供实时搜索和分析(Real-time search and analytics capabilities);
3.复杂的RESTful API接口(Sophisticated RESTful API);
</code></pre>

<p>其特征如下:</p>

<pre><code>1.Real-Time Data
2.Real-Time Analytics
3.Distributed
最开始规模可能很小,elasticsearch很方便的支持横向扩展,通过简单的在集群中增加节点就可以
4.High Availability
Elasticsearch集群是弹性的,它可以自动的感知新增的或者失效的节点,自动做数据的分发和均衡,保证数据客房问并且是安全的.
5.Multitenancy
集群可能包含多个索引(index),它们可以独立的提供查询服务,也可以组合在一起对外提供查询服务.
6.Full-Text Search
支持多种开发语言
7.Document-Oriented
将真实世界的复杂对象结构化乘JSON文档.所有字段默认都建立索引,所有的索引都可以单独提供查询.并且瞬间(breathtaking speed)返回复杂结果.
8.Schema-Free
对一个JSON文档建立索引,就会自动识别数据的结构和类型,创建所有并对外提供搜索服务.同时也可以自定义数据如何建立索引.
9.Developer-Friendly, RESTful API
Elasticsearch是API驱动的.基本所有的操作都可以通过一个简单的使用JSON格式数据的HTTP上的RESTful API.提供了很多种语言的Client.
10.Per-Operation Persistence
Elasticsearch将数据安全放在第一位.任何文档的变更都会记录在集群中多个节点上的事物日志,以此来将数据丢失几率降低到最小.
11.Apache 2 Open Source License
12.Build on top of Apache Lucene
Elasticsearch以Lucene为基础提供其优秀的分布式搜索和分析能力.
13.Conflict Management
</code></pre>

<h1>2.安装</h1>

<h3>2.1 elasticsearch安装</h3>

<p>安装很简单:</p>

<pre><code>1.下载并解压
下载地址:https://www.elastic.co/downloads/elasticsearch
这里下载是1.5.2版本,解压之后可以创建软链es:

```
xiaobaoqiu@xiaobaoqiu:~/elasticsearch$ ln -s elasticsearch-1.5.2 es
```

目录下主要三个文件夹:

```
xiaobaoqiu@xiaobaoqiu:~/elasticsearch/es$ ll
总用量 48
drwxr-xr-x 5 xiaobaoqiu xiaobaoqiu  4096  4月 27 09:22 ./
drwxr-xr-x 3 xiaobaoqiu xiaobaoqiu  4096  5月 20 14:40 ../
drwxr-xr-x 2 xiaobaoqiu xiaobaoqiu  4096  4月 27 09:22 bin/
drwxr-xr-x 2 xiaobaoqiu xiaobaoqiu  4096  5月 20 14:42 config/
drwxr-xr-x 3 xiaobaoqiu xiaobaoqiu  4096  4月 27 09:22 lib/
-rw-rw-r-- 1 xiaobaoqiu xiaobaoqiu 11358  4月 27 07:05 LICENSE.txt
-rw-rw-r-- 1 xiaobaoqiu xiaobaoqiu   150  4月 27 07:05 NOTICE.txt
-rw-rw-r-- 1 xiaobaoqiu xiaobaoqiu  8499  4月 27 09:03 README.textile
```
其中bin包含一些启动脚本(包括windows下的bat脚本和linux下的shell脚本),config主要是配置文件,lib包括es依赖的jar,在里面就可以看到熟悉的Lucene,查询,高亮等依赖的jar包.

启动elasticsearch之后会产生log目录,用于记录elasticsearch系统的一些中心日志信息:

```
-rw-r--r-- 1    0  5月 20 15:05 elasticsearch_index_indexing_slowlog.log
-rw-r--r-- 1    0  5月 20 15:05 elasticsearch_index_search_slowlog.log
-rw-r--r-- 1 1254  5月 20 15:06 elasticsearch.log
```
其中elasticsearch.log是系统日志,记录什么类型的日志,日志的命名及日志文件的滚动(Rolling)策略等由config目录下的logging.yml配置文件决定.

启动elasticsearch之后会产生data目录,用于
elasticSearch的数据存放位置

2.启动
直接启动bin目录下的elasticsearch的shell:

```
xiaobaoqiu@xiaobaoqiu:~/elasticsearch/es/bin$ ./elasticsearch -d
```

3.验证
直接本机浏览器访问:http://localhost:9200/

```
{
status: 200,
name: "Agon",
cluster_name: "elasticsearch",
version: {
    number: "1.5.2",
    build_hash: "62ff9868b4c8a0c45860bebb259e21980778ab1c",
    build_timestamp: "2015-04-27T09:21:06Z",
    build_snapshot: false,
    lucene_version: "4.10.4"
},
tagline: "You Know, for Search"
}
```
这说明Elasticsearch集群已经上线运行了，这时我们就可以进行各种实验了.
</code></pre>

<h3>2.2 集群管理工具插件</h3>

<p>elasticsearch-head是一个elasticsearch的集群管理工具，它是完全由html5编写的独立网页程序，其他它可以更好的获得各个切片和节点的信息.</p>

<p>该工具的git地址是： <a href="https://github.com/Aconex/elasticsearch-head">https://github.com/Aconex/elasticsearch-head</a></p>

<p>安装该插件:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xiaobaoqiu@xiaobaoqiu:~/elasticsearch$ ./es/bin/plugin -install mobz/elasticsearch-head
</span><span class='line'>-&gt; Installing mobz/elasticsearch-head...
</span><span class='line'>...//省略若干</span></code></pre></td></tr></table></div></figure>


<p>然后就可以访问(可以使用具体节点的IP):
<a href="http://localhost:9200/_plugin/head/">http://localhost:9200/_plugin/head/</a></p>

<p>图形化界面如下,包括集群的健康状况等信息:</p>

<p><img src="/images/Elasticsearch/elasticsearch_plugin_head.png"></p>

<h3>2.3 集群监控工具插件</h3>

<p>bigdesk是elasticsearch的一个集群监控工具，可以通过它来查看es集群的各种状态，如：cpu、内存使用情况，索引数据、搜索情况，http连接数等。</p>

<p>项目git地址： <a href="https://github.com/lukas-vlcek/bigdesk">https://github.com/lukas-vlcek/bigdesk</a></p>

<p>安装该插件:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xiaobaoqiu@xiaobaoqiu:~/elasticsearch$ ./es/bin/plugin -install lukas-vlcek/bigdesk
</span><span class='line'>-&gt; Installing lukas-vlcek/bigdesk...
</span><span class='line'>...//省略若干</span></code></pre></td></tr></table></div></figure>


<p>然后就可以访问(可以使用具体节点的IP):
<a href="http://localhost:9200/_plugin/bigdesk/">http://localhost:9200/_plugin/bigdesk/</a></p>

<p>图形化界面如下,包括JVM,Thread Pools,OS,Process,HTTP &amp; Transport,Indices和File system等监控图:</p>

<p><img src="/images/Elasticsearch/elasticsearch_plugin_bigdesk.png"></p>

<h3>2.4 安装Marvel</h3>

<p>Marvel是Elasticsearch的管理和监控工具，是一个商业版本的插件,在开发环境下免费使用。它包含了一个叫做Sense的交互式控制台，使用户方便的通过浏览器直接与Elasticsearch进行交互。</p>

<p>运行以下命令来下载和安装Marvel:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xiaobaoqiu@xiaobaoqiu:~/elasticsearch$ ./es/bin/plugin -i elasticsearch/marvel/latest
</span><span class='line'>-&gt; Installing elasticsearch/marvel/latest...
</span><span class='line'>...//省略若干</span></code></pre></td></tr></table></div></figure>


<p>Marvel包括一系列酷炫的监控,还有一个Sense的交互式控制台:</p>

<p><img src="/images/Elasticsearch/elasticsearch_plugin_marvel.png"></p>

<p><img src="/images/Elasticsearch/elasticsearch_plugin_marvel_sense.png"></p>

<p>你可能想要禁用监控，你可以通过以下命令关闭Marvel：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>echo 'marvel.agent.enabled: false' &gt;&gt; ./config/elasticsearch.yml</span></code></pre></td></tr></table></div></figure>


<h1>3.基本概念</h1>

<h3>3.1 集群和节点</h3>

<p>节点是Elasticsearch运行的实例。集群是一组有着同样cluster.name的节点，它们协同工作，互相分享数据，提供了故障转移和扩展的功能。当然一个节点也可以是一个集群。ES集群有自动发现的机制，只要几个节点用的是一个clustername，并且在一个局域网内，那么这些节点就可以自动的发现对方，并组成一个集群.</p>

<p>我们上面的运行就是一个单节点的集群.节点的cluster.name在配置文件elasticsearch.yml中配置,默认就叫elasticsearch:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cluster.name: elasticsearch</span></code></pre></td></tr></table></div></figure>


<p>ES的集群是一个去中心化的集群，每一个节点都可以被选举为主节点，如果主节点挂了，集群就会选举出新的主节点。</p>

<p>主节点的作用主要是管理集群，例如感知集群节点的增加和减少，平衡数据分配等.</p>

<p>ES集群对外是透明的，各个节点之间协同工作，分享数据，我们不管访问的是哪一个节点，这个节点都知道数据存在于哪个节点上，然后转发请求到数据所在的节点上，并且负责收集各节点返回的数据，最后一起返回给客户端.</p>

<h3>3.2 分片(shard)</h3>

<p>一个索引会被分割为多个片段存储，这样可以充分使用节点的吞吐率</p>

<h3>3.2 索引(index)</h3>

<p>相当于数据库</p>

<h3>3.3 类型(type)</h3>

<p>相当于数据库中的表</p>

<h3>3.4 文档(doc)</h3>

<p>相当于数据库中的一条记录，json串</p>

<h3>3.5 字段(Field)</h3>

<p>相当路数据库中的列。</p>

<p>参考:
<a href="http://es.xiaoleilu.com/">http://es.xiaoleilu.com/</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/05/20/tpcc-mysqljian-jie/">TPCC-MySQL简介</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-05-20T06:47:02+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>20</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>6:47 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>TPC(Tracsaction Processing Performance Council) 事务处理性能协会是一个评价大型数据库系统软硬件性能的非盈利的组织,TPC-C是TPC协会制定的，用来测试典型的复杂OLTP系统的性能；</p>

<p>Tpcc-mysql是percona基于tpcc衍生出来的产品，专用于mysql基准测试，其源码放在bazaar上，因此需要先安装bazaar客户端.</p>

<h1>1.OLTP and OLAP</h1>

<p>一般来说，可将数据库的应用类型分为OLTP(OnLine Transaction Processing，联机事务处理)和OLAP(OnLine Analysis Processing，联机分析处理)两种。OLTP是传统关系型数据库的主要应用，其主要面向基本的、日常的事务处理，例如银行交易。OLAP是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果.</p>

<p>OLTP也被称为面向交易的处理系统，其基本特征是可以立即将顾客的原始数据传送到计算中心进行处理，并在很短的时间内给出处理结果，这个过程的最大优点是可以即时地处理输入的数据、及时地回答，因此OLTP又被称为实时系统(Real Time System)。衡量OLTP系统的一个重要性能指标是系统性能，具体体现为实时响应时间(Response Time,简称RT)，即从用户在终端输入数据到计算机对这个请求做出回复所需的时间。OLTP 数据库旨在使事务应用程序仅完成对所需数据的写入，以便尽快处理单个事务。</p>

<p>OLAP的概念最早是由关系数据库之父E.F.Codd博士于1993年提出的，是一种用于组织大型商务数据库和支持商务智能的技术。OLAP数据库分为一个或多个多维数据集，每个多维数据集都由多维数据集管理员组织和设计，以适应用户检索和分析数据的方式，从而更易于创建和使用所需的数据透视表和数据透视图。</p>

<h1>2.Tpcc-mysql</h1>

<p>Tpcc-mysql简单说就是mysql的一个基准测试工具.一般用于比较Mysql在不同配置下的性能差异,从而选择一个相对较优的配置.</p>

<p>参考:
<a href="http://www.zhaokunyao.com/archives/5793">http://www.zhaokunyao.com/archives/5793</a></p>

<h1>3.NoSQL测试</h1>

<p>顺便记录一下一个NOSQL的测试case:</p>

<p><a href="https://www.aerospike.com/wp-content/uploads/2013/02/Ultra-High-Performance-NoSQL-Benchmarking_zh-CN.pdf">https://www.aerospike.com/wp-content/uploads/2013/02/Ultra-High-Performance-NoSQL-Benchmarking_zh-CN.pdf</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/05/20/crate-jdbccha-xun-si-xun-huan-bug/">Crate Jdbc查询死循环bug</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-05-20T05:41:17+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>20</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>5:41 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>历经一个月的项目,使用Crate提升搜索速度终于要上线.先交代一下背景,我们使用的crate相关的依赖的版本:</p>

<pre><code>1.crate-client  0.47.8
2.crate-jdbc    1.5.1
</code></pre>

<p>发布之后,验证阶段一切正常,等把流量入口打开,一段时间之后,猛然发现crate的一个查询服务所在的机器load飙到20往上,机器是4核CPU,4G内存的虚拟机.</p>

<p>top -H发现有大量的tomcat线程(10+),每个线程占用的CPU都达到20%,并且这种线程有增多的趋势.</p>

<p>vmstat命令发现r数字特别高,即正在等待CPU的线程非常多.</p>

<p>jstack的结果发现runnable的线程多达300多.</p>

<p>看现象,感觉问题是线程池分配没有回收,但是定位不到问题在哪.</p>

<p>最终定位的问题是在特定场景下存在死循环,并且直接才crate服务器执行相同的查询逻辑正常返回,因此基本定位在crate-jdbc中.</p>

<h1>1.死循环场景</h1>

<pre><code>1.crate中数据为空,这是很从crate中查询数据;
2.crate中存在满足查询条件数据,我们分页查询,假设总数据量为10页,我们因为代码问题,直接查询第11页的内容(实际上肯定不存在);
</code></pre>

<h1>2.原因</h1>

<p>原因是这个版本crate-jdbc和mybatis一起存在死循环,如下,我们对crate的查询首先经过mybatis,从</p>

<pre><code>1.MapperProxy.invoke
2.MapperMethod.execute
3.SqlSessionTemplate.selectList, SqlSessionTemplate.invoke
4.DefaultSqlSession.selectList
5.BaseExecutor.query, BaseExecutor.queryFromDatabase
6.ReuseExecutor.doQuery
7.RoutingStatementHandler.query
8.PreparedStatementHandler.query
9.CratePreparedStatement.execute()
10.DefaultResultSetHandler.handleResultSets, DefaultResultSetHandler.getFirstResultSet
</code></pre>

<p>问题的代码就在DefaultResultSetHandler.getFirstResultSet中:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private ResultSetWrapper getFirstResultSet(Statement stmt) throws SQLException {
</span><span class='line'>    ResultSet rs = stmt.getResultSet();
</span><span class='line'>    while (rs == null) {
</span><span class='line'>        // move forward to get the first resultset in case the driver
</span><span class='line'>        // doesn't return the resultset as the first result (HSQLDB 2.1)
</span><span class='line'>        if (stmt.getMoreResults()) {
</span><span class='line'>            rs = stmt.getResultSet();
</span><span class='line'>        } else {
</span><span class='line'>            if (stmt.getUpdateCount() == -1) {
</span><span class='line'>                // no more results. Must be no resultset
</span><span class='line'>                break;
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return rs != null ? new ResultSetWrapper(rs, configuration) : null;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>其中stmt为CratePreparedStatement,其getMoreResults()实现:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Override
</span><span class='line'>public boolean getMoreResults() throws SQLException {
</span><span class='line'>    return false;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>因此逻辑进入到else中,stmt.getUpdateCount()的实现:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Override
</span><span class='line'>public int getUpdateCount() throws SQLException {
</span><span class='line'>    checkClosed();  //check connection是否被关闭
</span><span class='line'>    if (resultSet == null && sqlResponse != null) {
</span><span class='line'>        return (int) sqlResponse.rowCount();
</span><span class='line'>    }
</span><span class='line'>    return -1;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>其中CratePreparedStatement的resultSet为null,并且sqlResponse不为空,sqlResponse的rowCount为0,因此getUpdateCount()返回值为0.因此getFirstResultSet中继续在while循环中,无法跳出.</p>

<p><img src="/images/crate/crate_jdbc_bug_code.png"></p>

<h1>3.绕过</h1>

<p>归结起来产生问题的很简单,就是查询的结果集为空的时候,就会产生死循环,针对两种死循环场景,我们都可以绕过:</p>

<pre><code>1.查询之前,先执行count查询,当count为0,即crate中没有满足我们查询条件的数据,则直接返回空数据集;
2.分页查询的时候,先执行count查询,当分页的offset大于等于count,则值额节返回空数据集;
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/05/19/mysql-thread-pool-size/">Mysql Thread_pool_size</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-05-19T06:23:18+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>19</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>6:23 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近项目中的beta环境,多个应用(10+个)连接数据库,使用的是连接池管理数据库连接.</p>

<p>最近应用中经常抛出数据库连接异常(我们使用的连接池是druid),简单的就是说无法获取Mysql的连接,创建连接失败(create connection error):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[2015-05-14 15:50:51 ERROR com.alibaba.druid.pool.DruidDataSource:1363] create connection error 
</span><span class='line'>com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: Communications link failure
</span><span class='line'>
</span><span class='line'>The last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server.
</span><span class='line'>    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) ~[na:1.7.0_45]
</span><span class='line'>    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57) ~[na:1.7.0_45]
</span><span class='line'>    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) ~[na:1.7.0_45]
</span><span class='line'>    at java.lang.reflect.Constructor.newInstance(Constructor.java:526) ~[na:1.7.0_45]
</span><span class='line'>    at com.mysql.jdbc.Util.handleNewInstance(Util.java:411) ~[mysql-connector-java-5.1.21.jar:na]
</span><span class='line'>    at com.mysql.jdbc.SQLError.createCommunicationsException(SQLError.java:1117) ~[mysql-connector-java-5.1.21.jar:na]
</span><span class='line'>    at com.mysql.jdbc.MysqlIO.&lt;init&gt;(MysqlIO.java:350) ~[mysql-connector-java-5.1.21.jar:na]
</span><span class='line'>    at com.mysql.jdbc.ConnectionImpl.coreConnect(ConnectionImpl.java:2393) ~[mysql-connector-java-5.1.21.jar:na]
</span><span class='line'>    at com.mysql.jdbc.ConnectionImpl.connectOneTryOnly(ConnectionImpl.java:2430) ~[mysql-connector-java-5.1.21.jar:na]
</span><span class='line'>    at com.mysql.jdbc.ConnectionImpl.createNewIO(ConnectionImpl.java:2215) ~[mysql-connector-java-5.1.21.jar:na]
</span><span class='line'>    at com.mysql.jdbc.ConnectionImpl.&lt;init&gt;(ConnectionImpl.java:813) ~[mysql-connector-java-5.1.21.jar:na]
</span><span class='line'>    at com.mysql.jdbc.JDBC4Connection.&lt;init&gt;(JDBC4Connection.java:47) ~[mysql-connector-java-5.1.21.jar:na]
</span><span class='line'>    at sun.reflect.GeneratedConstructorAccessor34.newInstance(Unknown Source) ~[na:na]
</span><span class='line'>    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) ~[na:1.7.0_45]
</span><span class='line'>    at java.lang.reflect.Constructor.newInstance(Constructor.java:526) ~[na:1.7.0_45]
</span><span class='line'>    at com.mysql.jdbc.Util.handleNewInstance(Util.java:411) ~[mysql-connector-java-5.1.21.jar:na]
</span><span class='line'>    at com.mysql.jdbc.ConnectionImpl.getInstance(ConnectionImpl.java:399) ~[mysql-connector-java-5.1.21.jar:na]
</span><span class='line'>    at com.mysql.jdbc.NonRegisteringDriver.connect(NonRegisteringDriver.java:334) ~[mysql-connector-java-5.1.21.jar:na]
</span><span class='line'>    at com.alibaba.druid.pool.DruidAbstractDataSource.createPhysicalConnection(DruidAbstractDataSource.java:1296) ~[druid-0.2.18.jar:0.2.18]
</span><span class='line'>    at com.alibaba.druid.pool.DruidAbstractDataSource.createPhysicalConnection(DruidAbstractDataSource.java:1352) ~[druid-0.2.18.jar:0.2.18]
</span><span class='line'>    at com.alibaba.druid.pool.DruidDataSource$CreateConnectionThread.run(DruidDataSource.java:1361) ~[druid-0.2.18.jar:0.2.18]
</span><span class='line'>Caused by: java.net.ConnectException: Connection refused
</span><span class='line'>        at java.net.PlainSocketImpl.socketConnect(Native Method) ~[na:1.7.0_45]
</span><span class='line'>        at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:339) ~[na:1.7.0_45]
</span><span class='line'>        at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:200) ~[na:1.7.0_45]
</span><span class='line'>        at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:182) ~[na:1.7.0_45]
</span><span class='line'>        at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392) ~[na:1.7.0_45]
</span><span class='line'>        at java.net.Socket.connect(Socket.java:579) ~[na:1.7.0_45]
</span><span class='line'>        at java.net.Socket.connect(Socket.java:528) ~[na:1.7.0_45]
</span><span class='line'>        at java.net.Socket.&lt;init&gt;(Socket.java:425) ~[na:1.7.0_45]
</span><span class='line'>        at java.net.Socket.&lt;init&gt;(Socket.java:241) ~[na:1.7.0_45]
</span><span class='line'>        at com.mysql.jdbc.StandardSocketFactory.connect(StandardSocketFactory.java:257) ~[mysql-connector-java-5.1.21.jar:na]
</span><span class='line'>        at com.mysql.jdbc.MysqlIO.&lt;init&gt;(MysqlIO.java:300) ~[mysql-connector-java-5.1.21.jar:na]
</span><span class='line'>        ... 14 common frames omitted</span></code></pre></td></tr></table></div></figure>


<p>开始怀疑机器的压力过大,将一些应用停止,还是出现这个问题.</p>

<p>但是相同的代码在dev环境一切正常,beta环境的机器配置要优于dev环境的.</p>

<h1>1.Druid配置</h1>

<p>首先怀疑那块的代码问题导致的Mysql连接没有被释放.</p>

<p>由于我们使用Druid连接池,尝试使用Druid的removeAbandoned功能,这个配置的意义就是连接泄漏监测,通过这个监控没有发现异常.</p>

<p>当程序存在缺陷时，申请的连接忘记关闭，这时候，就存在连接泄漏了。Druid提供了RemoveAbandanded相关配置，用来关闭长时间不使用的连接.</p>

<p>配置removeAbandoned对性能会有一些影响，建议怀疑存在泄漏之后再打开。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;property name="removeAbandoned" value="true" /&gt; &lt;!-- 打开removeAbandoned功能--&gt;
</span><span class='line'>&lt;property name="removeAbandonedTimeout" value="600" /&gt; &lt;!-- 600秒，也就是10分钟--&gt;
</span><span class='line'>&lt;property name="logAbandoned" value="true" /&gt; &lt;!-- 关闭abanded连接时输出错误日志--&gt;</span></code></pre></td></tr></table></div></figure>


<p>`
当removeAbandoned=true之后，可以在内置监控界面datasource.html中的查看ActiveConnection StackTrace属性的，可以看到未关闭连接的具体堆栈信息，从而方便查出哪些连接泄漏了。</p>

<p>参考:
<a href="https://github.com/alibaba/druid/wiki/%E8%BF%9E%E6%8E%A5%E6%B3%84%E6%BC%8F%E7%9B%91%E6%B5%8B">https://github.com/alibaba/druid/wiki/%E8%BF%9E%E6%8E%A5%E6%B3%84%E6%BC%8F%E7%9B%91%E6%B5%8B</a></p>

<h1>2.diff mysql status</h1>

<p>既然dev环境正常,因此我们的做法是拿出dev环境和beta环境的show status结果进行diff,结果发现了一个比较可疑的参数的配置有差异:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>thread_pool_size</span></code></pre></td></tr></table></div></figure>


<p>dev环境配置是16,而beta环境是4,同时线上环境的配置是24.初步判断beta环境的thread_pool_size设置应该是有问题的.</p>

<h1>3.thread_pool_size</h1>

<p>参考官网的描述</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>thread_pool_size is the most important parameter controlling thread pool performance. It can be set only at server startup. Our experience in testing the thread pool indicates the following:
</span><span class='line'>
</span><span class='line'>If the primary storage engine is InnoDB, the optimal thread_pool_size setting is likely to be between 16 and 36, with the most common optimal values tending to be from 24 to 36. We have not seen any situation where the setting has been optimal beyond 36. There may be special cases where a value smaller than 16 is optimal.
</span><span class='line'>
</span><span class='line'>For workloads such as DBT2 and Sysbench, the optimum for InnoDB seems to be usually around 36. For very write-intensive workloads, the optimal setting can sometimes be lower.
</span><span class='line'>
</span><span class='line'>If the primary storage engine is MyISAM, the thread_pool_size setting should be fairly low. We tend to get optimal performance for values from 4 to 8. Higher values tend to have a slightly negative but not dramatic impact on performance.</span></code></pre></td></tr></table></div></figure>


<p>简单的翻译一下:
thread_pool_size是控制线程池性能最重要的一个参数,这个参数只能在Mysql服务启动的时候设置(这是官网5.5版本的文档,5.6版本证明是可以动态修改的).官网的推荐设置:</p>

<pre><code>1.如果存储引擎是InnoDB,thread_pool_size值设置16到36之间比较好,一般配置在24到36之间;
2.如果存储引擎是MyISAM,thread_pool_size值应该被设置得相当小,倾向于设置在4到8之间;
</code></pre>

<p>官方网站:
<a href="https://dev.mysql.com/doc/refman/5.5/en/thread-pool-tuning.html">https://dev.mysql.com/doc/refman/5.5/en/thread-pool-tuning.html</a></p>

<h3>3.1 thread_pool_size意义</h3>

<p>参数thread_pool_size的命令可能会让大家产生误解，它不是指的线程池的大小，而是线程组的大小。</p>

<p>类似所有创建的线程都在某一个group里，group的编号从1~thread_pool_size，每个group里的worker线程数可以通过参数thread_pool_oversubscribe来控制（默认为3）.</p>

<p>同时活跃的最大worker线程数=thread_pool_size * (thread_pool_oversubscribe + 1);</p>

<p>thread_pool_size默认值为CPU核心数，最大为128(MAX_THREAD_GROUPS)，在启动时，就会把128个Group对应的结构体(all_groups)初始化好。每个group(编号小于等于thread_pool_size)会创建一个epoll对象；</p>

<p>当MySQL建立connection时, MySQL根据connection的thread id对thread_pool_size取模,将 connection发起的sql语句分配到对应的group.若worker达到最大数量后还是不足以处理回话请求, 则连接在本group上等待,导致sql语句的RT(Response time)增大。</p>

<p>简单示意图如下:</p>

<p><img src="/images/mysql/Mysql_Pool.png"></p>

<p>所有之前的问题出现的情况是:</p>

<pre><code>1.thread_pool_size为4,即mysql每个thread pool的group中work线程的大小为4,如果有多个应用,恰好多个线程的connection被分发到某一个group上(假设为group-2),并且相当长一段时间一致在占有(比如我们在beta环境的连接,会占用并忙碌长达半小时),这时候,新来的连接正好也分发到group-2上,这时候Mysql上的group-2就没有多余的work线程来为其服务,即其无法和mysql创建连接,从而出现create connection error的异常.
</code></pre>

<p>参考:
<a href="http://get.jobdeer.com/908.get">http://get.jobdeer.com/908.get</a>
<a href="http://chuansong.me/n/1192563">http://chuansong.me/n/1192563</a>
<a href="http://mysqllover.com/?p=826">http://mysqllover.com/?p=826</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/05/18/spring-aopwu-xiao/">Spring AOP无效</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-05-18T19:31:35+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>18</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>7:31 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近在重构项目,有一个场景:根据方法的返回值判断是否成功,成功则从入参里获取需要的参数,构造消息(Msg)并发送通知其他模块.</p>

<p>因为是比较通用的逻辑(判断返回值,获取参数,发送消息),因此做成Spring注解的形式,注解中会用AOP拦截方法获取方法的返回值和参数.</p>

<p>其中获取参数使用的是Spring SpEL表达式.</p>

<h1>1.使用背景</h1>

<p>碰到的一个问题是AOP拦截无法获取private,protected和inner方法的参数.使用场景如下:</p>

<h3>1.1 注解定义</h3>

<p>首先定义注解用于获取</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Target(ElementType.METHOD)
</span><span class='line'>@Retention(RetentionPolicy.RUNTIME)
</span><span class='line'>public @interface Param {
</span><span class='line'>    /**
</span><span class='line'>     * 参数定义,标识了参数的获取方式,或常量值
</span><span class='line'>     */
</span><span class='line'>    String[] params();
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 操作类型,标识了当前这注解该被哪个处理类来处理
</span><span class='line'>     */
</span><span class='line'>    String[] operate();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>1.2 定义切面</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Aspect
</span><span class='line'>public class testAspect {
</span><span class='line'>    /**
</span><span class='line'>     * 根据注解获取切面
</span><span class='line'>     */
</span><span class='line'>    @Pointcut("@annotation(com.aaa.bbb.ccc.ParamGrabber)")
</span><span class='line'>    public void aspectPointCut() {
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>    * AOP, 定义方法返回之后的操作
</span><span class='line'>    */
</span><span class='line'>    @AfterReturning(value = "aspectPointCut()", returning = "returnValue")
</span><span class='line'>    public void afterReturning(JoinPoint point, Object returnValue){
</span><span class='line'>        //1.获取拦截的类和方法
</span><span class='line'>
</span><span class='line'>        //2.获取方法上我们定义的特定注解
</span><span class='line'>
</span><span class='line'>        //3.根据注解的参数中的spel表达式,从方法入参中获取我们需要的参数
</span><span class='line'>
</span><span class='line'>        //4.一些列的Processor处理逻辑
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>1.3 处理类</h3>

<p>定义获取的参数之后的处理类的逻辑:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public interface Processor {
</span><span class='line'>    /**
</span><span class='line'>     * 本processor可以处理的操作类型
</span><span class='line'>     */
</span><span class='line'>    List&lt;String&gt; supportOperates();
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     *
</span><span class='line'>     * 此processor的处理逻辑
</span><span class='line'>     */
</span><span class='line'>    void process(XxxContext context);
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 返回值验证,是否需要执行process操作
</span><span class='line'>     */
</span><span class='line'>    boolean isReturnValid(XxxContext context, Object returnValue);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>之后利用Spring就可以获取上下问中所有的实现类:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class ProcessorSupport implements ApplicationContextAware, InitializingBean {
</span><span class='line'>    // Spring上下文
</span><span class='line'>    private ApplicationContext applicationContext;
</span><span class='line'>
</span><span class='line'>    private final Multimap&lt;String, Processor&gt; processorMap = HashMultimap.create();
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
</span><span class='line'>        this.applicationContext = applicationContext;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    public void afterPropertiesSet() throws Exception {
</span><span class='line'>        // 从Spring上下文获取Processor的所有具体实现类
</span><span class='line'>        Map&lt;String, Processor&gt; beansOfType = applicationContext.getBeansOfType(Processor.class);
</span><span class='line'>        for(Processor processor : beansOfType.values()) {
</span><span class='line'>            for(String op : processor.supportOperates()) {
</span><span class='line'>                processorMap.put(op, processor);
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //根据注解中定义的operate来获取具体的处理类Processor
</span><span class='line'>    @Override
</span><span class='line'>    public Collection&lt;Processor&gt; getProcessor(String operate) {
</span><span class='line'>        return processorMap.get(operate);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>1.4 使用</h3>

<p>使用的时候,首先得实现一个具体的Processor:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class MyProcessor implements Processor {
</span><span class='line'>
</span><span class='line'>    public static final String SPECIFIC_PROCESSOR_KEY = "SPECIFIC_PROCESSOR_KEY";
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    public List&lt;String&gt; supportOperates() {
</span><span class='line'>        return ImmutableList.of(
</span><span class='line'>                SPECIFIC_PROCESSOR_KEY
</span><span class='line'>        );
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    public void process(XxxContext context) {
</span><span class='line'>        //获取注解解析得到的参数
</span><span class='line'>        Map&lt;String, Object&gt; parsedParam = context.getParsedParam();
</span><span class='line'>
</span><span class='line'>        //构建发送的消息内容
</span><span class='line'>        Msg msg = buildNoticeMsg(parsedParam);
</span><span class='line'>
</span><span class='line'>        //发送消息
</span><span class='line'>        noticeService.doNotice(msg);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    public boolean isReturnValid(XxxContext context, Object returnValue) {
</span><span class='line'>        //判断返回值是否有效...
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>具体使用的地方:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'>* 根据SPECIFIC_PROCESSOR_KEY找到MyProcessor
</span><span class='line'>* params中使用SpEL获取参数中的某个属性
</span><span class='line'>*/
</span><span class='line'>@Param(operate = MyProcessor.SPECIFIC_PROCESSOR_KEY, params = {
</span><span class='line'>        CrateConstants.KEYS_KEY + "={#p0.![propertyName]}"})
</span><span class='line'>public int batchInsert(List&lt;Tag&gt; tagList) {
</span><span class='line'>    if (CollectionUtils.isEmpty(tagList)) {
</span><span class='line'>        return 0;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    return tagDao.insertBatchly(tagList);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h1>2.问题</h1>

<h3>2.1 private和protected方法无效</h3>

<p>private和protected方法(通常为类的inner方法)无法使用我们定义的注解来达到目的,如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//供外部调用的方法
</span><span class='line'>public class XxxService {
</span><span class='line'>    public int outerMethod(List&lt;Tag&gt; tagList) {
</span><span class='line'>        return innerMethod(tagList);
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>//被当前类的其他方法调用的内部方法
</span><span class='line'>@Param(operate = MyProcessor.SPECIFIC_PROCESSOR_KEY, params = {
</span><span class='line'>        CrateConstants.KEYS_KEY + "={#p0.![propertyName]}"})
</span><span class='line'>private int innerMethod(List&lt;Tag&gt; tagList) {
</span><span class='line'>    if (CollectionUtils.isEmpty(tagList)) {
</span><span class='line'>        return 0;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    return tagDao.insertBatchly(tagList);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.2 inner public方法无效</h3>

<p>定义如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//供外部调用的方法
</span><span class='line'>public class XxxService {
</span><span class='line'>    public int outerMethod(List&lt;Tag&gt; tagList) {
</span><span class='line'>        return innerMethod(tagList);
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>//被当前类的其他方法调用的内部方法
</span><span class='line'>@Param(operate = MyProcessor.SPECIFIC_PROCESSOR_KEY, params = {
</span><span class='line'>        CrateConstants.KEYS_KEY + "={#p0.![propertyName]}"})
</span><span class='line'>public int innerMethod(List&lt;Tag&gt; tagList) {
</span><span class='line'>    if (CollectionUtils.isEmpty(tagList)) {
</span><span class='line'>        return 0;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    return tagDao.insertBatchly(tagList);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>调用的时候调用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xxxServiceIns.outerMethod(...);</span></code></pre></td></tr></table></div></figure>


<h1>3.原因</h1>

<h3>3.1 private和protected方法无效</h3>

<p>Spring的AOP框架基于代理实现的(proxy-based).使用原生的Java的代理是无法代理protected和private类型的方法(详见后续结束).</p>

<p>而CGLIB的代理虽然在技术上可以代理protected和private类型的方法,但是用于AOP的时候不推荐代理protected和private类型的方法.</p>

<p>结论就是,任何定义的pointcut只在public方法上有效.</p>

<p>参考:</p>

<p><a href="http://stackoverflow.com/questions/15093894/aspectj-pointcut-for-annotated-private-methods">http://stackoverflow.com/questions/15093894/aspectj-pointcut-for-annotated-private-methods</a></p>

<p>spring官方文档关于AOP的解释中也有相关的说明:</p>

<p><a href="http://docs.spring.io/spring/docs/3.1.x/spring-framework-reference/html/aop.html#aop-introduction-spring-defn">http://docs.spring.io/spring/docs/3.1.x/spring-framework-reference/html/aop.html#aop-introduction-spring-defn</a></p>

<h3>3.2 inner public方法无效</h3>

<p>原因其实就是一句话:Spring AOP是基于代理机制的.</p>

<p>考虑如下场景,当你拿到一个无代理的、无任何特殊之处的对象引用时:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class SimplePojo implements SimpleInterface {
</span><span class='line'>    public void foo() {
</span><span class='line'>       // this next method invocation is a direct call on the 'this' reference
</span><span class='line'>       this.bar();
</span><span class='line'>    }
</span><span class='line'>                
</span><span class='line'>    public void bar() {
</span><span class='line'>        // some logic...
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当你调用一个对象引用的方法时,此对象引用上的方法直接被调用,如下所示:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void main(String[] args) {
</span><span class='line'>   SimplePojo ins = new SimplePojo();
</span><span class='line'>   // this is a direct method call on the 'ins' reference
</span><span class='line'>   ins.foo();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><img src="/images/sping/call_native.png"></p>

<p>当客户代码所持有的引用是一个代理的时候则略有不同了,当调用foo()方法时候,首先会调用原始foo()方法上的@Before的代码逻辑,然后调用原始的foo()方法,原始foo()方法内的bar()调用的是原始对象的this.bar(),即一旦调用最终抵达了目标对象 (此处为SimplePojo类的引用),任何对自身的调用例如this.bar()将对this引用进行调用而非代理。</p>

<p>这一点意义重大,它意味着自我调用将不会导致和方法调用关联的AOP通知得到执行的机会。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SimplePojo proxy = proxyFactory.getProxy(Pojo.class);
</span><span class='line'>proxy.foo();</span></code></pre></td></tr></table></div></figure>


<p><img src="/images/sping/call_proxy.png"></p>

<p>参考:
<a href="http://m.oschina.net/blog/161387">http://m.oschina.net/blog/161387</a></p>

<h1>4.Spring AOP代理</h1>

<p>Spring AOP使用JDK动态代理或者CGLIB来为目标对象创建代理。</p>

<p>如果被代理的目标对象实现了至少一个接口,则会使用JDK动态代理。所有该目标类型实现的接口都将被代理。 若该目标对象没有实现任何接口,则创建一个CGLIB代理。</p>

<p>如果你希望强制使用CGLIB代理,(例如：希望代理目标对象的所有方法,而不只是实现自接口的方法) 那也可以。但是需要考虑以下问题:</p>

<pre><code>1.无法通知(advise)final方法,因为他们不能被覆写。
2.代理对象的构造器会被调用两次。因为在CGLIB代理模式下每一个代理对象都会 产生一个子类。每一个代理实例会生成两个对象：实际代理对象和它的一个实现了通知的子类实例 而是用JDK代理时不会出现这样的行为。通常情况下,调用代理类型的构造器两次并不是问题, 因为除了会发生指派外没有任何真正的逻辑被实现。
3.CGLib的效率没有使用JDK代理机制高,速度平均要慢8倍左右。
</code></pre>

<p>强制使用CGLIB代理需要将&lt;aop:config>的proxy-target-class属性设为true:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;aop:config proxy-target-class="true"&gt;
</span><span class='line'>   ...
</span><span class='line'>&lt;/aop:config&gt;</span></code></pre></td></tr></table></div></figure>


<p>当使用@AspectJ自动代理时要强制使用CGLIB,请将&lt;aop:aspectj-autoproxy>的proxy-target-class属性设置为true:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt;</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/04/28/cratehuan-jing-da-jian/">Crate环境搭建</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-28T01:42:15+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>28</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>1:42 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>1.Crate简介</h1>

<p>最近工作中使用Crate来做搜索.总结工作中Crate的知识.</p>

<p>官方网站:<a href="https://crate.io/">https://crate.io/</a></p>

<h1>2.Crate安装要求</h1>

<p>Crate最低版本要求Java 7,并且Crate的所有节点和客户端需要使用相同的JVM版本.
并且Java 7要求update 55或者之后的版本,Java 8则要求update 20或者之后的版本.</p>

<p>警告:JAVA 7之前的版本会造成脏数据和数据丢失.</p>

<h1>3.Crate安装</h1>

<p>这里选择最基本的通过下载tar.gz安装包的形式安装,还可以通过Docker等形式安装</p>

<p>详见:<a href="https://crate.io/docs/en/latest/installation.html">https://crate.io/docs/en/latest/installation.html</a></p>

<h3>3.1.下载</h3>

<p>从下面的url下载最新的稳定版本:
<a href="https://crate.io/download/">https://crate.io/download/</a></p>

<p>所有可下载版本见:
<a href="https://cdn.crate.io/downloads/releases/">https://cdn.crate.io/downloads/releases/</a></p>

<p>这里下载的是0.47.7版本:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>wget https://cdn.crate.io/downloads/releases/crate-0.47.7.tar.gz --no-check-certificate</span></code></pre></td></tr></table></div></figure>


<h3>3.2.解压</h3>

<p>自动生成crate-0.47.7目录</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd /home/work
</span><span class='line'>sudo tar zxf ~/crate-0.47.7.tar.gz</span></code></pre></td></tr></table></div></figure>


<h1>4.Crate配置</h1>

<p>Crate配置参考:
<a href="https://crate.io/docs/en/latest/configuration.html">https://crate.io/docs/en/latest/configuration.html</a></p>

<p>Crate的有一套默认配置,通常情况下不需要额外的配置.</p>

<p>Crate的配置主要通过config/crate.yml文件,下载中的config/crate.yml包含了所有的配置项,包括其默认值和注释.</p>

<p>启动Crate的时候可以指定自己的配置文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>./bin/crate -Des.config=/path/to/config.yml</span></code></pre></td></tr></table></div></figure>


<p>任何配置都可以在配置文件中指定或者作为启动时候的系统属性.比如据群名称的设置可以在启动时设置:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>./bin/crate -Des.cluster.name=cluster</span></code></pre></td></tr></table></div></figure>


<p>也可以在配置文件中配置:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cluster.name = cluster</span></code></pre></td></tr></table></div></figure>


<p>配置的优先级如下,越往后优先级越大(即后面的配置会覆盖前面的配置):</p>

<pre><code>1.internal defaults
2.system properties
3.options from config file
4.command-line properties
</code></pre>

<h3>4.1 基本配置</h3>

<p>一些基本的配置,工作目录和机器列表等:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>path.data: /home/work/crate/data
</span><span class='line'>path.work: /home/work/crate/work
</span><span class='line'>path.logs: /home/work/crate/logs
</span><span class='line'>
</span><span class='line'>discovery.zen.minimum_master_nodes: 2
</span><span class='line'>discovery.zen.ping.timeout: 6s
</span><span class='line'>discovery.zen.ping.multicast.enabled: false
</span><span class='line'>discovery.zen.ping.unicast.hosts: ["192.168.1.100:4300", "192.168.1.101:4300", "192.168.1.102:4300"]
</span><span class='line'>discovery.zen.fd.ping_interval: 10s
</span><span class='line'>
</span><span class='line'>cluster.name: crate1
</span><span class='line'>transport.tcp.port: 4300
</span><span class='line'>http.port: 4200</span></code></pre></td></tr></table></div></figure>


<h1>5.Crate运行</h1>

<h3>5.1.启动</h3>

<p>在前台运行(可以通过Control-C中断其运行):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd ./crate-0.47.7
</span><span class='line'>./bin/crate</span></code></pre></td></tr></table></div></figure>


<p>加上-d参数让crate在后台运行.</p>

<h3>5.2.Crash</h3>

<p>bin下面还包含Crash(The Crate Shell),需要python环境运行,可以通过这个Crash输入诸如sql等命令</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[/workspace/crate/bin]$ ./crash
</span><span class='line'>...
</span><span class='line'>CONNECT OK
</span><span class='line'>cr&gt; select count(1) from test;
</span><span class='line'>+----------+
</span><span class='line'>| count(1) |
</span><span class='line'>+----------+
</span><span class='line'>|   522835 |
</span><span class='line'>+----------+
</span><span class='line'>SELECT 1 row in set (0.032 sec)</span></code></pre></td></tr></table></div></figure>


<h3>5.3.Admin</h3>

<p>Crate同时也提供了一个基于web的administration接口.在端口4200上提供服务,可以在浏览器中通过机器名访问:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>http://host1.example.com:4200/_plugin/crate-admin/#/console</span></code></pre></td></tr></table></div></figure>


<p>这个Admin在Crate的每个节点上都可以运行.</p>

<h1>6.Crate安装简单示例</h1>

<p>这里使用3台机器搭建Crate集群,假设三台机器的IP如下:</p>

<pre><code>host1.example.com    192.168.1.100
host2.example.com    192.168.1.101
host3.example.com    192.168.1.102
</code></pre>

<p>每台机器上做相同的工作:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1.将Crate下载到自己的目录
</span><span class='line'>wget https://cdn.crate.io/downloads/releases/crate-0.47.7.tar.gz --no-check-certificate
</span><span class='line'>
</span><span class='line'>2.解压
</span><span class='line'>cd /home/work
</span><span class='line'>sudo tar zxf ~/crate-0.47.7.tar.gz
</span><span class='line'>
</span><span class='line'>3.创建Crate工作目录
</span><span class='line'>cd /home/work
</span><span class='line'>sudo mkdir crate
</span><span class='line'>cd crate
</span><span class='line'>sudo mkdir data
</span><span class='line'>sudo mkdir logs
</span><span class='line'>sudo mkdir work
</span><span class='line'>
</span><span class='line'>4.修改基本配置(/config/crate.yml文件)
</span><span class='line'>path.data: /home/work/crate/data
</span><span class='line'>path.work: /home/work/crate/work
</span><span class='line'>path.logs: /home/work/crate/logs
</span><span class='line'>
</span><span class='line'>discovery.zen.minimum_master_nodes: 2
</span><span class='line'>discovery.zen.ping.timeout: 6s
</span><span class='line'>discovery.zen.ping.multicast.enabled: false
</span><span class='line'>discovery.zen.ping.unicast.hosts: ["192.168.1.100:4300", "192.168.1.101:4300", "192.168.1.102:4300"]
</span><span class='line'>discovery.zen.fd.ping_interval: 10s
</span><span class='line'>
</span><span class='line'>5.配置内存大小(/bin/crate文件)
</span><span class='line'>CRATE_HEAP_SIZE=4g
</span><span class='line'>
</span><span class='line'>6.启动Crate
</span><span class='line'>sudo /home/work/crate-0.47.7/bin/crate -d
</span><span class='line'>
</span><span class='line'>7.查看启动日志
</span><span class='line'>tail -f /home/work/crate/logs/crate.log</span></code></pre></td></tr></table></div></figure>


<p>三台机器都启动了,它们之间会相互感应,形成一个集群.</p>

<h1>7.Crate SQL</h1>

<p>crate的sql操作和mysql基本一致,详细可以参考:
<a href="https://crate.io/docs/en/latest/sql/index.html">https://crate.io/docs/en/latest/sql/index.html</a></p>

<h1>8.Crate运维脚本</h1>

<p>因为dev环境需求,搭建了6套dev的crate环境,发现每次启动停止crate比较麻烦,因此自己写了点基本的维护脚本,只适用于我当前的环境,即在/home/q/crate_workspace下存在6套环境,其他环境可以根据情况自行修改使用:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>drwxr-xr-x 4 root root 4096 Apr 28 17:37 crate1
</span><span class='line'>drwxr-xr-x 4 root root 4096 Apr 28 17:37 crate2
</span><span class='line'>drwxr-xr-x 4 root root 4096 Apr 28 17:37 crate3
</span><span class='line'>drwxr-xr-x 4 root root 4096 Apr 30 11:25 crate4
</span><span class='line'>drwxr-xr-x 4 root root 4096 Apr 28 17:37 crate5
</span><span class='line'>drwxr-xr-x 4 root root 4096 Apr 28 17:37 crate6
</span><span class='line'>-rwxr-xr-x 1 root root   53 Apr 28 15:41 restart_crate.sh
</span><span class='line'>-rwxr-xr-x 1 root root  724 Apr 28 16:31 start_crate.sh
</span><span class='line'>-rwxr-xr-x 1 root root 1041 Apr 28 17:15 stop_crate.sh</span></code></pre></td></tr></table></div></figure>


<p>每套环境之下有自己的配置(crate-source)和工作目录(crate)和一个存放crate线程id的文件:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>drwxr-xr-x 6 root root 4096 Apr 28 15:05 crate
</span><span class='line'>drwxr-xr-x 6 root root 4096 Apr 28 15:54 crate-source
</span><span class='line'>-rw-r--r-- 1 root root    5 Apr 28 17:37 pid</span></code></pre></td></tr></table></div></figure>


<p>脚本如下,启动crate的脚本start_crate.sh:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/bin/bash
</span><span class='line'>
</span><span class='line'>if echo $1 | grep -q "/home/q/crate_workspace"
</span><span class='line'>then
</span><span class='line'>    export CRATE_BASE=${1%/}
</span><span class='line'>else
</span><span class='line'>    export CRATE_BASE=/home/q/crate_workspace/${1%/}
</span><span class='line'>fi
</span><span class='line'>echo -e $CRATE_BASE
</span><span class='line'>
</span><span class='line'>if ! [ -e $CRATE_BASE/crate-source/bin/crate ]
</span><span class='line'>then
</span><span class='line'>    echo -e " usage: $0 home/q/crate_workspace/CRATE_DIR\n"
</span><span class='line'>    exit 1;
</span><span class='line'>fi
</span><span class='line'>
</span><span class='line'>if [ -e $CRATE_BASE/pid ]
</span><span class='line'>then
</span><span class='line'>    CRATE_ID=`cat $CRATE_BASE/pid`
</span><span class='line'>    echo "crate(${CRATE_ID}) still running now , please shutdown it firest";
</span><span class='line'>    exit 2;
</span><span class='line'>fi
</span><span class='line'>
</span><span class='line'>#CRATE_START_LOG=`$CRATE_BASE/crate-source/bin/crate -p $CRATE_BASE/pid -d`
</span><span class='line'>$CRATE_BASE/crate-source/bin/crate -p $CRATE_BASE/pid -d
</span><span class='line'>
</span><span class='line'>if [ "$?" = "0" ]; then
</span><span class='line'>    echo "$0 ${1%/} start succeed"
</span><span class='line'>else
</span><span class='line'>    echo "$0 ${1%/} start failed"
</span><span class='line'>    echo $CRATE_START_LOG
</span><span class='line'>fi</span></code></pre></td></tr></table></div></figure>


<p>停止crate的脚本stop_crate.sh:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/bin/bash
</span><span class='line'>
</span><span class='line'>if echo $1 | grep -q "/home/q/crate_workspace"
</span><span class='line'>then
</span><span class='line'>    export CRATE_BASE=${1%/}
</span><span class='line'>else
</span><span class='line'>    export CRATE_BASE=/home/q/crate_workspace/${1%/}
</span><span class='line'>fi
</span><span class='line'>echo -e $CRATE_BASE
</span><span class='line'>
</span><span class='line'>if ! [ -e $CRATE_BASE/crate-source/bin/crate ]
</span><span class='line'>then
</span><span class='line'>    echo -e " usage: $0 home/q/crate_workspace/CRATE_DIR\n"
</span><span class='line'>    exit 1;
</span><span class='line'>fi
</span><span class='line'>
</span><span class='line'>if ! [ -e $CRATE_BASE/pid ]
</span><span class='line'>then
</span><span class='line'>    echo "crate instance not found : ${1%/}";
</span><span class='line'>    exit;
</span><span class='line'>fi
</span><span class='line'>
</span><span class='line'>CRATE_ID=`cat $CRATE_BASE/pid`
</span><span class='line'>
</span><span class='line'>for i in {1..10}; do
</span><span class='line'>    if [ -e $CRATE_BASE/pid ]; then
</span><span class='line'>        CRATE_ID=`cat $CRATE_BASE/pid`
</span><span class='line'>        if [ "$i" = "1" ]; then
</span><span class='line'>            echo -n "trying stop ($CRATE_ID): $i"
</span><span class='line'>        else
</span><span class='line'>            echo -n -e "\b$i"
</span><span class='line'>        fi
</span><span class='line'>        
</span><span class='line'>        if [ $i -ge 5 ]; then
</span><span class='line'>            kill "$CRATE_ID"
</span><span class='line'>            rm -f "$CRATE_BASE/pid"
</span><span class='line'>        fi
</span><span class='line'>
</span><span class='line'>        sleep 1 
</span><span class='line'>    else
</span><span class='line'>        if [ $i -gt 5 ]; then
</span><span class='line'>            echo -e "\n$CRATE_BASE was killed($i)"
</span><span class='line'>        else
</span><span class='line'>            echo -e "\n$CRATE_BASE was stoped"
</span><span class='line'>        fi
</span><span class='line'>
</span><span class='line'>        exit;
</span><span class='line'>    fi
</span><span class='line'>done;
</span><span class='line'>
</span><span class='line'>kill -9 "$CRATE_ID"
</span><span class='line'>
</span><span class='line'>echo "$CRATE_BASE was force killed"</span></code></pre></td></tr></table></div></figure>


<p>重启crate的脚本restart_crate.sh:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/bin/bash
</span><span class='line'>
</span><span class='line'>./stop_crate.sh $1
</span><span class='line'>
</span><span class='line'>./start_crate.sh $1</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/04/11/telnet-dubbo/">Telnet Dubbo</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-11T03:10:33+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>11</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>3:10 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Dubbo 2.0.5版本以后支持telnet命令，可以用来debug各个dubbo接口。</p>

<p>Dubbo官网：<a href="http://dubbo.io/User+Guide-zh.htm">http://dubbo.io/User+Guide-zh.htm</a></p>

<p>telnet涉及的命令包括：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ls
</span><span class='line'>ps
</span><span class='line'>cd
</span><span class='line'>pwd
</span><span class='line'>trace
</span><span class='line'>count
</span><span class='line'>invoke
</span><span class='line'>status
</span><span class='line'>log
</span><span class='line'>help
</span><span class='line'>clear
</span><span class='line'>exit</span></code></pre></td></tr></table></div></figure>


<h1>1.telnet</h1>

<p>连接dubbo的provider：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>telnet 127.0.0.1 20880</span></code></pre></td></tr></table></div></figure>


<h1>2.ls</h1>

<p>ls显示服务列表,ls -l显示服务详细信息列表:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dubbo&gt;ls
</span><span class='line'>Xxx.xx.xxx.service.ConsumerMessageHandler
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>ls XxxService显示服务的方法列表，ls -l XxxService显示服务的方法详细信息列表</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ls -l Xxx.xx.xxx.service.ConsumerMessageHandler</span></code></pre></td></tr></table></div></figure>


<h1>3.ps</h1>

<p>ps显示服务端口列表，ps -l显示服务地址列表(ip + 端口)：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dubbo&gt;ps -l
</span><span class='line'>dubbo://10.100.11.222:30003</span></code></pre></td></tr></table></div></figure>


<p>ps 20880显示端口上的连接信息，ps -l 20880显示端口上的连接详细信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dubbo&gt;ps -l 20880
</span><span class='line'>/127.0.0.1:51478 -&gt; /127.0.0.1:20880
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<h1>4.cd</h1>

<p>改变缺省服务，当设置了缺省服务，凡是需要输入服务名作为参数的命令，都可以省略服务参数。</p>

<p>cd /可以取消缺省服务</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dubbo&gt;cd Xxx.xx.xxx.service.ConsumerMessageHandler 
</span><span class='line'>Used the Xxx.xx.xxx.service.ConsumerMessageHandler as default.
</span><span class='line'>You can cancel default service by command: cd /</span></code></pre></td></tr></table></div></figure>


<h1>5.pwd</h1>

<p>显示当前缺省服务</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dubbo&gt;pwd
</span><span class='line'>Xxx.xx.xxx.service.ConsumerMessageHandler
</span><span class='line'>
</span><span class='line'>dubbo&gt;cd /
</span><span class='line'>Cancelled default service qunar.tc.qmq.service.ConsumerMessageHandler.
</span><span class='line'>
</span><span class='line'>dubbo&gt;pwd 
</span><span class='line'>/</span></code></pre></td></tr></table></div></figure>


<h1>6.trace</h1>

<p>trace用来跟踪调用情况，当响应的Service的方法被调有，就会有调用日志：</p>

<pre><code>trace XxxService                跟踪1次服务任意方法的调用情况
trace XxxService 10             跟踪10次服务任意方法的调用情况
trace XxxService xxxMethod      跟踪1次服务方法的调用情况
trace XxxService xxxMethod 10   跟踪10次服务方法的调用情况
</code></pre>

<h1>7.count</h1>

<pre><code>count XxxService                统计1次服务任意方法的调用情况。
count XxxService 10             统计10次服务任意方法的调用情况。
count XxxService xxxMethod      统计1次服务方法的调用情况。
count XxxService xxxMethod 10   统计10次服务方法的调用情况。
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dubbo&gt;count Xxx.xx.xxx.service.ConsumerMessageHandler
</span><span class='line'>dubbo&gt;
</span><span class='line'>+-------------------+-------+--------+--------+---------+-----+
</span><span class='line'>| method            | total | failed | active | average | max |
</span><span class='line'>+-------------------+-------+--------+--------+---------+-----+
</span><span class='line'>| queryMessageState | 0     | 0      | 0      | 0ms     | 0ms |
</span><span class='line'>| handle            | 0     | 0      | 0      | 0ms     | 0ms |
</span><span class='line'>+-------------------+-------+--------+--------+---------+-----+</span></code></pre></td></tr></table></div></figure>


<h1>8.invoke</h1>

<pre><code>调用服务的某个方法:  invoke XxxService.xxxMethod({"prop": "value"})
调用服务的方法(自动查找包含此方法的服务):  invoke xxxMethod({"prop": "value"})
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>invoke Xxx.xx.xxx.service..batchGetExpiredList({"batch":1})</span></code></pre></td></tr></table></div></figure>


<h1>9.status</h1>

<pre><code>status:显示汇总状态，该状态将汇总所有资源的状态，当全部OK时则显示OK，只要有一个ERROR则显示ERROR，只要有一个WARN则显示WARN

status -l:显示状态列表。
</code></pre>

<p>所有的资源包括:</p>

<pre><code>load        cpu数据,包括当前load,cpu核数
server      ip+port的列表(ps -l的数据)
datasource  数据库连接参数
threadpool  线程池参数
memory      当前JVM的内存使用情况(max,used,free)
registry    注册中心参数
spring      spring的配置文件
summary     上面这些信息中出现的Error等信息的汇总
</code></pre>

<p>示例如下
+&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+
| resource   | status | message                          |
+&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+
| load       | OK     | load:0.61,cpu:4                  |
| spring     | OK     | classpath:applicationContext.xml |
| summary    | ERROR  | registry                         |
+&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+</p>

<h1>10.log</h1>

<p>2.0.6以上版本支持</p>

<pre><code>log  error:     修改dubbo logger的日志级别
log 100:        查看file logger的最后100字符的日志
</code></pre>

<h1>11.help</h1>

<pre><code>help        显示telnet命帮助信息
help Xxx    显示xxx命令的详细帮助信息
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dubbo&gt;help 
</span><span class='line'>Please input "help [command]" show detail.
</span><span class='line'> log level                        - Change log level or show log 
</span><span class='line'> pwd                              - Print working default service.
</span><span class='line'> trace [service] [method] [times] - Trace the service.
</span><span class='line'> clear [lines]                    - Clear screen.
</span><span class='line'> exit                             - Exit the telnet.
</span><span class='line'> help [command]                   - Show help.
</span><span class='line'> info                             - show dubbo info
</span><span class='line'> ls [-l] [service]                - List services and methods.
</span><span class='line'> invoke [service.]method(args)    - Invoke the service method.
</span><span class='line'> ps [-l] [port]                   - Print server ports and connections.
</span><span class='line'> cd [service]                     - Change default service.
</span><span class='line'> status [-l]                      - Show status.
</span><span class='line'> count [service] [method] [times] - Count the service.</span></code></pre></td></tr></table></div></figure>


<h1>12.clear</h1>

<pre><code>clear           清除屏幕上的内容
clear 100       清除屏幕上的指定行数的内容
</code></pre>

<h1>13.exit</h1>

<pre><code>exit    退出当前telnet命令行。
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/04/09/spring-spelyu-fa/">Spring SpEL语法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-09T07:25:44+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>9</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>7:25 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近项目中遇到一个问题，无意中发现Spring SpEL语法，Spring的Cache正是基于此实现的，感觉很强大，学习一下。</p>

<h1>1.简介</h1>

<p>SpEL官网：<a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html">http://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html</a></p>

<p>Spring表达式语言全称为Spring Expression Language(缩写为SpEL)，能在运行时构建复杂表达式、存取对象图属性、对象方法调用等等，并且能与Spring功能完美整合，如能用来配置Bean定义。
表达式语言给静态Java语言增加了动态功能。</p>

<p>SpEL是单独模块，只依赖于core模块，不依赖于其他模块，可以单独使用。</p>

<p>SpEL支持以下功能:</p>

<pre><code>1.文本表达式(Literal expressions)
2.布尔操作和关系操作(Boolean and relational operators)
3.正则表达式(Regular expressions)
4.类表达式(Class expressions)
5.访问属性,数组,list和map(Accessing properties, arrays, lists, maps)
6.方法调用(Method invocation)
7.关系操作符(Relational operators)
8.赋值(Assignment)
9.调用构造器(Calling constructors)
10.Bean引用(Bean references)
11.数组构造(Array construction)
12.内脸list(Inline lists)
13.内联Map(Inline maps)
14.三元运算符(Ternary operator)
15.变量(Variables)
16.自定义函数(User defined functions)
17.集合投影(Collection projection)
18.集合筛选(Collection selection)
19.模板表达式(Templated expressions)
</code></pre>

<h1>2.SpEL使用</h1>

<p>下面通过一些简单的case来示范SpEL的使用.</p>

<h3>2.1 第一个SpEL</h3>

<p>SpEL表达式可以直接使用ExpressionParser解析,主要是调用ExpressionParser的parseExpression()方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_1(){
</span><span class='line'>    Expression expression = parser.parseExpression("'Testing Spring Expression Framework'");
</span><span class='line'>    String message = (String) expression.getValue();
</span><span class='line'>    System.out.println("Message is " + message);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.2 字面量表达式</h3>

<p>SpEL支持的字面量包括字符串、数字类型（int、long、float、double）、bool类型、null类型,注意字符串必须要单引号括起来:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_2(){
</span><span class='line'>    // evals to "Hello World"
</span><span class='line'>    String helloWorld = (String) parser.parseExpression("'Hello World'").getValue();
</span><span class='line'>    double avogadrosNumber = (Double) parser.parseExpression("6.0221415E+23").getValue();
</span><span class='line'>
</span><span class='line'>    // evals to 2147483647
</span><span class='line'>    int maxValue = (Integer) parser.parseExpression("0x7FFFFFFF").getValue();
</span><span class='line'>    boolean trueValue = (Boolean) parser.parseExpression("true").getValue();
</span><span class='line'>    Object nullValue = parser.parseExpression("null").getValue();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.3 算数运算表达式</h3>

<p>SpEL支持加(+)、减(-)、乘(*)、除(/)、求余（%）、幂（^）运算,SpEL还提供求余（MOD）和除（DIV）而外两个运算符，与"%&ldquo;和&rdquo;/&ldquo;等价，不区分大小写:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_3(){
</span><span class='line'>    int result1 = parser.parseExpression("1+2-3*4/2").getValue(Integer.class);
</span><span class='line'>    int result2 = parser.parseExpression("4%3").getValue(Integer.class);
</span><span class='line'>    int result3 = parser.parseExpression("2^3").getValue(Integer.class);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.4 关系表达式</h3>

<p>等于（==）、不等于(!=)、大于(>)、大于等于(>=)、小于(&lt;)、小于等于(&lt;=)，区间（between）运算:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_4(){
</span><span class='line'>    boolean result1 = parser.parseExpression("1&gt;2").getValue(boolean.class);
</span><span class='line'>    boolean result2 = parser.parseExpression("1 between {1, 2}").getValue(boolean.class);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>between运算符右边操作数必须是列表类型，且只能包含2个元素。第一个元素为开始，第二个元素为结束，区间运算是包含边界值的。</p>

<p>SpEL同样提供了等价的"EQ" 、"NE"、 &ldquo;GT"、"GE"、 "LT&rdquo; 、"LE"来表示等于、不等于、大于、大于等于、小于、小于等于，不区分大小写。</p>

<h3>2.5 逻辑表达式</h3>

<p>且（and）、或(or)、非(!或NOT),注意,逻辑运算符不支持 Java中的 &amp;&amp; 和 ||:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_5() {
</span><span class='line'>    String expression1 = "2&gt;1 and (!true or !false)";
</span><span class='line'>    boolean result1 = parser.parseExpression(expression1).getValue(boolean.class);
</span><span class='line'>
</span><span class='line'>    String expression2 = "2&gt;1 and (NOT true or NOT false)";
</span><span class='line'>    boolean result2 = parser.parseExpression(expression2).getValue(boolean.class);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.6 字符串连接及截取表达式</h3>

<p>使用"+&ldquo;进行字符串连接，使用&rdquo;&lsquo;String&rsquo;[0] [index]&ldquo;来截取一个字符，目前只支持截取一个，如&rdquo;&lsquo;Hello &rsquo; + &lsquo;World!&rsquo;&ldquo;得到"Hello World!"；而&rdquo;&lsquo;Hello World!&rsquo;[0]&ldquo;将返回"H"。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_6() {
</span><span class='line'>//    String expression1 = "'Hello Spring SpEL'[0] [5]";
</span><span class='line'>//    String result1 = parser.parseExpression(expression1).getValue(String.class);
</span><span class='line'>//    System.out.println("result1=" + result1);
</span><span class='line'>
</span><span class='line'>    String expression2 = "'Hello' + 'Spring' + 'SpEL.'";
</span><span class='line'>    String result2 = parser.parseExpression(expression2).getValue(String.class);
</span><span class='line'>//    System.out.println("result1=" + result1);
</span><span class='line'>    System.out.println("result2=" + result2);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.7 三目运算</h3>

<p>三目运算符 &ldquo;表达式1?表达式2:表达式3"用于构造三目运算表达式，如"2>1?true:false"将返回true；</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_7() {
</span><span class='line'>    boolean result1 = parser.parseExpression("2&gt;1?true:false").getValue(boolean.class);
</span><span class='line'>    System.out.println("result1=" + result1);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.8 正则表达式</h3>

<p>可以正则,格式为:str matches regex</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_8() {
</span><span class='line'>    boolean result1 = parser.parseExpression("'123' matches '\\d{3}'").getValue(boolean.class);
</span><span class='line'>    System.out.println("result1=" + result1);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.9 括号优先级表达式</h3>

<p>使用"(表达式)&ldquo;构造，括号里的具有高优先级</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_9() {
</span><span class='line'>    int result1 = parser.parseExpression("1+2-3*4/2").getValue(Integer.class);
</span><span class='line'>    int result2 = parser.parseExpression("1+(2-3)*4/2").getValue(Integer.class);
</span><span class='line'>    System.out.println("result1=" + result1);
</span><span class='line'>    System.out.println("result2=" + result2);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.10 类类型表达式</h3>

<p>使用"T(Type)&ldquo;来表示java.lang.Class实例，"Type"必须是类全限定名，"java.lang"包除外，即该包下的类可以不指定包名；使用类类型表达式还可以进行访问类静态方法及类静态字段。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_10() {
</span><span class='line'>    //java.lang包类访问
</span><span class='line'>    Class&lt;String&gt; result1 = parser.parseExpression("T(String)").getValue(Class.class);
</span><span class='line'>    System.out.println("result1=" + result1);
</span><span class='line'>    //其他包类访问
</span><span class='line'>    String expression2 = "T(com.qunar.scm.spel.SpelParser)";
</span><span class='line'>    Class&lt;String&gt; result2 = parser.parseExpression(expression2).getValue(Class.class);
</span><span class='line'>    System.out.println("result2=" + result2);
</span><span class='line'>    //类静态字段访问
</span><span class='line'>    int result3=parser.parseExpression("T(Integer).MAX_VALUE").getValue(int.class);
</span><span class='line'>    System.out.println("result3=" + result3);
</span><span class='line'>    //类静态方法调用
</span><span class='line'>    int result4 = parser.parseExpression("T(Integer).parseInt('1')").getValue(int.class);
</span><span class='line'>    System.out.println("result4=" + result4);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.11 类实例化</h3>

<p>类实例化同样使用java关键字"new"，类名必须是全限定名，但java.lang包内的类型除外，如String、Integer.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_11() {
</span><span class='line'>    String result1 = parser.parseExpression("new String('Spring SpEL')").getValue(String.class);
</span><span class='line'>    System.out.println("result1=" + result1);
</span><span class='line'>
</span><span class='line'>    Date result2 = parser.parseExpression("new java.util.Date()").getValue(Date.class);
</span><span class='line'>    System.out.println("result2=" + result2);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.12 instanceof表达式</h3>

<p>SpEL支持instanceof运算符，跟Java内使用同义:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_12() {
</span><span class='line'>    boolean result1 = parser.parseExpression("'Spring SpEL' instanceof T(String)").getValue(Boolean.class);
</span><span class='line'>    System.out.println("result1=" + result1);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.13 变量定义及引用</h3>

<p>变量定义通过EvaluationContext接口的setVariable(variableName, value)方法定义；在表达式中使用"#variableName"引用；</p>

<p>除了引用自定义变量，SpE还允许引用根对象及当前上下文对象，使用"#root"引用根对象，使用"#this"引用当前上下文对象；</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_13() {
</span><span class='line'>    EvaluationContext context = new StandardEvaluationContext();
</span><span class='line'>    context.setVariable("variable", "Spring SpEL");
</span><span class='line'>    String result1 = parser.parseExpression("#variable").getValue(context, String.class);
</span><span class='line'>    System.out.println("result1=" + result1);   //Spring SpEL
</span><span class='line'>
</span><span class='line'>    context = new StandardEvaluationContext("Spring SpEL");
</span><span class='line'>    String result2 = parser.parseExpression("#root").getValue(context, String.class);
</span><span class='line'>    System.out.println("result2=" + result2);   //Spring SpEL
</span><span class='line'>    String result3 = parser.parseExpression("#this").getValue(context, String.class);
</span><span class='line'>    System.out.println("result3=" + result3);   //Spring SpEL
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.14 自定义函数</h3>

<p>学习编写自定义的函数并将其注册,这样这个函数就可以在SpEL表达式中使用.</p>

<p>首先是两个工具类的代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class CollectionUtils {
</span><span class='line'>    /**
</span><span class='line'>     * 集合中的最大元素
</span><span class='line'>     * @param collection
</span><span class='line'>     * @return
</span><span class='line'>     */
</span><span class='line'>    public static Integer maxElement(Collection&lt;Integer&gt; collection) {
</span><span class='line'>        Integer maxElement = null;
</span><span class='line'>        Iterator iterator = collection.iterator();
</span><span class='line'>        while (iterator.hasNext()) {
</span><span class='line'>
</span><span class='line'>            Integer integer = (Integer) iterator.next();
</span><span class='line'>
</span><span class='line'>            if (maxElement == null) {
</span><span class='line'>                maxElement = integer;
</span><span class='line'>            } else {
</span><span class='line'>                if (integer.intValue() &gt; maxElement.intValue()) {
</span><span class='line'>                    maxElement = integer;
</span><span class='line'>                }
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>        return maxElement;
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public class MathUtils {
</span><span class='line'>    /**
</span><span class='line'>     * 测试一个数字是否为素数
</span><span class='line'>     * @param number
</span><span class='line'>     * @return
</span><span class='line'>     */
</span><span class='line'>    public static boolean isPrime(Integer number) {
</span><span class='line'>
</span><span class='line'>        if (number == 0) {
</span><span class='line'>            return false;
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        for (int index = 2; index &lt; number; index++) {
</span><span class='line'>            if (number % index == 0) {
</span><span class='line'>                return false;
</span><span class='line'>            } else {
</span><span class='line'>                continue;
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>        return true;
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>下面,我们首先初始化一个EvaluationContext,具体类是StandardEvaluationContext.</p>

<p>一个context evaluation object能用来存储任意多个对象,这些对象会在在随后的表达式解析中使用.
另外evaluation context也能用来注册用户自定义的方法.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void main(String[] args) throws Exception {
</span><span class='line'>        ExpressionParser parser = new SpelExpressionParser();
</span><span class='line'>
</span><span class='line'>        StandardEvaluationContext context = new StandardEvaluationContext();
</span><span class='line'>        Method method = null;
</span><span class='line'>        Expression expression = null;
</span><span class='line'>        Boolean value = null;
</span><span class='line'>
</span><span class='line'>        // 注册方法 isPrime() 为 prime
</span><span class='line'>        method = MathUtils.class.getMethod("isPrime", Integer.class);
</span><span class='line'>        context.registerFunction("prime", method);
</span><span class='line'>
</span><span class='line'>        expression = parser.parseExpression("#prime(10)");
</span><span class='line'>        value = expression.getValue(context, Boolean.class);
</span><span class='line'>        System.out.println("Number 10 is prime: " + value);
</span><span class='line'>
</span><span class='line'>        expression = parser.parseExpression("#prime(37)");
</span><span class='line'>        value = expression.getValue(context, Boolean.class);
</span><span class='line'>        System.out.println("Number 37 is prime: " + value);
</span><span class='line'>
</span><span class='line'>        // 注册方法 maxElement() 为 max
</span><span class='line'>        method = CollectionUtils.class.getMethod("maxElement", Collection.class);
</span><span class='line'>        context.registerFunction("max", method);
</span><span class='line'>
</span><span class='line'>        // Collection为参数maxElement()
</span><span class='line'>        expression = parser.parseExpression("#max({10, 43, 45, 98, 32, 1})");
</span><span class='line'>        Integer maxElement = expression.getValue(context, Integer.class);
</span><span class='line'>        System.out.println("Max element in the list is : " + maxElement);
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>注：EvaluationContext开销较大，所以多用于数据变化较少的情况。如果数据变化频繁，我们可以考虑直接引用对象（比如上例中的simple）以减小开销。</p>

<h3>2.15 赋值表达式</h3>

<p>SpEL即允许给自定义变量赋值，也允许给跟对象赋值，直接使用"#variableName=value"即可赋值：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_15() {
</span><span class='line'>    EvaluationContext context = new StandardEvaluationContext();
</span><span class='line'>    //1.给自定义变量赋值
</span><span class='line'>    context.setVariable("variable", "Spring SpEL");
</span><span class='line'>    String result1 = parser.parseExpression("#variable").getValue(context, String.class);
</span><span class='line'>    System.out.println("result1=" + result1);
</span><span class='line'>
</span><span class='line'>    //修改
</span><span class='line'>    String result2 = parser.parseExpression("#variable='ABC'").getValue(context, String.class);
</span><span class='line'>    System.out.println("result2=" + result2);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.16 对象属性存取及安全导航表达式</h3>

<p>对象属性获取非常简单，即使用如"a.property.property"这种点缀式获取，SpEL对于属性名首字母是不区分大小写的；修改对象属性值则可以通过赋值表达式或Expression接口的setValue方法修改。</p>

<p>对于当前上下文对象属性及方法访问，可以直接使用属性或方法名访问，注意此处属性名首字母不区分大小写。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_16() {
</span><span class='line'>    ExpressionParser parser = new SpelExpressionParser();
</span><span class='line'>    // 1.访问root对象属性
</span><span class='line'>    Date date = new Date();
</span><span class='line'>    System.out.println("date=" + date);
</span><span class='line'>    StandardEvaluationContext context = new StandardEvaluationContext(date);
</span><span class='line'>    int result1 = parser.parseExpression("Month").getValue(context, int.class);
</span><span class='line'>    System.out.println("result1=" + result1);
</span><span class='line'>    int result2 = parser.parseExpression("month").getValue(context, int.class);
</span><span class='line'>    System.out.println("result2=" + result2);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>SpEL还引入了Groovy语言中的安全导航运算符"(对象|属性)?.属性"，用来避免但"?.&ldquo;前边的表达式为null时抛出空指针异常，而是返回null；</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_16() {
</span><span class='line'>    ExpressionParser parser = new SpelExpressionParser();
</span><span class='line'>    // 2.安全访问
</span><span class='line'>    context.setRootObject(null);
</span><span class='line'>    Object result3 = parser.parseExpression("#root?.year").getValue(context, Object.class);
</span><span class='line'>    System.out.println("result3=" + result3);   //null
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.17 对象方法调用</h3>

<p>对象方法调用更简单，跟Java语法一样；如"&lsquo;Spring&rsquo;.substring(2,4)&ldquo;将返回"ri"；而对于根对象可以直接调用方法；</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_17() {
</span><span class='line'>    String result1 = parser.parseExpression("'Spring SpEL'.substring(2,4)").getValue(String.class);
</span><span class='line'>    System.out.println("result1=" + result1);
</span><span class='line'>
</span><span class='line'>    //root对象date方法"getYear"可以直接调用
</span><span class='line'>    Date date = new Date();
</span><span class='line'>    StandardEvaluationContext context = new StandardEvaluationContext(date);
</span><span class='line'>    int result2 = parser.parseExpression("getMonth()").getValue(context, int.class);
</span><span class='line'>    System.out.println("result2=" + result2);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.18 Bean引用</h3>

<p>SpEL支持使用"@&ldquo;符号来引用Bean，在引用Bean时需要使用BeanResolver接口实现来查找Bean，Spring提供BeanFactoryResolver实现；</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_18() {
</span><span class='line'>    ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext();
</span><span class='line'>    ctx.refresh();
</span><span class='line'>    ExpressionParser parser = new SpelExpressionParser();
</span><span class='line'>    StandardEvaluationContext context = new StandardEvaluationContext();
</span><span class='line'>    context.setBeanResolver(new BeanFactoryResolver(ctx));
</span><span class='line'>    Properties result1 = parser.parseExpression("@systemProperties").getValue(context, Properties.class);
</span><span class='line'>    System.out.println("result1=" + result1);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在示例中我们首先初始化了一个IoC容器，ClassPathXmlApplicationContext实现默认会把"System.getProperties()&ldquo;注册为"systemProperties"Bean，因此我们使用 &rdquo;@systemProperties"来引用该Bean。</p>

<h3>2.19 内联List</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_19() {
</span><span class='line'>    // 将返回不可修改的空List
</span><span class='line'>    List&lt;Integer&gt; result0 = parser.parseExpression("{}").getValue(List.class);
</span><span class='line'>    System.out.println("result0=" + result0);   //[]
</span><span class='line'>
</span><span class='line'>    //对于字面量列表也将返回不可修改的List
</span><span class='line'>    List&lt;Integer&gt; result1 = parser.parseExpression("{1,2,3}").getValue(List.class);
</span><span class='line'>    System.out.println("result1=" + result1);   //[1, 2, 3]
</span><span class='line'>    Assert.assertEquals(new Integer(1), result1.get(0));
</span><span class='line'>    try {
</span><span class='line'>        result1.set(0, 2);
</span><span class='line'>        //不可能执行到这，对于字面量列表不可修改
</span><span class='line'>    } catch (Exception e) {
</span><span class='line'>        e.printStackTrace();
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //对于列表中只要有一个不是字面量表达式，将只返回原始List， 会进行不可修改处理
</span><span class='line'>    String expression3 = "\{\{1+2,2+4\},\{3,4+4\}\}";
</span><span class='line'>    List&lt;List&lt;Integer&gt;&gt; result2 = parser.parseExpression(expression3).getValue(List.class);
</span><span class='line'>    System.out.println("result2=" + result2);   //[[3, 6], [3, 8]]
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.20 内联数组</h3>

<p>和Java 数组定义类似，只是在定义时进行多维数组初始化</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_20() {
</span><span class='line'>    //定义一维数组并初始化
</span><span class='line'>    int[] result1 = parser.parseExpression("new int[1]{8}").getValue(int[].class);
</span><span class='line'>    System.out.println("result1.length=" + result1.length + ",result1=" + result1);
</span><span class='line'>
</span><span class='line'>    // 定义多维数组但不初始化, 多维数组不能初始化
</span><span class='line'>    String expression1 = "new int[1][2]";
</span><span class='line'>    //String expression2 = "new int[1][2]\{\{1}\{2\}\}"; //多维数组不能初始化
</span><span class='line'>    int[][] result2 = parser.parseExpression(expression1).getValue(int[][].class);
</span><span class='line'>    System.out.println("result2.length=" + result2.length + ",result2=" + result2);
</span><span class='line'>
</span><span class='line'>    //解析到多维数据
</span><span class='line'>    String expression3 = "\{\{3,4\},\{5,6\}\}";
</span><span class='line'>    int[][] result3 = parser.parseExpression(expression3).getValue(int[][].class);
</span><span class='line'>    System.out.println("result3=" + result3);   //[[3, 6], [3, 8]]
</span><span class='line'>    for (int[] row : result3) {
</span><span class='line'>        for(int data : row) {
</span><span class='line'>            System.out.print(data + "   ");
</span><span class='line'>        }
</span><span class='line'>        System.out.println();
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.21 集合，字典元素访问</h3>

<p>SpEL目前支持所有集合类型和字典类型的元素访问，使用"集合[索引]&ldquo;访问集合元素，使用"map[key]"访问字典元素；</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_21() {
</span><span class='line'>    // SpEL内联List访问
</span><span class='line'>    int result1 = parser.parseExpression("{1,2,3}[0]").getValue(int.class);
</span><span class='line'>    System.out.println("result1=" + result1);   //1
</span><span class='line'>
</span><span class='line'>    EvaluationContext context = new StandardEvaluationContext();
</span><span class='line'>
</span><span class='line'>    //SpEL目前支持所有集合类型的访问
</span><span class='line'>    Collection&lt;Integer&gt; collection = new HashSet&lt;Integer&gt;();
</span><span class='line'>    collection.add(1);
</span><span class='line'>    collection.add(2);
</span><span class='line'>    context.setVariable("collection", collection);
</span><span class='line'>    int result2 = parser.parseExpression("#collection[1]").getValue(context, int.class);
</span><span class='line'>    System.out.println("result2=" + result2);   //2
</span><span class='line'>
</span><span class='line'>    //SpEL对Map字典元素访问的支持
</span><span class='line'>    Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();
</span><span class='line'>    map.put("A", 3);
</span><span class='line'>    context.setVariable("map", map);
</span><span class='line'>    int result3 = parser.parseExpression("#map['A']").getValue(context, int.class);
</span><span class='line'>    System.out.println("result3=" + result3);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.22 列表，字典，数组元素修改</h3>

<p>可以使用赋值表达式或Expression接口的setValue方法修改</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_22() {
</span><span class='line'>    EvaluationContext context = new StandardEvaluationContext();
</span><span class='line'>
</span><span class='line'>    //1.修改数组元素值
</span><span class='line'>    int[] array = new int[] {1, 2};
</span><span class='line'>    context.setVariable("array", array);
</span><span class='line'>    int result1 = parser.parseExpression("#array[1] = 3").getValue(context, int.class);
</span><span class='line'>    System.out.println("result1=" + result1);   //3
</span><span class='line'>
</span><span class='line'>    //2.修改集合值
</span><span class='line'>    Collection&lt;Integer&gt; collection = new ArrayList&lt;Integer&gt;();
</span><span class='line'>    collection.add(1);
</span><span class='line'>    collection.add(2);
</span><span class='line'>    context.setVariable("collection", collection);
</span><span class='line'>    int result2 = parser.parseExpression("#collection[1] = 4").getValue(context, int.class);
</span><span class='line'>    System.out.println("result2=" + result2);   //4
</span><span class='line'>    parser.parseExpression("#collection[1]").setValue(context, 5);
</span><span class='line'>    int result3 = parser.parseExpression("#collection[1]").getValue(context, int.class);
</span><span class='line'>    System.out.println("result3=" + result3);   //5
</span><span class='line'>
</span><span class='line'>    //3.修改map元素值
</span><span class='line'>    Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();
</span><span class='line'>    map.put("A", 1);
</span><span class='line'>    context.setVariable("map", map);
</span><span class='line'>    int result4 = parser.parseExpression("#map['A'] = 6").getValue(context, int.class);
</span><span class='line'>    System.out.println("result4=" + result4);   //6
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.23 集合投影</h3>

<p>在SQL中投影指从表中选择出列，而在SpEL指根据集合中的元素中通过选择来构造另一个集合，该集合和原集合具有相同数量的元素；SpEL使用"（list|map）.![投影表达式]&ldquo;来进行投影运算.</p>

<p>对于集合或数组使用如上表达式进行投影运算，其中投影表达式中"#this"代表每个集合或数组元素，可以使用比如"#this.property"来获取集合元素的属性，其中"#this"可以省略。</p>

<p>SpEL投影运算还支持Map投影，但Map投影最终只能得到List结果，如上所示，对于投影表达式中的"#this"将是Map.Entry，所以可以使用"value"来获取值，使用"key"来获取键。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_23() {
</span><span class='line'>    EvaluationContext context = new StandardEvaluationContext();
</span><span class='line'>
</span><span class='line'>    //1.首先准备测试数据
</span><span class='line'>    Collection&lt;Integer&gt; collection = new ArrayList&lt;Integer&gt;();
</span><span class='line'>    collection.add(4);
</span><span class='line'>    collection.add(5);
</span><span class='line'>
</span><span class='line'>    Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();
</span><span class='line'>    map.put("A", 1);
</span><span class='line'>    map.put("B", 2);
</span><span class='line'>
</span><span class='line'>    //2.collection中每个值加1
</span><span class='line'>    context.setVariable("collection", collection);
</span><span class='line'>    Collection&lt;Integer&gt; result1 = parser.parseExpression("#collection.![#this+1]").getValue(context,
</span><span class='line'>            Collection.class);
</span><span class='line'>    System.out.println("result1.size()=" + result1.size() + ", result1=" + result1);//result1.size()=2, result1=[5, 6]
</span><span class='line'>
</span><span class='line'>    //3.测试map
</span><span class='line'>    context.setVariable("map", map);
</span><span class='line'>    List&lt;Integer&gt; result2 = parser.parseExpression("#map.![value+1]").getValue(context, List.class);
</span><span class='line'>    System.out.println("result2.size()=" + result2.size() + ", result2=" + result2);    //result2.size()=2, result2=[2, 3]
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.24 集合选择</h3>

<p>在SQL中指使用select进行选择行数据，而在SpEL指根据原集合通过条件表达式选择出满足条件的元素并构造为新的集合，SpEL使用"(list|map).?[选择表达式]&ldquo;，其中选择表达式结果必须是boolean类型，如果true则选择的元素将添加到新集合中，false将不添加到新集合中。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_24() {
</span><span class='line'>    EvaluationContext context = new StandardEvaluationContext();
</span><span class='line'>
</span><span class='line'>    // 1.首先准备测试数据
</span><span class='line'>    Collection&lt;Integer&gt; collection = new ArrayList&lt;Integer&gt;();
</span><span class='line'>    collection.add(4);
</span><span class='line'>    collection.add(5);
</span><span class='line'>
</span><span class='line'>    Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();
</span><span class='line'>    map.put("A", 1);
</span><span class='line'>    map.put("B", 2);
</span><span class='line'>
</span><span class='line'>    // 2.集合或数组测试:出集合元素值大于4的所有元素
</span><span class='line'>    context.setVariable("collection", collection);
</span><span class='line'>    Collection&lt;Integer&gt; result1 = parser.parseExpression("#collection.?[#this&gt;4]").getValue(context,
</span><span class='line'>            Collection.class);
</span><span class='line'>    System.out.println("result1.size()=" + result1.size() + ", result1=" + result1); // result1.size()=1, result1=[5]
</span><span class='line'>
</span><span class='line'>    // 3.字典测试:选择键值不等于"A"的,注意map选择表达式中"#this"是Map.Entry类型
</span><span class='line'>    context.setVariable("map", map);
</span><span class='line'>    Map&lt;String, Integer&gt; result2 = parser.parseExpression("#map.?[#this.key != 'A']").getValue(context, Map.class);
</span><span class='line'>    System.out.println("result2=" + result2); // result2={B=2}
</span><span class='line'>
</span><span class='line'>    List&lt;Integer&gt; result3 = parser.parseExpression("#map.?[key != 'A'].![value+1]").getValue(context, List.class);
</span><span class='line'>    System.out.println("result3.size()=" + result3.size() + ", result3=" + result3); // result3.size()=1,
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.25 表达式模板</h3>

<h1>3.Spring Cache</h1>

<p>Spring 3.1引入了激动人心的基于注释(annotation)的缓存(cache)技术，它本质上不是一个具体的缓存实现方案(例如 EHCache等)，而是一个对缓存使用的抽象,通过在既有代码中添加少量它定义的各种 annotation,即能够达到缓存方法的返回对象的效果。</p>

<p>Spring Cache是使用SpEL表达式的一个地方.将会另起一篇单独介绍Sping Cache.</p>

<h1>4.参考</h1>

<p><a href="http://sishuok.com/forum/blogPost/list/2463.html">http://sishuok.com/forum/blogPost/list/2463.html</a></p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/5">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/3">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <div class="panel-heading">
    <h1 class="panel-title">最新文章</h3>
  </div>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/07/22/%5B%3F%5D-ge-si-suo-wen-ti/">一个死锁问题</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/07/15/cong-dai-li-dao-springshi-wu-aop/">从代理到Spring事务2-AOP</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/07/07/springshi-wu/">从代理到Spring事务3-Spring事务</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/04/06/activitiru-men/">Activiti入门</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/03/11/cong-dai-li-dao-springshi-wu/">从代理到Spring事务1-代理</a>
      </li>
    
  </ul>
</section>
<section class="panel panel-default">
  <div  class="panel-heading">
    <h1 class="panel-title">文章分类</h1>
  </div>
  <div id="categories_list_div" class="list-group">
    <li><a class='list-group-item' href='/blog/categories/algorithm/'>algorithm (5)</a></li>
<li><a class='list-group-item' href='/blog/categories/druid/'>druid (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/dubbo/'>dubbo (2)</a></li>
<li><a class='list-group-item' href='/blog/categories/guava/'>guava (2)</a></li>
<li><a class='list-group-item' href='/blog/categories/java/'>java (24)</a></li>
<li><a class='list-group-item' href='/blog/categories/library/'>library (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/linux/'>linux (13)</a></li>
<li><a class='list-group-item' href='/blog/categories/maven/'>maven (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/memcached/'>memcached (6)</a></li>
<li><a class='list-group-item' href='/blog/categories/mybatis/'>mybatis (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/mysql/'>mysql (12)</a></li>
<li><a class='list-group-item' href='/blog/categories/octopress/'>octopress (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/postgresql/'>postgresql (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/protocol/'>protocol (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/qa/'>qa (2)</a></li>
<li><a class='list-group-item' href='/blog/categories/reading/'>reading (7)</a></li>
<li><a class='list-group-item' href='/blog/categories/search/'>search (8)</a></li>
<li><a class='list-group-item' href='/blog/categories/spring/'>spring (6)</a></li>
<li><a class='list-group-item' href='/blog/categories/squid/'>squid (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/structure/'>structure (3)</a></li>
<li><a class='list-group-item' href='/blog/categories/tomcat/'>tomcat (3)</a></li>
<li><a class='list-group-item' href='/blog/categories/tools/'>tools (8)</a></li>
<li><a class='list-group-item' href='/blog/categories/web/'>web (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/workflow/'>workflow (1)</a></li>
 
  </div>
</section>
<section class="panel panel-default">
  <div  class="panel-heading">
    <h1 class="panel-title">其他博客</h3>
  </div>
  <div id="categories_list_div" class="list-group">
    <a class='list-group-item' href='http://wenzhang.baidu.com/'>百度空间</a>
  </div>
</section>

  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - xiaobaoqiu -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
