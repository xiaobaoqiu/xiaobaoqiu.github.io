
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>xiaobaoqiu Blog</title>
  <meta name="author" content="xiaobaoqiu">

  
  <meta name="description" content="1.简介 Elasticsearch 是一个建立在全文搜索引擎 Apache Lucene&trade; 基础上的分布式的，高可用的，基于json格式的数据构建索引，准实时查询的搜索引擎。Lucene 是当今最先进最高效的全功能开源搜索引擎框架,但是Lucene使用非常复杂。 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://xiaobaoqiu.github.io/posts/9/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  

  <link href="/atom.xml" rel="alternate" title="xiaobaoqiu Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <!-- <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script> -->
  <script src="/javascripts/libs/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!--
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
-->

  

  
  <meta name="baidu-site-verification" content="5oIt2xaFFz" />
  <meta name="google-site-verification" content="U9Avd5Yqzpetvn_zxo1KaK2iqYNwSlLon27veprwBRY" />
</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">xiaobaoqiu Blog</a></h1>
  
    <h2>Think More, Code Less</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss email">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
    <li><a href="xiaobaoqiu@163.com" rel="subscribe-email" title="subscribe via email">Email</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="xiaobaoqiu.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">所有博文</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/05/20/elasticsearch/">Elasticsearch</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-05-20T22:14:33+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>20</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>10:14 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>1.简介</h1>

<p>Elasticsearch 是一个建立在全文搜索引擎 Apache Lucene&trade; 基础上的分布式的，高可用的，基于json格式的数据构建索引，准实时查询的搜索引擎。Lucene 是当今最先进最高效的全功能开源搜索引擎框架,但是Lucene使用非常复杂。</p>

<p>Elasticsearch使用 Lucene 作为内部引擎，但是在你使用它做全文搜索时，只需要使用统一开发好的API即可，而并不需要了解其背后复杂的 Lucene 的运行原理。</p>

<p>Elasticsearch是一种准实时搜索，其实是可以做到实时的，因为lucene是可以做到实时的，但是这样做，要么是牺牲索引的效率（每次都索引之后刷新），要么就是牺牲查询的效率（每次查询之前都进行刷新），所以
采取一种折中的方案，每隔n秒自动刷新，这样你创建索引之后，最多在ns之内肯定能查到，这就是所谓的准实时(near real-time)查询，缺省是刷新间隔时间是1秒，可以通过index.refresh_interval参数修改间隔.</p>

<p>刷新是为了让文档可以搜索到，但是不保证这些数据被写入disk进入一个永久的存储状态，数据会被先被写入一个事务日志，然后在适当的时候持久化到磁盘中.</p>

<p>官网:<a href="https://www.elastic.co/products/elasticsearch">https://www.elastic.co/products/elasticsearch</a></p>

<p>文档:<a href="https://www.elastic.co/guide/index.html">https://www.elastic.co/guide/index.html</a></p>

<p>github地址:<a href="https://github.com/elastic/elasticsearch">https://github.com/elastic/elasticsearch</a></p>

<p>博客地址:<a href="https://www.elastic.co/blog">https://www.elastic.co/blog</a></p>

<p>其优点很吸引人:</p>

<pre><code>1.分布式,可扩展,高科用(Distributed, scalable, and highly available);
2.提供实时搜索和分析(Real-time search and analytics capabilities);
3.复杂的RESTful API接口(Sophisticated RESTful API);
</code></pre>

<p>其特征如下:</p>

<pre><code>1.Real-Time Data
2.Real-Time Analytics
3.Distributed
最开始规模可能很小,elasticsearch很方便的支持横向扩展,通过简单的在集群中增加节点就可以
4.High Availability
Elasticsearch集群是弹性的,它可以自动的感知新增的或者失效的节点,自动做数据的分发和均衡,保证数据客房问并且是安全的.
5.Multitenancy
集群可能包含多个索引(index),它们可以独立的提供查询服务,也可以组合在一起对外提供查询服务.
6.Full-Text Search
支持多种开发语言
7.Document-Oriented
将真实世界的复杂对象结构化乘JSON文档.所有字段默认都建立索引,所有的索引都可以单独提供查询.并且瞬间(breathtaking speed)返回复杂结果.
8.Schema-Free
对一个JSON文档建立索引,就会自动识别数据的结构和类型,创建所有并对外提供搜索服务.同时也可以自定义数据如何建立索引.
9.Developer-Friendly, RESTful API
Elasticsearch是API驱动的.基本所有的操作都可以通过一个简单的使用JSON格式数据的HTTP上的RESTful API.提供了很多种语言的Client.
10.Per-Operation Persistence
Elasticsearch将数据安全放在第一位.任何文档的变更都会记录在集群中多个节点上的事物日志,以此来将数据丢失几率降低到最小.
11.Apache 2 Open Source License
12.Build on top of Apache Lucene
Elasticsearch以Lucene为基础提供其优秀的分布式搜索和分析能力.
13.Conflict Management
</code></pre>

<h1>2.安装</h1>

<h3>2.1 elasticsearch安装</h3>

<p>安装很简单:</p>

<pre><code>1.下载并解压
下载地址:https://www.elastic.co/downloads/elasticsearch
这里下载是1.5.2版本,解压之后可以创建软链es:

```
xiaobaoqiu@xiaobaoqiu:~/elasticsearch$ ln -s elasticsearch-1.5.2 es
```

目录下主要三个文件夹:

```
xiaobaoqiu@xiaobaoqiu:~/elasticsearch/es$ ll
总用量 48
drwxr-xr-x 5 xiaobaoqiu xiaobaoqiu  4096  4月 27 09:22 ./
drwxr-xr-x 3 xiaobaoqiu xiaobaoqiu  4096  5月 20 14:40 ../
drwxr-xr-x 2 xiaobaoqiu xiaobaoqiu  4096  4月 27 09:22 bin/
drwxr-xr-x 2 xiaobaoqiu xiaobaoqiu  4096  5月 20 14:42 config/
drwxr-xr-x 3 xiaobaoqiu xiaobaoqiu  4096  4月 27 09:22 lib/
-rw-rw-r-- 1 xiaobaoqiu xiaobaoqiu 11358  4月 27 07:05 LICENSE.txt
-rw-rw-r-- 1 xiaobaoqiu xiaobaoqiu   150  4月 27 07:05 NOTICE.txt
-rw-rw-r-- 1 xiaobaoqiu xiaobaoqiu  8499  4月 27 09:03 README.textile
```
其中bin包含一些启动脚本(包括windows下的bat脚本和linux下的shell脚本),config主要是配置文件,lib包括es依赖的jar,在里面就可以看到熟悉的Lucene,查询,高亮等依赖的jar包.

启动elasticsearch之后会产生log目录,用于记录elasticsearch系统的一些中心日志信息:

```
-rw-r--r-- 1    0  5月 20 15:05 elasticsearch_index_indexing_slowlog.log
-rw-r--r-- 1    0  5月 20 15:05 elasticsearch_index_search_slowlog.log
-rw-r--r-- 1 1254  5月 20 15:06 elasticsearch.log
```
其中elasticsearch.log是系统日志,记录什么类型的日志,日志的命名及日志文件的滚动(Rolling)策略等由config目录下的logging.yml配置文件决定.

启动elasticsearch之后会产生data目录,用于
elasticSearch的数据存放位置

2.启动
直接启动bin目录下的elasticsearch的shell:

```
xiaobaoqiu@xiaobaoqiu:~/elasticsearch/es/bin$ ./elasticsearch -d
```

3.验证
直接本机浏览器访问:http://localhost:9200/

```
{
status: 200,
name: "Agon",
cluster_name: "elasticsearch",
version: {
    number: "1.5.2",
    build_hash: "62ff9868b4c8a0c45860bebb259e21980778ab1c",
    build_timestamp: "2015-04-27T09:21:06Z",
    build_snapshot: false,
    lucene_version: "4.10.4"
},
tagline: "You Know, for Search"
}
```
这说明Elasticsearch集群已经上线运行了，这时我们就可以进行各种实验了.
</code></pre>

<h3>2.2 集群管理工具插件</h3>

<p>elasticsearch-head是一个elasticsearch的集群管理工具，它是完全由html5编写的独立网页程序，其他它可以更好的获得各个切片和节点的信息.</p>

<p>该工具的git地址是： <a href="https://github.com/Aconex/elasticsearch-head">https://github.com/Aconex/elasticsearch-head</a></p>

<p>安装该插件:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xiaobaoqiu@xiaobaoqiu:~/elasticsearch$ ./es/bin/plugin -install mobz/elasticsearch-head
</span><span class='line'>-&gt; Installing mobz/elasticsearch-head...
</span><span class='line'>...//省略若干</span></code></pre></td></tr></table></div></figure>


<p>然后就可以访问(可以使用具体节点的IP):
<a href="http://localhost:9200/_plugin/head/">http://localhost:9200/_plugin/head/</a></p>

<p>图形化界面如下,包括集群的健康状况等信息:</p>

<p><img src="/images/Elasticsearch/elasticsearch_plugin_head.png"></p>

<h3>2.3 集群监控工具插件</h3>

<p>bigdesk是elasticsearch的一个集群监控工具，可以通过它来查看es集群的各种状态，如：cpu、内存使用情况，索引数据、搜索情况，http连接数等。</p>

<p>项目git地址： <a href="https://github.com/lukas-vlcek/bigdesk">https://github.com/lukas-vlcek/bigdesk</a></p>

<p>安装该插件:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xiaobaoqiu@xiaobaoqiu:~/elasticsearch$ ./es/bin/plugin -install lukas-vlcek/bigdesk
</span><span class='line'>-&gt; Installing lukas-vlcek/bigdesk...
</span><span class='line'>...//省略若干</span></code></pre></td></tr></table></div></figure>


<p>然后就可以访问(可以使用具体节点的IP):
<a href="http://localhost:9200/_plugin/bigdesk/">http://localhost:9200/_plugin/bigdesk/</a></p>

<p>图形化界面如下,包括JVM,Thread Pools,OS,Process,HTTP &amp; Transport,Indices和File system等监控图:</p>

<p><img src="/images/Elasticsearch/elasticsearch_plugin_bigdesk.png"></p>

<h3>2.4 安装Marvel</h3>

<p>Marvel是Elasticsearch的管理和监控工具，是一个商业版本的插件,在开发环境下免费使用。它包含了一个叫做Sense的交互式控制台，使用户方便的通过浏览器直接与Elasticsearch进行交互。</p>

<p>运行以下命令来下载和安装Marvel:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xiaobaoqiu@xiaobaoqiu:~/elasticsearch$ ./es/bin/plugin -i elasticsearch/marvel/latest
</span><span class='line'>-&gt; Installing elasticsearch/marvel/latest...
</span><span class='line'>...//省略若干</span></code></pre></td></tr></table></div></figure>


<p>Marvel包括一系列酷炫的监控,还有一个Sense的交互式控制台:</p>

<p><img src="/images/Elasticsearch/elasticsearch_plugin_marvel.png"></p>

<p><img src="/images/Elasticsearch/elasticsearch_plugin_marvel_sense.png"></p>

<p>你可能想要禁用监控，你可以通过以下命令关闭Marvel：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>echo 'marvel.agent.enabled: false' &gt;&gt; ./config/elasticsearch.yml</span></code></pre></td></tr></table></div></figure>


<h1>3.基本概念</h1>

<h3>3.1 集群和节点</h3>

<p>节点是Elasticsearch运行的实例。集群是一组有着同样cluster.name的节点，它们协同工作，互相分享数据，提供了故障转移和扩展的功能。当然一个节点也可以是一个集群。ES集群有自动发现的机制，只要几个节点用的是一个clustername，并且在一个局域网内，那么这些节点就可以自动的发现对方，并组成一个集群.</p>

<p>我们上面的运行就是一个单节点的集群.节点的cluster.name在配置文件elasticsearch.yml中配置,默认就叫elasticsearch:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cluster.name: elasticsearch</span></code></pre></td></tr></table></div></figure>


<p>ES的集群是一个去中心化的集群，每一个节点都可以被选举为主节点，如果主节点挂了，集群就会选举出新的主节点。</p>

<p>主节点的作用主要是管理集群，例如感知集群节点的增加和减少，平衡数据分配等.</p>

<p>ES集群对外是透明的，各个节点之间协同工作，分享数据，我们不管访问的是哪一个节点，这个节点都知道数据存在于哪个节点上，然后转发请求到数据所在的节点上，并且负责收集各节点返回的数据，最后一起返回给客户端.</p>

<h3>3.2 分片(shard)</h3>

<p>一个索引会被分割为多个片段存储，这样可以充分使用节点的吞吐率</p>

<h3>3.2 索引(index)</h3>

<p>相当于数据库</p>

<h3>3.3 类型(type)</h3>

<p>相当于数据库中的表</p>

<h3>3.4 文档(doc)</h3>

<p>相当于数据库中的一条记录，json串</p>

<h3>3.5 字段(Field)</h3>

<p>相当路数据库中的列。</p>

<p>参考:
<a href="http://es.xiaoleilu.com/">http://es.xiaoleilu.com/</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/05/20/tpcc-mysqljian-jie/">TPCC-MySQL简介</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-05-20T06:47:02+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>20</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>6:47 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>TPC(Tracsaction Processing Performance Council) 事务处理性能协会是一个评价大型数据库系统软硬件性能的非盈利的组织,TPC-C是TPC协会制定的，用来测试典型的复杂OLTP系统的性能；</p>

<p>Tpcc-mysql是percona基于tpcc衍生出来的产品，专用于mysql基准测试，其源码放在bazaar上，因此需要先安装bazaar客户端.</p>

<h1>1.OLTP and OLAP</h1>

<p>一般来说，可将数据库的应用类型分为OLTP(OnLine Transaction Processing，联机事务处理)和OLAP(OnLine Analysis Processing，联机分析处理)两种。OLTP是传统关系型数据库的主要应用，其主要面向基本的、日常的事务处理，例如银行交易。OLAP是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果.</p>

<p>OLTP也被称为面向交易的处理系统，其基本特征是可以立即将顾客的原始数据传送到计算中心进行处理，并在很短的时间内给出处理结果，这个过程的最大优点是可以即时地处理输入的数据、及时地回答，因此OLTP又被称为实时系统(Real Time System)。衡量OLTP系统的一个重要性能指标是系统性能，具体体现为实时响应时间(Response Time,简称RT)，即从用户在终端输入数据到计算机对这个请求做出回复所需的时间。OLTP 数据库旨在使事务应用程序仅完成对所需数据的写入，以便尽快处理单个事务。</p>

<p>OLAP的概念最早是由关系数据库之父E.F.Codd博士于1993年提出的，是一种用于组织大型商务数据库和支持商务智能的技术。OLAP数据库分为一个或多个多维数据集，每个多维数据集都由多维数据集管理员组织和设计，以适应用户检索和分析数据的方式，从而更易于创建和使用所需的数据透视表和数据透视图。</p>

<h1>2.Tpcc-mysql</h1>

<p>Tpcc-mysql简单说就是mysql的一个基准测试工具.一般用于比较Mysql在不同配置下的性能差异,从而选择一个相对较优的配置.</p>

<p>参考:
<a href="http://www.zhaokunyao.com/archives/5793">http://www.zhaokunyao.com/archives/5793</a></p>

<h1>3.NoSQL测试</h1>

<p>顺便记录一下一个NOSQL的测试case:</p>

<p><a href="https://www.aerospike.com/wp-content/uploads/2013/02/Ultra-High-Performance-NoSQL-Benchmarking_zh-CN.pdf">https://www.aerospike.com/wp-content/uploads/2013/02/Ultra-High-Performance-NoSQL-Benchmarking_zh-CN.pdf</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/05/20/crate-jdbccha-xun-si-xun-huan-bug/">Crate Jdbc查询死循环bug</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-05-20T05:41:17+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>20</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>5:41 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>历经一个月的项目,使用Crate提升搜索速度终于要上线.先交代一下背景,我们使用的crate相关的依赖的版本:</p>

<pre><code>1.crate-client  0.47.8
2.crate-jdbc    1.5.1
</code></pre>

<p>发布之后,验证阶段一切正常,等把流量入口打开,一段时间之后,猛然发现crate的一个查询服务所在的机器load飙到20往上,机器是4核CPU,4G内存的虚拟机.</p>

<p>top -H发现有大量的tomcat线程(10+),每个线程占用的CPU都达到20%,并且这种线程有增多的趋势.</p>

<p>vmstat命令发现r数字特别高,即正在等待CPU的线程非常多.</p>

<p>jstack的结果发现runnable的线程多达300多.</p>

<p>看现象,感觉问题是线程池分配没有回收,但是定位不到问题在哪.</p>

<p>最终定位的问题是在特定场景下存在死循环,并且直接才crate服务器执行相同的查询逻辑正常返回,因此基本定位在crate-jdbc中.</p>

<h1>1.死循环场景</h1>

<pre><code>1.crate中数据为空,这是很从crate中查询数据;
2.crate中存在满足查询条件数据,我们分页查询,假设总数据量为10页,我们因为代码问题,直接查询第11页的内容(实际上肯定不存在);
</code></pre>

<h1>2.原因</h1>

<p>原因是这个版本crate-jdbc和mybatis一起存在死循环,如下,我们对crate的查询首先经过mybatis,从</p>

<pre><code>1.MapperProxy.invoke
2.MapperMethod.execute
3.SqlSessionTemplate.selectList, SqlSessionTemplate.invoke
4.DefaultSqlSession.selectList
5.BaseExecutor.query, BaseExecutor.queryFromDatabase
6.ReuseExecutor.doQuery
7.RoutingStatementHandler.query
8.PreparedStatementHandler.query
9.CratePreparedStatement.execute()
10.DefaultResultSetHandler.handleResultSets, DefaultResultSetHandler.getFirstResultSet
</code></pre>

<p>问题的代码就在DefaultResultSetHandler.getFirstResultSet中:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private ResultSetWrapper getFirstResultSet(Statement stmt) throws SQLException {
</span><span class='line'>    ResultSet rs = stmt.getResultSet();
</span><span class='line'>    while (rs == null) {
</span><span class='line'>        // move forward to get the first resultset in case the driver
</span><span class='line'>        // doesn't return the resultset as the first result (HSQLDB 2.1)
</span><span class='line'>        if (stmt.getMoreResults()) {
</span><span class='line'>            rs = stmt.getResultSet();
</span><span class='line'>        } else {
</span><span class='line'>            if (stmt.getUpdateCount() == -1) {
</span><span class='line'>                // no more results. Must be no resultset
</span><span class='line'>                break;
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return rs != null ? new ResultSetWrapper(rs, configuration) : null;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>其中stmt为CratePreparedStatement,其getMoreResults()实现:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Override
</span><span class='line'>public boolean getMoreResults() throws SQLException {
</span><span class='line'>    return false;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>因此逻辑进入到else中,stmt.getUpdateCount()的实现:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Override
</span><span class='line'>public int getUpdateCount() throws SQLException {
</span><span class='line'>    checkClosed();  //check connection是否被关闭
</span><span class='line'>    if (resultSet == null && sqlResponse != null) {
</span><span class='line'>        return (int) sqlResponse.rowCount();
</span><span class='line'>    }
</span><span class='line'>    return -1;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>其中CratePreparedStatement的resultSet为null,并且sqlResponse不为空,sqlResponse的rowCount为0,因此getUpdateCount()返回值为0.因此getFirstResultSet中继续在while循环中,无法跳出.</p>

<p><img src="/images/crate/crate_jdbc_bug_code.png"></p>

<h1>3.绕过</h1>

<p>归结起来产生问题的很简单,就是查询的结果集为空的时候,就会产生死循环,针对两种死循环场景,我们都可以绕过:</p>

<pre><code>1.查询之前,先执行count查询,当count为0,即crate中没有满足我们查询条件的数据,则直接返回空数据集;
2.分页查询的时候,先执行count查询,当分页的offset大于等于count,则值额节返回空数据集;
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/05/19/mysql-thread-pool-size/">Mysql Thread_pool_size</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-05-19T06:23:18+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>19</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>6:23 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近项目中的beta环境,多个应用(10+个)连接数据库,使用的是连接池管理数据库连接.</p>

<p>最近应用中经常抛出数据库连接异常(我们使用的连接池是druid),简单的就是说无法获取Mysql的连接,创建连接失败(create connection error):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[2015-05-14 15:50:51 ERROR com.alibaba.druid.pool.DruidDataSource:1363] create connection error 
</span><span class='line'>com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: Communications link failure
</span><span class='line'>
</span><span class='line'>The last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server.
</span><span class='line'>    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) ~[na:1.7.0_45]
</span><span class='line'>    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57) ~[na:1.7.0_45]
</span><span class='line'>    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) ~[na:1.7.0_45]
</span><span class='line'>    at java.lang.reflect.Constructor.newInstance(Constructor.java:526) ~[na:1.7.0_45]
</span><span class='line'>    at com.mysql.jdbc.Util.handleNewInstance(Util.java:411) ~[mysql-connector-java-5.1.21.jar:na]
</span><span class='line'>    at com.mysql.jdbc.SQLError.createCommunicationsException(SQLError.java:1117) ~[mysql-connector-java-5.1.21.jar:na]
</span><span class='line'>    at com.mysql.jdbc.MysqlIO.&lt;init&gt;(MysqlIO.java:350) ~[mysql-connector-java-5.1.21.jar:na]
</span><span class='line'>    at com.mysql.jdbc.ConnectionImpl.coreConnect(ConnectionImpl.java:2393) ~[mysql-connector-java-5.1.21.jar:na]
</span><span class='line'>    at com.mysql.jdbc.ConnectionImpl.connectOneTryOnly(ConnectionImpl.java:2430) ~[mysql-connector-java-5.1.21.jar:na]
</span><span class='line'>    at com.mysql.jdbc.ConnectionImpl.createNewIO(ConnectionImpl.java:2215) ~[mysql-connector-java-5.1.21.jar:na]
</span><span class='line'>    at com.mysql.jdbc.ConnectionImpl.&lt;init&gt;(ConnectionImpl.java:813) ~[mysql-connector-java-5.1.21.jar:na]
</span><span class='line'>    at com.mysql.jdbc.JDBC4Connection.&lt;init&gt;(JDBC4Connection.java:47) ~[mysql-connector-java-5.1.21.jar:na]
</span><span class='line'>    at sun.reflect.GeneratedConstructorAccessor34.newInstance(Unknown Source) ~[na:na]
</span><span class='line'>    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) ~[na:1.7.0_45]
</span><span class='line'>    at java.lang.reflect.Constructor.newInstance(Constructor.java:526) ~[na:1.7.0_45]
</span><span class='line'>    at com.mysql.jdbc.Util.handleNewInstance(Util.java:411) ~[mysql-connector-java-5.1.21.jar:na]
</span><span class='line'>    at com.mysql.jdbc.ConnectionImpl.getInstance(ConnectionImpl.java:399) ~[mysql-connector-java-5.1.21.jar:na]
</span><span class='line'>    at com.mysql.jdbc.NonRegisteringDriver.connect(NonRegisteringDriver.java:334) ~[mysql-connector-java-5.1.21.jar:na]
</span><span class='line'>    at com.alibaba.druid.pool.DruidAbstractDataSource.createPhysicalConnection(DruidAbstractDataSource.java:1296) ~[druid-0.2.18.jar:0.2.18]
</span><span class='line'>    at com.alibaba.druid.pool.DruidAbstractDataSource.createPhysicalConnection(DruidAbstractDataSource.java:1352) ~[druid-0.2.18.jar:0.2.18]
</span><span class='line'>    at com.alibaba.druid.pool.DruidDataSource$CreateConnectionThread.run(DruidDataSource.java:1361) ~[druid-0.2.18.jar:0.2.18]
</span><span class='line'>Caused by: java.net.ConnectException: Connection refused
</span><span class='line'>        at java.net.PlainSocketImpl.socketConnect(Native Method) ~[na:1.7.0_45]
</span><span class='line'>        at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:339) ~[na:1.7.0_45]
</span><span class='line'>        at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:200) ~[na:1.7.0_45]
</span><span class='line'>        at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:182) ~[na:1.7.0_45]
</span><span class='line'>        at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392) ~[na:1.7.0_45]
</span><span class='line'>        at java.net.Socket.connect(Socket.java:579) ~[na:1.7.0_45]
</span><span class='line'>        at java.net.Socket.connect(Socket.java:528) ~[na:1.7.0_45]
</span><span class='line'>        at java.net.Socket.&lt;init&gt;(Socket.java:425) ~[na:1.7.0_45]
</span><span class='line'>        at java.net.Socket.&lt;init&gt;(Socket.java:241) ~[na:1.7.0_45]
</span><span class='line'>        at com.mysql.jdbc.StandardSocketFactory.connect(StandardSocketFactory.java:257) ~[mysql-connector-java-5.1.21.jar:na]
</span><span class='line'>        at com.mysql.jdbc.MysqlIO.&lt;init&gt;(MysqlIO.java:300) ~[mysql-connector-java-5.1.21.jar:na]
</span><span class='line'>        ... 14 common frames omitted</span></code></pre></td></tr></table></div></figure>


<p>开始怀疑机器的压力过大,将一些应用停止,还是出现这个问题.</p>

<p>但是相同的代码在dev环境一切正常,beta环境的机器配置要优于dev环境的.</p>

<h1>1.Druid配置</h1>

<p>首先怀疑那块的代码问题导致的Mysql连接没有被释放.</p>

<p>由于我们使用Druid连接池,尝试使用Druid的removeAbandoned功能,这个配置的意义就是连接泄漏监测,通过这个监控没有发现异常.</p>

<p>当程序存在缺陷时，申请的连接忘记关闭，这时候，就存在连接泄漏了。Druid提供了RemoveAbandanded相关配置，用来关闭长时间不使用的连接.</p>

<p>配置removeAbandoned对性能会有一些影响，建议怀疑存在泄漏之后再打开。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;property name="removeAbandoned" value="true" /&gt; &lt;!-- 打开removeAbandoned功能--&gt;
</span><span class='line'>&lt;property name="removeAbandonedTimeout" value="600" /&gt; &lt;!-- 600秒，也就是10分钟--&gt;
</span><span class='line'>&lt;property name="logAbandoned" value="true" /&gt; &lt;!-- 关闭abanded连接时输出错误日志--&gt;</span></code></pre></td></tr></table></div></figure>


<p>`
当removeAbandoned=true之后，可以在内置监控界面datasource.html中的查看ActiveConnection StackTrace属性的，可以看到未关闭连接的具体堆栈信息，从而方便查出哪些连接泄漏了。</p>

<p>参考:
<a href="https://github.com/alibaba/druid/wiki/%E8%BF%9E%E6%8E%A5%E6%B3%84%E6%BC%8F%E7%9B%91%E6%B5%8B">https://github.com/alibaba/druid/wiki/%E8%BF%9E%E6%8E%A5%E6%B3%84%E6%BC%8F%E7%9B%91%E6%B5%8B</a></p>

<h1>2.diff mysql status</h1>

<p>既然dev环境正常,因此我们的做法是拿出dev环境和beta环境的show status结果进行diff,结果发现了一个比较可疑的参数的配置有差异:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>thread_pool_size</span></code></pre></td></tr></table></div></figure>


<p>dev环境配置是16,而beta环境是4,同时线上环境的配置是24.初步判断beta环境的thread_pool_size设置应该是有问题的.</p>

<h1>3.thread_pool_size</h1>

<p>参考官网的描述</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>thread_pool_size is the most important parameter controlling thread pool performance. It can be set only at server startup. Our experience in testing the thread pool indicates the following:
</span><span class='line'>
</span><span class='line'>If the primary storage engine is InnoDB, the optimal thread_pool_size setting is likely to be between 16 and 36, with the most common optimal values tending to be from 24 to 36. We have not seen any situation where the setting has been optimal beyond 36. There may be special cases where a value smaller than 16 is optimal.
</span><span class='line'>
</span><span class='line'>For workloads such as DBT2 and Sysbench, the optimum for InnoDB seems to be usually around 36. For very write-intensive workloads, the optimal setting can sometimes be lower.
</span><span class='line'>
</span><span class='line'>If the primary storage engine is MyISAM, the thread_pool_size setting should be fairly low. We tend to get optimal performance for values from 4 to 8. Higher values tend to have a slightly negative but not dramatic impact on performance.</span></code></pre></td></tr></table></div></figure>


<p>简单的翻译一下:
thread_pool_size是控制线程池性能最重要的一个参数,这个参数只能在Mysql服务启动的时候设置(这是官网5.5版本的文档,5.6版本证明是可以动态修改的).官网的推荐设置:</p>

<pre><code>1.如果存储引擎是InnoDB,thread_pool_size值设置16到36之间比较好,一般配置在24到36之间;
2.如果存储引擎是MyISAM,thread_pool_size值应该被设置得相当小,倾向于设置在4到8之间;
</code></pre>

<p>官方网站:
<a href="https://dev.mysql.com/doc/refman/5.5/en/thread-pool-tuning.html">https://dev.mysql.com/doc/refman/5.5/en/thread-pool-tuning.html</a></p>

<h3>3.1 thread_pool_size意义</h3>

<p>参数thread_pool_size的命令可能会让大家产生误解，它不是指的线程池的大小，而是线程组的大小。</p>

<p>类似所有创建的线程都在某一个group里，group的编号从1~thread_pool_size，每个group里的worker线程数可以通过参数thread_pool_oversubscribe来控制（默认为3）.</p>

<p>同时活跃的最大worker线程数=thread_pool_size * (thread_pool_oversubscribe + 1);</p>

<p>thread_pool_size默认值为CPU核心数，最大为128(MAX_THREAD_GROUPS)，在启动时，就会把128个Group对应的结构体(all_groups)初始化好。每个group(编号小于等于thread_pool_size)会创建一个epoll对象；</p>

<p>当MySQL建立connection时, MySQL根据connection的thread id对thread_pool_size取模,将 connection发起的sql语句分配到对应的group.若worker达到最大数量后还是不足以处理回话请求, 则连接在本group上等待,导致sql语句的RT(Response time)增大。</p>

<p>简单示意图如下:</p>

<p><img src="/images/mysql/Mysql_Pool.png"></p>

<p>所有之前的问题出现的情况是:</p>

<pre><code>1.thread_pool_size为4,即mysql每个thread pool的group中work线程的大小为4,如果有多个应用,恰好多个线程的connection被分发到某一个group上(假设为group-2),并且相当长一段时间一致在占有(比如我们在beta环境的连接,会占用并忙碌长达半小时),这时候,新来的连接正好也分发到group-2上,这时候Mysql上的group-2就没有多余的work线程来为其服务,即其无法和mysql创建连接,从而出现create connection error的异常.
</code></pre>

<p>参考:
<a href="http://get.jobdeer.com/908.get">http://get.jobdeer.com/908.get</a>
<a href="http://chuansong.me/n/1192563">http://chuansong.me/n/1192563</a>
<a href="http://mysqllover.com/?p=826">http://mysqllover.com/?p=826</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/05/18/spring-aopwu-xiao/">Spring AOP无效</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-05-18T19:31:35+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>18</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>7:31 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近在重构项目,有一个场景:根据方法的返回值判断是否成功,成功则从入参里获取需要的参数,构造消息(Msg)并发送通知其他模块.</p>

<p>因为是比较通用的逻辑(判断返回值,获取参数,发送消息),因此做成Spring注解的形式,注解中会用AOP拦截方法获取方法的返回值和参数.</p>

<p>其中获取参数使用的是Spring SpEL表达式.</p>

<h1>1.使用背景</h1>

<p>碰到的一个问题是AOP拦截无法获取private,protected和inner方法的参数.使用场景如下:</p>

<h3>1.1 注解定义</h3>

<p>首先定义注解用于获取</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Target(ElementType.METHOD)
</span><span class='line'>@Retention(RetentionPolicy.RUNTIME)
</span><span class='line'>public @interface Param {
</span><span class='line'>    /**
</span><span class='line'>     * 参数定义,标识了参数的获取方式,或常量值
</span><span class='line'>     */
</span><span class='line'>    String[] params();
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 操作类型,标识了当前这注解该被哪个处理类来处理
</span><span class='line'>     */
</span><span class='line'>    String[] operate();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>1.2 定义切面</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Aspect
</span><span class='line'>public class testAspect {
</span><span class='line'>    /**
</span><span class='line'>     * 根据注解获取切面
</span><span class='line'>     */
</span><span class='line'>    @Pointcut("@annotation(com.aaa.bbb.ccc.ParamGrabber)")
</span><span class='line'>    public void aspectPointCut() {
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>    * AOP, 定义方法返回之后的操作
</span><span class='line'>    */
</span><span class='line'>    @AfterReturning(value = "aspectPointCut()", returning = "returnValue")
</span><span class='line'>    public void afterReturning(JoinPoint point, Object returnValue){
</span><span class='line'>        //1.获取拦截的类和方法
</span><span class='line'>
</span><span class='line'>        //2.获取方法上我们定义的特定注解
</span><span class='line'>
</span><span class='line'>        //3.根据注解的参数中的spel表达式,从方法入参中获取我们需要的参数
</span><span class='line'>
</span><span class='line'>        //4.一些列的Processor处理逻辑
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>1.3 处理类</h3>

<p>定义获取的参数之后的处理类的逻辑:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public interface Processor {
</span><span class='line'>    /**
</span><span class='line'>     * 本processor可以处理的操作类型
</span><span class='line'>     */
</span><span class='line'>    List&lt;String&gt; supportOperates();
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     *
</span><span class='line'>     * 此processor的处理逻辑
</span><span class='line'>     */
</span><span class='line'>    void process(XxxContext context);
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 返回值验证,是否需要执行process操作
</span><span class='line'>     */
</span><span class='line'>    boolean isReturnValid(XxxContext context, Object returnValue);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>之后利用Spring就可以获取上下问中所有的实现类:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class ProcessorSupport implements ApplicationContextAware, InitializingBean {
</span><span class='line'>    // Spring上下文
</span><span class='line'>    private ApplicationContext applicationContext;
</span><span class='line'>
</span><span class='line'>    private final Multimap&lt;String, Processor&gt; processorMap = HashMultimap.create();
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
</span><span class='line'>        this.applicationContext = applicationContext;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    public void afterPropertiesSet() throws Exception {
</span><span class='line'>        // 从Spring上下文获取Processor的所有具体实现类
</span><span class='line'>        Map&lt;String, Processor&gt; beansOfType = applicationContext.getBeansOfType(Processor.class);
</span><span class='line'>        for(Processor processor : beansOfType.values()) {
</span><span class='line'>            for(String op : processor.supportOperates()) {
</span><span class='line'>                processorMap.put(op, processor);
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //根据注解中定义的operate来获取具体的处理类Processor
</span><span class='line'>    @Override
</span><span class='line'>    public Collection&lt;Processor&gt; getProcessor(String operate) {
</span><span class='line'>        return processorMap.get(operate);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>1.4 使用</h3>

<p>使用的时候,首先得实现一个具体的Processor:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class MyProcessor implements Processor {
</span><span class='line'>
</span><span class='line'>    public static final String SPECIFIC_PROCESSOR_KEY = "SPECIFIC_PROCESSOR_KEY";
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    public List&lt;String&gt; supportOperates() {
</span><span class='line'>        return ImmutableList.of(
</span><span class='line'>                SPECIFIC_PROCESSOR_KEY
</span><span class='line'>        );
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    public void process(XxxContext context) {
</span><span class='line'>        //获取注解解析得到的参数
</span><span class='line'>        Map&lt;String, Object&gt; parsedParam = context.getParsedParam();
</span><span class='line'>
</span><span class='line'>        //构建发送的消息内容
</span><span class='line'>        Msg msg = buildNoticeMsg(parsedParam);
</span><span class='line'>
</span><span class='line'>        //发送消息
</span><span class='line'>        noticeService.doNotice(msg);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    public boolean isReturnValid(XxxContext context, Object returnValue) {
</span><span class='line'>        //判断返回值是否有效...
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>具体使用的地方:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'>* 根据SPECIFIC_PROCESSOR_KEY找到MyProcessor
</span><span class='line'>* params中使用SpEL获取参数中的某个属性
</span><span class='line'>*/
</span><span class='line'>@Param(operate = MyProcessor.SPECIFIC_PROCESSOR_KEY, params = {
</span><span class='line'>        CrateConstants.KEYS_KEY + "={#p0.![propertyName]}"})
</span><span class='line'>public int batchInsert(List&lt;Tag&gt; tagList) {
</span><span class='line'>    if (CollectionUtils.isEmpty(tagList)) {
</span><span class='line'>        return 0;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    return tagDao.insertBatchly(tagList);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h1>2.问题</h1>

<h3>2.1 private和protected方法无效</h3>

<p>private和protected方法(通常为类的inner方法)无法使用我们定义的注解来达到目的,如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//供外部调用的方法
</span><span class='line'>public class XxxService {
</span><span class='line'>    public int outerMethod(List&lt;Tag&gt; tagList) {
</span><span class='line'>        return innerMethod(tagList);
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>//被当前类的其他方法调用的内部方法
</span><span class='line'>@Param(operate = MyProcessor.SPECIFIC_PROCESSOR_KEY, params = {
</span><span class='line'>        CrateConstants.KEYS_KEY + "={#p0.![propertyName]}"})
</span><span class='line'>private int innerMethod(List&lt;Tag&gt; tagList) {
</span><span class='line'>    if (CollectionUtils.isEmpty(tagList)) {
</span><span class='line'>        return 0;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    return tagDao.insertBatchly(tagList);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.2 inner public方法无效</h3>

<p>定义如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//供外部调用的方法
</span><span class='line'>public class XxxService {
</span><span class='line'>    public int outerMethod(List&lt;Tag&gt; tagList) {
</span><span class='line'>        return innerMethod(tagList);
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>//被当前类的其他方法调用的内部方法
</span><span class='line'>@Param(operate = MyProcessor.SPECIFIC_PROCESSOR_KEY, params = {
</span><span class='line'>        CrateConstants.KEYS_KEY + "={#p0.![propertyName]}"})
</span><span class='line'>public int innerMethod(List&lt;Tag&gt; tagList) {
</span><span class='line'>    if (CollectionUtils.isEmpty(tagList)) {
</span><span class='line'>        return 0;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    return tagDao.insertBatchly(tagList);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>调用的时候调用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xxxServiceIns.outerMethod(...);</span></code></pre></td></tr></table></div></figure>


<h1>3.原因</h1>

<h3>3.1 private和protected方法无效</h3>

<p>Spring的AOP框架基于代理实现的(proxy-based).使用原生的Java的代理是无法代理protected和private类型的方法(详见后续结束).</p>

<p>而CGLIB的代理虽然在技术上可以代理protected和private类型的方法,但是用于AOP的时候不推荐代理protected和private类型的方法.</p>

<p>结论就是,任何定义的pointcut只在public方法上有效.</p>

<p>参考:</p>

<p><a href="http://stackoverflow.com/questions/15093894/aspectj-pointcut-for-annotated-private-methods">http://stackoverflow.com/questions/15093894/aspectj-pointcut-for-annotated-private-methods</a></p>

<p>spring官方文档关于AOP的解释中也有相关的说明:</p>

<p><a href="http://docs.spring.io/spring/docs/3.1.x/spring-framework-reference/html/aop.html#aop-introduction-spring-defn">http://docs.spring.io/spring/docs/3.1.x/spring-framework-reference/html/aop.html#aop-introduction-spring-defn</a></p>

<h3>3.2 inner public方法无效</h3>

<p>原因其实就是一句话:Spring AOP是基于代理机制的.</p>

<p>考虑如下场景,当你拿到一个无代理的、无任何特殊之处的对象引用时:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class SimplePojo implements SimpleInterface {
</span><span class='line'>    public void foo() {
</span><span class='line'>       // this next method invocation is a direct call on the 'this' reference
</span><span class='line'>       this.bar();
</span><span class='line'>    }
</span><span class='line'>                
</span><span class='line'>    public void bar() {
</span><span class='line'>        // some logic...
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当你调用一个对象引用的方法时,此对象引用上的方法直接被调用,如下所示:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void main(String[] args) {
</span><span class='line'>   SimplePojo ins = new SimplePojo();
</span><span class='line'>   // this is a direct method call on the 'ins' reference
</span><span class='line'>   ins.foo();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><img src="/images/sping/call_native.png"></p>

<p>当客户代码所持有的引用是一个代理的时候则略有不同了,当调用foo()方法时候,首先会调用原始foo()方法上的@Before的代码逻辑,然后调用原始的foo()方法,原始foo()方法内的bar()调用的是原始对象的this.bar(),即一旦调用最终抵达了目标对象 (此处为SimplePojo类的引用),任何对自身的调用例如this.bar()将对this引用进行调用而非代理。</p>

<p>这一点意义重大,它意味着自我调用将不会导致和方法调用关联的AOP通知得到执行的机会。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SimplePojo proxy = proxyFactory.getProxy(Pojo.class);
</span><span class='line'>proxy.foo();</span></code></pre></td></tr></table></div></figure>


<p><img src="/images/sping/call_proxy.png"></p>

<p>参考:
<a href="http://m.oschina.net/blog/161387">http://m.oschina.net/blog/161387</a></p>

<h1>4.Spring AOP代理</h1>

<p>Spring AOP使用JDK动态代理或者CGLIB来为目标对象创建代理。</p>

<p>如果被代理的目标对象实现了至少一个接口,则会使用JDK动态代理。所有该目标类型实现的接口都将被代理。 若该目标对象没有实现任何接口,则创建一个CGLIB代理。</p>

<p>如果你希望强制使用CGLIB代理,(例如：希望代理目标对象的所有方法,而不只是实现自接口的方法) 那也可以。但是需要考虑以下问题:</p>

<pre><code>1.无法通知(advise)final方法,因为他们不能被覆写。
2.代理对象的构造器会被调用两次。因为在CGLIB代理模式下每一个代理对象都会 产生一个子类。每一个代理实例会生成两个对象：实际代理对象和它的一个实现了通知的子类实例 而是用JDK代理时不会出现这样的行为。通常情况下,调用代理类型的构造器两次并不是问题, 因为除了会发生指派外没有任何真正的逻辑被实现。
3.CGLib的效率没有使用JDK代理机制高,速度平均要慢8倍左右。
</code></pre>

<p>强制使用CGLIB代理需要将&lt;aop:config>的proxy-target-class属性设为true:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;aop:config proxy-target-class="true"&gt;
</span><span class='line'>   ...
</span><span class='line'>&lt;/aop:config&gt;</span></code></pre></td></tr></table></div></figure>


<p>当使用@AspectJ自动代理时要强制使用CGLIB,请将&lt;aop:aspectj-autoproxy>的proxy-target-class属性设置为true:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt;</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/10">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/8">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <div class="panel-heading">
    <h1 class="panel-title">最新文章</h3>
  </div>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2017/02/03/shallowetagheaderfilter/">ShallowEtagHeaderFilter</a>
      </li>
    
      <li class="post">
        <a href="/blog/2017/02/03/activitizi-dong-liu-zhuan-ren-wu/">Activiti自动流转任务</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/30/springshang-chuan-zu-jian-chong-tu/">Spring上传组件冲突</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/29/activitishi-jian-chu-li/">Activiti事件处理</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/29/activitiren-wu-zeng-jia-shu-xing/">Activiti任务增加属性</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/16/activitibiao/">Activiti表</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/11/28/ni-zhen-de-liao-jie-stringma/">你真的了解String吗</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/08/20/cratewen-dang-fan-yi/">Crate文档翻译</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/07/22/%5B%3F%5D-ge-si-suo-wen-ti/">一个死锁问题</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/07/15/cong-dai-li-dao-springshi-wu-aop/">从代理到Spring事务2-AOP</a>
      </li>
    
  </ul>
</section>
<section class="panel panel-default">
  <div  class="panel-heading">
    <h1 class="panel-title">文章分类</h1>
  </div>
  <div id="categories_list_div" class="list-group">
    <li><a class='list-group-item' href='/blog/categories/algorithm/'>algorithm (5)</a></li>
<li><a class='list-group-item' href='/blog/categories/druid/'>druid (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/dubbo/'>dubbo (2)</a></li>
<li><a class='list-group-item' href='/blog/categories/guava/'>guava (2)</a></li>
<li><a class='list-group-item' href='/blog/categories/java/'>java (25)</a></li>
<li><a class='list-group-item' href='/blog/categories/library/'>library (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/linux/'>linux (13)</a></li>
<li><a class='list-group-item' href='/blog/categories/maven/'>maven (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/memcached/'>memcached (6)</a></li>
<li><a class='list-group-item' href='/blog/categories/mybatis/'>mybatis (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/mysql/'>mysql (12)</a></li>
<li><a class='list-group-item' href='/blog/categories/octopress/'>octopress (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/postgresql/'>postgresql (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/protocol/'>protocol (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/qa/'>qa (2)</a></li>
<li><a class='list-group-item' href='/blog/categories/reading/'>reading (7)</a></li>
<li><a class='list-group-item' href='/blog/categories/search/'>search (9)</a></li>
<li><a class='list-group-item' href='/blog/categories/spring/'>spring (8)</a></li>
<li><a class='list-group-item' href='/blog/categories/squid/'>squid (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/structure/'>structure (3)</a></li>
<li><a class='list-group-item' href='/blog/categories/tomcat/'>tomcat (3)</a></li>
<li><a class='list-group-item' href='/blog/categories/tools/'>tools (8)</a></li>
<li><a class='list-group-item' href='/blog/categories/web/'>web (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/workflow/'>workflow (5)</a></li>
 
  </div>
</section>
<section class="panel panel-default">
  <div  class="panel-heading">
    <h1 class="panel-title">友情链接</h3>
  </div>
  <div id="categories_list_div" class="list-group">
    <a class='list-group-item' href='http://wenzhang.baidu.com/'>百度文章</a>
  </div>
  <div id="categories_list_div" class="list-group">
    <a class='list-group-item' href='https://github.com/xiaobaoqiu/leetcode'>LeetCode Solution</a>
  </div>
  <div id="categories_list_div" class="list-group">
    <a class='list-group-item' href='http://youdang.github.io/'>Youdang's Blog</a>
  </div>
  <div id="categories_list_div" class="list-group">
    <a class='list-group-item' href='http://blog.csdn.net/ghsau'>Gaoshuang's Blog</a>
  </div>
  <div id="categories_list_div" class="list-group">
    <a class='list-group-item' href='http://kriszhang.com/'>kriszhang's Blog</a>
  </div>
</section>

  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2017 - xiaobaoqiu -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







<!--  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script> -->





</body>
</html>
