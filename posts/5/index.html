
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>xiaobaoqiu Blog</title>
  <meta name="author" content="xiaobaoqiu">

  
  <meta name="description" content="Crate再项目中扮演越来越重要的角色.但是很多时候我对Crate,包括其下层的ElasticSearch以及Lucene都是一知半解,甚至可以说是完全不懂.因为没看过源代码.所以这段时间会集中学习一下Lucene和ElasticSearch的源码. 从Lucene开始.会包含以下内容: 1. &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://xiaobaoqiu.github.io/posts/5/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  

  <link href="/atom.xml" rel="alternate" title="xiaobaoqiu Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <!-- <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script> -->
  <script src="/javascripts/libs/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!--
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
-->

  

  
  <meta name="baidu-site-verification" content="5oIt2xaFFz" />
  <meta name="google-site-verification" content="U9Avd5Yqzpetvn_zxo1KaK2iqYNwSlLon27veprwBRY" />
</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">xiaobaoqiu Blog</a></h1>
  
    <h2>Think More, Code Less</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss email">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
    <li><a href="xiaobaoqiu@163.com" rel="subscribe-email" title="subscribe via email">Email</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="xiaobaoqiu.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">所有博文</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/09/03/luceneru-men/">Lucene入门</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-09-03T14:13:54+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2015</span></span> <span class='time'>2:13 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Crate再项目中扮演越来越重要的角色.但是很多时候我对Crate,包括其下层的ElasticSearch以及Lucene都是一知半解,甚至可以说是完全不懂.因为没看过源代码.所以这段时间会集中学习一下Lucene和ElasticSearch的源码.</p>

<p>从Lucene开始.会包含以下内容:</p>

<pre><code>1.Lucene简介;
2.Lunece整体架构;
3.Lucene的存储;
4.Lucene的搜索;
5.Lucene其他功能,如高亮等;
</code></pre>

<p>这里从Lucene简介开始.第一次使用Lucene已经是两年前入职的时候,写了个简单的爬虫,抓取999网的疾病信息并提供一个简单的搜索入口.这里主要弄懂以下几个问题:</p>

<pre><code>1.信息检索
2.Lucene是什么;
3.Lucene建立索引的大致过程;
4.Lucene搜索的大致过程;
</code></pre>

<p>Lucene官网: <a href="http://lucene.apache.org/">http://lucene.apache.org/</a></p>

<p>在Lucene基础上衍生出很多搜索框架,下面是这些框架的对比:<a href="http://stackoverflow.com/questions/2271600/elasticsearch-sphinx-lucene-solr-xapian-which-fits-for-which-usage">http://stackoverflow.com/questions/2271600/elasticsearch-sphinx-lucene-solr-xapian-which-fits-for-which-usage</a></p>

<h2>1.信息检索</h2>

<p>信息检索简单讲就是从一堆数据中找到你需要的数据,数据的来源可能是文本或者网络,甚至别人说的话或者声波等等.比如:</p>

<ul>
<li>从一个Excel表格中找到你的名字;</li>
<li>从学生成绩标表中找到不及格的学生;</li>
<li>从图书馆里面找Java编程相关的书籍;</li>
<li>从网络搜索Lucene相关知识;</li>
<li>老师点名时候喊到;</li>
</ul>


<p>人类信息检索也是一个不断发展的过程,下面这个例子简单的诠释了信息检索的改善过程:</p>

<ol>
<li>一个书生想从书屋(假设1000本书)里找一本书他能做的就是,从第一本书开始一本一本的往后找,直到找到他要的那本书.如果很不幸,书屋里面每这本书,那么他就必须翻遍所以的书,很可能他找一遍需要10个小时;</li>
<li>经历过几次这样痛苦的找书经历之后,书生开始想招了,将书分类(假设10个分类),文学类在第一个书架子,史学类再第二个书架子&hellip;从此以后,他找书比以前方便多了.找一本书最多只需要翻一个架子,时间缩短到1个小时;但是带来的成本是:必须将书正确的放在其正确的架子上;</li>
<li>每次翻遍一个架子,书生觉得还是比较麻烦,于是他给每本书加了一个编号,将书按照编号排列好,并将所以的书名和编号的对应关系记录到一个单独的册子上.下次他找书只需要在册子上找就可以了(只需要看册子上的1000个书名),找到书名对应的编号,然后就能快速的找到书,时间只需要10分钟.成本是书必须按照需要排列;</li>
<li>10分钟还是有点长,书生于是决定再改善,结合2和3的改进措施.书按照各种类型放在不同的架子,每个架子的书单独编号,比如文学1,文学2&hellip;.册子上也按照书种类进行分开登记.这样找一本书只需要看一个分类下的书名(100个),只需要1分钟.</li>
</ol>


<p>我们生活中的数据分为:结构化数据和非结构化数据.结构化数据指具有固定格式或有限长度的数据,如数据库或者Excel表等.非结构化数据指不定长或无固定格式的数据,如邮件,word文档等.</p>

<p>计算机的产生对信息检索产生了质的变化,帮我们做了很多简单却耗时的工作.在计算机检索的世界里面我们已知了很多技术:</p>

<pre><code>1.对链表的搜索,我们采用从头到位逐项比较,O(N)的时间复杂度;
2.对于有序数组,我们可以采用二分搜索(其实就是二叉树,通常称之为二叉查找树),能够达到O(logN),底数是2;
3.多叉数的查找比二叉树更快,参考Tire树,B树等数据结构,O(logN),底数大于2;
4.Hash表的查找理论上是O(1)的时间复杂度;
</code></pre>

<p>除了顺序查找,其他几种检索都非常的快,但是这种快都是有维护成本的,比如二分搜索需要保证数据有序,因此新来的数据的插入成本会很高,包括删除数据的成本也会很高.但是其带来的检索效率的提升是非常大的.针对结构化数据,我们往往很简单的实现数据的快速搜索,比如数据库就是使用B树来达到快速搜索的目的.</p>

<p>但是现实中99%以上的原始数据都是混乱无须的非结构化数据.当数据量很大的时候,检索成为一个极其困难的问题(量变导致质变),即使对于计算很快的计算机而言.比如一个简单的字符串查找,假设在1页书的内容(约1000字)中查找一个单词可能需要1毫秒,那么在一本书的内容中(约50W词)中查找一个名字可能需要0.5秒,在1W本书(约50亿个单词)中查找这个单词需要5000秒,也就是接近1个半小时;假设每分钟要找一次呢?不敢想象.</p>

<p>在当今网络及其发达的今天,已经很多的公司的数据量超过了1W本书的信息量.这时候无序信息的全文检索显得极其重要.因此也催生了诸如Google,Yahoo和Baidu这些搜索巨头.</p>

<p>索引是全文搜索的基础,也是现代搜索引擎的核心,建立索引的过程就是把源数据处理成非常方便查询的索引文件的过程.你可以把索引想象成这样一种数据结构,他能够使你快速的随机访问存储在索引中的关键词,进而找到该关键词所关联的文档.</p>

<p>还是以书的例子来说,假设书前三页的内容:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//page1:
</span><span class='line'>如何使用Lucene完善搜索
</span><span class='line'>
</span><span class='line'>//page2
</span><span class='line'>Lucene数据如何存储
</span><span class='line'>
</span><span class='line'>//page3
</span><span class='line'>Lucene如何实现搜索
</span><span class='line'>
</span><span class='line'>//page4
</span><span class='line'>作者:肖宝秋</span></code></pre></td></tr></table></div></figure>


<p>我们首先使用分词软件见这四页的内容分词,得到以下结果:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//page1:
</span><span class='line'>如何, 使用, Lucene, 完善, 搜索
</span><span class='line'>
</span><span class='line'>//page2
</span><span class='line'>Lucene, 数据, 如何, 存储
</span><span class='line'>
</span><span class='line'>//page3
</span><span class='line'>Lucene, 如何, 实现, 搜索
</span><span class='line'>作者, 肖宝秋</span></code></pre></td></tr></table></div></figure>


<p>建立词&ndash;>文档的映射关系:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>如何 --&gt; page1, page2, page3
</span><span class='line'>使用 --&gt; page1
</span><span class='line'>Lucene --&gt; page1, page2, page3
</span><span class='line'>完善 --&gt; page1
</span><span class='line'>搜索 --&gt; page1, page3
</span><span class='line'>数据 --&gt; page2
</span><span class='line'>存储 --&gt; page2
</span><span class='line'>实现 --&gt; page3
</span><span class='line'>作者 --&gt; page4
</span><span class='line'>肖宝秋 --&gt; page4</span></code></pre></td></tr></table></div></figure>


<p>现在搜索"Lucene"的时候,我知道在page1,page2,page3中出现了.搜索"作者"的时候,我知道在page4出现了.</p>

<p>另外一个支撑现代搜索理论的既定现实是:词的数量是有限的,而且非常有限.比如常用的中文词就几万个.</p>

<h2>2.Lucene是什么</h2>

<p>简单讲,Lucene是一个高效的,基于Java的全文检索工具包,它不是一个完整的搜索应用程序,而是为你的应用程序提供索引和搜索功能.Lucene是Apache家族中的一个开源项目.也是目前最为流行的基于 Java 开源全文检索工具包.</p>

<p>Lucene 能够为文本类型的数据建立索引,所以你只要能把你要索引的数据格式转化的文本的,Lucene 就能对你的文档进行索引和搜索.比如你要对一些 HTML 文档,PDF 文档进行索引的话你只需要把 HTML 文档和 PDF 文档转化成文本格式的,然后将转化后的内容交给Lucene进行索引,然后把创建好的索引文件保存到磁盘或者内存中,最后根据用户输入的查询条件在索引文件上进行查询.不指定要索引的文档的格式也使Lucene能够几乎适用于所有的搜索应用程序.</p>

<p>下图展示搜索应用程序和Lucene之间的关系,也描述了Lucene的两个核心过程:建立索引和通过索引检索</p>

<p><img src="/images/lucene/lucene_and_application.jpg"></p>

<h4>2.1 Lucene优点</h4>

<p>Lucene作为一个全文搜索引擎,其具有如下突出的优点:</p>

<ul>
<li>1.索引文件格式独立于应用平台.Lucene定义了一套以八字节为基础的索引文件格式,使得兼容系统和不同平台的应用能够共享建立的索引文件.</li>
<li>2.在传统全文检索引擎的倒序索引的基础上实现了分块索引,能够针对新的文件建立小文件索引,提升索引速度.然后通过与原有的索引的合并,达到优化的目的.</li>
<li>3.优秀的面向对象的系统架构,使得对于Lucene扩展的学习难度降低,方便加入新功能.</li>
<li>4.设计了独立于语言和文件格式的文本分析接口,索引器通过接受token流完成索引文件的创立,用户扩展新的语言和文件格式,只需要实现文本分析的接口.</li>
<li>5.已经默认实现了一套强大的查询引擎,用户无须自己编写代码即可使系统获得强大的查询能力,Lucene的查询实现中默认实现了布尔操作、模糊查询、分组查询.</li>
</ul>


<p>参考: <a href="http://lucene.apache.org/core/index.html">http://lucene.apache.org/core/index.html</a></p>

<h4>2.2 倒排索引</h4>

<p>现代搜索引擎基本都是基于倒排索引(反向索引).因为搜索问题本质就是求解"哪文档包含搜索词"这个问题.</p>

<p>简单讲一下什么是倒排索引,简单讲就是字符串到文件的映射关系.假设我的文档集合里面有100篇文档,为了方便表示,我们为文档编号从1到100,得到下面的结构:</p>

<p><img src="/images/lucene/inverted_index.jpg"></p>

<p>左边保存的是一系列字符串,称为词典.每个字符串都指向包含此字符串的文档(Document)链表,此文档链表称为倒排表.</p>

<p>有了索引,便使保存的信息和要搜索的信息一致,可以大大加快搜索的速度.比如说,我们要寻找既包含字符串“lucene”又包含字符串“solr”的文档,我们只需要以下几步:</p>

<ol>
<li>取出包含字符串lucene的文档链表.</li>
<li>取出包含字符串solr的文档链表.</li>
<li>通过合并链表,找出既包含lucene又包含solr的文件.</li>
</ol>


<p><img src="/images/lucene/inverted_index_merge.jpg"></p>

<h2>3.Lucene建立索引</h2>

<p>Lucene的建立索引包括以下几个过程:</p>

<h4>3.1.原始文档</h4>

<p>一些要索引的原文档(Document).包括Html文档,PDF文档,MC Word文档等.而Lucene是只能处理文本文档.</p>

<p>庆幸的是现在很多工具帮我们处理这些问题.如Apache的Tika, 官网:<a href="http://tika.apache.org/">http://tika.apache.org/</a></p>

<h4>3.2.分词</h4>

<p>确定输入的文本之后首先将文本传递给分词组件,分词组件(Tokenizer)会做以下几件事情(此过程称为Tokenize):</p>

<pre><code>1. 将文档分成一个一个单独的单词;
2. 去除标点符号;
3. 去除停词(Stop word);
</code></pre>

<p>停词(Stop word)就是一种语言中最普通的一些单词,由于没有特别的意义,因而大多数情况下不能成为搜索的关键词,因而创建索引时,这种词会被去掉而减少索引的大小.英语中挺词(Stop word)如:the,a,this,is等.对于每一种语言的分词组件(Tokenizer),都有一个停词(stop word)集合.经过分词(Tokenizer)后得到的结果称为词元(Token).</p>

<h4>3.3 语言处理</h4>

<p>分词之后将词元传递给语言处理模块,语言处理组件(linguistic processor)主要是对得到的词元(Token)做一些同语言相关的处理.</p>

<p>比如对于英语,语言处理组件(Linguistic Processor)一般做以下几点:</p>

<pre><code>1. 变为小写(Lowercase).
2. 将单词缩减为词根形式,如cars到car等.这种操作称为:stemming.
3. 将单词转变为词根形式,如“drove”到“drive”等.这种操作称为:lemmatization.
</code></pre>

<p>语言处理组件(linguistic processor)的结果称为词(Term).</p>

<h4>3.4 索引</h4>

<p>语言处理之后将词给索引模块,索引模块主要做以下几个事情:</p>

<pre><code>1. 利用得到的词(Term)创建一个字典.
即Term1--&gt;doc1, Term2--&gt;doc1这种映射关系
2. 对字典按字母顺序进行排序.
3. 合并相同的词(Term)成为文档倒排链表.
</code></pre>

<p>倒排链表的格式如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Term1,Document Frequency  --&gt; Doc1,Frequency1 ; Doc2,Frequency2</span></code></pre></td></tr></table></div></figure>


<p>Document Frequency 即文档频次,表示总共有多少文件包含此词(Term),即链表中文档数目.
Frequency 即词频率,表示此文件中包含了几个此词(Term).</p>

<p>下面是一个建立索引的例子,输入文本如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>文件一:Students should be allowed to go out with their friends, but not allowed to drink beer.
</span><span class='line'>文件二:My friend Jerry went to school to see his students but found them drunk which is not allowed.</span></code></pre></td></tr></table></div></figure>


<p>经过分词(Tokenizer)后得到的结果称为词元(Token):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Students,allowed,go,their,friends,allowed,drink,beer,My,friend,Jerry,went,school,see,his,students,found,them,drunk,allowed</span></code></pre></td></tr></table></div></figure>


<p>经过语言处理,得到的词(Term)如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>student,allow,go,their,friend,allow,drink,beer,my,friend,jerry,go,school,see,his,student,find,them,drink,allow</span></code></pre></td></tr></table></div></figure>


<p>最后得到的倒排索引表如下:</p>

<p><img src="/images/lucene/posting_list.jpg"></p>

<p>所以对词allow来讲,总共有两篇文档包含此词(Term),从而词(Term)后面的文档链表总共有两项,第一项表示包含allow的第一篇文档,即1号文档,此文档中,allow出现了2次,第二项表示包含allow的第二个文档,是2号文档,此文档中,allow出现了1次.</p>

<h2>4.Lucene搜索</h2>

<p>有了倒排索引,我们就可以做搜索了,但是事实上Lucene的搜索过程也不简单.</p>

<p>简单来讲,搜索解决的问题是:找到和搜索词相关性最好的文档.细分的这个问题:</p>

<pre><code>1.找到相关文档;
2.评价搜索词和文档的相关性;
</code></pre>

<p>Lucene的搜索包括以下几个过程.</p>

<h4>3.1.用户输入</h4>

<p>查询语句同我们普通的语言一样,也是有一定语法的.查询语句的语法根据全文检索系统的实现而不同.最基本的有比如:AND, OR, NOT等.举个例子,用户输入语句:lucene AND learned NOT hadoop.说明用户想找一个包含lucene和learned然而不包括hadoop的文档.</p>

<p>目前看来,Google和Baidu都不支出这种语法:</p>

<p><img src="/images/lucene/Google_Search.png"></p>

<p><img src="/images/lucene/Baidu_Search.png"></p>

<h4>3.2.词法分析,语法分析,语言处理</h4>

<p>由于查询语句有语法,因而也要进行语法分析,语法分析及语言处理.</p>

<ul>
<li><p>词法分析主要用来切词,识别单词和关键字.通常建立索引的切词组件和对搜索词的切词组件一致.</p></li>
<li><p>语法分析主要是根据查询语句的语法规则来形成一棵语法树.比如例子:lucene AND learned NOT hadoop形成的语法树如下:</p>

<p>  <img src="/images/lucene/Token_tree.jpg"></p></li>
<li><p>语言处理同索引过程中的语言处理几乎相同.如learned变成learn等.经过第三步,我们得到一棵经过语言处理的语法树.</p>

<p> <img src="/images/lucene/Term_Tree.jpg"></p></li>
</ul>


<h4>3.3 搜索索引</h4>

<p>此步骤有分几小步:</p>

<ul>
<li>在反向索引表中,分别找出包含lucene,learn,hadoop的文档链表.</li>
<li>对包含lucene,learn的链表进行合并操作,得到既包含lucene又包含learn的文档链表.</li>
<li>将此链表与hadoop的文档链表进行差操作,去除包含hadoop的文档,从而得到既包含lucene又包含learn而且不包含hadoop的文档链表.此文档链表就是我们要找的文档.</li>
</ul>


<h4>3.4 结果文档排序</h4>

<p>虽然在上一步,我们得到了想要的文档,然而对于查询结果应该按照与查询语句的相关性进行排序,越相关者越靠前.</p>

<p>通常会把查询语句看作一片短小的文档,对文档与文档之间的相关性(relevance)进行打分(scoring),分数高的相关性好,就应该排在前面.</p>

<p>对于文档之间的关系,不同的Term重要性不同,比如对于本篇文档,search, Lucene, full-text就相对重要一些,this, a , what可能相对不重要一些.所以如果两篇文档都包含search, Lucene,fulltext,这两篇文档的相关性好一些,然而就算一篇文档包含this, a, what,另一篇文档不包含this, a, what,也不能影响两篇文档的相关性.</p>

<p>找出词(Term)对文档的重要性的过程称为计算词的权重(Term weight)的过程.计算词的权重(term weight)有两个参数,第一个是词(Term),第二个是文档(Document).词的权重(Term weight)表示此词(Term)在此文档中的重要程度,越重要的词(Term)有越大的权重(Term weight),因而在计算文档之间的相关性中将发挥更大的作用.</p>

<p>下面分析这两个过程:</p>

<ul>
<li>计算权重(Term weight).</li>
</ul>


<p>影响一个词(Term)在一篇文档中的重要性主要有两个因素:</p>

<pre><code>1.Term Frequency (tf):即此Term在此文档中出现了多少次. tf越大说明越重要.
2.Document Frequency (df):即有多少文档包含次Term. df越大说明越不重要.
</code></pre>

<p>很容易理解,词(Term)在文档中出现的次数越多,说明此词(Term)对该文档越重要,如“搜索”这个词,在本文档中出现的次数很多,说明本文档主要就是讲这方面的事的.然而在一篇英语文档中,this出现的次数更多,就说明越重要吗？不是的,这是由第二个因素进行调整,第二个因素说明,有越多的文档包含此词(Term), 说明此词(Term)太普通,不足以区分这些文档,因而重要性越低.</p>

<p>简单公式如下:</p>

<p><img src="/images/lucene/Term_Weight.png"></p>

<ul>
<li>根据Term之间的关系得到文档相关性.</li>
</ul>


<p>我们把文档看作一系列词(Term),每一个词(Term)都有一个权重(Term weight),不同的词(Term)根据自己在文档中的权重来影响文档相关性的打分计算.</p>

<p>于是我们把所有此文档中词(term)的权重(term weight) 看作一个向量.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Document = {term1, term2, …… ,term N}
</span><span class='line'>Document Vector = {weight1, weight2, …… ,weight N}</span></code></pre></td></tr></table></div></figure>


<p>同样我们把查询语句看作一个简单的文档,也用向量来表示.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Query = {term1, term 2, …… , term N}
</span><span class='line'>Query Vector = {weight1, weight2, …… , weight N}</span></code></pre></td></tr></table></div></figure>


<p>我们把所有搜索出的文档向量及查询向量放到一个N维空间中,每个词(term)是一维:</p>

<p><img src="/images/lucene/document_relative_vsm.jpg"></p>

<p>我们认为两个向量之间的夹角越小,相关性越大.所以我们计算夹角的余弦值作为相关性的打分,夹角越小,余弦值越大,打分越高,相关性越大.</p>

<p>需要注意的是,查询语句一般是很短的,包含的词(Term)是很少的,因而查询向量的维数很小,而文档很长,包含词(Term)很多,文档向量维数很大, 但是需要放到相同的向量空间,因此要保证二者维数是相同的.处理方式很简单,维数不同时,取二者的并集,如果不含某个词(Term)时,则权重(Term Weight)为0.</p>

<p>相关性打分公式如下:</p>

<p><img src="/images/lucene/documet_relative_caculate.png"></p>

<p>举个例子,查询语句有11个Term,共有三篇文档搜索出来.其中各自的权重(Term weight),如下:</p>

<p><img src="/images/lucene/document_score.png"></p>

<p>于是计算,三篇文档同查询语句的相关性打分分别为:</p>

<p><img src="/images/lucene/score_example.png"></p>

<p>于是文档二相关性最高,先返回,其次是文档一,最后是文档三.到此为止,我们可以找到我们最想要的文档了.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/09/03/mysql-join/">Mysql Join</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-09-03T11:42:33+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2015</span></span> <span class='time'>11:42 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>join 用于多表中字段之间的关联,语法如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>... FROM table1 INNER|LEFT|RIGHT JOIN table2 ON conditiona</span></code></pre></td></tr></table></div></figure>


<p>JOIN实际上是两个表的的乘积(即笛卡尔积).假设集合A={a,b}，集合B={0,1,2}，则两个集合的笛卡尔积为{(a,0),(a,1),(a,2),(b,0),(b,1), (b,2)}.</p>

<p>JOIN按照功能大致分为如下三类:</p>

<pre><code>INNER JOIN: 取得两个表中存在连接匹配关系的记录;
LEFT JOIN: 取得左表完全记录，即使右表并无对应匹配记录,如果没有匹配,右侧将包含null;
RIGHT JOIN: 与 LEFT JOIN 相反，取得右表完全记录，即使左表并无匹配对应记录;
</code></pre>

<h2>. 1.显示join和隐式join</h2>

<p>另外,写join语句有所谓的显示join和隐式join的写法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-- 显示join
</span><span class='line'>select * from
</span><span class='line'>table1 inner join table2
</span><span class='line'>on table1.name = table2.name;
</span><span class='line'>
</span><span class='line'>-- 隐式join
</span><span class='line'>select table1.*, table2.*
</span><span class='line'>from table1, table2
</span><span class='line'>where table1.name = table2.name;</span></code></pre></td></tr></table></div></figure>


<p>这两种写法性能上基本没有差异,参考stackoverflow: <a href="http://stackoverflow.com/questions/44917/explicit-vs-implicit-sql-joins">http://stackoverflow.com/questions/44917/explicit-vs-implicit-sql-joins</a></p>

<h2>. 2.ON条件和WHERE条件</h2>

<p>在执行顺序上需要注意的是on条件和where条件执行顺序: 首先使用on条件产生初始笛卡尔积集合,再在这个集合上使用where条件筛选.所以join的时候应该首先好的on条件保证笛卡尔积集合尽可能小,从而减少Where的执行.</p>

<p>比如下面两种写法,方案2写法保证产生的笛卡尔积集合很小,因而从执行性能来看第二个显然更加省时。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-- 方案1
</span><span class='line'>select * from A
</span><span class='line'>inner join B on B.name = A.name
</span><span class='line'>left join C on C.name = B.name
</span><span class='line'>left join D on D.id = C.id
</span><span class='line'>where C.status&gt;1 and D.status=1;
</span><span class='line'>
</span><span class='line'>-- 方案2
</span><span class='line'>select * from A
</span><span class='line'>inner join B on B.name = A.name
</span><span class='line'>left join C on C.name = B.name and C.status&gt;1
</span><span class='line'>left join D on D.id = C.id and D.status=1</span></code></pre></td></tr></table></div></figure>


<h2>. 3.STRAIGHT_JOIN和NATURAL JOIN</h2>

<h4>. 3.1 STRAIGHT_JOIN</h4>

<p>再Join的时候,MySQL优化器要确定以谁为驱动表，也就是说以哪个表为基准，在处理此类问题时，MySQL优化器采用了简单粗暴的解决方法：哪个表的结果集小，就以哪个表为驱动表，当然MySQL优化器实际的处理方式会复杂许多，具体可以参考：<a href="http://www.orczhou.com/index.php/2013/04/how-mysql-choose-index-in-a-join/">http://www.orczhou.com/index.php/2013/04/how-mysql-choose-index-in-a-join/</a></p>

<p>说明：在EXPLAIN结果中，第一行出现的表就是驱动表。</p>

<p>但是这个由的时候比较愚蠢,比如我们order by的字段在大结果集的表上,也就是说排序字段不在驱动表里，于是乎不可避免的出现了Using filesort和Using temporary.</p>

<p>上面这种场景,我们就可以通过使用STRAIGHT_JOIN显示的指定驱动表</p>

<p>参考: <a href="http://huoding.com/2013/06/04/261">http://huoding.com/2013/06/04/261</a></p>

<h4>. 3.2 NATURAL</h4>

<p>MySQL将表中具有相同名称的字段自动进行记录匹配，而这些同名字段类型可以不同。因此，NATURAL JOIN 不用指定匹配条件。</p>

<p>同样包含NATURAL LEFT JOIN和NATURAL RIGHT JOIN.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SELECT article.aid,article.title,user.username FROM article NATURAL JOIN user</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/08/27/zai-xian-zhen-duan-gong-ju/">在线诊断工具</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-27T19:54:38+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>27</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>7:54 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Java诊断我相信再日常开发中都十分需要.相信大家都使用过以下几种诊断方式:</p>

<pre><code>1.肉眼诊断
就是出现问题时候企图通过肉眼来发现代码问题.通常很明显的问题有效;
2.日志诊断
通过给出问题的代码入参或者上下游加上日志,或者出问题的时候加上日志来诊断;这种方式的问题就是出现问题你需要重新拉分支,加日志,本地测试再上限这一系列流程.另外一个问题是过多的日志会影响应用性能;
3.监控诊断
通过完善的监控,通常包括完善且精确的异常划分.对不同的异常情况有独立的监控.加上完善的报警机制.这是最理想的情况.其优势是能快速定位问题点,问题是建立这一套完善的机制需要很长时间.并且监控只能发现问题类型,比如监控发现是数据错误,但是到底那条数据错误还是需要日志等手段来定位.
4.在线诊断工具
在不需要重新发布的情况下,在线诊断应用的问题所在.通常还可以用于定位接口瓶颈等问题;
</code></pre>

<p>这里简单介绍一下最近找到的几个在线诊断工具.它们都是非侵入式的,即不需要修改原始应用的代码再重新发布上线这个过程.</p>

<p>常用包括几个诊断工具包括,这里做一个简单的介绍:</p>

<pre><code>1.BTrace
2.HouseMD
3.Greys-Anatomy
</code></pre>

<p>参考: <a href="http://www.infoq.com/cn/articles/java-profiling-with-open-source/">http://www.infoq.com/cn/articles/java-profiling-with-open-source/</a></p>

<h2>. 1.BTrace</h2>

<p>Btrace(bytecode trace)是Kenai在2009年开发的一个开源项目(<a href="https://kenai.com/projects/btrace/">https://kenai.com/projects/btrace/</a>)，是一个动态跟踪分析JAVA源代码的工具。
它可以用来帮我们做运行时的JAVA程序分析，追踪，监控等.</p>

<p>官网: <a href="https://kenai.com/projects/btrace/">https://kenai.com/projects/btrace/</a></p>

<p>用户手册: <a href="https://kenai.com/projects/btrace/pages/UserGuide">https://kenai.com/projects/btrace/pages/UserGuide</a></p>

<p>samples下有很多使用例子.参考网上的一个例子:
<a href="http://mgoann.iteye.com/blog/1409685">http://mgoann.iteye.com/blog/1409685</a></p>

<p>参考: <a href="http://wiki.corp.qunar.com/pages/viewpage.action?pageId=56198121">http://wiki.corp.qunar.com/pages/viewpage.action?pageId=56198121</a></p>

<h4>1.1使用场景:</h4>

<p>1.数据采样
比如我们要优化某块代码，就可以先写一个btrace脚本，丢到线上服务器上跑一段时间；
这样可以收集到最真实的数据，而且不用发布之类的；
然后根据收集到的数据，做有目的的优化，优化之后，还可以对比出优化的效果。
2.排查问题
3.性能监控</p>

<h4>1.2优点</h4>

<p>1.跟踪任何java代码的调用（包括第三方类库中的，甚至jdk中的），比如统计某方法的调用次数，耗时。
2.可以监控的维度有很多，比如异常，同步块，内存申请，数组声明，甚至可以精确到行
3.完全不侵入业务代码，不需要重启服务
4.安全，对于应用内的数据来说是只读的。</p>

<h4>1.3缺点</h4>

<ol>
<li>有较多的使用限制，如只能调用用BtraceUtils中的方法、不能写实例变量；
（见docs/usersguide.html中的BTrace Restrictions条目）
所以刚编写脚本的时候，可能会有各种不习惯，但其实大多会用到的方法，BtraceUtils里都有封装
（其实个人感觉这个不算缺点，只是这个工具定位在追踪和监控，所以出于安全考虑，做了这个限制）</li>
<li>监控基本上只能单点，集群环境没法玩</li>
<li>被监控的服务重启，btrace也需要跟着重启
4.有影响原始应用的风险,严重可能导致JVM Crash.</li>
</ol>


<h4>1.4使用方式</h4>

<ul>
<li><p>Boot方式启动
追踪已启动的jvm进程
命令：btrace/bin/btrace 12345 SomeScript.java
注意，下载下来后bin下的文件都不可执行，需要chmod u+x，并且需要和目标进程是同一个用户来启动</p></li>
<li><p>Agent方式启动
与目标jvm同时启动
配置jvm参数：-javaagent:btrace-agent.jar=script=SqlMapTracer.class
注意：agent方式启动只能使用编译过的脚本
使用btrace/bin/btracec SqlMapTracer.java 编译
agent方式启动的btrace的标准输出位于你的SqlMapTracer.class所在目录下的SqlMapTracer.class.btrace文件</p></li>
</ul>


<p>boot方式灵活，但是当要求追踪结果精确时，就不太好用了。因为不知道btrace启动之前，目标进程已经执行了多少代码。agent方式是和目标进程同时启动的，可以保证结果精确。</p>

<h4>1.5原理</h4>

<p>主要就是使用ASM来实现对类的修改,再使用Instumentation实现类的内存替换.</p>

<p>btrace原理: <a href="http://victorzhzh.iteye.com/blog/965789">http://victorzhzh.iteye.com/blog/965789</a></p>

<p>btrace源码分析: <a href="http://agapple.iteye.com/blog/1005918">http://agapple.iteye.com/blog/1005918</a></p>

<h2>. 2.HouseMD</h2>

<p>高负载服务器端Java程序 诊断工具的特性要求有:</p>

<pre><code>1.命令行接口, 能够方便在服务器环境中运行;
2.支持常用诊断调式手段, 能够在其中快速来回切换;
3.容易定位跟踪目标, 且不易出错;
4.弱侵入, 目标Java程序无需任何修改, 不用重新部署或重启;
5.有效控制给目标进程带来的资源消耗;
6.不遗留任何"代码垃圾"等后遗症.
</code></pre>

<p>使用手册: <a href="https://github.com/CSUG/HouseMD/wiki/UserGuideCN">https://github.com/CSUG/HouseMD/wiki/UserGuideCN</a></p>

<h4>. 2.1安装</h4>

<p>首先安装jenv:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xiaobaoqiu@xiaobaoqiu:~/Tools/HouseMD$ curl -L -s get.jenv.io | bash
</span><span class='line'>...
</span><span class='line'>xiaobaoqiu@xiaobaoqiu:~/Tools/HouseMD$ source /home/xiaobaoqiu/.jenv/bin/jenv-init.sh
</span><span class='line'>...
</span><span class='line'>xiaobaoqiu@xiaobaoqiu:~/Tools/HouseMD$ jenv help
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>再安装HouseMD就很简单:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xiaobaoqiu@xiaobaoqiu:~/Tools/HouseMD$ jenv install housemd
</span><span class='line'>Installing: housemd 0.2.7
</span><span class='line'>Parsing http://jenv.mvnsearch.org/candidate/housemd/download/0.2.7/Linux/x86_64
</span><span class='line'>
</span><span class='line'>Downloading: housemd 0.2.7
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<h2>. 3.Greys-Anatomy</h2>

<p>Greys是一个java进程执行过程中的异常诊断工具。 在不中断程序执行的情况下轻松完成问题排查工作.</p>

<p>源码: <a href="https://github.com/oldmanpushcart/greys-anatomy">https://github.com/oldmanpushcart/greys-anatomy</a></p>

<p>使用范例: <a href="https://github.com/oldmanpushcart/greys-anatomy/wiki/Getting-Start">https://github.com/oldmanpushcart/greys-anatomy/wiki/Getting-Start</a></p>

<p>交互方式: 命令行交互</p>

<p>功能:</p>

<pre><code>1.查看加载类，方法信息
2.方法执行监控（调用量，成功失败率，响应时间）
3.方法执行数据观测（参数，返回结果，异常信息等）
4.方法执行数据记录
5.性能开销渲染
6.方法执行数据自定义观测（js脚本）
7.查看方法调用堆栈
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/08/22/chu-li-sqlchao-shi/">处理sql超时</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-22T14:18:23+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>22</span><span class='date-suffix'>nd</span>, <span class='date-year'>2015</span></span> <span class='time'>2:18 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近组内又出现一次因为SQL慢查询导致业务整体雪崩的情况.很惭愧的是,那个慢查询SQL是我大概一年之前写的(一个统计的SQL,数据量又比较大),那时还很稚嫩.</p>

<p>之前组内出现这种情况一般是让DBA上一个慢查询脚本,直接暴力kill那些慢查询.</p>

<p>其实各个JDBC driver实现java.sql.Statement的时候都需要实现setQueryTimeout这个函数,其作用就是设置SQL的执行超时时间,当SQL超时会直接被取消掉并且抛出QLTimeoutException异常.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'>     * Sets the number of seconds the driver will wait for a
</span><span class='line'>     * &lt;code&gt;Statement&lt;/code&gt; object to execute to the given number of seconds.
</span><span class='line'>     *By default there is no limit on the amount of time allowed for a running
</span><span class='line'>     * statement to complete. If the limit is exceeded, an
</span><span class='line'>     * &lt;code&gt;SQLTimeoutException&lt;/code&gt; is thrown.
</span><span class='line'>     * A JDBC driver must apply this limit to the &lt;code&gt;execute&lt;/code&gt;,
</span><span class='line'>     * &lt;code&gt;executeQuery&lt;/code&gt; and &lt;code&gt;executeUpdate&lt;/code&gt; methods.
</span><span class='line'>     * &lt;p&gt;
</span><span class='line'>     * &lt;strong&gt;Note:&lt;/strong&gt; JDBC driver implementations may also apply this
</span><span class='line'>     * limit to {@code ResultSet} methods
</span><span class='line'>     * (consult your driver vendor documentation for details).
</span><span class='line'>     * &lt;p&gt;
</span><span class='line'>     * &lt;strong&gt;Note:&lt;/strong&gt; In the case of {@code Statement} batching, it is
</span><span class='line'>     * implementation defined as to whether the time-out is applied to
</span><span class='line'>     * individual SQL commands added via the {@code addBatch} method or to
</span><span class='line'>     * the entire batch of SQL commands invoked by the {@code executeBatch}
</span><span class='line'>     * method (consult your driver vendor documentation for details).
</span><span class='line'>     *
</span><span class='line'>     * @param seconds the new query timeout limit in seconds; zero means
</span><span class='line'>     *        there is no limit
</span><span class='line'>     * @exception SQLException if a database access error occurs,
</span><span class='line'>     * this method is called on a closed &lt;code&gt;Statement&lt;/code&gt;
</span><span class='line'>     *            or the condition seconds &gt;= 0 is not satisfied
</span><span class='line'>     * @see #getQueryTimeout
</span><span class='line'>     */
</span><span class='line'>    void setQueryTimeout(int seconds) throws SQLException;</span></code></pre></td></tr></table></div></figure>


<p>默认情况下都不设置超时时间(即默认值0).即永远不超时.Druid的Filter机制很容易的让我们设置这个查询超时时间.</p>

<h2>1.SQL超时时间Filter实现</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> * 设置SQL执行时间
</span><span class='line'> * 如果超时,查询被cancel,并抛出SQLTimeoutException异常
</span><span class='line'> *
</span><span class='line'> * @author: xiaobaoqiu  Date: 15-8-22 Time: 下午1:55
</span><span class='line'> */
</span><span class='line'>public class SqlTimeOutFilter extends FilterEventAdapter {
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 默认超时时间,单位秒
</span><span class='line'>     * 注意不要设置太小
</span><span class='line'>     */
</span><span class='line'>    private static final int QUERY_TIMEOUT_THRESHOLD_SECOND = 100;
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 超时时间,默认为QUERY_TIMEOUT_THRESHOLD_SECOND
</span><span class='line'>     */
</span><span class='line'>    private int timeoutThreshold = QUERY_TIMEOUT_THRESHOLD_SECOND;
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    protected void statementExecuteBefore(StatementProxy statement, String sql) {
</span><span class='line'>        setQueryTimeout(statement);
</span><span class='line'>        super.statementExecuteBefore(statement, sql);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    protected void statementExecuteBatchBefore(StatementProxy statement) {
</span><span class='line'>        setQueryTimeout(statement);
</span><span class='line'>        super.statementExecuteBatchBefore(statement);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    protected void statementExecuteUpdateBefore(StatementProxy statement, String sql) {
</span><span class='line'>        setQueryTimeout(statement);
</span><span class='line'>        super.statementExecuteUpdateBefore(statement, sql);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    protected void statementExecuteQueryBefore(StatementProxy statement, String sql) {
</span><span class='line'>        setQueryTimeout(statement);
</span><span class='line'>        super.statementExecuteQueryBefore(statement, sql);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 设置Statement超时时间,
</span><span class='line'>     * statement.setQueryTimeout单位是秒,0表示没有限制.这个函数可能会抛出SQLException异常,场景:
</span><span class='line'>     *      1.数据库访问错误
</span><span class='line'>     *      2.在一个已经关闭的Statement上调用这个方法
</span><span class='line'>     *      3.超时时间不满足seconds &gt;= 0的条件
</span><span class='line'>     *
</span><span class='line'>     * @param statement
</span><span class='line'>     */
</span><span class='line'>    private void setQueryTimeout(StatementProxy statement) {
</span><span class='line'>        try {
</span><span class='line'>            statement.setQueryTimeout(timeoutThreshold);
</span><span class='line'>        }catch (SQLException se) {
</span><span class='line'>            //TODO: do something
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public int getTimeoutThreshold() {
</span><span class='line'>        return timeoutThreshold;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public void setTimeoutThreshold(int timeoutThreshold) {
</span><span class='line'>        this.timeoutThreshold = timeoutThreshold;
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>2.SQL超时时间Filter使用</h2>

<p>默认的DruidDataSource就支持设置设置Filter:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void setProxyFilters(List&lt;Filter&gt; filters) {
</span><span class='line'>        if (filters != null) {
</span><span class='line'>            this.filters.addAll(filters);
</span><span class='line'>        }
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>我们可以实现DataSourceFactory(参考默认实现DefaultDataSourceFactory),在创建DataSource的时候调用setProxyFilters加上我们自己写的Filter:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class DruidDataSourceFactory implements DataSourceFactory {
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    public DataSource create(String host, int port, String username, String password, String dbName, int corePoolSize,
</span><span class='line'>                             int maxPoolSize, String jdbcUrlOption, boolean autoCommit) throws ResourceException {
</span><span class='line'>        DruidDataSource dataSource = new DruidDataSource();//使用默认实现DruidDataSource
</span><span class='line'>        //设置dataSource参数, username等
</span><span class='line'>
</span><span class='line'>        //设置dataSource的Filter
</span><span class='line'>        List&lt;Filter&gt; filters = Lists.newArrayList();
</span><span class='line'>        SqlTimeOutFilter timeOutFilter = new SqlTimeOutFilter();
</span><span class='line'>        filters.add(timeOutFilter);
</span><span class='line'>        dataSource.setProxyFilters(filters);
</span><span class='line'>        
</span><span class='line'>        //dataSource初始化等操作
</span><span class='line'>        ...
</span><span class='line'>
</span><span class='line'>        return dataSource;
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>关于超时时间设置的一篇博文,很全面:</p>

<p><a href="http://www.importnew.com/2466.html">http://www.importnew.com/2466.html</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/08/22/mybatiskong-wherelan-jie-qi/">MyBatis空where拦截器</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-22T12:37:48+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>22</span><span class='date-suffix'>nd</span>, <span class='date-year'>2015</span></span> <span class='time'>12:37 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近项目中出现了至少两次因为Mybatis的动态where条件不满足导致实际sql语句的where条件为空,进而查询全表,当数据量比较大的时候,导致OOM的情况.</p>

<p>如何禁止这种情况,个人觉得三种措施:</p>

<ul>
<li>1.在逻辑层面加充分的参数有效性检查;</li>
<li>2.在where条件中如果索引条件都不满足,加上1=2这种必然失败的条件;</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;where&gt;
</span><span class='line'>    &lt;choose&gt;
</span><span class='line'>        &lt;when test="id != null"&gt;
</span><span class='line'>            ...
</span><span class='line'>        &lt;/when&gt;
</span><span class='line'>        ...
</span><span class='line'>        &lt;otherwise&gt;
</span><span class='line'>        and 1=2
</span><span class='line'>        &lt;/otherwise&gt;
</span><span class='line'>    &lt;/choose&gt;
</span><span class='line'>&lt;/where&gt;</span></code></pre></td></tr></table></div></figure>


<ul>
<li>3.Mybatis拦截器;</li>
</ul>


<p>前两种措施都是依赖人,从这个层面讲,是不靠谱的,即一个策略不是强制的,就是不靠谱的.相对而言,第三种是不依赖程序员的自觉性,是最靠谱的.乘周六有时间,实现一个简单的Mybatis拦截器来拦截where条件为空的SQL语句.</p>

<h1>1.实现</h1>

<p>先上代码,这里拦截了SqlCommandType为select,update,delete这三种类型.出现情况目前只是打日志.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> * Mybatis拦截器, 拦截:
</span><span class='line'> *      select语句where条件为空
</span><span class='line'> *      update语句where条件为空
</span><span class='line'> *      delete语句where条件为空
</span><span class='line'> *
</span><span class='line'> * 处理: 目前只是打warning日志,因为项目中存在数据量很少的表读全表的情况(比如加载数据进缓存)
</span><span class='line'> *      TODO:后续考虑设置拦截器的白名单,不在白名单的触发where条件为空的直接抛出异常.
</span><span class='line'> *
</span><span class='line'> * @author: xiaobaoqiu  Date: 15-8-22 Time: 上午10:26
</span><span class='line'> */
</span><span class='line'>@Intercepts({ @Signature(
</span><span class='line'>        type = StatementHandler.class,
</span><span class='line'>        method = "prepare",
</span><span class='line'>        args = { Connection.class }) })
</span><span class='line'>public class EmptyWhereInterceptor implements Interceptor {
</span><span class='line'>
</span><span class='line'>    private static final Logger logger = LoggerFactory.getLogger(EmptyWhereInterceptor.class);
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 拦截的 COMMAND 类型
</span><span class='line'>     */
</span><span class='line'>    private static final Set&lt;String&gt; INTERCEPTOR_COMMAND = Sets.newHashSet("select", "update", "delete");
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    public Object intercept(Invocation invocation) throws Throwable {
</span><span class='line'>        StatementHandler handler = (StatementHandler) invocation.getTarget();
</span><span class='line'>
</span><span class='line'>        //获取实际的StatementHandler
</span><span class='line'>        if (handler instanceof RoutingStatementHandler) {
</span><span class='line'>            handler = (BaseStatementHandler) ReflectUtil.getFieldValue(handler, "delegate");
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        //获取SqlCommandType
</span><span class='line'>        String commandType = getCommandType(handler);
</span><span class='line'>
</span><span class='line'>        if (INTERCEPTOR_COMMAND.contains(commandType)) {
</span><span class='line'>            String originSql = handler.getBoundSql().getSql().toLowerCase();  //获取sql
</span><span class='line'>            if (!originSql.contains("where")) {
</span><span class='line'>                logger.warn("禁止使用不带where条件的SQL语句.原始SQL={}", originSql);
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        return invocation.proceed();
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    public Object plugin(Object target) {
</span><span class='line'>        return Plugin.wrap(target, this);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    public void setProperties(Properties properties) {
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 获取Command类型,小写化返回
</span><span class='line'>     *
</span><span class='line'>     * @param handler
</span><span class='line'>     * @return
</span><span class='line'>     */
</span><span class='line'>    private String getCommandType(StatementHandler handler) {
</span><span class='line'>        MappedStatement mappedStatement = (MappedStatement) ReflectUtil.getFieldValue(handler, "mappedStatement");
</span><span class='line'>        return mappedStatement.getSqlCommandType().toString().toLowerCase();
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>包括一个简单反射工具的实现:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> * 反射工具
</span><span class='line'> *
</span><span class='line'> * @author: xiaobaoqiu  Date: 15-8-22 Time: 上午11:52
</span><span class='line'> */
</span><span class='line'>public class ReflectUtil {
</span><span class='line'>    public ReflectUtil() {
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 改变 Accessible,便于访问private等属性
</span><span class='line'>     * @param field
</span><span class='line'>     */
</span><span class='line'>    private static void makeAccessible(Field field) {
</span><span class='line'>        if(!Modifier.isPublic(field.getModifiers())) {
</span><span class='line'>            field.setAccessible(true);
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 获取 object 的字段,字段名称为filedName,获取不到返回null
</span><span class='line'>     * @param object
</span><span class='line'>     * @param filedName
</span><span class='line'>     * @return
</span><span class='line'>     */
</span><span class='line'>    private static Field getDeclaredField(Object object, String filedName) {
</span><span class='line'>        Class superClass = object.getClass();
</span><span class='line'>
</span><span class='line'>        while(superClass != Object.class) {
</span><span class='line'>            try {
</span><span class='line'>                return superClass.getDeclaredField(filedName);
</span><span class='line'>            } catch (NoSuchFieldException var4) {
</span><span class='line'>                superClass = superClass.getSuperclass();
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        return null;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 获取object字段fieldName的值,如果字段不存在直接抛异常
</span><span class='line'>     *
</span><span class='line'>     * @param object
</span><span class='line'>     * @param fieldName
</span><span class='line'>     * @return
</span><span class='line'>     */
</span><span class='line'>    public static Object getFieldValue(Object object, String fieldName) {
</span><span class='line'>        Field field = getDeclaredField(object, fieldName);
</span><span class='line'>        if(field == null) {
</span><span class='line'>            throw new IllegalArgumentException("Could not find field [" + fieldName + "] on target [" + object + "]");
</span><span class='line'>        } else {
</span><span class='line'>            makeAccessible(field);
</span><span class='line'>            Object result = null;
</span><span class='line'>
</span><span class='line'>            try {
</span><span class='line'>                result = field.get(object);
</span><span class='line'>            } catch (IllegalAccessException var5) {
</span><span class='line'>                var5.printStackTrace();
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>            return result;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 设置object字段fieldName的值,如果字段不存在直接抛异常
</span><span class='line'>     *
</span><span class='line'>     * @param object
</span><span class='line'>     * @param fieldName
</span><span class='line'>     * @param value
</span><span class='line'>     */
</span><span class='line'>    public static void setFieldValue(Object object, String fieldName, Object value) {
</span><span class='line'>        Field field = getDeclaredField(object, fieldName);
</span><span class='line'>        if(field == null) {
</span><span class='line'>            throw new IllegalArgumentException("Could not find field [" + fieldName + "] on target [" + object + "]");
</span><span class='line'>        } else {
</span><span class='line'>            makeAccessible(field);
</span><span class='line'>
</span><span class='line'>            try {
</span><span class='line'>                field.set(object, value);
</span><span class='line'>            } catch (IllegalAccessException var5) {
</span><span class='line'>                var5.printStackTrace();
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h1>2.Mybatis的Interceptor原理</h1>

<p><a href="http://www.tuicool.com/articles/RbyUfu">这篇文章</a>很好的解释了Mybatis的Interceptor机制.</p>

<p>mybatis读取配置再xml文件中Interceptor,通过反射构造其实例，将所有的Interceptor保存到InterceptorChain中。</p>

<p>mybatis的拦截器只能代理指定的四个类：ParameterHandler、ResultSetHandler、StatementHandler以及Executor。</p>

<p>参考:</p>

<p><a href="http://www.tuicool.com/articles/RbyUfu">http://www.tuicool.com/articles/RbyUfu</a></p>

<p><a href="http://blog.csdn.net/hupanfeng/article/details/9247379">http://blog.csdn.net/hupanfeng/article/details/9247379</a></p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/6">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/4">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <div class="panel-heading">
    <h1 class="panel-title">最新文章</h3>
  </div>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2017/02/03/activitizi-dong-liu-zhuan-ren-wu/">Activiti自动流转任务</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/30/springshang-chuan-zu-jian-chong-tu/">Spring上传组件冲突</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/29/activitishi-jian-chu-li/">Activiti事件处理</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/29/activitiren-wu-zeng-jia-shu-xing/">Activiti任务增加属性</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/16/activitibiao/">Activiti表</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/11/28/ni-zhen-de-liao-jie-stringma/">你真的了解String吗</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/08/20/cratewen-dang-fan-yi/">Crate文档翻译</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/07/22/%5B%3F%5D-ge-si-suo-wen-ti/">一个死锁问题</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/07/15/cong-dai-li-dao-springshi-wu-aop/">从代理到Spring事务2-AOP</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/07/07/springshi-wu/">从代理到Spring事务3-Spring事务</a>
      </li>
    
  </ul>
</section>
<section class="panel panel-default">
  <div  class="panel-heading">
    <h1 class="panel-title">文章分类</h1>
  </div>
  <div id="categories_list_div" class="list-group">
    <li><a class='list-group-item' href='/blog/categories/algorithm/'>algorithm (5)</a></li>
<li><a class='list-group-item' href='/blog/categories/druid/'>druid (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/dubbo/'>dubbo (2)</a></li>
<li><a class='list-group-item' href='/blog/categories/guava/'>guava (2)</a></li>
<li><a class='list-group-item' href='/blog/categories/java/'>java (25)</a></li>
<li><a class='list-group-item' href='/blog/categories/library/'>library (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/linux/'>linux (13)</a></li>
<li><a class='list-group-item' href='/blog/categories/maven/'>maven (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/memcached/'>memcached (6)</a></li>
<li><a class='list-group-item' href='/blog/categories/mybatis/'>mybatis (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/mysql/'>mysql (12)</a></li>
<li><a class='list-group-item' href='/blog/categories/octopress/'>octopress (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/postgresql/'>postgresql (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/protocol/'>protocol (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/qa/'>qa (2)</a></li>
<li><a class='list-group-item' href='/blog/categories/reading/'>reading (7)</a></li>
<li><a class='list-group-item' href='/blog/categories/search/'>search (9)</a></li>
<li><a class='list-group-item' href='/blog/categories/spring/'>spring (7)</a></li>
<li><a class='list-group-item' href='/blog/categories/squid/'>squid (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/structure/'>structure (3)</a></li>
<li><a class='list-group-item' href='/blog/categories/tomcat/'>tomcat (3)</a></li>
<li><a class='list-group-item' href='/blog/categories/tools/'>tools (8)</a></li>
<li><a class='list-group-item' href='/blog/categories/web/'>web (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/workflow/'>workflow (5)</a></li>
 
  </div>
</section>
<section class="panel panel-default">
  <div  class="panel-heading">
    <h1 class="panel-title">友情链接</h3>
  </div>
  <div id="categories_list_div" class="list-group">
    <a class='list-group-item' href='http://wenzhang.baidu.com/'>百度文章</a>
  </div>
  <div id="categories_list_div" class="list-group">
    <a class='list-group-item' href='https://github.com/xiaobaoqiu/leetcode'>LeetCode Solution</a>
  </div>
  <div id="categories_list_div" class="list-group">
    <a class='list-group-item' href='http://youdang.github.io/'>Youdang's Blog</a>
  </div>
  <div id="categories_list_div" class="list-group">
    <a class='list-group-item' href='http://blog.csdn.net/ghsau'>Gaoshuang's Blog</a>
  </div>
  <div id="categories_list_div" class="list-group">
    <a class='list-group-item' href='http://kriszhang.com/'>kriszhang's Blog</a>
  </div>
</section>

  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2017 - xiaobaoqiu -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







<!--  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script> -->





</body>
</html>
