
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>xiaobaoqiu Blog</title>
  <meta name="author" content="xiaobaoqiu">

  
  <meta name="description" content="最近项目的图片服务器从公司的服务器下载图片做裁剪等操作的时候，老是存在超时的问题 1
2
3
4
5
6
7
8
java.net.SocketTimeoutException: Read timed out at java.net.SocketInputStream.socketRead0( &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://xiaobaoqiu.github.io/posts/5/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  

  <link href="/atom.xml" rel="alternate" title="xiaobaoqiu Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">xiaobaoqiu Blog</a></h1>
  
    <h2>Keep Runnnnnnnnnning...</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss email">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
    <li><a href="xiaobaoqiu@163.com" rel="subscribe-email" title="subscribe via email">Email</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="xiaobaoqiu.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">所有博文</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/16/linuxwang-qia-su-du/">Linux网卡速度</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-01-16T18:58:54+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>16</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>6:58 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近项目的图片服务器从公司的服务器下载图片做裁剪等操作的时候，老是存在超时的问题</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>java.net.SocketTimeoutException: Read timed out
</span><span class='line'>    at java.net.SocketInputStream.socketRead0(Native Method) ~[na:1.7.0_51]
</span><span class='line'>    at java.net.SocketInputStream.read(SocketInputStream.java:152) ~[na:1.7.0_51]
</span><span class='line'>    at java.net.SocketInputStream.read(SocketInputStream.java:122) ~[na:1.7.0_51]
</span><span class='line'>    at java.io.BufferedInputStream.read1(BufferedInputStream.java:273) ~[na:1.7.0_51]
</span><span class='line'>    at java.io.BufferedInputStream.read(BufferedInputStream.java:334) ~[na:1.7.0_51]
</span><span class='line'>    at sun.net.www.MeteredStream.read(MeteredStream.java:134) ~[na:1.7.0_51]
</span><span class='line'>    at java.io.FilterInputStream.read(FilterInputStream.java:133) ~[na:1.7.0_51]</span></code></pre></td></tr></table></div></figure>


<p>手动wget图片一切正常，但是速度还不如本地机器，于是想看一下服务器的网卡信息。下面用本机作为示例：</p>

<h1>1.使用ifconfig找到网卡：</h1>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>eth0      Link encap:以太网  硬件地址 f0:1f:af:27:58:8d  
</span><span class='line'>          inet 地址:192.168.138.99  广播:192.168.139.255  掩码:255.255.254.0
</span><span class='line'>          inet6 地址: fe80::f21f:afff:fe27:588d/64 Scope:Link
</span><span class='line'>          UP BROADCAST RUNNING MULTICAST  MTU:1500  跃点数:1
</span><span class='line'>          接收数据包:696848 错误:0 丢弃:0 过载:0 帧数:0
</span><span class='line'>          发送数据包:334077 错误:0 丢弃:0 过载:0 载波:0
</span><span class='line'>          碰撞:0 发送队列长度:1000 
</span><span class='line'>          接收字节:486532283 (486.5 MB)  发送字节:49164276 (49.1 MB)
</span><span class='line'>          中断:18 
</span><span class='line'>
</span><span class='line'>lo        Link encap:本地环回  
</span><span class='line'>          inet 地址:127.0.0.1  掩码:255.0.0.0
</span><span class='line'>          inet6 地址: ::1/128 Scope:Host
</span><span class='line'>          UP LOOPBACK RUNNING  MTU:65536  跃点数:1
</span><span class='line'>          接收数据包:14772 错误:0 丢弃:0 过载:0 帧数:0
</span><span class='line'>          发送数据包:14772 错误:0 丢弃:0 过载:0 载波:0
</span><span class='line'>          碰撞:0 发送队列长度:0 
</span><span class='line'>          接收字节:1329005 (1.3 MB)  发送字节:1329005 (1.3 MB)</span></code></pre></td></tr></table></div></figure>


<h1>2.查看网卡是否被识别及型号</h1>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xiaobaoqiu@xiaobaoqiu:~/octopress$ lspci | grep Ethernet
</span><span class='line'>0c:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5761 Gigabit Ethernet PCIe (rev 10)</span></code></pre></td></tr></table></div></figure>


<h1>3.使用ethtool工具查看网卡的详细信息：</h1>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xiaobaoqiu@xiaobaoqiu:~/octopress$ sudo ethtool eth0
</span><span class='line'>[sudo] password for xiaobaoqiu: 
</span><span class='line'>Settings for eth0:
</span><span class='line'>    Supported ports: [ TP ]
</span><span class='line'>    Supported link modes:   10baseT/Half 10baseT/Full 
</span><span class='line'>                            100baseT/Half 100baseT/Full 
</span><span class='line'>                            1000baseT/Half 1000baseT/Full 
</span><span class='line'>    Supported pause frame use: No
</span><span class='line'>    Supports auto-negotiation: Yes
</span><span class='line'>    Advertised link modes:  10baseT/Half 10baseT/Full 
</span><span class='line'>                            100baseT/Half 100baseT/Full 
</span><span class='line'>                            1000baseT/Half 1000baseT/Full 
</span><span class='line'>    Advertised pause frame use: Symmetric
</span><span class='line'>    Advertised auto-negotiation: Yes
</span><span class='line'>    Link partner advertised link modes:  10baseT/Half 10baseT/Full 
</span><span class='line'>                                         100baseT/Half 100baseT/Full 
</span><span class='line'>    Link partner advertised pause frame use: No
</span><span class='line'>    Link partner advertised auto-negotiation: Yes
</span><span class='line'>    Speed: 100Mb/s      #网卡速度
</span><span class='line'>    Duplex: Full        #全双工
</span><span class='line'>    Port: Twisted Pair  #网络类型-双绞线
</span><span class='line'>    PHYAD: 1
</span><span class='line'>    Transceiver: internal
</span><span class='line'>    Auto-negotiation: on
</span><span class='line'>    MDI-X: on
</span><span class='line'>    Supports Wake-on: g
</span><span class='line'>    Wake-on: g          #唤醒起用（远程关机开机需设置）
</span><span class='line'>    Current message level: 0x000000ff (255)
</span><span class='line'>                   drv probe link timer ifdown ifup rx_err tx_err
</span><span class='line'>    Link detected: yes  #链路检测</span></code></pre></td></tr></table></div></figure>


<h1>4.查看网卡的连接状态</h1>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xiaobaoqiu@xiaobaoqiu:~/octopress$ sudo mii-tool eth0
</span><span class='line'>eth0: negotiated 100baseTx-FD, link ok</span></code></pre></td></tr></table></div></figure>


<h1>5.网卡数据包收发统计</h1>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xiaobaoqiu@xiaobaoqiu:~/octopress$ sudo ethtool -S eth0
</span><span class='line'>NIC statistics:
</span><span class='line'>     rx_octets: 494545915
</span><span class='line'>     rx_fragments: 0
</span><span class='line'>     rx_ucast_packets: 437748
</span><span class='line'>     rx_mcast_packets: 147474
</span><span class='line'>     rx_bcast_packets: 128799
</span><span class='line'>     rx_fcs_errors: 0
</span><span class='line'>     rx_align_errors: 0
</span><span class='line'>     rx_xon_pause_rcvd: 0
</span><span class='line'>     rx_xoff_pause_rcvd: 0
</span><span class='line'>     ...</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/16/how-to-read-files-quickly/">How to Read Files Quickly</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-01-16T01:00:42+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>16</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>1:00 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Java中有很多读写文件或者网络流的方法，特别是Java7中加入了AIO之后，可选择的方法更多，本文的目的是想比较一下各种方式的优劣。</p>

<p>本文基本是参考这篇英文：<a href="http://nadeausoftware.com/articles/2008/02/java_tip_how_read_files_quikcly">http://nadeausoftware.com/articles/2008/02/java_tip_how_read_files_quikcly</a></p>

<h1>1.方法List</h1>

<p>这里涉及的读文件的方法包括：</p>

<h3>1.1 FileInputStreamOneByte</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Override
</span><span class='line'>public long doRead() throws IOException {
</span><span class='line'>    long checkSum = 0L;
</span><span class='line'>    FileInputStream fis = new FileInputStream(filePath);
</span><span class='line'>    int b;
</span><span class='line'>    while ((b = fis.read()) != -1)
</span><span class='line'>        checkSum += b;
</span><span class='line'>    Closeables.close(fis, false);
</span><span class='line'>    return checkSum;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>1.2 FileInputStreamBytes</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Override
</span><span class='line'>    public long doRead() throws IOException {
</span><span class='line'>        long checkSum = 0L;
</span><span class='line'>        FileInputStream fis = new FileInputStream(filePath);
</span><span class='line'>        byte[] array = new byte[BUF_SIZE];
</span><span class='line'>        int nRead;
</span><span class='line'>        while ((nRead = fis.read(array, 0, BUF_SIZE)) != -1) {
</span><span class='line'>            for (int i = 0; i &lt; nRead; i++)
</span><span class='line'>                checkSum += array[i];
</span><span class='line'>        }
</span><span class='line'>        Closeables.close(fis, false);
</span><span class='line'>        return checkSum;
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<h3>1.3 BufferedInputStreamOneByte</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Override
</span><span class='line'>    public long doRead() throws IOException {
</span><span class='line'>        long checkSum = 0L;
</span><span class='line'>        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(filePath), BUF_SIZE);
</span><span class='line'>        int b;
</span><span class='line'>        while ((b = bis.read()) != -1)
</span><span class='line'>            checkSum += b;
</span><span class='line'>        Closeables.close(bis, false);
</span><span class='line'>        return checkSum;
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<h3>1.4 BufferedInputStreamBytes</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Override
</span><span class='line'>    public long doRead() throws IOException {
</span><span class='line'>        long checkSum = 0L;
</span><span class='line'>        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(filePath), BUF_SIZE);
</span><span class='line'>        byte[] array = new byte[BUF_SIZE];
</span><span class='line'>        int nRead;
</span><span class='line'>        while ((nRead = bis.read(array, 0, BUF_SIZE)) != -1) {
</span><span class='line'>            for (int i = 0; i &lt; nRead; i++)
</span><span class='line'>                checkSum += array[i];
</span><span class='line'>        }
</span><span class='line'>        Closeables.close(bis, false);
</span><span class='line'>        return checkSum;
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<h3>1.5 RandomAccessOneByte</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public long doRead() throws IOException {
</span><span class='line'>        long checkSum = 0L;
</span><span class='line'>        RandomAccessFile raf = new RandomAccessFile(filePath, READ_MODE);
</span><span class='line'>        int b;
</span><span class='line'>        while ((b = raf.read()) != -1) {
</span><span class='line'>            checkSum += b;
</span><span class='line'>        }
</span><span class='line'>        Closeables.close(raf, false);
</span><span class='line'>        return checkSum;
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<h3>1.6 RandomAccessBytes</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public long doRead() throws IOException {
</span><span class='line'>        long checkSum = 0L;
</span><span class='line'>        RandomAccessFile raf = new RandomAccessFile(filePath, READ_MODE);
</span><span class='line'>        byte[] array = new byte[BUF_SIZE];
</span><span class='line'>        int nRead;
</span><span class='line'>        while ((nRead = raf.read(array, 0, BUF_SIZE)) != -1) {
</span><span class='line'>            for (int i = 0; i &lt; nRead; i++)
</span><span class='line'>                checkSum += array[i];
</span><span class='line'>        }
</span><span class='line'>        Closeables.close(raf, false);
</span><span class='line'>        return checkSum;
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<h3>1.7 FileChannelByteBufferOneByte</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public long doRead() throws IOException {
</span><span class='line'>        long checkSum = 0L;
</span><span class='line'>        FileInputStream fis = new FileInputStream(filePath);
</span><span class='line'>        FileChannel ch = fis.getChannel();
</span><span class='line'>        ByteBuffer bb = ByteBuffer.allocate(BUF_SIZE);
</span><span class='line'>        int nRead;
</span><span class='line'>        while ((nRead = ch.read(bb)) != -1) {
</span><span class='line'>            if (nRead == 0)
</span><span class='line'>                continue;
</span><span class='line'>            bb.position(0);
</span><span class='line'>            bb.limit(nRead);
</span><span class='line'>            while (bb.hasRemaining())
</span><span class='line'>                checkSum += bb.get(); // 从ByteBuffer读一个字节
</span><span class='line'>            bb.clear();
</span><span class='line'>        }
</span><span class='line'>        Closeables.close(fis, false);
</span><span class='line'>        return checkSum;
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<h3>1.8 FileChannelByteBufferBytes</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public long doRead() throws IOException {
</span><span class='line'>        long checkSum = 0L;
</span><span class='line'>        FileInputStream fis = new FileInputStream(filePath);
</span><span class='line'>        FileChannel ch = fis.getChannel();
</span><span class='line'>        ByteBuffer bb = ByteBuffer.allocate(BIG_BUF_SIZE);
</span><span class='line'>        byte[] array = new byte[BUF_SIZE];
</span><span class='line'>        int nRead, nGet;
</span><span class='line'>        while ((nRead = ch.read(bb)) != -1) {
</span><span class='line'>            if (nRead == 0)
</span><span class='line'>                continue;
</span><span class='line'>            bb.position(0);
</span><span class='line'>            bb.limit(nRead);
</span><span class='line'>            while (bb.hasRemaining()) {
</span><span class='line'>                nGet = Math.min(bb.remaining(), BUF_SIZE);
</span><span class='line'>                bb.get(array, 0, nGet);
</span><span class='line'>                for (int i = 0; i &lt; nGet; i++)
</span><span class='line'>                    checkSum += array[i];
</span><span class='line'>            }
</span><span class='line'>            bb.clear();
</span><span class='line'>        }
</span><span class='line'>        Closeables.close(fis, false);
</span><span class='line'>        return checkSum;
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<h3>1.9 FileChannelByteBufferWrap</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public long doRead() throws IOException {
</span><span class='line'>        long checkSum = 0L;
</span><span class='line'>        FileInputStream fis = new FileInputStream(filePath);
</span><span class='line'>        FileChannel ch = fis.getChannel();
</span><span class='line'>        byte[] barray = new byte[BUF_SIZE];
</span><span class='line'>        ByteBuffer bb = ByteBuffer.wrap(barray); // ByteBuffer包装本地array
</span><span class='line'>        int nRead;
</span><span class='line'>        while ((nRead = ch.read(bb)) != -1) {
</span><span class='line'>            for (int i = 0; i &lt; nRead; i++)
</span><span class='line'>                checkSum += barray[i];
</span><span class='line'>            bb.clear();
</span><span class='line'>        }
</span><span class='line'>        Closeables.close(fis, false);
</span><span class='line'>        return checkSum;
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<h3>1.10 FileChannelMappedByteBufferOneByte</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public long doRead() throws IOException {
</span><span class='line'>        long checkSum = 0L;
</span><span class='line'>        FileInputStream fis = new FileInputStream(filePath);
</span><span class='line'>        FileChannel ch = fis.getChannel();
</span><span class='line'>        MappedByteBuffer mb = ch.map(FileChannel.MapMode.READ_ONLY, 0L, ch.size());
</span><span class='line'>        while (mb.hasRemaining())
</span><span class='line'>            checkSum += mb.get();
</span><span class='line'>        Closeables.close(fis, false);
</span><span class='line'>        return checkSum;
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<h3>1.11 FileChannelMappedByteBufferBytes</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public long doRead() throws IOException {
</span><span class='line'>        long checkSum = 0L;
</span><span class='line'>        FileInputStream fis = new FileInputStream(filePath);
</span><span class='line'>        FileChannel ch = fis.getChannel();
</span><span class='line'>        MappedByteBuffer mb = ch.map(FileChannel.MapMode.READ_ONLY, 0L, ch.size());
</span><span class='line'>        byte[] barray = new byte[BUF_SIZE];
</span><span class='line'>        int nGet;
</span><span class='line'>        while (mb.hasRemaining()) {
</span><span class='line'>            nGet = Math.min(mb.remaining(), BUF_SIZE);
</span><span class='line'>            mb.get(barray, 0, nGet);
</span><span class='line'>            for (int i = 0; i &lt; nGet; i++)
</span><span class='line'>                checkSum += barray[i];
</span><span class='line'>        }
</span><span class='line'>        Closeables.close(fis, false);
</span><span class='line'>        return checkSum;
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<h3>1.12 FileChannelDirectByteBufferOneByte</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public long doRead() throws IOException {
</span><span class='line'>        long checkSum = 0L;
</span><span class='line'>        FileInputStream fis = new FileInputStream(filePath);
</span><span class='line'>        FileChannel ch = fis.getChannel();
</span><span class='line'>        ByteBuffer bb = ByteBuffer.allocateDirect(BUF_SIZE);
</span><span class='line'>        int nRead;
</span><span class='line'>        while ((nRead = ch.read(bb)) != -1) {
</span><span class='line'>            bb.position(0);
</span><span class='line'>            bb.limit(nRead);
</span><span class='line'>            while (bb.hasRemaining())
</span><span class='line'>                checkSum += bb.get();
</span><span class='line'>            bb.clear();
</span><span class='line'>        }
</span><span class='line'>        Closeables.close(fis, false);
</span><span class='line'>        return checkSum;
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<h3>1.13 FileChannelDirectByteBufferBytes</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public long doRead() throws IOException {
</span><span class='line'>        long checkSum = 0L;
</span><span class='line'>        FileInputStream fis = new FileInputStream(filePath);
</span><span class='line'>        FileChannel ch = fis.getChannel();
</span><span class='line'>        ByteBuffer bb = ByteBuffer.allocateDirect(BIG_BUF_SIZE);
</span><span class='line'>        byte[] barray = new byte[BUF_SIZE];
</span><span class='line'>        int nRead, nGet;
</span><span class='line'>        while ((nRead = ch.read(bb)) != -1) {
</span><span class='line'>            if (nRead == 0)
</span><span class='line'>                continue;
</span><span class='line'>            bb.position(0);
</span><span class='line'>            bb.limit(nRead);
</span><span class='line'>            while (bb.hasRemaining()) {
</span><span class='line'>                nGet = Math.min(bb.remaining(), BUF_SIZE);
</span><span class='line'>                bb.get(barray, 0, nGet);
</span><span class='line'>                for (int i = 0; i &lt; nGet; i++)
</span><span class='line'>                    checkSum += barray[i];
</span><span class='line'>            }
</span><span class='line'>            bb.clear();
</span><span class='line'>        }
</span><span class='line'>        Closeables.close(fis, false);
</span><span class='line'>        return checkSum;
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<h1>2.测试</h1>

<p>测试文件的大小为83M：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xiaobaoqiu@xiaobaoqiu:~/Documents/TestData$ ll -h BXBooks.sql
</span><span class='line'>-rw------- 1 xiaobaoqiu xiaobaoqiu 83M 10月  8  2004 BXBooks.sql</span></code></pre></td></tr></table></div></figure>


<h1>3.结论</h1>

<p>得到测试数据之后，为了直观展示代码的速度，用ECharts展示，对应的js代码如下(可以在<a href="http://echarts.baidu.com/doc/example/line1.html#helianthus%E4%B8%AD%E4%BD%BF%E7%94%A8">http://echarts.baidu.com/doc/example/line1.html#helianthus%E4%B8%AD%E4%BD%BF%E7%94%A8</a>)：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>option = {
</span><span class='line'>    title : {
</span><span class='line'>        text: 'how_to_read_file_quickly',
</span><span class='line'>        subtext: 'baoqiu.xiao'
</span><span class='line'>    },
</span><span class='line'>    tooltip : {
</span><span class='line'>        trigger: 'axis'
</span><span class='line'>    },
</span><span class='line'>    legend: {
</span><span class='line'>        data:['FileInputStreamOneByte','FileInputStreamBytes','BufferedInputStreamOneByte','BufferedInputStreamBytes','RandomAccessOneByte','RandomAccessBytes','FileChannelByteBufferOneByte','FileChannelByteBufferBytes','FileChannelByteBufferWrap','FileChannelMappedByteBufferOneByte','FileChannelMappedByteBufferBytes','FileChannelDirectByteBufferOneByte','FileChannelDirectByteBufferBytes']
</span><span class='line'>    },
</span><span class='line'>    dataZoom : {
</span><span class='line'>        show : true,
</span><span class='line'>        realtime: true,
</span><span class='line'>        start : 0,
</span><span class='line'>        end : 30
</span><span class='line'>    },
</span><span class='line'>    toolbox: {
</span><span class='line'>        show : true,
</span><span class='line'>        feature : {
</span><span class='line'>            saveAsImage : {show: true}
</span><span class='line'>        }
</span><span class='line'>    },
</span><span class='line'>    calculable : true,
</span><span class='line'>    xAxis : [
</span><span class='line'>        {
</span><span class='line'>            type : 'category',
</span><span class='line'>            boundaryGap : false,
</span><span class='line'>            data : ['1','2','4','8','16','32','64','128','256','512','1K','2K','4K','8K','16K','32K','64K','128K']
</span><span class='line'>        }
</span><span class='line'>    ],
</span><span class='line'>    yAxis : [
</span><span class='line'>        {
</span><span class='line'>            type : 'value',
</span><span class='line'>            axisLabel : {
</span><span class='line'>                formatter: '{value} 毫秒'
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    ],
</span><span class='line'>    series : [
</span><span class='line'>        {
</span><span class='line'>            name:'FileInputStreamOneByte',
</span><span class='line'>            type:'line',
</span><span class='line'>            data:[29119,28353,27872,27950,32035,40377,34904,36804,36835,33177,32252,37362,32359,31892,32621,32312,32943,33369]
</span><span class='line'>        },
</span><span class='line'>        {
</span><span class='line'>            name:'FileInputStreamBytes',
</span><span class='line'>            type:'line',
</span><span class='line'>            data:[38182,20208,10194,4768,2616,1551,645,471,262,183,150,100,118,125,96,83,124,110]
</span><span class='line'>        },
</span><span class='line'>        {
</span><span class='line'>            name:'BufferedInputStreamOneByte',
</span><span class='line'>            type:'line',
</span><span class='line'>            data:[33404,16966,8613,4718,2525,1491,980,728,677,681,558,608,557,615,505,606,656,693]
</span><span class='line'>        },
</span><span class='line'>        {
</span><span class='line'>            name:'BufferedInputStreamBytes',
</span><span class='line'>            type:'line',
</span><span class='line'>            data:[33880,17333,8487,4851,2293,1632,627,358,242,147,129,113,89,92,107,88,100,95]
</span><span class='line'>        },
</span><span class='line'>        {
</span><span class='line'>            name:'RandomAccessOneByte',
</span><span class='line'>            type:'line',
</span><span class='line'>            data:[28430,27445,26794,27053,28929,28633,29509,28870,28195,27376,28236,27444,28061,28889,27423,28064,28481,28084]
</span><span class='line'>        },
</span><span class='line'>        {
</span><span class='line'>            name:'RandomAccessBytes',
</span><span class='line'>            type:'line',
</span><span class='line'>            data:[31497,16162,8135,4365,2131,1117,561,321,193,146,110,101,109,87,89,91,102,96]
</span><span class='line'>        },
</span><span class='line'>        {
</span><span class='line'>            name:'FileChannelByteBufferOneByte',
</span><span class='line'>            type:'line',
</span><span class='line'>            data:[38778,18325,9447,5344,2430,1413,779,507,380,310,298,259,267,263,249,264,260,258]
</span><span class='line'>        },
</span><span class='line'>        {
</span><span class='line'>            name:'FileChannelByteBufferBytes',
</span><span class='line'>            type:'line',
</span><span class='line'>            data:[19279,9823,5090,2605,1407,854,577,380,333,272,272,239,237,241,237,234,249,270]
</span><span class='line'>        },
</span><span class='line'>        {
</span><span class='line'>            name:'FileChannelByteBufferWrap',
</span><span class='line'>            type:'line',
</span><span class='line'>            data:[38382,17636,9094,4608,2327,1198,646,355,249,151,108,100,92,90,88,103,85,92]
</span><span class='line'>        },
</span><span class='line'>        {
</span><span class='line'>            name:'FileChannelMappedByteBufferOneByte',
</span><span class='line'>            type:'line',
</span><span class='line'>            data:[913,240,92,83,82,87,85,88,83,94,87,90,81,124,81,84,83,120]
</span><span class='line'>        },
</span><span class='line'>        {
</span><span class='line'>            name:'FileChannelMappedByteBufferBytes',
</span><span class='line'>            type:'line',
</span><span class='line'>            data:[731,447,305,332,225,164,139,110,98,88,87,140,97,86,93,92,92,92]
</span><span class='line'>        },
</span><span class='line'>        {
</span><span class='line'>            name:'FileChannelDirectByteBufferOneByte',
</span><span class='line'>            type:'line',
</span><span class='line'>            data:[31287,14473,7296,3815,1919,1001,547,319,200,135,109,98,84,77,80,82,77,86]
</span><span class='line'>        },
</span><span class='line'>        {
</span><span class='line'>            name:'FileChannelDirectByteBufferBytes',
</span><span class='line'>            type:'line',
</span><span class='line'>            data:[14945,8060,4107,2174,1120,580,334,206,149,110,96,95,79,89,81,81,86,84]
</span><span class='line'>        }       
</span><span class='line'>    ]
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>整体展示图如下：
<img src="/images/iospeed/read_file_speed.png"></p>

<h3>3.1 最快的三种方法</h3>

<p>为了展示更细节的地方，设置了y区间范围，在yAxis上设置min和max属性：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>yAxis : [
</span><span class='line'>        {
</span><span class='line'>            type : 'value',
</span><span class='line'>            min:0,
</span><span class='line'>            max:200,
</span><span class='line'>            axisLabel : {
</span><span class='line'>                formatter: '{value} 毫秒'
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    ],</span></code></pre></td></tr></table></div></figure>


<p>得到如下展示图：
<img src="/images/iospeed/read_file_speed_small.png"></p>

<p>从上面这个图可以大致看出，最快的三种方法（PS，这里只做了一次实验，不是多次实验的平均值，所有数据可能不一定准确）：</p>

<pre><code>1.FileChannelMappedByteBufferBytes
2.FileChannelMappedByteBufferOneByte
3.FileChannelDirectByteBufferBytes
</code></pre>

<h1>4.解析</h1>

<p>下面解析一下代码中之前接触较少的东东。</p>

<h3>4.1 RandomAccessFile</h3>

<p>支持对文件的随机读取和写入。随机存取文件的行为类似存储在文件系统中的一个大型字节数组。存在指向该隐含数组的光标或索引，称为文件指针。</p>

<p>读取操作从文件指针开始读取字节，并随着对字节的读取而前移此文件指针。如果随机存取文件以读取/写入模式创建，则写入操作也可用；写入操作从文件指针开始写入字节，并随着对字节的写入而前移此文件指针。该文件指针可以通过 getFilePointer 方法读取，并通过 seek 方法设置。</p>

<p>提供了boolean，byte，char, short, int, long, float, double这些基本类型的read和write方法。</p>

<h3>4.2 FileChannel</h3>

<p>FileChannel是一个连接到文件的通道。可以通过文件通道读写文件。FileChannel无法设置为非阻塞模式，它总是运行在阻塞模式下。</p>

<p>在使用FileChannel之前，必须先打开它。但是，我们无法直接打开一个FileChannel，需要通过使用一个InputStream、OutputStream或RandomAccessFile来获取一个FileChannel实例。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>FileInputStream fis = new FileInputStream(filePath);
</span><span class='line'>FileChannel ch = fis.getChannel();</span></code></pre></td></tr></table></div></figure>


<p>有时可能需要在FileChannel的某个特定位置进行数据的读/写操作。可以通过调用position()方法获取FileChannel的当前位置。也可以通过调用position(long pos)方法设置FileChannel的当前位置。</p>

<p>FileChannel实例的size()方法将返回该实例所关联文件的大小。</p>

<p>FileChannel.force()方法将通道里尚未写入磁盘的数据强制写到磁盘上。出于性能方面的考虑，操作系统会将数据缓存在内存中，所以无法保证写入到FileChannel里的数据一定会即时写到磁盘上。要保证这一点，需要调用force()方法。</p>

<h3>4.3 ByteBuffer</h3>

<p>ByteBuffer知识下一次单独讲。</p>

<h1>5.BufferedInputStream的defaultBufferSize</h1>

<p>BufferedInputStream默认buffer大小为8K：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class BufferedInputStream extends FilterInputStream {
</span><span class='line'>    private static int defaultBufferSize = 8192;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个从图上也可以比较直观的看到，在缓存为8K左右的时候，性能最好：
<img src="/images/iospeed/BufferedInputStream_buffer.png"></p>

<h1>5.参考：</h1>

<p><a href="http://nadeausoftware.com/articles/2008/02/java_tip_how_read_files_quickly">http://nadeausoftware.com/articles/2008/02/java_tip_how_read_files_quickly</a></p>

<p><a href="http://colobu.com/2014/10/20/java-buffer-basic/">http://colobu.com/2014/10/20/java-buffer-basic/</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/15/abjian-dan-shi-yong/">AB简单使用</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-01-15T22:04:47+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>15</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>10:04 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>简单熟悉Apache附带的压测工具ab，它非常容易使用，ab可以直接在Web服务器本地发起测试请求。</p>

<p>需要清楚的是，ab进行一切测试的本质都是基于HTTP，所以可以说它是对于Web服务器软件的黑盒性能测试，它获得的一切数据和计算结果，都可以通过HTTP来解释。</p>

<p>本文的ab版本信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xiaobaoqiu@xiaobaoqiu:~/octopress/source/images/io$ ab -V
</span><span class='line'>This is ApacheBench, Version 2.3 &lt;$Revision: 1430300 $&gt;
</span><span class='line'>Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/
</span><span class='line'>Licensed to The Apache Software Foundation, http://www.apache.org/</span></code></pre></td></tr></table></div></figure>


<h1>1.参数</h1>

<p>所有的参数及意义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Usage: ab [options] [http[s]://]hostname[:port]/path
</span><span class='line'>Options are:
</span><span class='line'>    -n requests     总请求数目，要访问页面的次数，默认为1
</span><span class='line'>    -c concurrency  同一时刻的并发请求数目，默认1
</span><span class='line'>    -t timelimit    测试进行的最大秒数，内部隐含值为50000，默认无时间限制
</span><span class='line'>    -s timeout      response超时时间，默认30秒
</span><span class='line'>    -b windowsize   TCP buffer的大小，单位是bytes
</span><span class='line'>    -B address      指定发出请求的本地ip地址
</span><span class='line'>    -p postfile     包含待POST的数据的文件，需要设置参数-T
</span><span class='line'>    -u putfile      包含待PUT的数据的文件，需要设置参数-T
</span><span class='line'>    -T content-type POST/PUT 数据的Content-type header信息, 比如.
</span><span class='line'>                    'application/x-www-form-urlencoded'
</span><span class='line'>                    默认是'text/plain'
</span><span class='line'>    -v verbosity    设置显示信息的详细程度，- 
</span><span class='line'>                    4或者更大的值会显示头信息，3或者更大的值可以显示响应代码(200等)，2或者更大可以显示警告和其他信息。
</span><span class='line'>    -w              已html表格的形式输出结果
</span><span class='line'>    -i              执行HEAD请求，而不是GET
</span><span class='line'>    -x attributes   设置&lt;table&gt;属性的字符串,此属性被填入&lt;table 这里&gt;
</span><span class='line'>    -y attributes   设置&lt;tr&gt;属性的字符串
</span><span class='line'>    -z attributes   设置&lt;td&gt;或者&lt;th&gt;属性的字符串
</span><span class='line'>    -C attribute    对请求附加一个Cookie行，其典型形式是name=value的一个参数对，  
</span><span class='line'>                    此参数可以重复。
</span><span class='line'>    -H attribute    对请求附加额外的头信息。此参数的典型形式是一个有效的头信息行，其中包含
</span><span class='line'>                    了以冒号分隔的字段和值的对 (如, "Accept-Encoding: zip/zop;8bit")
</span><span class='line'>    -A attribute    对服务器提供BASIC认证信任。用户名和密码由一个:隔开，并以base64编码形
</span><span class='line'>                    式发送。无论服务器是否需要(即, 是否发送了401认证需求代码)，此字符串都会被发送。
</span><span class='line'>    -P attribute    对一个中转代理提供BASIC认证信任。用户名和密码由一个:隔开，并以base64
</span><span class='line'>                    编码形式发送。无论服务器是否需要(即, 是否发送了401认证需求代码)，此字符串都会被发送。
</span><span class='line'>    -X proxy:port   对请求使用代理服务器
</span><span class='line'>    -V              版本信息
</span><span class='line'>    -k              启用HTTP KeepAlive功能，即在一个HTTP会话中执行多个请求。 
</span><span class='line'>                    默认时，不启用KeepAlive功能Use HTTP KeepAlive feature
</span><span class='line'>    -d              不显示"percentage served within XX [ms] table"的消息.
</span><span class='line'>    -S              Do not show confidence estimators and warnings.
</span><span class='line'>    -q              如果处理的请求数大于150，  
</span><span class='line'>                    ab每处理大约10%或者100个请求时，会在stderr输出一个进度计数。 此-q标记可以抑制这些信息。
</span><span class='line'>    -g filename     Output collected data to gnuplot format file.
</span><span class='line'>    -e filename     产生一个以逗号分隔的(CSV)文件，其中包含了处理每个相应百分比的请求 
</span><span class='line'>                    所需要(从1%到100%)的相应百分比的(以微妙为单位)时间。由于这种格式已经“二进制化”，所以比'gnuplot'格式更有用。
</span><span class='line'>    -r              socket接收错误的时候也不退出
</span><span class='line'>    -h              显示usage信息</span></code></pre></td></tr></table></div></figure>


<h1>2.简单使用及结果解析</h1>

<p>就对我的博客进行压测，结果如下，简单加入了一些我的注释：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xiaobaoqiu@xiaobaoqiu:~/octopress/source/images/io$ ab -n 10 -c 2 -s 10 http://xiaobaoqiu.github.io/
</span><span class='line'>This is ApacheBench, Version 2.3 &lt;$Revision: 1430300 $&gt;
</span><span class='line'>Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/
</span><span class='line'>Licensed to The Apache Software Foundation, http://www.apache.org/
</span><span class='line'>
</span><span class='line'>Benchmarking xiaobaoqiu.github.io (be patient).....done
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>Server Software:        GitHub.com
</span><span class='line'>Server Hostname:        xiaobaoqiu.github.io
</span><span class='line'>Server Port:            80
</span><span class='line'>
</span><span class='line'>Document Path:          /
</span><span class='line'>Document Length:        287269 bytes
</span><span class='line'>
</span><span class='line'>Concurrency Level:      2
</span><span class='line'>Time taken for tests:   20.788 seconds
</span><span class='line'>Complete requests:      10
</span><span class='line'>Failed requests:        0
</span><span class='line'>Write errors:           0
</span><span class='line'>Total transferred:      2877109 bytes
</span><span class='line'>HTML transferred:       2872690 bytes
</span><span class='line'>Requests per second:    0.48 [#/sec] (mean)
</span><span class='line'>Time per request:       4157.564 [ms] (mean)    #每个请求的时间
</span><span class='line'>Time per request:       2078.782 [ms] (mean, across all concurrent requests)
</span><span class='line'>Transfer rate:          135.16 [Kbytes/sec] received
</span><span class='line'>
</span><span class='line'>Connection Times (ms)
</span><span class='line'>              min  mean[+/-sd] median   max
</span><span class='line'>Connect:       59  402 717.5     94    2234
</span><span class='line'>Processing:   362 3674 3112.7   3479    8508
</span><span class='line'>Waiting:       60  164 132.8    100     407
</span><span class='line'>Total:        422 4076 3420.4   3558    8602
</span><span class='line'>
</span><span class='line'>Percentage of the requests served within a certain time (ms)
</span><span class='line'>  50%   3558        #50%的请求响应时间小于3558毫秒
</span><span class='line'>  66%   7110
</span><span class='line'>  75%   7312
</span><span class='line'>  80%   8544
</span><span class='line'>  90%   8602
</span><span class='line'>  95%   8602
</span><span class='line'>  98%   8602
</span><span class='line'>  99%   8602
</span><span class='line'> 100%   8602 (longest request)  #请求的最长响应时间为8602毫秒</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/08/ubuntuda-jian-ftp/">Ubuntu搭建FTP</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-01-08T20:16:58+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>8</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>8:16 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>想在Ubuntu下搭建一个简单ftp服务器，用于和同事之间传数据。发现了vsftpd这个工具。</p>

<h1>1.vsftpd简介</h1>

<p>首先，网上介绍的比较全面的资料有：
vsftpd入门专题：<a href="http://os.51cto.com/art/201008/222036.htm">http://os.51cto.com/art/201008/222036.htm</a></p>

<p>我见过最好的vsftpd配置教程：<a href="http://blog.csdn.net/fafa211/article/details/8095081">http://blog.csdn.net/fafa211/article/details/8095081</a></p>

<p>前者确实介绍的很全面，但是有很多内容都是属于高级主题，初级用户真的很难全部看懂。如果使用要求不搞的话，其实后者就挺合适，更适合入门级菜鸟（想我这样的）参考，我就是参考这篇文章来搭建的。另外，还有一篇：<a href="http://www.blogjava.net/stonestyle/articles/369104.html%E3%80%82">http://www.blogjava.net/stonestyle/articles/369104.html%E3%80%82</a></p>

<h1>2.安装vsftpd</h1>

<p>直接运行下面命令即可:</p>

<pre><code>sudo apt-get install vsftpd
</code></pre>

<p>安装完毕后，默认配置下就可以直接登录fpt://ip了，比如我的IP是192.168.1.2，则直接在浏览器或者其他入口访问fpt://192.168.1.2。</p>

<p>默认情况下需要username和password访问，默认就是192.168.1.2的ubuntu系统中的账户。</p>

<p>参考文章有更详细的配置讲解。</p>

<h1>3.参考</h1>

<p><a href="http://blog.csdn.net/dongtingzhizi/article/details/12028627">http://blog.csdn.net/dongtingzhizi/article/details/12028627</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/04/io-mo-xing/">IO模型</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-01-04T19:38:04+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>4</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>7:38 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>本文主要想理清同步，异步，阻塞，非阻塞这几个概念;之后理解unix上的五种IO模型。</p>

<h1>1.同步VS异步，阻塞VS非阻塞</h1>

<h3>1.1 同步VS异步</h3>

<p>访问数据的方式，同步需要主动读写数据，在读写数据的过程中还是会阻塞；异步只需要I/O操作完成的通知，并不主动读写数据，由操作系统内核完成数据的读写。</p>

<p>同步(synchronous)和异步(asynchronous)是针对应用程序和内核的交互而言的:</p>

<pre><code>(1).同步指的是用户进程触发I/O操作并等待或者轮询的去查看I/O操作是否就绪;
(2).异步是指用户进程触发I/O操作以后便开始做自己的事情，而当I/O操作已经完成的时候会得到I/O完成的通知;
</code></pre>

<h3>1.2 阻塞VS非阻塞</h3>

<p>阻塞(blocking)和非阻塞(non-blocking)是针对于进程在访问数据的时候，根据I/O操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式:</p>

<pre><code>(1).阻塞方式下读取或者写入函数将一直等待;
(2).非阻塞方式下，读取或者写入函数会立即返回一个状态值;
</code></pre>

<h1>2.IO模型</h1>

<p>《Unix网络编程卷》将unix上的IO模型分为5类：</p>

<pre><code>(1).Blocking I/O
(2).Nonblocking I/O
(3).I/O Multiplexing (select and poll)
(4).Signal Driven I/O (SIGIO)
(5).Asynchronous I/O (the POSIX aio_functions).
</code></pre>

<p>一个读操作通常包括两个不同阶段：</p>

<pre><code>(1).等待数据准备好;
(2).从内核向进程复制数据;
</code></pre>

<p>我们以一个从网络读数据为例，当网络数据包到达的时候，首先内核通过网卡读输入数据，数据被复制到内核的缓冲区;然后应用程序从内核中将数据拷贝到应用程序缓冲区。</p>

<p>以从网络读数据为例解释上面提到的5个IO模型, 即应用程序通过socket的recvfrom方法读取网络数据，关于recvfrom方法参考：<a href="http://baike.baidu.com/view/1744189.htm.">http://baike.baidu.com/view/1744189.htm.</a></p>

<h3>2.1 Blocking I/O</h3>

<p>阻塞IO：应用程序调用recvfrom试图读取数据，其实是通过系统调用从网卡读取网络数据，当网络无数据可读的时候，应用程序会一直等待;当内核从网卡读取完数据，会将数据从内核缓冲区拷贝到应用程序缓冲区，当拷贝完成，应用程序调用recvfrom才算完成。示意图如下：</p>

<p><img src="/images/io/block.jpg"></p>

<p>优势在于非常简单，等待的过程中占用的系统资源微乎其微，程序调用返回时，必定可以拿到数据；
但简单也带来一些缺点，程序在数据到来并准备好以前，不能进行其他操作;</p>

<h3>2.2 Nonblocking I/O</h3>

<p>非阻塞IO：应用程序调用recvfrom试图读取数据，当网络无数据可读的时候，应用程序不是一直等待，而是直接返回错误，过一段时间再去查看数据是否可读，即有一个操作时轮询（polling）。 示意图如下：</p>

<p><img src="/images/io/noblock.jpg"></p>

<p>这种模式在没有数据可以接收时，可以进行其他的一些操作；实际应用中，这种I/O模型的直接使用并不常见，因为它需要不停的查询，而这些查询大部分会是无必要的调用，白白浪费了系统资源；非阻塞I/O应该算是一个铺垫，为I/O复用和信号驱动奠定了非阻塞使用的基础。</p>

<h3>2.3 I/O Multiplexing</h3>

<p>首先I/O多路复用的函数也是阻塞的，但是其与以上两种还是有不同的，I/O多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上。</p>

<p>IO复用的目的：将等待数据准备和将数据拷贝给应用这两个阶段分开处理，让一个线程（而且是内核级别的线程）来处理所有的等待，一旦有相应的IO事件发生就通知继续完成IO操作，虽然仍然有阻塞和等待，但是等待总是发生在一个线程，这时使用多线程可以保证其他线程一旦唤醒就是处理数据。</p>

<p><img src="/images/io/select_poll.jpg"></p>

<p>至于select、poll和epoll的区别，推荐这篇文章： <a href="http://www.cnblogs.com/Anker/p/3265058.html">http://www.cnblogs.com/Anker/p/3265058.html</a> 。简单来说：select,poll无脑的轮询，忽略了高并发下，轮询本身成了瓶颈，而epoll使用回调实现了轮询真正需要处理的连接。</p>

<h3>2.4 Signal Driven I/O</h3>

<p>应用线程调用recvfrom试图读取数据，并且直接返回，不管是否有数据可读，内核线程读完数据，给发信号通知应用线程，应用线程收到信息，等待内核线程将数据拷贝给应用线程。</p>

<p><img src="/images/io/sign.jpg"></p>

<h3>2.5 Asynchronous I/O</h3>

<p>这类函数的工作机制是告知内核启动某个操作，并让内核在整个操作（包括将数据从内核拷贝到用户空间）完成后通知我们。</p>

<p><img src="/images/io/aio.jpg"></p>

<p>注意，之前的几个模型的recvfrom都是在数据拷贝完成（即第二阶段完成）才返回，而异步IO是在第一阶段直接返回并继续往下执行，数据拷贝完成后系统内核再通知应用进程。</p>

<h3>2.6 总结</h3>

<p>前4种都是同步IO，只有最后一种是异步IO。他们第二阶段（拷贝数据阶段）是相同的，区别在于第一阶段，同步IO第二阶段是阻塞的，即一定会阻塞于等待数据拷贝完成，而异步IO是不阻塞于数据拷贝，数据拷贝完成，内核进程会通知应用进程。</p>

<p>这就是同步和异步的区别：异步在整个过程都没有阻塞，而同步至少有一个步骤被阻塞（等待内核IO或者等待内核将数据拷贝给应用）。</p>

<p>5种IO的比较：</p>

<p><img src="/images/io/compare.png"></p>

<h1>3.举例子</h1>

<p>为了理解上面的理论，举例子如下：</p>

<p>陪女朋友逛街，逛累了，向找个地方吃饭，于是取了一个山西面馆，但是发现面馆生意比较好人比较多，而且面条都是先做的。但是这段时间又想干点别的事，比如去附近的书店看看书。于是引发了一些列的思考：</p>

<h3>3.1 Blocking I/O</h3>

<p>我不指定做面条需要多久，不敢出去，只能在那里坐在等。等做完，等服务员上面并且我吃调再走。</p>

<p>这里我们是应用线程，面条相当于等待读的数据，厨师相当于内核线程，我们需要等待初始做面条，还需要等待等服务员上面，我才能吃到我的面。</p>

<h3>3.2 Nonblocking I/O</h3>

<p>我不甘心在这里无聊的等待，我想在这段时间逛逛书店，但是又怕面条做好了，所有我决定取书店看一会书就回面馆看一下我的面是不是好了。如果没好继续取书店看会书再回面馆看看。结果就是来回跑了很多次。</p>

<h3>3.3 I/O Multiplexing</h3>

<p>我饭量比较大，同时在几个餐馆都点了饭菜，我这样来回来回看的话累死了，善良的管理员（管理所有餐馆）在前台装了一个大屏幕，上面写着每个人每个菜的状态。因此我虽然点了很多份饭菜，但只需要看屏幕就可以了。屏幕高速我某一个菜号了，我就可以去吃。</p>

<h3>3.4 Signal Driven I/O</h3>

<p>管理员看老是很多人来前台看状态，烦死了，于是弄来个喊号的系统，即每次有饭菜做好了，就会喊点菜的人来吃。但是，这个喊号的系统只会喊一次，并且如果同时多个菜好了，需要一个一个喊，因此部分饭菜有延时。</p>

<h3>3.5 Asynchronous I/O</h3>

<p>随着行业竞争加大，管理员为了提高用户体验，每次饭菜好了，让各个餐馆的服务员亲自将饭菜送到顾客的手上。</p>

<h1>4.参考</h1>

<p><a href="http://www.yeolar.com/note/2012/12/15/high-performance-io-design-patterns/">http://www.yeolar.com/note/2012/12/15/high-performance-io-design-patterns/</a></p>

<p><a href="http://www.cnblogs.com/zhuYears/archive/2012/09/28/2690194.html">http://www.cnblogs.com/zhuYears/archive/2012/09/28/2690194.html</a></p>

<p><a href="http://yaocoder.blog.51cto.com/2668309/1308899">http://yaocoder.blog.51cto.com/2668309/1308899</a></p>

<p><a href="http://www.open-open.com/doc/view/cbb2c3363c3b49ceb5812220a9c42e42">http://www.open-open.com/doc/view/cbb2c3363c3b49ceb5812220a9c42e42</a></p>

<p><a href="http://www.ibm.com/developerworks/cn/linux/l-async/">http://www.ibm.com/developerworks/cn/linux/l-async/</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/12/31/githubbo-ke-jia-ping-lun/">Github博客加评论</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-12-31T01:43:36+08:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>31</span><span class='date-suffix'>st</span>, <span class='date-year'>2014</span></span> <span class='time'>1:43 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>想给自己的博客加评论很久了，一致没时间。今天抽了点时间，上午把google和百度检索的搞定了，下午抽时间把评论系统加上。</p>

<p>本文的评论是基于disqus实现的。</p>

<h1>1.Disqus介绍</h1>

<p>Disqus号称世界级的评论系统，对现在各种系统的支持都比较全面。</p>

<p>官方网站：<a href="https://disqus.com/">https://disqus.com/</a></p>

<h1>2.引用Disqus</h1>

<h3>2.1 注册</h3>

<p>在Disqus官网 <a href="https://disqus.com/">https://disqus.com/</a> 注册帐号</p>

<h3>2.2 Universal Code</h3>

<p><strong>(1).Add Disqus to your site，填写自己的网址，Disqus URL和Category等</strong></p>

<p><img src="/images/tools/disqus_add.png"></p>

<p><strong>(2).Choose your platform，生成Disqus Code</strong></p>

<p><img src="/images/tools/disqus_platform.png"></p>

<p>这里选择Universal Code，然后会生成一段代码：</p>

<p><img src="/images/tools/disqus_code.png"></p>

<p><strong>(3).引用Disqus Code</strong></p>

<p>将生成的代码嵌入到我们的博客系统中，以我的博客为例，找到source/_includes/post目录下的disqus_thread.html文件，将生成的代码放到这个文件中</p>

<p>在source/_layouts中模板页post.html中，引入disqus_thread.html文件：</p>

<p><img src="/images/tools/disqus_code_use.png"></p>

<p>其中的page.comments，在写每篇文章的时候进行设置，如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>layout: post
</span><span class='line'>title: "github博客加评论"
</span><span class='line'>date: 2014-12-30 17:43:36 +0000
</span><span class='line'>comments: true
</span><span class='line'>categories: Tools</span></code></pre></td></tr></table></div></figure>


<h3>3 效果</h3>

<p><img src="/images/tools/disqus_result.png"></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/12/30/tomcat-access-logpei-zhi/">Tomcat Access Log配置</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-12-30T18:39:56+08:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>30</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>6:39 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近在跟一个图片请求超时的问题，需要在项目的access log中增加请求的响应时间参数。正好学习一下tomcat access log中参数的配置。</p>

<p>我们假设将我的工程命名为project.com,即目录的文件名为project.com。</p>

<h1>1.配置的位置</h1>

<p>项目conf目录下的server.xml文件，其中的AccessLogValve这个Valve的配置，比如下面这个配置：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs" prefix="access." suffix=".log" 
</span><span class='line'>        pattern="%h %l %u %t &quot;%r&quot; %s %b &quot;%{Referer}i&quot; &quot;%{User-Agent}i&quot; %{X-Forwarded-For}i &quot;%Dms&quot;" resolveHosts="false"/&gt;</span></code></pre></td></tr></table></div></figure>


<h1>2.参数详解</h1>

<p>Tomcat AccessLogValve支持写列配置参数：</p>

<h3>2.1 className</h3>

<p>执行Access Log任务的类，默认是org.apache.catalina.valves.AccessLogValve;也可以使用org.apache.catalina.valves.FastCommonAccessLogValve，但这时候只支持common和combined patterns。</p>

<h3>2.2 directory</h3>

<p>AccessLogValve产生的Access Log文件存放目录的绝对路径或者相对路径。如果是相对路径，那么是相对$CATALINA_HOME的。如果没有指定这个参数，默认值是"logs"(相对$CATALINA_HOME)。</p>

<h3>2.3 pattern</h3>

<p>用于指定展示在Access Log中的各种request和response的信息字段的格式，也可以使用单词common或者combined来选择一种标准的日志形式。下一节会详细介绍。</p>

<p>注意优化的access只支持common和combined格式。</p>

<h3>2.4 prefix</h3>

<p>每个Access Log文件的文件名前缀，如果没有指定，默认是"access_log.&ldquo;，如果想没有前缀，则指定一个空的字符串(zero-length string)。</p>

<h3>2.5 resolveHosts</h3>

<p>如果设置为true，则会通过DNS lookup将远程主机的IP地址转换成对应的主机。设置成false则跳过这个DNS lookup过程，然后在日志中直接展示IP地址。</p>

<h3>2.6 suffix</h3>

<p>每个Access Log文件的文件名后缀，如果没有指定，默认值是“”，如果想没有后缀，则指定一个空的字符串(zero-length string)。</p>

<h3>2.7 rotatable</h3>

<p>默认为true。这个参数决定是否需要切换切换日志文件，如果被设置为false，则日志文件不会切换，即所有文件打到同一个日志文件中，并且fileDateFormat参数也会被忽略。小心使用这个参数。</p>

<h3>2.8 condition</h3>

<p>设置是否打开条件日志，如果设置了这个参数，requests只有当ServletRequest.getAttribute()为null的时候才会被记录日志。比如这个值被设置成junk，然后当一个特定请求的ServletRequest.getAttribute(&ldquo;junk&rdquo;) == null的时候，这个request会被记录。使用Filters很容易在ServletRequest中设置或者不设置这个属性。</p>

<h3>2.9 fileDateFormat</h3>

<p>Tomcat允许指定Access Log文件名中日期格式。日期格式同时也决定了如何切换日志文件的策略，比如如果你想每小时生成一个日志文件，设置这个值为yyyy-MM-dd.HH。</p>

<h1>3.pattern参数</h1>

<p>pattern属性有一系列的字符串参数组成，每个参数都有前缀"%&ldquo;，目前支持下面这些参数：</p>

<pre><code>%a - 远程IP地址
%A - 本地IP地址
%b - 发送的字节数(Bytes sent), 不包括HTTP headers的字节，如果为0则展示'-'
%B - 发送的字节数(Bytes sent), 不包括HTTP headers的字节
%h - 远程主机名称(如果resolveHosts为false则展示IP)
%H - 请求协议
%l - 远程用户名，始终为'-'(Remote logical username from identd)
%m - 请求的方法(GET, POST等)
%p - 接受请求的本地端口
%q - 查询字符串，如果存在，有一个前置的'?'
%r - 请求的第一行(包括请求方法和请求的URI)
%s - response的HTTP状态码(200,404等)
%S - 用户的session ID
%t - 日期和时间，Common Log Format格式
%u - 被认证的远程用户, 不存在则展示'-'
%U - 请求URL路径
%v - 本地服务名
%D - 处理请求的时间，单位为毫秒
%T - 处理请求的时间，单位为秒
%I - 当前请求的线程名(can compare later with stacktraces)
</code></pre>

<p>另外，Access Log中也支持cookie，请求header，响应headers，Session或者其他在ServletRequest中的对象的信息。格式遵循apache语法：</p>

<pre><code>%{xxx}i 请求headers的信息
%{xxx}o 响应headers的信息
%{xxx}c 请求cookie的信息
%{xxx}r xxx是ServletRequest的一个属性
%{xxx}s xxx是HttpSession的一个属性
</code></pre>

<p>common模式的pattern(即默认pattern参数)的格式为'%h %l %u %t &ldquo;%r&rdquo; %s %b'。</p>

<p>combined模式的pattern可以增加Referer和User-Agent headers的参数形式，每个参数用双引号包起来，引号中的内容还是上面列举的参数。比如&quot;%{User-Agent}i&quot;使其为”%{User-Agent}i“，即请求的User-Agent(客户端，浏览器)。</p>

<p>关于Common Log Format参考：<a href="http://baike.baidu.com/view/2948003.htm">http://baike.baidu.com/view/2948003.htm</a></p>

<h1>3.参考</h1>

<p><a href="http://tomcat.apache.org/tomcat-5.5-doc/config/valve.html">http://tomcat.apache.org/tomcat-5.5-doc/config/valve.html</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/12/30/ru-he-zi-ji-de-githubbo-ke-bei-googlejian-suo-dao/">如何自己的Github博客被google检索到</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-12-30T17:59:17+08:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>30</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>5:59 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>本文主要解决如何让自己搭建的github博客被google和百度检索到的问题。</p>

<h1>1.html标签验证</h1>

<p>我只实验了html标签验证的方法，因为这样侵入最小，特别是对github博客，不需要额外的创建html文件等。</p>

<p>google站长工具：<a href="https://www.google.com/webmasters/">https://www.google.com/webmasters/</a></p>

<p>百度站长工具：<a href="http://zhanzhang.baidu.com/">http://zhanzhang.baidu.com/</a></p>

<h3>1.1 google</h3>

<p><img src="/images/tools/google_webmasters.png"></p>

<p>按照其提示将这段html放在head里面就ok了，比如我的博客是放在_include/head.html里面。</p>

<p>google还包含一系列提升文章被检索到的方案，包括提交sitemap.xml等文件。</p>

<p><img src="/images/tools/google_improve.png"></p>

<h3>1.2 百度</h3>

<p><img src="/images/tools/baidu_zhanzhang.png"></p>

<p>和google一样，将这段html放在head里。</p>

<h1>2.参考</h1>

<p><a href="http://zyzhang.github.io/blog/2012/09/03/blog-with-github-pages-and-jekyll-seo/">http://zyzhang.github.io/blog/2012/09/03/blog-with-github-pages-and-jekyll-seo/</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/12/25/concurrenthashmap/">ConcurrentHashMap</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-12-25T03:47:49+08:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>25</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>3:47 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>ConcurrentHashMap基本策略是将hash表切分成多个段(Segments),每个Segment包含多个桶，每次加锁只在Segment级别加锁。</p>

<h1>1.结构模型</h1>

<p>ConcurrentHashMap 类中包含两个静态内部类 HashEntry 和 Segment。HashEntry 用来封装映射表的键 / 值对；Segment 用来充当锁的角色，每个 Segment 对象守护整个散列映射表的若干个桶。每个桶是由若干个 HashEntry 对象链接起来的链表。一个 ConcurrentHashMap 实例中包含由若干个 Segment 对象组成的数组。</p>

<h3>1.1 HashEntry 类</h3>

<p>HashEntry 用来封装散列映射表中的键值对，可以理解为一个桶。在 HashEntry 类中，key，hash 和 next 域都被声明为 final 型，value 域被声明为 volatile 型。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">final</span> <span class="n">K</span> <span class="n">key</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">final</span> <span class="kt">int</span> <span class="n">hash</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">volatile</span> <span class="n">V</span> <span class="n">value</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">final</span> <span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">HashEntry</span><span class="o">(</span><span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">hash</span> <span class="o">=</span> <span class="n">hash</span><span class="o">;</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&quot;unchecked&quot;</span><span class="o">)</span>
</span><span class='line'>    <span class="kd">static</span> <span class="kd">final</span> <span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="nf">newArray</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">new</span> <span class="n">HashEntry</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在 ConcurrentHashMap 中，在散列时如果产生“碰撞”，将采用“链地址法”来处理“碰撞”：把“碰撞”的 HashEntry 对象链接成一个链表。由于 HashEntry 的 next 域为 final 型，所以新节点只能在链表的表头处插入。下图是在一个空桶中依次插入 A，B，C 三个 HashEntry 对象后的结构图：</p>

<p><img src="/images/concurrent/concurentHashMap_Entry.jpg"></p>

<h3>1.1 Segment 类</h3>

<p>Segment 类继承于 ReentrantLock 类，从而使得 Segment 对象能充当锁的角色。每个 Segment 对象用来守护其（成员对象 table 中）包含的若干个桶。</p>

<p>table 是一个由 HashEntry 对象组成的数组。table 数组的每一个数组成员就是散列映射表的一个桶。
count 变量是一个计数器，它表示每个 Segment 对象管理的 table 数组（若干个 HashEntry 组成的链表）包含的 HashEntry 对象的个数。每一个 Segment 对象都有一个 count 对象来表示本 Segment 中包含的 HashEntry 对象的总数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">ReentrantLock</span> <span class="kd">implements</span> <span class="n">Serializable</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 管理的HashEntry对象的个数</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">transient</span> <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * table 被更新的次数</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">transient</span> <span class="kt">int</span> <span class="n">modCount</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 当 table 中包含的 HashEntry 元素的个数超过本变量值时，触发 table 的再散列</span>
</span><span class='line'><span class="cm">     * threshold总是等于capacity * loadFactor</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">transient</span> <span class="kt">int</span> <span class="n">threshold</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Segment管理的HashEntry</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">transient</span> <span class="kd">volatile</span> <span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">table</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">final</span> <span class="kt">float</span> <span class="n">loadFactor</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Segment</span><span class="o">(</span><span class="kt">int</span> <span class="n">initialCapacity</span><span class="o">,</span> <span class="kt">float</span> <span class="n">lf</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">loadFactor</span> <span class="o">=</span> <span class="n">lf</span><span class="o">;</span>
</span><span class='line'>        <span class="n">setTable</span><span class="o">(</span><span class="n">HashEntry</span><span class="o">.&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span><span class="n">newArray</span><span class="o">(</span><span class="n">initialCapacity</span><span class="o">));</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 设置 table 引用到这个新生成的 HashEntry 数组</span>
</span><span class='line'><span class="cm">     * 只能在持有锁或构造函数中调用本方法</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kt">void</span> <span class="nf">setTable</span><span class="o">(</span><span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">newTable</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">threshold</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="n">newTable</span><span class="o">.</span><span class="na">length</span> <span class="o">*</span> <span class="n">loadFactor</span><span class="o">);</span>
</span><span class='line'>        <span class="n">table</span> <span class="o">=</span> <span class="n">newTable</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 根据 key 的散列值，找到 table 中对应的那个桶（table 数组的某个数组成员）</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="nf">getFirst</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">tab</span><span class="o">[</span><span class="n">hash</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">tab</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)];</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>下图是依次插入 ABC 三个 HashEntry 节点后，Segment 的结构示意图：</p>

<p><img src="/images/concurrent/concurentHashMap_Segment.jpg"></p>

<h1>2.ConcurrentHashMap源码分析</h1>

<p>ConcurrentHashMap 在默认并发级别会创建包含 16 个 Segment 对象的数组。每个 Segment 的成员对象 table 包含若干个散列表的桶。每个桶是由 HashEntry 链接起来的一个链表。如果键能均匀散列，每个 Segment 大约守护整个散列表中桶总数的 1/16。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ConcurrentHashMap</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">AbstractMap</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span>
</span><span class='line'>        <span class="kd">implements</span> <span class="n">ConcurrentMap</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;,</span> <span class="n">Serializable</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 默认的hash表的容量</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">DEFAULT_INITIAL_CAPACITY</span> <span class="o">=</span> <span class="mi">16</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 默认加载因子</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">float</span> <span class="n">DEFAULT_LOAD_FACTOR</span> <span class="o">=</span> <span class="mf">0.75f</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 默认的并发级别，即Segment的数目</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">DEFAULT_CONCURRENCY_LEVEL</span> <span class="o">=</span> <span class="mi">16</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 最大容量</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MAXIMUM_CAPACITY</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 最大segments数量</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MAX_SEGMENTS</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="o">;</span> <span class="c1">// slightly conservative</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * </span>
</span><span class='line'><span class="cm">     Number of unsynchronized retries in size and containsValue</span>
</span><span class='line'><span class="cm">     * methods before resorting to locking. This is used to avoid</span>
</span><span class='line'><span class="cm">     * unbounded retries if tables undergo continuous modification</span>
</span><span class='line'><span class="cm">     * which would make it impossible to obtain an accurate result.</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">RETRIES_BEFORE_LOCK</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * segment掩码，用于找到处于哪个segments</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">final</span> <span class="kt">int</span> <span class="n">segmentMask</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Shift value for indexing within segments.</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">final</span> <span class="kt">int</span> <span class="n">segmentShift</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * segments， 每个segment是一个hash表</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">final</span> <span class="n">Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">segments</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">transient</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span> <span class="n">keySet</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">transient</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;&gt;</span> <span class="n">entrySet</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">transient</span> <span class="n">Collection</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">values</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">ConcurrentHashMap</span><span class="o">(</span><span class="kt">int</span> <span class="n">initialCapacity</span><span class="o">,</span>
</span><span class='line'>                             <span class="kt">float</span> <span class="n">loadFactor</span><span class="o">,</span> <span class="kt">int</span> <span class="n">concurrencyLevel</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(!(</span><span class="n">loadFactor</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">||</span> <span class="n">initialCapacity</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">concurrencyLevel</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">concurrencyLevel</span> <span class="o">&gt;</span> <span class="n">MAX_SEGMENTS</span><span class="o">)</span>
</span><span class='line'>            <span class="n">concurrencyLevel</span> <span class="o">=</span> <span class="n">MAX_SEGMENTS</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 找到最接近concurrencyLevel的2的幂，用来做最终的concurrencyLevel，比如传入的</span>
</span><span class='line'>        <span class="c1">//concurrencyLevel为10，则最终concurrencyLevel为16</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">sshift</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">ssize</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>        <span class="k">while</span> <span class="o">(</span><span class="n">ssize</span> <span class="o">&lt;</span> <span class="n">concurrencyLevel</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="o">++</span><span class="n">sshift</span><span class="o">;</span>
</span><span class='line'>            <span class="n">ssize</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">segmentShift</span> <span class="o">=</span> <span class="mi">32</span> <span class="o">-</span> <span class="n">sshift</span><span class="o">;</span>
</span><span class='line'>        <span class="n">segmentMask</span> <span class="o">=</span> <span class="n">ssize</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">segments</span> <span class="o">=</span> <span class="n">Segment</span><span class="o">.</span><span class="na">newArray</span><span class="o">(</span><span class="n">ssize</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">initialCapacity</span> <span class="o">&gt;</span> <span class="n">MAXIMUM_CAPACITY</span><span class="o">)</span>
</span><span class='line'>            <span class="n">initialCapacity</span> <span class="o">=</span> <span class="n">MAXIMUM_CAPACITY</span><span class="o">;</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">initialCapacity</span> <span class="o">/</span> <span class="n">ssize</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">ssize</span> <span class="o">&lt;</span> <span class="n">initialCapacity</span><span class="o">)</span>
</span><span class='line'>            <span class="o">++</span><span class="n">c</span><span class="o">;</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">cap</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>        <span class="k">while</span> <span class="o">(</span><span class="n">cap</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">)</span>
</span><span class='line'>            <span class="n">cap</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">.</span><span class="na">segments</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span>
</span><span class='line'>            <span class="k">this</span><span class="o">.</span><span class="na">segments</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;(</span><span class="n">cap</span><span class="o">,</span> <span class="n">loadFactor</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面是 ConcurrentHashMap 的结构示意图：</p>

<p><img src="/images/concurrent/concurentHashMap_Struct.jpg"></p>

<h3>2.1 高并发的put</h3>

<p>以 put 操作为例说明对 ConcurrentHashMap 做结构性修改的过程。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="n">V</span> <span class="nf">put</span><span class="o">(</span><span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>    <span class="c1">// 计算键对应的散列码</span>
</span><span class='line'>    <span class="c1">// 根据散列码找到对应的 Segment</span>
</span><span class='line'>    <span class="k">return</span> <span class="nf">segmentFor</span><span class="o">(</span><span class="n">hash</span><span class="o">).</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">hash</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>segmentFor代码：首先左移segmentShift位(比如segment总数为16, 则segmentShift为4)，高维填充0，再和segmentMask做掩码(比如segment总数为16,则掩码为2<sup>16</sup>-1)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">final</span> <span class="n">Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="nf">segmentFor</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">segments</span><span class="o">[(</span><span class="n">hash</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">segmentShift</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">segmentMask</span><span class="o">];</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>segment内的put逻辑：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">V</span> <span class="nf">put</span><span class="o">(</span><span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">onlyIfAbsent</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">lock</span><span class="o">();</span> <span class="c1">//加锁</span>
</span><span class='line'>    <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">count</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">c</span><span class="o">++</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="o">)</span> <span class="c1">// ensure capacity</span>
</span><span class='line'>            <span class="n">rehash</span><span class="o">();</span>
</span><span class='line'>        <span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">;</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">hash</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">tab</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>    <span class="c1">//找到桶</span>
</span><span class='line'>        <span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">first</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">index</span><span class="o">];</span>
</span><span class='line'>        <span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
</span><span class='line'>        <span class="c1">//遍历桶的链表，现有hash值比较，再用key比较</span>
</span><span class='line'>        <span class="k">while</span> <span class="o">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">!=</span> <span class="n">hash</span> <span class="o">||</span> <span class="o">!</span><span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)))</span>
</span><span class='line'>            <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">V</span> <span class="n">oldValue</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>    <span class="c1">//key在链表中找到，则执行更新</span>
</span><span class='line'>            <span class="n">oldValue</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(!</span><span class="n">onlyIfAbsent</span><span class="o">)</span>
</span><span class='line'>                <span class="n">e</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">else</span> <span class="o">{</span>  <span class="c1">//key在链表中找不到，新插入到表头</span>
</span><span class='line'>            <span class="n">oldValue</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>            <span class="o">++</span><span class="n">modCount</span><span class="o">;</span>
</span><span class='line'>            <span class="n">tab</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;(</span><span class="n">key</span><span class="o">,</span> <span class="n">hash</span><span class="o">,</span> <span class="n">first</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
</span><span class='line'>            <span class="n">count</span> <span class="o">=</span> <span class="n">c</span><span class="o">;</span> <span class="c1">// write-volatile</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">oldValue</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">unlock</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>从put的代码逻辑我们可以看出来，其他写线程对另外 15 个(假设全部为16个)Segment 的加锁并不会因为当前线程对这个 Segment 的加锁而阻塞。每次put锁住的只是对应的segment而不是整个表，即同时允许多个线程操作不同的segment，对整个HashMap而言，就是同时运行多个线程写这个HashMap。同时，所有读线程几乎不会因本线程的加锁而阻塞（除非读线程刚好读到这个 Segment 中某个 HashEntry 的 value 域的值为 null，此时需要加锁后重新读取该值）。</p>

<p>相比较于 HashTable 和由同步包装器包装的 HashMap每次只能有一个线程执行读或写操作，ConcurrentHashMap 在并发访问性能上有了质的提高。在理想状态下，ConcurrentHashMap 可以支持 16 个线程执行并发写操作（如果并发级别设置为 16），及任意数量线程的读操作。</p>

<h3>2.2 读操作对加锁的需求</h3>

<p>在ConcurrentHashMap中有两个策略来降低读操作对加锁的需求：</p>

<pre><code>(1).HashEntry 中的 key，hash，next 都声明为 final 型:
在代码清单HashEntry 类的定义中我们可以看到，HashEntry 中的 key，hash，next 都声明为 final 型。这意味着，不能把节点添加到链接的中间和尾部，也不能在链接的中间和尾部删除节点。这个特性可以保证：在访问某个节点时，这个节点之后的链接不会被改变。这个特性可以大大降低处理链表时的复杂性;
(2).HashEntry 类的 value 域被声明为 Volatile 型:
同时，HashEntry 类的 value 域被声明为 Volatile 型，Java 的内存模型可以保证：某个写线程对 value 域的写入马上可以被后续的某个读线程“看”到。在 ConcurrentHashMap 中，不允许用 null 作为键和值，当读线程读到某个 HashEntry 的 value 域的值为 null 时，便知道产生了冲突(发生了重排序现象)，需要加锁后重新读入这个 value 值。这些特性互相配合，使得读线程即使在不加锁状态下，也能正确访问 ConcurrentHashMap;

由于对 Volatile 变量的写入操作将与随后对这个变量的读操作进行同步。当一个写线程修改了某个 HashEntry 的 value 域后，另一个读线程读这个值域，Java 内存模型能够保证读线程读取的一定是更新后的值。所以，写线程对链表的非结构性修改能够被后续不加锁的读线程看到;
</code></pre>

<h3>2.3 结构性变更</h3>

<p>上面的2.2中的第(2)点能保证我们写线程对value的变更，能够被读线程看到。但是，如果对 ConcurrentHashMap 做结构性修改，怎么保证读线程尽可能少被阻塞?</p>

<p>对 ConcurrentHashMap 做结构性修改，实质上是对某个桶指向的链表做结构性修改。如果能够确保：在读线程遍历一个链表期间，写线程对这个链表所做的结构性修改不影响读线程继续正常遍历这个链表。那么读 / 写线程之间就可以安全并发访问这个 ConcurrentHashMap。</p>

<p>结构性修改操作包括 put，remove，clear。下面我们分别分析这三个操作。</p>

<p><strong>clear操作</strong></p>

<p>clear 操作只是把 ConcurrentHashMap 中所有的桶“置空”，每个桶之前引用的链表依然存在，只是桶不再引用到这些链表（所有链表的结构并没有被修改）。正在遍历某个链表的读线程依然可以正常执行对该链表的遍历。</p>

<p><strong>put操作</strong></p>

<p>从上面的代码清单“在 Segment 中执行具体的 put 操作”中，我们可以看出：put 操作如果需要插入一个新节点到链表中时 , 会在链表头部插入这个新节点。此时，链表中的原有节点的链接并没有被修改。也就是说：插入新健 / 值对到链表中的操作不会影响读线程正常遍历这个链表。</p>

<p><strong>remove操作</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="n">V</span> <span class="nf">remove</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>
</span><span class='line'>    <span class="k">return</span> <span class="nf">segmentFor</span><span class="o">(</span><span class="n">hash</span><span class="o">).</span><span class="na">remove</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">hash</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">V</span> <span class="nf">remove</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">Object</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">lock</span><span class="o">();</span>
</span><span class='line'>    <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>        <span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">;</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">hash</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">tab</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
</span><span class='line'>        <span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">first</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">index</span><span class="o">];</span>
</span><span class='line'>        <span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
</span><span class='line'>        <span class="k">while</span> <span class="o">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">!=</span> <span class="n">hash</span> <span class="o">||</span> <span class="o">!</span><span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)))</span>
</span><span class='line'>            <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">V</span> <span class="n">oldValue</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>    <span class="c1">//找到了节点</span>
</span><span class='line'>            <span class="n">V</span> <span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">value</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">oldValue</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
</span><span class='line'>                <span class="o">++</span><span class="n">modCount</span><span class="o">;</span>
</span><span class='line'>                <span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">newFirst</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>   <span class="c1">//待删除节点的next</span>
</span><span class='line'>                <span class="k">for</span> <span class="o">(</span><span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">e</span><span class="o">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">)</span>
</span><span class='line'>                    <span class="n">newFirst</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;(</span><span class="n">p</span><span class="o">.</span><span class="na">key</span><span class="o">,</span> <span class="n">p</span><span class="o">.</span><span class="na">hash</span><span class="o">,</span>
</span><span class='line'>                                                  <span class="n">newFirst</span><span class="o">,</span> <span class="n">p</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>
</span><span class='line'>                <span class="n">tab</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">newFirst</span><span class="o">;</span>
</span><span class='line'>                <span class="n">count</span> <span class="o">=</span> <span class="n">c</span><span class="o">;</span> <span class="c1">// write-volatile</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">oldValue</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">unlock</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>和 get 操作一样，首先根据散列码找到具体的链表；然后遍历这个链表找到要删除的节点；最后把待删除节点之后的所有节点原样保留在新链表中，把待删除节点之前的每个节点克隆到新链表中。下面通过图例来说明 remove 操作。假设写线程执行 remove 操作，要删除链表的 C 节点，另一个读线程同时正在遍历这个链表：</p>

<p><img src="/images/concurrent/concurentHashMap_remove1.jpg"></p>

<p><img src="/images/concurrent/concurentHashMap_remove2.jpg"></p>

<p>从上图可以看出，删除节点 C 之后的所有节点原样保留到新链表中；删除节点 C 之前的每个节点被克隆到新链表中，注意：它们在新链表中的链接顺序被反转了。</p>

<p>在执行 remove 操作时，原始链表并没有被修改，也就是说：读线程不会受同时执行 remove 操作的并发写线程的干扰。</p>

<p>综合上面的分析我们可以看出，写线程对某个链表的结构性修改不会影响其他的并发读线程对这个链表的遍历访问。</p>

<h3>2.4 读操作</h3>

<p>首先找到对应的segment，再在segment内找对应的数据,当读到的数据为null的时候，加锁再重新读(因为 ConcurrentHashMap不允许value为null，因此正常情况下不会出现null)：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="n">V</span> <span class="nf">get</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>
</span><span class='line'>    <span class="k">return</span> <span class="nf">segmentFor</span><span class="o">(</span><span class="n">hash</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">hash</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">V</span> <span class="nf">get</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hash</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 读volatile变量值</span>
</span><span class='line'>        <span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">getFirst</span><span class="o">(</span><span class="n">hash</span><span class="o">);</span>
</span><span class='line'>        <span class="k">while</span> <span class="o">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">V</span> <span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
</span><span class='line'>                <span class="k">if</span> <span class="o">(</span><span class="n">v</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
</span><span class='line'>                    <span class="k">return</span> <span class="n">v</span><span class="o">;</span>
</span><span class='line'>                <span class="c1">//v == null，说明发生了重排序，需要加锁后重新读取</span>
</span><span class='line'>                <span class="k">return</span> <span class="nf">readValueUnderLock</span><span class="o">(</span><span class="n">e</span><span class="o">);</span> <span class="c1">// recheck</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>            <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//加锁读</span>
</span><span class='line'><span class="n">V</span> <span class="nf">readValueUnderLock</span><span class="o">(</span><span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">lock</span><span class="o">();</span>
</span><span class='line'>    <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">unlock</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在 ConcurrentHashMap 中，所有执行写操作的方法（put, remove, clear），在对链表做结构性修改之后，在退出写方法前都会去写这个 count 变量。所有未加锁的读操作（get, contains, containsKey）在读方法中，都会首先去读取这个 count 变量。</p>

<p>根据 Java 内存模型，对 同一个 volatile 变量的写 / 读操作可以确保：写线程写入的值，能够被之后未加锁的读线程“看到”。</p>

<p>这个特性和前面介绍的 HashEntry 对象的不变性相结合，使得在 ConcurrentHashMap 中，读线程在读取散列表时，基本不需要加锁就能成功获得需要的值。这两个特性相配合，不仅减少了请求同一个锁的频率（读操作一般不需要加锁就能够成功获得值），也减少了持有同一个锁的时间（只有读到 value 域的值为 null 时 , 读线程才需要加锁后重读）。</p>

<h1>3.总结</h1>

<p>ConcurrentHashMap 是一个并发散列映射表的实现，它允许完全并发的读取，并且支持给定数量的并发更新。相比于 HashTable 和用同步包装器包装的 HashMap（Collections.synchronizedMap(new HashMap())），ConcurrentHashMap 拥有更高的并发性。在 HashTable 和由同步包装器包装的 HashMap 中，使用一个全局的锁来同步不同线程间的并发访问。同一时间点，只能有一个线程持有锁，也就是说在同一时间点，只能有一个线程能访问容器。这虽然保证多线程间的安全并发访问，但同时也导致对容器的访问变成串行化的了。</p>

<p>ConcurrentHashMap 的高并发性主要来自于三个方面：</p>

<pre><code>(1).用分离锁(Segment锁)实现多个线程间的更深层次的共享访问;
(2).用 HashEntery 对象的不变性来降低执行读操作的线程在遍历链表期间对加锁的需求;
(3).通过对同一个 Volatile 变量的写 / 读访问，协调不同线程间读 / 写操作的内存可见性;
</code></pre>

<h1>参考</h1>

<p><a href="http://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/#icomments">http://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/#icomments</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/12/25/concurrentlinkedqueue/">ConcurrentLinkedQueue</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-12-25T03:44:39+08:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>25</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>3:44 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>如果我们要实现一个线程安全的队列有两种实现方式：一种是使用阻塞算法，另一种是使用非阻塞算法。使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁，比如ArryBlockingQueue）或两个锁（入队和出队用不同的锁，比如LinkedBlockingDeque）等方式来实现，而非阻塞的实现方式则可以使用循环CAS的方式来实现。</p>

<h1>1非阻塞算法</h1>

<h3>1.1 Java的多线程同步机制</h3>

<p>在现代的多处理器系统中，提高程序的并行执行能力是有效利用 CPU 资源的关键。为了有效协调多线程间的并发访问，必须采用适当的同步机制来协调竞争。当前常用的多线程同步机制可以分为下面三种类型：</p>

<pre><code>(1).volatile 变量：轻量级多线程同步机制，不会引起上下文切换和线程调度。仅提供内存可见性保证，不提供原子性。
(2).CAS 原子指令：轻量级多线程同步机制，不会引起上下文切换和线程调度。它同时提供内存可见性和原子化更新保证。
(3).内部锁和显式锁：重量级多线程同步机制，可能会引起上下文切换和线程调度，它同时提供内存可见性和原子性。
</code></pre>

<p>从 Amdahl 定律我们可以知道，要想提高并发性，就应该尽量使串行部分达到最大程度的并行；也就是说：最小化串行代码的粒度是提高并发性能的关键。</p>

<p>与锁相比，非阻塞算法在更细粒度（机器级别的原子指令）的层面协调多线程间的竞争。它使得多个线程在竞争相同资源时不会发生阻塞，它的并发性与锁相比有了质的提高；同时也大大减少了线程调度的开销。同时，由于几乎所有的同步原语都只能对单个变量进行操作，这个限制导致非阻塞算法的设计和实现非常复杂。</p>

<h3>1.2 ConcurrentLinkedQueue非阻塞算法实现</h3>

<p>ConcurrentLinkedQueue的非阻塞算法实现可概括为下面5点：</p>

<pre><code>(1).使用CAS原子指令来处理对数据的并发访问，这是非阻塞算法得以实现的基础;
(2).head/tail并非总是指向队列的头/尾节点，也就是说允许队列处于不一致状态;这个特性把入队/出队时，原本需要一起原子化执行的两个步骤分离开来，从而缩小了入队/出队时需要原子化更新值的范围到唯一变量,这是非阻塞算法得以实现的关键;
(3).由于队列有时会处于不一致状态。为此，ConcurrentLinkedQueue使用三个不变式来维护非阻塞算法的正确性;
(4).以批处理方式来更新head/tail，从整体上减少入队/出队操作的开销;
(5).为了有利于垃圾收集，队列使用特有的head更新机制；为了确保从已删除节点向后遍历，可到达所有的非删除节点，队列使用了特有的向后推进策略;
</code></pre>

<p>在后面的源代码分析中，我们将会看到队列有时会处于不一致状态。为此，ConcurrentLinkedQueue 使用三个不变式(基本不变式，head 的不变式和tail的不变式)，来约束队列中方法的执行。通过这三个不变式来维护非阻塞算法的正确性：</p>

<pre><code>(1).基本不变式
在执行方法之前和之后，队列必须要保持的不变式：
    当入队插入新节点之后，队列中有一个 next域为null的（最后）节点;
    从head开始遍历队列，可以访问所有item域不为null的节点;
(2).head的不变式和可变式
在执行方法之前和之后，head必须保持的不变式：
    所有“活着”的节点（指未删除节点），都能从head通过调用succ()方法遍历可达;
    head不能为null;
    head节点的next域不能引用到自身;
在执行方法之前和之后，head的可变式：
    head节点的item域可能为null，也可能不为null;
    允许tail滞后于head，也就是说从head开始遍历队列，不一定能到达tail;
(3).tail的不变式和可变式
在执行方法之前和之后，tail必须保持的不变式：
    通过tail调用succ()方法，最后节点总是可达的;
    tail不能为null;
在执行方法之前和之后，tail的可变式：
    tail节点的item域可能为null，也可能不为null;
    允许tail滞后于head，也就是说从head开始遍历队列，不一定能到达tail;
    tail节点的next域可以引用到自身;
</code></pre>

<h1>2 ConcurrentLinkedQueue源码</h1>

<p>ConcurrentLinkedQueue就是一个使用非阻塞算法实现的一个基于链接节点的无界线程安全队列，按照 FIFO（先进先出）原则对元素进行排序。队列元素中不可以放置null元素。</p>

<p>ConcurrentLinkedQueue的链表Node中的next的类型是volatile，而且链表数据item的类型也是volatile。关于volatile，我们知道它的语义包含：“即对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入”。ConcurrentLinkedQueue就是通过volatile来实现多线程对竞争资源的互斥访问的。</p>

<p>ConcurrentLinkedQueue由head节点和tair节点组成，每个节点（Node）由节点元素（item）和指向下一个节点的引用(next)组成，节点与节点之间就是通过这个next关联起来，从而组成一张链表结构的队列。默认情况下head节点存储的元素为空，tail节点等于head节点。</p>

<h3>2.1 声明</h3>

<p>从类名上我们就可以看得出来，Concurrent保证了并发中的线程安全，Linked提示是链表实现，Queue则说明是一个队列。声明如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ConcurrentLinkedQueue</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">AbstractQueue</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span>
</span><span class='line'>        <span class="kd">implements</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;,</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">Serializable</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">//链表头尾指针</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">transient</span> <span class="kd">volatile</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;(</span><span class="kc">null</span><span class="o">);</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">transient</span> <span class="kd">volatile</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
</span><span class='line'>    <span class="c1">//用于Unsafe实现对head和tail的更新</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">headOffset</span> <span class="o">=</span>
</span><span class='line'>        <span class="n">objectFieldOffset</span><span class="o">(</span><span class="n">UNSAFE</span><span class="o">,</span> <span class="s">&quot;head&quot;</span><span class="o">,</span> <span class="n">ConcurrentLinkedQueue</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">tailOffset</span> <span class="o">=</span>
</span><span class='line'>        <span class="n">objectFieldOffset</span><span class="o">(</span><span class="n">UNSAFE</span><span class="o">,</span> <span class="s">&quot;tail&quot;</span><span class="o">,</span> <span class="n">ConcurrentLinkedQueue</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>2.2 Node</h3>

<p>其中的Node为单链表节点，但是提供了Unsafe提供的CAS操作：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">volatile</span> <span class="n">E</span> <span class="n">item</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">volatile</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Node</span><span class="o">(</span><span class="n">E</span> <span class="n">item</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">// Piggyback on imminent casNext()</span>
</span><span class='line'>        <span class="n">lazySetItem</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>
</span><span class='line'>     <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">E</span> <span class="nf">getItem</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">item</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="c1">//如果当前节点item等于cmp，则将其设置为val</span>
</span><span class='line'>    <span class="kt">boolean</span> <span class="nf">casItem</span><span class="o">(</span><span class="n">E</span> <span class="n">cmp</span><span class="o">,</span> <span class="n">E</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapObject</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">itemOffset</span><span class="o">,</span> <span class="n">cmp</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">void</span> <span class="nf">setItem</span><span class="o">(</span><span class="n">E</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>         <span class="n">item</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">void</span> <span class="nf">lazySetItem</span><span class="o">(</span><span class="n">E</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">UNSAFE</span><span class="o">.</span><span class="na">putOrderedObject</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">itemOffset</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">void</span> <span class="nf">lazySetNext</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">UNSAFE</span><span class="o">.</span><span class="na">putOrderedObject</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">nextOffset</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="nf">getNext</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">next</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">boolean</span> <span class="nf">casNext</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">cmp</span><span class="o">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapObject</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">nextOffset</span><span class="o">,</span> <span class="n">cmp</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Unsafe mechanics</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">sun</span><span class="o">.</span><span class="na">misc</span><span class="o">.</span><span class="na">Unsafe</span> <span class="n">UNSAFE</span> <span class="o">=</span> <span class="n">sun</span><span class="o">.</span><span class="na">misc</span><span class="o">.</span><span class="na">Unsafe</span><span class="o">.</span><span class="na">getUnsafe</span><span class="o">();</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">nextOffset</span> <span class="o">=</span> <span class="n">objectFieldOffset</span><span class="o">(</span><span class="n">UNSAFE</span><span class="o">,</span> <span class="s">&quot;next&quot;</span><span class="o">,</span> <span class="n">Node</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>   <span class="c1">//next域的偏移量</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">itemOffset</span> <span class="o">=</span> <span class="n">objectFieldOffset</span><span class="o">(</span><span class="n">UNSAFE</span><span class="o">,</span> <span class="s">&quot;item&quot;</span><span class="o">,</span> <span class="n">Node</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>   <span class="c1">//item域的偏移量</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中UNSAFE.putOrderedObject的语义是：它能够实现非堵塞的写入，这些写入不会被Java的JIT重新排序指令(instruction reordering)，这种性能提升是有代价的，虽然便宜，也就是写后结果并不会被其他线程看到(即写操作不提供可见性)，甚至是自己的线程，通常是几纳秒后被其他线程看到，这个时间比较短，所以代价可以忍受。这个方法在对低延迟代码是很有用的。</p>

<p>类似Unsafe.putOrderedObject还有unsafe.putOrderedLong等方法，unsafe.putOrderedLong比使用 volatile long要快3倍左右。</p>

<p>如果需要具备可见性，则需要指定字段为volatile，而我们这里item正是声明为volatile。</p>

<h3>2.3 入队列</h3>

<p>入队列就是将入队节点添加到队列的尾部。入队主要做两件事情:</p>

<pre><code>(1)将入队节点设置成当前队列尾节点的下一个节点;
(2)更新tail节点，如果tail节点的next节点不为空，则将入队节点设置成tail节点，如果tail节点的next节点为空，则将入队节点设置成tail的next节点，所以tail节点不总是尾节点，理解这一点对于我们研究源码会非常有帮助;
</code></pre>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nf">offer</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">offer</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>    <span class="c1">//不支持元素为null</span>
</span><span class='line'>    <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">n</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;(</span><span class="n">e</span><span class="o">);</span>
</span><span class='line'>    <span class="nl">retry:</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span>
</span><span class='line'>        <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">hops</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">;</span> <span class="n">hops</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">succ</span><span class="o">(</span><span class="n">p</span><span class="o">);</span> <span class="c1">//p的后继节点</span>
</span><span class='line'>            <span class="c1">//next!=null，即p节点的后继不为null，指p没有指向最后一个节点</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="k">if</span> <span class="o">(</span><span class="n">hops</span> <span class="o">&gt;</span> <span class="n">HOPS</span> <span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">tail</span><span class="o">)</span>   <span class="c1">//tail发生了变化</span>
</span><span class='line'>                    <span class="k">continue</span> <span class="n">retry</span><span class="o">;</span>
</span><span class='line'>                <span class="n">p</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
</span><span class='line'>            <span class="o">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">casNext</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="n">n</span><span class="o">))</span> <span class="o">{</span>    <span class="c1">//p是尾节点，则将其next设置为新结点n</span>
</span><span class='line'>                <span class="k">if</span> <span class="o">(</span><span class="n">hops</span> <span class="o">&gt;=</span> <span class="n">HOPS</span><span class="o">)</span>
</span><span class='line'>                    <span class="n">casTail</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span> <span class="c1">//更新tail，允许失败</span>
</span><span class='line'>                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">p</span> <span class="o">=</span> <span class="n">succ</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>succ函数表示后继节点，由于 tail 可以指向任意节点，所以从 tail 向后遍历寻找尾节点的过程中，可能会遇到哨兵节点。此时 succ() 方法会直接跳转到 head 指向的节点继续遍历。下面是 succ() 方法的源代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">final</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="nf">succ</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getNext</span><span class="o">();</span>
</span><span class='line'>    <span class="c1">//如果 p 节点的 next 域链接到自身（p 节点是哨兵节点），就跳转到 head，从 </span>
</span><span class='line'>    <span class="c1">//head开始继续遍历，否则向后推进到下一个节点</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">next</span><span class="o">)</span> <span class="o">?</span> <span class="n">head</span> <span class="o">:</span> <span class="n">next</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>从上面的源代码我们可以看出，如果向后推进过程中遇到哨兵节点，就跳转到 head，从 head 开始继续遍历；否则，就推进到下一个节点。</p>

<p><img src="/images/concurrent/concurrentLinkedQueue_succ.jpg"></p>

<p>上图的队列当前处于 tail 滞后于 head 状态。假设现在执行入队操作，需要从 tail 开始向后遍历找到队列的尾节点。tail 开始时指向 A 节点，执行 succ() 方法向后推进到 B 节点。在 B 节点执行 succ() 方法时，由于 B 节点链接到自身，所以跳转到 head 指向的 E 节点继续遍历。</p>

<p>第二步设置入队节点为尾节点。p.casNext(null, n)方法用于将入队节点设置为当前队列尾节点的next节点，p如果是null表示p是当前队列的尾节点，如果不为null表示有其他线程更新了尾节点，则需要重新获取当前队列的尾节点。</p>

<p>队列的入队方法包含两个步骤：添加新节点和更新 tail 指向这个新节点。从代码中我们可以看到，这两个步骤都是用 CAS 原子指令来完成的。由于 ConcurrentLinkedQueue 允许队列处于不一致状态，所以这两个步骤不必一起原子的执行。添加新节点后，只有当 tail 与新添加节点之间的距离达到了 HOPS 指定的阀值，才会执行更新 tail。</p>

<h4>2.3.1 tail 在队列中的位置分析</h4>

<p>在执行入队操作前，tail 在队列中的位置共有三种可能：</p>

<pre><code>(1).tail 指向尾节点
(2).tail 节点指向非尾节点
(3).tail 滞后于 head
</code></pre>

<p><strong>tail 指向尾节点</strong></p>

<p><img src="/images/concurrent/concurrentLinkedQueue_tail_1.jpg"></p>

<p>开始时，tail 指向 D 节点，首先寻找 D 节点的后继节点。由于 D 的后继节点为 null，所以插入新节点到 D 节点的后面。如果插入成功就退出方法；如果插入失败（说明其他线程刚刚插入了一个新节点），就向后推进到新插入的节点，然后重新开始迭代。下图是插入成功后的示意图：</p>

<p><img src="/images/concurrent/concurrentLinkedQueue_tail_1_1.jpg"></p>

<p>在上图中，由于 tail 滞后于尾节点的节点数还没有达到 HOPS 指定的阈值，所以 tail 没有被更新。</p>

<p><strong>tail 节点指向非尾节点</strong></p>

<p><img src="/images/concurrent/concurrentLinkedQueue_tail_2.jpg"></p>

<p>开始时，tail 指向 C 节点。首先找到 C 的后继节点 D，然后向后推进到节点 D，后面代码执行路径与上面的“tail 指向尾节点 ”的代码执行路径相同。下图是插入成功后的结构示意图：</p>

<p><img src="/images/concurrent/concurrentLinkedQueue_tail_2_1.jpg"></p>

<p>上图中的 tail 更新了位置。因为在添加 E 节点后，tail 滞后的节点数达到了 HOPS 指定的阈值。这触发执行更新 tail 的 CAS 操作。</p>

<p><strong>tail 滞后于 head</strong></p>

<p><img src="/images/concurrent/concurrentLinkedQueue_tail_3.jpg"></p>

<p>开始时，tail 指向 A 节点。首先找到 A 的后继节点 B，然后向后推进到节点 B。由于 B 是哨兵节点，产生跳转动作，跳过 C 节点，从 head 指向的 D 节点开始继续向后遍历。后面的代码执行路径与“tail 指向非尾节点”相同。下面是成功插入一个新节点后的结构示意图：</p>

<p><img src="/images/concurrent/concurrentLinkedQueue_tail_3_1.jpg"></p>

<p>上图的 tail 更新了位置，因为 tail 滞后的节点数达到了 HOPS 指定的阈值，这触发执行更新 tail 的 CAS 操作。</p>

<h4>2.3.2 hops的设计意图</h4>

<p>为了尽量减少执行 CAS 原子指令的次数，执行入队 / 出队操作时 , ConcurrentLinkedQueue 并不总是更新 head/tail。只有从 head/tail 到头 / 尾节点之间的“距离”达到变量 HOPS 指定的阀值，入队 / 出队操作才会更新它们。</p>

<pre><code>// 更新 head/tail 的阀值
private static final int HOPS = 1;
</code></pre>

<p>不使用hops，下面的代码逻辑可能更清晰：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">offer</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
</span><span class='line'>    <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">n</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;(</span><span class="n">e</span><span class="o">);</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">casNext</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">casTail</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">n</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>让tail节点永远作为队列的尾节点，这样实现代码量非常少，而且逻辑非常清楚和易懂。</p>

<p>但是这么做有个缺点就是每次都需要使用循环CAS更新tail节点。如果能减少CAS更新tail节点的次数，就能提高入队的效率，所以JDK实现中使用hops变量来控制并减少tail节点的更新频率，并不是每次节点入队后都将tail节点更新成尾节点，而是当tail节点和尾节点的距离大于等于常量HOPS的值（默认等于1）时才更新tail节点，tail和尾节点的距离越长使用CAS更新tail节点的次数就会越少，但是距离越长带来的负面效果就是每次入队时定位尾节点的时间就越长，因为循环体需要多循环一次来定位出尾节点，但是这样仍然能提高入队的效率，因为从本质上来看它通过增加对volatile变量的读操作来减少了对volatile变量的写操作，而对volatile变量的CAS操作开销要远远大于读操作，所以入队效率会有所提升。因为 CAS 原子指令的执行包含了内存屏障（Memory barriers），防止乱序执行以及对各种编译器优化的抑制。</p>

<p>还有一点需要注意的是入队方法永远返回true，所以不要通过返回值判断入队是否成功。</p>

<h3>2.4 出队列</h3>

<p>出队列的就是从队列里返回一个节点元素，并清空该节点对元素的引用。</p>

<p>并不是每次出队时都更新head节点，当head节点里有元素时，直接弹出head节点里的元素，而不会更新head节点。只有当head节点里没有元素时，出队操作才会更新head节点。这种做法也是通过hops变量来减少使用CAS更新head节点的消耗，从而提高出队效率。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="n">E</span> <span class="nf">poll</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">h</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
</span><span class='line'>    <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">h</span><span class="o">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">hops</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">;</span> <span class="n">hops</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">E</span> <span class="n">item</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getItem</span><span class="o">();</span>   <span class="c1">//p执行head节点</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">item</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">.</span><span class="na">casItem</span><span class="o">(</span><span class="n">item</span><span class="o">,</span> <span class="kc">null</span><span class="o">))</span> <span class="o">{</span>    <span class="c1">//将head内容置为null</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">hops</span> <span class="o">&gt;=</span> <span class="n">HOPS</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getNext</span><span class="o">();</span>
</span><span class='line'>                <span class="n">updateHead</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="o">(</span><span class="n">q</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">q</span> <span class="o">:</span> <span class="n">p</span><span class="o">);</span><span class="c1">//将p节点下一个节点设置成head节点</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">item</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="c1">//如果头节点的元素为空或头节点发生了变化，这说明头节点已经被另外一个线程修改了，那么获取p节点的下一个节点</span>
</span><span class='line'>        <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">succ</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
</span><span class='line'>        <span class="c1">//如果p的下一个节点也为空，说明这个队列已经空了</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">updateHead</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">p</span><span class="o">);</span>
</span><span class='line'>            <span class="k">break</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="c1">//如果下一个元素不为空，则将头节点的下一个节点设置成头节点</span>
</span><span class='line'>        <span class="n">p</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>队列的出队方法包含两个步骤：删除头节点和更新 head 指向新头节点。这里对头节点的删除使用了一个小技巧：设置头节点的 item 域为 null，即删除了它（虽然这个节点还在队列中，但它以是无效节点）。在代码中我们可以看到，这两个步骤都使用 CAS 原子指令来完成。由于 ConcurrentLinkedQueue 允许队列处于不一致状态，所以这两个步骤不必一起原子的执行。在删除头节点后，只有当 head 与新头节点之间的距离达到了 HOPS 指定的阀值，才会执行更新 head。</p>

<h4>2.4.1 head在队列中的位置分析</h4>

<p>在执行出队操作前，head 在队列中的位置共有两种可能：</p>

<pre><code>(1).head 指向有效节点。
(2).head 指向无效节点。
</code></pre>

<p><strong>head 指向有效节点</strong></p>

<p><img src="/images/concurrent/concurrentLinkedQueue_head_1.jpg"></p>

<p>出队时，首先取得 head 指向的 A 节点的 item 域的值，然后通过 CAS 设置 A 节点 item 域的值为 null。如果成功，由于此时越过的节点数为 0，所以直接返回 A 节点 item 域原有的值。如果不成功，说明其他线程已经抢先删除了该节点，此时向后推进到 B 节点。重复这个过程，直到成功删除一个节点；如果遍历完队列也没有删除成功，则返回 null。下面是成功删除后的结构示意图：</p>

<p><img src="/images/concurrent/concurrentLinkedQueue_head_1_1.jpg"></p>

<p>在上图中，虽然 A 节点被设置成无效节点，但 head 依然指向它，因为删除操作越过的节点数还没有达到 HOPS 指定的阀值。</p>

<p><strong>head 指向无效节点</strong></p>

<p><img src="/images/concurrent/concurrentLinkedQueue_head_2.jpg"></p>

<p>首先获得 head 指向节点的 item 域的值，由于为 null，所以向后推进到 B 节点。获得 B 节点 item 域的值后，通过 CAS 设置该值为 null。如果成功，由于已经达到 HOPS 指定的阀值，触发执行 head 更新。如果不成功（说明其他线程已经抢先删除了 B 节点），继续向后推进到 C 节点。重复这个过程，直到删除一个有效节点。如果遍历完队列也没有删除成功，则返回 null。下图是成功删除后的结构示意图：</p>

<p><img src="/images/concurrent/concurrentLinkedQueue_head_3_1.jpg"></p>

<p>从上图我们可以看到，在执行删除操作过程中，head 越过的节点数达到阀值，触发执行 head 的更新，使它指向 C 节点。</p>

<h4>2.4.2 更新 head</h4>

<p>为了有利于垃圾收集，ConcurrentLinkedQueue 在更新 head 指向新头结点后，会把旧头节点设置为哨兵节点(链接到自身的节点,同时也是以删除节点)。下面是更新 head 的源代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">final</span> <span class="kt">void</span> <span class="nf">updateHead</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">h</span><span class="o">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">// 如果两个节点不相同，尝试用 CAS 指令原子更新 head 指向新头节点</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">h</span> <span class="o">!=</span> <span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">casHead</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">p</span><span class="o">))</span>
</span><span class='line'>    <span class="c1">// 惰性设置旧头结点为哨兵节点</span>
</span><span class='line'>    <span class="n">h</span><span class="o">.</span><span class="na">lazySetNext</span> <span class="o">(</span><span class="n">h</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面通过一个示意图来理解已删除节点在队列中的状态：</p>

<p><img src="/images/concurrent/concurrentLinkedQueue_update_head.jpg"></p>

<p>在上图中，假设开始时 head 指向 A 节点，然后连续执行了 4 次出队操作，删除 A，B，C，D 4 个节点。在出队 B 节点时，head 与头结点之间的距离达到变量 HOPS 指定的阀值。这触发执行 updateHead（）方法：首先设置 head 指向 C 节点，然后设置 B 节点的 next 域指向自身。同样，在出队 D 节点时，重复同样的过程。由于 B 和 D 节点断开了以删除节点与队列的链接，这将有利于虚拟机回收这些以删除节点占用的内存空间。</p>

<h3>2.4 注意点</h3>

<p>ConcurrentLinkedQueue的size()会遍历整个队列，因此时间复杂度为O(n).</p>

<h1>3.参考</h1>

<p><a href="http://blog.csdn.net/tomato__/article/details/24179019">http://blog.csdn.net/tomato__/article/details/24179019</a></p>

<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-concurrent/">https://www.ibm.com/developerworks/cn/java/j-lo-concurrent/</a></p>

<p><a href="http://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf">http://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf</a></p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/6">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/4">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <div class="panel-heading">
    <h1 class="panel-title">最新文章</h3>
  </div>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/08/22/mybatiskong-wherelan-jie-qi/">MyBatis空where拦截器</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/12/mysql-packettoobigexception/">Mysql PacketTooBigException</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/08/oomkiller/">Oomkiller</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/03/fan-she-de-xiao-lu/">反射的效率</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/01/mycli/">Mycli</a>
      </li>
    
  </ul>
</section>
<section class="panel panel-default">
  <div  class="panel-heading">
    <h1 class="panel-title">文章分类</h1>
  </div>
  <div id="categories_list_div" class="list-group">
    <li><a class='list-group-item' href='/blog/categories/algorithm/'>algorithm (4)</a></li>
<li><a class='list-group-item' href='/blog/categories/dubbo/'>dubbo (2)</a></li>
<li><a class='list-group-item' href='/blog/categories/guava/'>guava (2)</a></li>
<li><a class='list-group-item' href='/blog/categories/java/'>java (22)</a></li>
<li><a class='list-group-item' href='/blog/categories/linux/'>linux (12)</a></li>
<li><a class='list-group-item' href='/blog/categories/maven/'>maven (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/memcached/'>memcached (4)</a></li>
<li><a class='list-group-item' href='/blog/categories/mybatis/'>mybatis (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/mysql/'>mysql (10)</a></li>
<li><a class='list-group-item' href='/blog/categories/octopress/'>octopress (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/postgresql/'>postgresql (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/qa/'>qa (2)</a></li>
<li><a class='list-group-item' href='/blog/categories/reading/'>reading (7)</a></li>
<li><a class='list-group-item' href='/blog/categories/search/'>search (6)</a></li>
<li><a class='list-group-item' href='/blog/categories/spring/'>spring (3)</a></li>
<li><a class='list-group-item' href='/blog/categories/squid/'>squid (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/structure/'>structure (3)</a></li>
<li><a class='list-group-item' href='/blog/categories/tomcat/'>tomcat (3)</a></li>
<li><a class='list-group-item' href='/blog/categories/tools/'>tools (8)</a></li>
<li><a class='list-group-item' href='/blog/categories/web/'>web (1)</a></li>
 
  </div>
</section>
<section class="panel panel-default">
  <div  class="panel-heading">
    <h1 class="panel-title">其他博客</h3>
  </div>
  <div id="categories_list_div" class="list-group">
    <a class='list-group-item' href='http://www.baidu.com/p/Nicker_2010'>百度空间</a>
  </div>
</section>

  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - xiaobaoqiu -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
