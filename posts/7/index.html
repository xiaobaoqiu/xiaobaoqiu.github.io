
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>xiaobaoqiu Blog</title>
  <meta name="author" content="xiaobaoqiu">

  
  <meta name="description" content="1.什么是Selenium Selenium 是一种 Web 应用的自动测试工具，通过模拟用户对 Web 页面的各种操作，可以精确重现软件测试人员编写的 Test Cases 步骤。它所采用的原理是通过录制应用程序产生的线性脚本进行回放从而达到自动化测试的目的。其优点是简单， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://xiaobaoqiu.github.io/posts/7/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  

  <link href="/atom.xml" rel="alternate" title="xiaobaoqiu Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">xiaobaoqiu Blog</a></h1>
  
    <h2>Keep Runnnnnnnnnning...</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss email">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
    <li><a href="xiaobaoqiu@163.com" rel="subscribe-email" title="subscribe via email">Email</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="xiaobaoqiu.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">所有博文</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/12/15/selenium/">Selenium</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-12-15T17:45:32+08:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>15</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>5:45 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>1.什么是Selenium</h1>

<p>Selenium 是一种 Web 应用的自动测试工具，通过模拟用户对 Web 页面的各种操作，可以精确重现软件测试人员编写的 Test Cases 步骤。它所采用的原理是通过录制应用程序产生的线性脚本进行回放从而达到自动化测试的目的。其优点是简单，通过录制就可以得到所需脚本。类似于录制/回放测试工具有很多，我们之所以选择它的原因是它是开源的，而且它测试直接在浏览器中运行，就像真实用户所做的一样。Selenium测试可以在 Windows、Linux上的 Internet Explorer、Mozilla和 Firefox 中运行。其他测试工具都不能覆盖如此多的平台，更重要的是Selenium支持多种语言、JAVA、Ruby、Python等。</p>

<p>Selenium的核心，也称browser bot,是用JavaScript编写的。这使得测试脚本可以在受支持的浏览器中运行。browser bot负责执行从测试脚本接收到的命令，测试脚本要么是用 HTML的表布局编写的，要么是使用一种受支持的编程语言编写的。</p>

<h3>1.1 Selenium名字的来源</h3>

<p>Selenium的中文名为“硒”，是一种化学元素的名字，它对汞（Mercury）有天然的解毒作用，实验表明汞暴露水平越高，硒对汞毒性的拮抗作用越明显，所以说硒是汞的克星。大家应该知道Mercury测试工具系 列吧（QTP，QC，LR，WR&hellip;），他们功能强大，但却价格不菲，大家对此又爱又恨！故thoughtworks特意把他们的Web开源测试工具命 名为Selenium，以此帮助大家脱离汞毒。</p>

<p>Selenium 是thoughtworks所做的，用于Web应用程序测试的工具。Selenium测试直接运行在浏览器中，就像真正的用户在操作一样。支持的浏览器包括IE、Mozilla Firefox、Mozilla Suite等。</p>

<p>在selenium2.0中，包含2个部分 selenium ide 和 selenium webdriver.</p>

<h3>1.2 优势</h3>

<p>使用 Selenium 和在浏览器中运行测试还有很多其他好处。下面是主要的两大好处：</p>

<pre><code>(1).通过编写模仿用户操作的 Selenium 测试脚本，可以从终端用户的角度来测试应用程序;
(2).通过在不同浏览器中运行测试，更容易发现浏览器的不兼容性;
</code></pre>

<h3>1.3 Selenium 模式</h3>

<p>可以按两种模式来使用test runner 和 driven,这两种模式在复杂性和编写方式方面有所不同。driven 测试脚本编写起来往往要更复杂一些，因为它们是用编程语言编写的。</p>

<p>两种模式之间最大的不同点在于:如果使用 driven 脚本，测试有一部分在浏览器之外运行，而如果使用 test runner 脚本的话，测试是完全在浏览器中运行的。</p>

<p>不管是 test runner 还是 driven 测试用例，都可以与持续集成工具集成。</p>

<p>本文这里只简单介绍了 driven 模式。</p>

<h1>2.driven 模式</h1>

<p>driven Selenium 脚本是用多种受支持的编程语言中的一种编写的,目前可用的有 Java、Ruby 和 Python 等驱动程序。这些脚本在浏览器之外的一个单独的进程中运行。驱动程序的任务是执行测试脚本，并通过与运行在浏览器中的 browser bot 进行通信来驱动浏览器。驱动程序与 browser bot 之间的通信使用一种简单的特定于 Selenium 的连接语言 Selenese。</p>

<p>driven 脚本比 test runner 脚本更强大、更灵活，可以将它们与 xUnit (比如JUnit)框架集成。driven 脚本的缺点（与 test runner 脚本相比）是，这种脚本编写和部署起来更复杂。这是因为驱动程序必须执行以下任务：</p>

<pre><code>(1).启动服务器;
(2).部署所测试的应用程序;
(3).部署测试脚本;
(4).启动浏览器;
(5).发送命令到 browser bot;
(6).验证 browser bot 执行的命令的结果;
</code></pre>

<h1>3.简单case</h1>

<p>这里用Java实现一个简单的使用Selenium的case</p>

<h3>3.1 Maven包</h3>

<p>使用现有的maven包：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="o">&lt;</span><span class="n">dependency</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="o">&lt;</span><span class="n">groupId</span><span class="o">&gt;</span><span class="n">org</span><span class="o">.</span><span class="na">seleniumhq</span><span class="o">.</span><span class="na">selenium</span><span class="o">&lt;/</span><span class="n">groupId</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="o">&lt;</span><span class="n">artifactId</span><span class="o">&gt;</span><span class="n">selenium</span><span class="o">-</span><span class="n">java</span><span class="o">&lt;/</span><span class="n">artifactId</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">dependency</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>3.2 简单case</h3>

<p>下面结合JUnit以打开google为例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kn">import</span> <span class="nn">com.google.common.collect.Lists</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">com.qunar.scm.common.BrowserDriver</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.apache.commons.collections.CollectionUtils</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.junit.Assert</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.junit.Test</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.openqa.selenium.By</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.openqa.selenium.Keys</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.openqa.selenium.WebDriver</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.openqa.selenium.WebElement</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.slf4j.Logger</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.slf4j.LoggerFactory</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * 测试Google</span>
</span><span class='line'><span class="cm"> *</span>
</span><span class='line'><span class="cm"> * @author baoqiu.xiao@qunar.com  Date: 14-12-31 Time: 下午1:42</span>
</span><span class='line'><span class="cm"> * @version \$Id$</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GoogleTest</span> <span class="kd">extends</span> <span class="n">AbstractBaseTest</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Logger</span> <span class="n">logger</span> <span class="o">=</span> <span class="n">LoggerFactory</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="n">GoogleTest</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">GOOGLE_URL</span> <span class="o">=</span> <span class="s">&quot;https://www.google.com.hk&quot;</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Test</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testGoogle</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">//当前测试case名称</span>
</span><span class='line'>        <span class="n">caseName</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getStackTrace</span><span class="o">()[</span><span class="mi">1</span><span class="o">].</span><span class="na">getMethodName</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">boolean</span> <span class="n">flag</span> <span class="o">=</span> <span class="n">testCommonProcess</span><span class="o">(</span><span class="n">currentDriverList</span><span class="o">(),</span> <span class="k">new</span> <span class="nf">BrowserVisiter</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>            <span class="nd">@Override</span>
</span><span class='line'>            <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">visit</span><span class="o">(</span><span class="n">BrowserDriver</span> <span class="n">browserDriver</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="k">return</span> <span class="nf">doTestGoogle</span><span class="o">(</span><span class="n">browserDriver</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">});</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">Assert</span><span class="o">.</span><span class="na">assertTrue</span><span class="o">(</span><span class="n">flag</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 实际的测试逻辑</span>
</span><span class='line'><span class="cm">     *</span>
</span><span class='line'><span class="cm">     * @param browserDriver</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">doTestGoogle</span><span class="o">(</span><span class="kd">final</span> <span class="n">BrowserDriver</span> <span class="n">browserDriver</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">browserDriver</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">&quot;browserDriver is null&quot;</span><span class="o">);</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">WebDriver</span> <span class="n">driver</span> <span class="o">=</span> <span class="n">browserDriver</span><span class="o">.</span><span class="na">getWebDriver</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//1.打开页面</span>
</span><span class='line'>        <span class="n">driver</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">GOOGLE_URL</span><span class="o">);</span>
</span><span class='line'>        <span class="n">driver</span><span class="o">.</span><span class="na">manage</span><span class="o">().</span><span class="na">window</span><span class="o">().</span><span class="na">maximize</span><span class="o">();</span>
</span><span class='line'>        <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//2.在搜索框内输入关键字,输入回车</span>
</span><span class='line'>        <span class="n">WebElement</span> <span class="n">keyWord</span> <span class="o">=</span> <span class="n">driver</span><span class="o">.</span><span class="na">findElement</span><span class="o">(</span><span class="n">By</span><span class="o">.</span><span class="na">name</span><span class="o">(</span><span class="s">&quot;q&quot;</span><span class="o">));</span>
</span><span class='line'>        <span class="n">keyWord</span><span class="o">.</span><span class="na">sendKeys</span><span class="o">(</span><span class="s">&quot;xiaobaoqiu&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="n">keyWord</span><span class="o">.</span><span class="na">sendKeys</span><span class="o">(</span><span class="n">Keys</span><span class="o">.</span><span class="na">RETURN</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 当前需要测试的浏览器列表，这里只使用了firefox</span>
</span><span class='line'><span class="cm">     *</span>
</span><span class='line'><span class="cm">     * @return</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">protected</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">BrowserDriver</span><span class="o">&gt;</span> <span class="nf">currentDriverList</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">Lists</span><span class="o">.</span><span class="na">newArrayList</span><span class="o">(</span><span class="n">BrowserDriver</span><span class="o">.</span><span class="na">FIREFOX_DRIVER</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 生成测试报告</span>
</span><span class='line'><span class="cm">     *</span>
</span><span class='line'><span class="cm">     * @param driverList</span>
</span><span class='line'><span class="cm">     * @param result</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doReportResult</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">BrowserDriver</span><span class="o">&gt;</span> <span class="n">driverList</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="o">&gt;</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">CollectionUtils</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">(</span><span class="n">driverList</span><span class="o">)</span> <span class="o">||</span> <span class="n">CollectionUtils</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">(</span><span class="n">result</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">&quot;isEmpty(driverList) or isEmpty(result)&quot;</span><span class="o">);</span>
</span><span class='line'>            <span class="k">return</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">driverList</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">!=</span> <span class="n">result</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">&quot;driverList.size() != result.size()&quot;</span><span class="o">);</span>
</span><span class='line'>            <span class="k">return</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;BEG====================================={}=====================================BEG&quot;</span><span class="o">,</span> <span class="n">caseName</span><span class="o">);</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">driverList</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;{} = {}&quot;</span><span class="o">,</span> <span class="n">driverList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">getBrowser</span><span class="o">().</span><span class="na">getName</span><span class="o">(),</span> <span class="n">resultString</span><span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)));</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;END====================================={}=====================================END&quot;</span><span class="o">,</span> <span class="n">caseName</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>结果：</p>

<p><img src="/images/selenium/selenium_page_result.png"></p>

<p><img src="/images/selenium/selenium_code_result.png"></p>

<h3>3.3 注意点</h3>

<p>一些Selenuim的注意点，持续补充中：</p>

<pre><code>(1).Selenium默认状态下只支持Firefox，支持Chrome和IE需要安装插件;
</code></pre>

<h1>4.参考</h1>

<p><a href="http://code.google.com/p/selenium/">http://code.google.com/p/selenium/</a></p>

<p><a href="https://www.ibm.com/developerworks/cn/java/wa-selenium-ajax/">https://www.ibm.com/developerworks/cn/java/wa-selenium-ajax/</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/24/javabing-fa-rong-qi-zhi-blockingqueue/">Java并发容器之BlockingQueue</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-11-24T17:35:13+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>24</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>5:35 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>这篇文章主要分析Concurrent包中的BlockingQueue系列的并发容器实现原理和源代码.</p>

<h1>1.实现原理</h1>

<p>阻塞队列与普通队列的区别在于，当队列是空的时，从队列中获取元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞。试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其他的线程往空的队列插入新的元素。同样，试图往已满的阻塞队列中添加新元素的线程同样也会被阻塞，直到其他的线程使队列重新变得空闲起来，如从队列中移除一个或者多个元素，或者完全清空队列.</p>

<p>下图展示了如何通过阻塞队列来合作：</p>

<p><img src="/images/concurrent/blocking-queue.png"></p>

<p>线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素.</p>

<h1>1.1 阻塞队列简单实现</h1>

<p>下面是阻塞队列的一个简单实现:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BlockingQueue</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="n">List</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">LinkedList</span><span class="o">();</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span>  <span class="n">limit</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">BlockingQueue</span><span class="o">(</span><span class="kt">int</span> <span class="n">limit</span><span class="o">){</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">limit</span> <span class="o">=</span> <span class="n">limit</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//入队列</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">enqueue</span><span class="o">(</span><span class="n">Object</span> <span class="n">item</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">while</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">queue</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="k">this</span><span class="o">.</span><span class="na">limit</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">wait</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">queue</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">notifyAll</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//出队列</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="n">Object</span> <span class="nf">dequeue</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">while</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">queue</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
</span><span class='line'>            <span class="n">wait</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">queue</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="k">this</span><span class="o">.</span><span class="na">limit</span><span class="o">){</span>
</span><span class='line'>            <span class="n">notifyAll</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">queue</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>必须注意到，在enqueue和dequeue方法内部，只有队列的大小等于上限（limit）或者下限（0）时，才调用notifyAll方法。如果队列的大小既不等于上限，也不等于下限，任何线程调用enqueue或者dequeue方法时，都不会阻塞，都能够正常的往队列中添加或者移除元素。</p>

<h1>2.Java BlockingQueue整体介绍</h1>

<p>BlockingQueue系列并发容器包括一下几个:</p>

<pre><code>BlockingQueue
BlockingDeque
ArrayBlockingQueue
LinkedBlockingDeque
LinkedBlockingQueue
PriorityBlockingQueue
DelayQueue
</code></pre>

<h3>2.1 其继承关系如下图:</h3>

<h3>2.2 主要的方法如下:</h3>

<p><strong>放入数据</strong></p>

<pre><code>(1).offer(anObject)
表示如果可能的话,将anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,则返回true,否则返回false.(本方法不阻塞当前执行方法的线程);
(2).offer(E o, long timeout, TimeUnit unit)可以设定等待的时间，如果在指定的时间内，还不能往队列中加入BlockingQueue，则返回失败;
(3).put(anObject)
把anObject加到BlockingQueue里,如果BlockQueue没有空间,则调用此方法的线程被阻断直到BlockingQueue里面有空间再继续.
</code></pre>

<p><strong>获取数据</strong></p>

<pre><code>(1).poll(time)
取走BlockingQueue里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,取不到时返回null;
(2).poll(long timeout, TimeUnit unit)
从BlockingQueue取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据,否则知道时间超时还没有数据可取，返回失败;
(3).take()
取走BlockingQueue里排在首位的对象,若BlockingQueue为空,阻断进入等待状态直到BlockingQueue有新的数据被加入; 
(4).drainTo()
一次性从BlockingQueue获取所有可用的数据对象（还可以指定获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。
</code></pre>

<h1>3. ArrayBlockingQueue</h1>

<p>数组实现的BlockingQueue,实现上用一个数组保存数据</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ArrayBlockingQueue</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">AbstractQueue</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span>
</span><span class='line'>        <span class="kd">implements</span> <span class="n">BlockingQueue</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;,</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">Serializable</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="o">-</span><span class="mi">817911632652898426L</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/** 队列数据  */</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="n">E</span><span class="o">[]</span> <span class="n">items</span><span class="o">;</span>
</span><span class='line'>    <span class="cm">/** 下一个take, poll 或者 remove的下标 */</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">takeIndex</span><span class="o">;</span>
</span><span class='line'>    <span class="cm">/** 下一个 put, offer 或者 add的下标 */</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">putIndex</span><span class="o">;</span>
</span><span class='line'>    <span class="cm">/** 队列内元素的数目 */</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/** 锁 */</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="n">ReentrantLock</span> <span class="n">lock</span><span class="o">;</span>
</span><span class='line'>    <span class="cm">/** 等待take的Condition */</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Condition</span> <span class="n">notEmpty</span><span class="o">;</span>
</span><span class='line'>    <span class="cm">/** 等待puts的Condition */</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Condition</span> <span class="n">notFull</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>三个构造函数,可以输入容量,锁的公平性等,默认是锁非公平的,注意这里的锁是独占的ReentrantLock,因为这里从队列(数组)中读取数据和旺队列中写数据都应该和别的线程是互斥的.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">//默认锁是不公平的</span>
</span><span class='line'><span class="kd">public</span> <span class="nf">ArrayBlockingQueue</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">this</span><span class="o">(</span><span class="n">capacity</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="nf">ArrayBlockingQueue</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">fair</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">capacity</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">();</span>
</span><span class='line'>    <span class="k">this</span><span class="o">.</span><span class="na">items</span> <span class="o">=</span> <span class="o">(</span><span class="n">E</span><span class="o">[])</span> <span class="k">new</span> <span class="n">Object</span><span class="o">[</span><span class="n">capacity</span><span class="o">];</span>
</span><span class='line'>    <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ReentrantLock</span><span class="o">(</span><span class="n">fair</span><span class="o">);</span>
</span><span class='line'>    <span class="n">notEmpty</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span>
</span><span class='line'>    <span class="n">notFull</span> <span class="o">=</span>  <span class="n">lock</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="c1">//c为初始数据</span>
</span><span class='line'><span class="kd">public</span> <span class="nf">ArrayBlockingQueue</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">fair</span><span class="o">,</span>
</span><span class='line'>                          <span class="n">Collection</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">E</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">this</span><span class="o">(</span><span class="n">capacity</span><span class="o">,</span> <span class="n">fair</span><span class="o">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">capacity</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="n">Iterator</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">E</span><span class="o">&gt;</span> <span class="n">it</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span> <span class="n">it</span><span class="o">.</span><span class="na">hasNext</span><span class="o">();)</span>
</span><span class='line'>        <span class="n">add</span><span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="na">next</span><span class="o">());</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面分析offer,put,poll,take这几个主要的函数实现:</p>

<h3>3.1 offer</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">offer</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>    <span class="c1">//不支持null元素</span>
</span><span class='line'>    <span class="kd">final</span> <span class="n">ReentrantLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">lock</span><span class="o">;</span>
</span><span class='line'>    <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
</span><span class='line'>    <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">items</span><span class="o">.</span><span class="na">length</span><span class="o">)</span>  <span class="c1">//队列满,直接返回false</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>        <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">insert</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>insert的实现:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="n">E</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">items</span><span class="o">[</span><span class="n">putIndex</span><span class="o">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
</span><span class='line'>    <span class="n">putIndex</span> <span class="o">=</span> <span class="n">inc</span><span class="o">(</span><span class="n">putIndex</span><span class="o">);</span>
</span><span class='line'>    <span class="o">++</span><span class="n">count</span><span class="o">;</span>
</span><span class='line'>    <span class="n">notEmpty</span><span class="o">.</span><span class="na">signal</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>即offer不能插入立即返回,插入成功会触发notEmpty这个Condition,唤醒那些等待读取数据的被阻塞的线程</p>

<h3>3.2 put</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
</span><span class='line'>    <span class="kd">final</span> <span class="n">E</span><span class="o">[]</span> <span class="n">items</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">items</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">final</span> <span class="n">ReentrantLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">lock</span><span class="o">;</span>
</span><span class='line'>    <span class="n">lock</span><span class="o">.</span><span class="na">lockInterruptibly</span><span class="o">();</span>   <span class="c1">//可被interrupt的lock</span>
</span><span class='line'>    <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">while</span> <span class="o">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">items</span><span class="o">.</span><span class="na">length</span><span class="o">)</span>
</span><span class='line'>                <span class="n">notFull</span><span class="o">.</span><span class="na">await</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">ie</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">notFull</span><span class="o">.</span><span class="na">signal</span><span class="o">();</span> <span class="c1">// propagate to non-interrupted thread</span>
</span><span class='line'>            <span class="k">throw</span> <span class="n">ie</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">insert</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>put不能插入时候,会一直被阻塞,但是这个阻塞的线程是可以被interrupt的.</p>

<h3>3.3 poll</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="n">E</span> <span class="nf">poll</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">final</span> <span class="n">ReentrantLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">lock</span><span class="o">;</span>
</span><span class='line'>    <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
</span><span class='line'>    <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="c1">//没有数据可取,直接返回</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>        <span class="n">E</span> <span class="n">x</span> <span class="o">=</span> <span class="n">extract</span><span class="o">();</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中extract()的实现如下:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="n">E</span> <span class="nf">extract</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">final</span> <span class="n">E</span><span class="o">[]</span> <span class="n">items</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">items</span><span class="o">;</span>
</span><span class='line'>    <span class="n">E</span> <span class="n">x</span> <span class="o">=</span> <span class="n">items</span><span class="o">[</span><span class="n">takeIndex</span><span class="o">];</span>
</span><span class='line'>    <span class="n">items</span><span class="o">[</span><span class="n">takeIndex</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>    <span class="n">takeIndex</span> <span class="o">=</span> <span class="n">inc</span><span class="o">(</span><span class="n">takeIndex</span><span class="o">);</span>
</span><span class='line'>    <span class="o">--</span><span class="n">count</span><span class="o">;</span>
</span><span class='line'>    <span class="n">notFull</span><span class="o">.</span><span class="na">signal</span><span class="o">();</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>poll成功会触发notFull这个Condition,即唤醒所有等待插入数据的线程.</p>

<h3>3.4 take</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="n">E</span> <span class="nf">take</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">final</span> <span class="n">ReentrantLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">lock</span><span class="o">;</span>
</span><span class='line'>    <span class="n">lock</span><span class="o">.</span><span class="na">lockInterruptibly</span><span class="o">();</span>
</span><span class='line'>    <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">while</span> <span class="o">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
</span><span class='line'>                <span class="n">notEmpty</span><span class="o">.</span><span class="na">await</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">ie</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">notEmpty</span><span class="o">.</span><span class="na">signal</span><span class="o">();</span> <span class="c1">// propagate to non-interrupted thread</span>
</span><span class='line'>            <span class="k">throw</span> <span class="n">ie</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">E</span> <span class="n">x</span> <span class="o">=</span> <span class="n">extract</span><span class="o">();</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>take当无数据可取的时候,线程会一致阻塞,但是线程的阻塞状态是可以被interrupt的.</p>

<h1>4. LinkedBlockingQueue</h1>

<p>LinkedBlockingQueue即一个单链表实现的阻塞队列,单链表节点定义如下:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">E</span> <span class="n">item</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>
</span><span class='line'>    <span class="n">Node</span><span class="o">(</span><span class="n">E</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span> <span class="n">item</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span> <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>内部实现,链表实现,注意有两个锁,即一个读取的锁(takeLock)和一个写入的锁(putLock).原因是put和take是不冲突的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LinkedBlockingQueue</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">AbstractQueue</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span>
</span><span class='line'>        <span class="kd">implements</span> <span class="n">BlockingQueue</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;,</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">Serializable</span> <span class="o">{</span>
</span><span class='line'>    <span class="cm">/** 容量 */</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">capacity</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/** 当前元素个数 */</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="n">AtomicInteger</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">AtomicInteger</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/** 链表首节点 */</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">transient</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">head</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/** 链表尾节点 */</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">transient</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">last</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/** take, poll等操作的锁 */</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="n">ReentrantLock</span> <span class="n">takeLock</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ReentrantLock</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/** takes操作的等待Condition */</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Condition</span> <span class="n">notEmpty</span> <span class="o">=</span> <span class="n">takeLock</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/** put, offer等的锁 */</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="n">ReentrantLock</span> <span class="n">putLock</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ReentrantLock</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/** puts操作的等待Condition */</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Condition</span> <span class="n">notFull</span> <span class="o">=</span> <span class="n">putLock</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>默认构造指定最大容量为Integer.MAX_VALUE,通过构造函数可以指定容量.</p>

<h1>4. PriorityBlockingQueue</h1>

<p>PriorityBlockingQueue是基于PriorityQueue实现的一个优先级阻塞队列。而PriorityQueue是基于二叉堆实现的优先级队列,它每次从队列中取出的是具有最高优先权的元素。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PriorityBlockingQueue</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">AbstractQueue</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="kd">implements</span> <span class="n">BlockingQueue</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;,</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">Serializable</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="n">ReentrantLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ReentrantLock</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Condition</span> <span class="n">notEmpty</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>构造函数可以指定比较器(Comparator)，如果不指定就按照对象的自然顺序(对象必须是Comparable的)。</p>

<h1>5.DelayQueue</h1>

<p>DelayQueue是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。这种队列是有序的，即队头对象的延迟到期时间最长。</p>

<p>Delayed扩展了Comparable接口，比较的基准为延时的时间值，Delayed接口的实现类getDelay的返回值应为固定值（final）。</p>

<p>DelayQueue是基于PriorityQueue实现。简单的说，DelayQueue是一个使用优先队列（PriorityQueue）实现的BlockingQueue，优先队列的比较基准值是时间。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DelayQueue</span><span class="o">&lt;</span><span class="n">E</span> <span class="kd">extends</span> <span class="n">Delayed</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">AbstractQueue</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="kd">implements</span> <span class="n">BlockingQueue</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">transient</span> <span class="kd">final</span> <span class="n">ReentrantLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ReentrantLock</span><span class="o">();</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">transient</span> <span class="kd">final</span> <span class="n">Condition</span> <span class="n">available</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;();</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>看起take函数的实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="n">E</span> <span class="nf">take</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">final</span> <span class="n">ReentrantLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">lock</span><span class="o">;</span>
</span><span class='line'>    <span class="n">lock</span><span class="o">.</span><span class="na">lockInterruptibly</span><span class="o">();</span>
</span><span class='line'>    <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">E</span> <span class="n">first</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span> <span class="c1">//第一个元素</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">first</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">available</span><span class="o">.</span><span class="na">await</span><span class="o">();</span>
</span><span class='line'>            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>                <span class="kt">long</span> <span class="n">delay</span> <span class="o">=</span>  <span class="n">first</span><span class="o">.</span><span class="na">getDelay</span><span class="o">(</span><span class="n">TimeUnit</span><span class="o">.</span><span class="na">NANOSECONDS</span><span class="o">);</span>
</span><span class='line'>                <span class="k">if</span> <span class="o">(</span><span class="n">delay</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>    <span class="c1">//没有过期，继续等待</span>
</span><span class='line'>                    <span class="kt">long</span> <span class="n">tl</span> <span class="o">=</span> <span class="n">available</span><span class="o">.</span><span class="na">awaitNanos</span><span class="o">(</span><span class="n">delay</span><span class="o">);</span>
</span><span class='line'>                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>    <span class="c1">//过期</span>
</span><span class='line'>                    <span class="n">E</span> <span class="n">x</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
</span><span class='line'>                    <span class="k">assert</span> <span class="n">x</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>                    <span class="k">if</span> <span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
</span><span class='line'>                        <span class="n">available</span><span class="o">.</span><span class="na">signalAll</span><span class="o">();</span> <span class="c1">//唤醒其他等待take的线程</span>
</span><span class='line'>                    <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/17/java-tips/">Java Tips</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-11-17T23:02:23+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>17</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>11:02 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>总结日常代码出现的问题.</p>

<h1>1.获取周一日期</h1>

<p>期望根据当前日期获取周一日期.</p>

<pre><code>Date today = CommonDateTimeUtils.parseDate("2014-11-16");   //周日
System.out.println("today = " + today);

Calendar calendar = Calendar.getInstance();
calendar.setTime(today);
calendar.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY);
Date monday = DateUtils.truncate(calendar.getTime(), Calendar.DAY_OF_MONTH);
System.out.println("monday = " + monday);
</code></pre>

<p>如上,today是2014-11-16(周日),获取周一的时间,我们期望获取得到2014-11-10(周一),实际周一的时间为2014-11-17(周一).</p>

<p>原因是时间系统默认周日是一周的第一天.我们可以设置周一是一周的第一天.</p>

<pre><code>Date today = CommonDateTimeUtils.parseDate("2014-11-16");   //周日
System.out.println("today = " + today);

Calendar calendar = Calendar.getInstance();
calendar.setFirstDayOfWeek(Calendar.MONDAY);
calendar.setTime(today);
calendar.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY);
Date monday = DateUtils.truncate(calendar.getTime(), Calendar.DAY_OF_MONTH);
System.out.println("monday = " + monday);
</code></pre>

<h1>2.Velocity String to number</h1>

<p>经常在Velocity中将字符串转成数字，比如double或者int，写法如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#set($Integer = 0)
</span><span class='line'>$Integer.parseInt($intString)</span></code></pre></td></tr></table></div></figure>


<p>大概的理解就是：volocity会把基本数据类型的静态方法转换到velocity里。所以，定义一个int，就能调用Integer中的方法。</p>

<p>注意其中第一句#set($Integer = 0)是必须的。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/12/java-lock/">Java Lock</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-11-12T18:35:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>12</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>6:35 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>这篇博客的目的是了解Java Concurrent包中Lock的实现原理.</p>

<p>java.util.concurrent.locks包下提供了一系列关于锁的抽象的类,主要实现有两种锁ReentrantLock和ReentrantReadWriteLock.</p>

<h1>1.一个简单的锁</h1>

<p>让我们从java中的一个同步块开始</p>

<h3>1.1 synchronized实现同步块</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Counter</span><span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">inc</span><span class="o">(){</span>
</span><span class='line'>        <span class="kd">synchronized</span><span class="o">(</span><span class="k">this</span><span class="o">){</span>
</span><span class='line'>            <span class="k">return</span> <span class="o">++</span><span class="n">count</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到在inc()方法中有一个synchronized(this)代码块。该代码块可以保证在同一时间只有一个线程可以执行return ++count操作。虽然在synchronized的同步块中的代码可以更加复杂，但是++count这种简单的操作已经足以表达出线程同步的意思。</p>

<h3>1.2 Lock实现同步块</h3>

<p>以下的Counter类用Lock代替synchronized可以达到了同样的目的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Counter</span><span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Lock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Lock</span><span class="o">();</span> <span class="c1">//锁</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">inc</span><span class="o">(){</span>
</span><span class='line'>        <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">newCount</span> <span class="o">=</span> <span class="o">++</span><span class="n">count</span><span class="o">;</span>
</span><span class='line'>        <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">newCount</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>lock()方法会对Lock实例对象进行加锁，因此所有对该对象调用lock()方法的线程都会被阻塞，直到该Lock对象的unlock()方法被调用。</p>

<h3>1.3 Lock类实现</h3>

<p>这里有一个Lock类的简单实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Lock</span><span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">isLocked</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span>
</span><span class='line'>        <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">{</span>
</span><span class='line'>        <span class="k">while</span><span class="o">(</span><span class="n">isLocked</span><span class="o">){</span>
</span><span class='line'>            <span class="n">wait</span><span class="o">();</span>         <span class="c1">//阻塞</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">isLocked</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">unlock</span><span class="o">(){</span>
</span><span class='line'>        <span class="n">isLocked</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>        <span class="n">notify</span><span class="o">();</span>           <span class="c1">//唤醒</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意其中的while(isLocked)循环，它又被叫做“自旋锁”。自旋锁以及wait()和notify()方法在<a href="http://tutorials.jenkov.com/java-concurrency/thread-signaling.html">线程通信</a>这篇文章中有更加详细的介绍。</p>

<p>当isLocked为true时，调用lock()的线程在wait()调用上阻塞等待。为防止该线程没有收到notify()调用也从wait()中返回，这个线程会重新去检查isLocked条件以决定当前是否可以安全地继续执行还是需要重新保持等待，而不是认为线程被唤醒了就可以安全地继续执行了。如果isLocked为false，当前线程会退出while(isLocked)循环，并将isLocked设回true，让其它正在调用lock()方法的线程能够在Lock实例上加锁。</p>

<p>当线程完成了临界区（锁住的代码端,即位于lock()和unlock()之间）中的代码，就会调用unlock()。执行unlock()会重新将isLocked设置为false，并且通知（唤醒）其中一个（若有的话）在lock()方法中调用了wait()函数而处于等待状态的线程。</p>

<h3>1.4 在finally语句中调用unlock()</h3>

<p>如果用Lock来保护临界区，并且临界区有可能会抛出异常，那么在finally语句中调用unlock()就显得非常重要了,这样可以保证这个锁对象可以被解锁以便其它线程能继续对其加锁:</p>

<pre><code>lock.lock();
try{
    //do critical section code,
    //which may throw exception
} finally {
    lock.unlock();
}
</code></pre>

<p>这个简单的结构可以保证当临界区抛出异常时Lock对象可以被解锁。如果不是在finally语句中调用的unlock()，当临界区抛出异常时，Lock对象将永远停留在被锁住的状态，这会导致其它所有在该Lock对象上调用lock()的线程一直阻塞。</p>

<h1>2.锁的可重入性</h1>

<h4>2.1 什么是可重入</h4>

<p>如果一个线程持有某个管程对象(monitor object)上的锁，那么它就有权访问所有在该管程对象上同步块。这就叫可重入。
通俗讲即若线程已经持有锁，那么它就可以重复访问所有使用该锁的代码块。</p>

<h3>2.2 synchronized同步块是可重入的</h3>

<p>Java中的synchronized同步块是可重入的。这意味着如果一个java线程进入了代码中的synchronized同步块，并因此获得了该同步块使用的同步对象对应的管程上的锁，那么这个线程可以进入由同一个管程对象所同步的另一个java代码块。因此下面的代码没有问题:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Reentrant</span><span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="nf">outer</span><span class="o">(){</span>
</span><span class='line'>        <span class="n">inner</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="nf">inner</span><span class="o">(){</span>
</span><span class='line'>        <span class="c1">//do something</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意outer()和inner()都声明为synchronized，这在Java中这相当于synchronized(this)块.如果某个线程调用了outer()，outer()中的inner()调用是没问题的，因为两个方法都是在同一个管程对象(即this)上同步的。</p>

<h3>2.3 不可重入锁</h3>

<p>1.3节的锁实现是不可重入的,原因是如果一个线程在两次调用lock()间没有调用unlock()方法，那么第二次调用lock()就会被阻塞，这就出现了重入锁死,如下:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Reentrant2</span><span class="o">{</span>
</span><span class='line'>    <span class="n">Lock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Lock</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">outer</span><span class="o">(){</span>
</span><span class='line'>        <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
</span><span class='line'>        <span class="n">inner</span><span class="o">();</span>
</span><span class='line'>        <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="nf">inner</span><span class="o">(){</span>
</span><span class='line'>        <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
</span><span class='line'>        <span class="c1">//do something</span>
</span><span class='line'>        <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>调用outer()的线程首先会锁住Lock实例，然后继续调用inner()。inner()方法中该线程将再一次尝试锁住Lock实例，结果该动作会失败（也就是说该线程会被阻塞），因为这个Lock实例已经在outer()方法中被锁住了。</p>

<h3>2.4 修改成可重入锁</h3>

<p>为了让这个Lock类具有可重入性，我们需要对它做一点小的改动:</p>

<pre><code>(1).可重入锁需要一个重入计数变量，初始值设为0，当成功请求锁时加1，释放锁时减1，当释放锁之后计数为0则真正释放锁;
(2).重入锁还必须持有对锁持有者的引用，用以判断是否可以重入;
</code></pre>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Lock</span><span class="o">{</span>
</span><span class='line'>    <span class="kt">boolean</span> <span class="n">isLocked</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>    <span class="n">Thread</span>  <span class="n">lockedBy</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>    <span class="c1">//阻塞的线程</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">lockedCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>        <span class="c1">//同一个线程加锁的次数</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">{</span>
</span><span class='line'>        <span class="n">Thread</span> <span class="n">callingThread</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
</span><span class='line'>        <span class="k">while</span><span class="o">(</span><span class="n">isLocked</span> <span class="o">&amp;&amp;</span> <span class="n">lockedBy</span> <span class="o">!=</span> <span class="n">callingThread</span><span class="o">){</span>
</span><span class='line'>            <span class="n">wait</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">isLocked</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="n">lockedCount</span><span class="o">++;</span>
</span><span class='line'>        <span class="n">lockedBy</span> <span class="o">=</span> <span class="n">callingThread</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">unlock</span><span class="o">(){</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">curentThread</span><span class="o">()</span> <span class="o">==</span> <span class="k">this</span><span class="o">.</span><span class="na">lockedBy</span><span class="o">){</span>
</span><span class='line'>            <span class="n">lockedCount</span><span class="o">--;</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">if</span><span class="o">(</span><span class="n">lockedCount</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>   <span class="c1">//锁次数为0之后才解锁</span>
</span><span class='line'>                <span class="n">isLocked</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>                <span class="n">notify</span><span class="o">();</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意到现在的while循环（自旋锁）也考虑到了已锁住该Lock实例的线程。如果当前的锁对象没有被加锁(isLocked = false)，或者当前调用线程已经对该Lock实例加了锁，那么while循环就不会被执行，调用lock()的线程就不会被阻塞了。</p>

<p>除此之外，我们需要记录同一个线程重复对一个锁对象加锁的次数。否则，一次unblock()调用就会解除整个锁，即使当前锁已经被加锁过多次。在unlock()调用没有达到对应lock()调用的次数之前，我们不希望锁被解除。</p>

<h1>3.锁的公平性</h1>

<p>Java的synchronized块并不保证尝试进入它们的线程的顺序。如果一个线程因为CPU时间全部被其他线程抢走而得不到CPU运行时间，这种状态被称之为“饥饿”。而该线程被“饥饿致死”正是因为它得不到CPU运行时间的机会。解决饥饿的方案被称之为“公平性”,即所有线程均能公平地获得运行机会。</p>

<p>通俗讲,如果在绝对时间上，先对锁进行获取的请求一定被先满足，那么这个锁是公平的，反之，是不公平的，也就是说等待时间最长的线程最有机会获取锁，也可以说锁的获取是有序的。</p>

<h3>3.1 Java中导致饥饿的原因</h3>

<p><strong>(1).高优先级线程抢占所有的低优先级线程的CPU时间</strong></p>

<p>我们能为每个线程设置独自的线程优先级，优先级越高的线程获得的CPU时间越多，线程优先级值设置在1到10之间，这些优先级值所表示行为的准确解释则依赖于你的应用运行平台。</p>

<p><strong>(2).线程被永久堵塞在一个等待进入同步块的状态</strong></p>

<p>Java的同步代码区也是一个导致饥饿的因素。Java的同步代码区对哪个线程允许进入的次序没有任何保障。这就意味着理论上存在一个试图进入该同步区的线程处于被永久堵塞的风险，因为其他线程总是能持续地先于它获得访问，这即是“饥饿”问题，而一个线程被“饥饿致死”正是因为它得不到CPU运行时间的机会。</p>

<p><strong>(3).线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的wait方法)</strong></p>

<p>如果多个线程处在wait()方法执行上，而对其调用notify()不会保证哪一个线程会获得唤醒，任何线程都有可能处于继续等待的状态。因此存在这样一个风险：一个等待线程从来得不到唤醒，因为其他等待线程总是能被获得唤醒。</p>

<h3>3.2 实现公平锁</h3>

<p>下面来讲述将上面Lock类转变为公平锁FairLock。基本原理是每一个调用lock()的线程都会进入一个队列，当解锁后，只有队列里的第一个线程被允许锁住Farlock实例，所有其它的线程都将处于等待状态，直到他们处于队列头部。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FairLock</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">boolean</span>           <span class="n">isLocked</span>       <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Thread</span>            <span class="n">lockingThread</span>  <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>    <span class="c1">//用于等待的线程队列</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">QueueObject</span><span class="o">&gt;</span> <span class="n">waitingThreads</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">QueueObject</span><span class="o">&gt;();</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">{</span>
</span><span class='line'>        <span class="n">QueueObject</span> <span class="n">queueObject</span>           <span class="o">=</span> <span class="k">new</span> <span class="nf">QueueObject</span><span class="o">();</span>
</span><span class='line'>        <span class="kt">boolean</span>     <span class="n">isLockedForThisThread</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="kd">synchronized</span><span class="o">(</span><span class="k">this</span><span class="o">){</span> <span class="c1">//加入等到队列</span>
</span><span class='line'>            <span class="n">waitingThreads</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">queueObject</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">while</span><span class="o">(</span><span class="n">isLockedForThisThread</span><span class="o">){</span>
</span><span class='line'>            <span class="kd">synchronized</span><span class="o">(</span><span class="k">this</span><span class="o">){</span>
</span><span class='line'>                <span class="n">isLockedForThisThread</span> <span class="o">=</span>
</span><span class='line'>                <span class="n">isLocked</span> <span class="o">||</span> <span class="n">waitingThreads</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">!=</span> <span class="n">queueObject</span><span class="o">;</span>
</span><span class='line'>                <span class="k">if</span><span class="o">(!</span><span class="n">isLockedForThisThread</span><span class="o">){</span> <span class="c1">//当前线程没有被阻塞</span>
</span><span class='line'>                    <span class="n">isLocked</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>                    <span class="n">waitingThreads</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">queueObject</span><span class="o">);</span>
</span><span class='line'>                    <span class="n">lockingThread</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
</span><span class='line'>                    <span class="k">return</span><span class="o">;</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>            <span class="c1">//isLockedForThisThread == true</span>
</span><span class='line'>            <span class="k">try</span><span class="o">{</span>
</span><span class='line'>                <span class="n">queueObject</span><span class="o">.</span><span class="na">doWait</span><span class="o">();</span>   <span class="c1">//通知当前线程等待</span>
</span><span class='line'>            <span class="o">}</span><span class="k">catch</span><span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">){</span>
</span><span class='line'>                <span class="kd">synchronized</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                    <span class="n">waitingThreads</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">queueObject</span><span class="o">);</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>                <span class="k">throw</span> <span class="n">e</span><span class="o">;</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">unlock</span><span class="o">(){</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">lockingThread</span> <span class="o">!=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">()){</span>
</span><span class='line'>          <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalMonitorStateException</span><span class="o">(</span>
</span><span class='line'>            <span class="s">&quot;Calling thread has not locked this lock&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">isLocked</span>      <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>        <span class="n">lockingThread</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">waitingThreads</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
</span><span class='line'>            <span class="n">waitingThreads</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">doNotify</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>QueueObject实现:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">QueueObject</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">isNotified</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">//被唤醒</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">doWait</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">while</span><span class="o">(!</span><span class="n">isNotified</span><span class="o">){</span>
</span><span class='line'>            <span class="k">this</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">isNotified</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">doNotify</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">isNotified</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">notify</span><span class="o">();</span>  <span class="c1">//唤醒等待当前QueueObject对象的线程</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">this</span> <span class="o">==</span> <span class="n">o</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>首先注意到lock()方法不在声明为synchronized，取而代之的是对必需同步的代码，在synchronized中进行嵌套。</p>

<p>FairLock新创建了一个QueueObject的实例，并对每个调用lock()的线程进行入队列。调用unlock()的线程将从队列头部获取QueueObject，并对其调用doNotify()，以唤醒在该对象上等待的线程。通过这种方式，在同一时间仅有一个等待线程获得唤醒，而不是所有的等待线程。这也是实现FairLock公平性的核心所在。</p>

<p>请注意，在同一个同步块中，锁状态依然被检查和设置，以避免出现滑漏条件。</p>

<p>还需注意到，QueueObject实际是一个信号量(Semaphore)。doWait()和doNotify()方法在QueueObject中保存着信号。这样做以避免一个线程在调用queueObject.doWait()之前被另一个调用unlock()并随之调用queueObject.doNotify()的线程重入，从而导致信号丢失。queueObject.doWait()调用放置在synchronized(this)块之外，以避免被monitor嵌套锁死，所以另外的线程可以解锁，只要当没有线程在lock方法的synchronized(this)块中执行即可。</p>

<p>最后，注意到queueObject.doWait()在try – catch块中是怎样调用的。在InterruptedException抛出的情况下，线程得以离开lock()，并需让它从队列中移除。</p>

<h1>4.ReentrantLock源码</h1>

<p>ReentrantLock是java中可重入锁的一个实现,一次只能有一个线程持有锁，也即所谓独占锁的概念。它包含三个内部类:Sync、NonfairSync、FairSync，通过构造函数的参数来指定锁是否是公平的，下面是一些核心代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReentrantLock</span> <span class="kd">implements</span> <span class="n">Lock</span><span class="o">,</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">Serializable</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Sync</span> <span class="n">sync</span><span class="o">;</span>
</span><span class='line'>    <span class="c1">//默认是不公平锁</span>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">ReentrantLock</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">sync</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">NonfairSync</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="c1">//参数fair决定,true为公平锁实现,false为非公平锁实现</span>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">ReentrantLock</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">fair</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">sync</span> <span class="o">=</span> <span class="o">(</span><span class="n">fair</span><span class="o">)?</span> <span class="k">new</span> <span class="nf">FairSync</span><span class="o">()</span> <span class="o">:</span> <span class="k">new</span> <span class="nf">NonfairSync</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">sync</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="c1">//不公平锁</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">tryLock</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">nonfairTryAcquire</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="c1">//带超时时间的锁</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">tryLock</span><span class="o">(</span><span class="kt">long</span> <span class="n">timeout</span><span class="o">,</span> <span class="n">TimeUnit</span> <span class="n">unit</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">tryAcquireNanos</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">unit</span><span class="o">.</span><span class="na">toNanos</span><span class="o">(</span><span class="n">timeout</span><span class="o">));</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">unlock</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">sync</span><span class="o">.</span><span class="na">release</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="c1">//是否有线程等待当前锁</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">hasQueuedThreads</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">hasQueuedThreads</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="o">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们可以发现,ReentrantLock都是把具体实现委托给内部类(Sync、NonfairSync、FairSync),ReentrantLock的重入计数是使用AbstractQueuedSynchronizer的state属性的，state大于0表示锁被占用、等于0表示空闲，小于0则是重入次数太多导致溢出了.</p>

<h3>4.1 ReentrantLock.Sync</h3>

<p>Sync类代码如下:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">static</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Sync</span> <span class="kd">extends</span> <span class="n">AbstractQueuedSynchronizer</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//非公平获取,公平锁和非公平锁都需要这个方法</span>
</span><span class='line'>        <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">nonfairTryAcquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">acquires</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="kd">final</span> <span class="n">Thread</span> <span class="n">current</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">getState</span><span class="o">();</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>   <span class="c1">//state == 0表示无锁</span>
</span><span class='line'>                <span class="c1">//CAS确保即使有多个线程竞争锁也是安全的</span>
</span><span class='line'>                <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetState</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">acquires</span><span class="o">))</span> <span class="o">{</span>  <span class="c1">//加锁成功  </span>
</span><span class='line'>                    <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="n">current</span><span class="o">);</span>   <span class="c1">//设置当前持有锁的线程</span>
</span><span class='line'>                    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>                        <span class="c1">//获取成功</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">current</span> <span class="o">==</span> <span class="n">getExclusiveOwnerThread</span><span class="o">())</span> <span class="o">{</span><span class="c1">//当前线程正是锁持有者</span>
</span><span class='line'>                <span class="kt">int</span> <span class="n">nextc</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">acquires</span><span class="o">;</span>
</span><span class='line'>                <span class="k">if</span> <span class="o">(</span><span class="n">nextc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="c1">// 被锁次数上溢(很少出现)</span>
</span><span class='line'>                    <span class="k">throw</span> <span class="k">new</span> <span class="nf">Error</span><span class="o">(</span><span class="s">&quot;Maximum lock count exceeded&quot;</span><span class="o">);</span>
</span><span class='line'>                <span class="c1">//锁被持有的情况下,只有持有者才能更新锁保护的资源</span>
</span><span class='line'>                <span class="n">setState</span><span class="o">(</span><span class="n">nextc</span><span class="o">);</span>
</span><span class='line'>                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="c1">//释放</span>
</span><span class='line'>        <span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">tryRelease</span><span class="o">(</span><span class="kt">int</span> <span class="n">releases</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">getState</span><span class="o">()</span> <span class="o">-</span> <span class="n">releases</span><span class="o">;</span>
</span><span class='line'>            <span class="c1">//只有锁的持有者才能释放锁</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">()</span> <span class="o">!=</span> <span class="n">getExclusiveOwnerThread</span><span class="o">())</span>
</span><span class='line'>                <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalMonitorStateException</span><span class="o">();</span>
</span><span class='line'>            <span class="kt">boolean</span> <span class="n">free</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>   <span class="c1">//锁被释放</span>
</span><span class='line'>                <span class="n">free</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>                <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>            <span class="n">setState</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">free</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="c1">//当前线程是否持有锁</span>
</span><span class='line'>        <span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">isHeldExclusively</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="nf">getExclusiveOwnerThread</span><span class="o">()</span> <span class="o">==</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="kd">final</span> <span class="n">ConditionObject</span> <span class="nf">newCondition</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="k">new</span> <span class="nf">ConditionObject</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//锁的持有者</span>
</span><span class='line'>        <span class="kd">final</span> <span class="n">Thread</span> <span class="nf">getOwner</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="nf">getState</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">getExclusiveOwnerThread</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="c1">//加锁次数</span>
</span><span class='line'>        <span class="kd">final</span> <span class="kt">int</span> <span class="nf">getHoldCount</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="nf">isHeldExclusively</span><span class="o">()</span> <span class="o">?</span> <span class="n">getState</span><span class="o">()</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="c1">//是否上锁,根据state字段可以判断</span>
</span><span class='line'>        <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">isLocked</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="nf">getState</span><span class="o">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>4.2 ReentrantLock.NonfairSync</h3>

<p>公平锁的实现:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">final</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">NonfairSync</span> <span class="kd">extends</span> <span class="n">Sync</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>     <span class="c1">// 执行lock,尝试立即闯入，失败就退回常规流程</span>
</span><span class='line'>    <span class="kd">final</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetState</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">))</span>   <span class="c1">//比较并设置state,成功则表示获取成功</span>
</span><span class='line'>            <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">());</span><span class="c1">//锁持有者</span>
</span><span class='line'>        <span class="k">else</span>
</span><span class='line'>            <span class="nf">acquire</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span><span class="c1">//获取失败，进入常规流程：acquire会首先调用tryAcquire</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">tryAcquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">acquires</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="nf">nonfairTryAcquire</span><span class="o">(</span><span class="n">acquires</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>acquire的实现(AbstractQueuedSynchronizer.java):</p>

<pre><code>public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;&amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
</code></pre>

<p>就是说常规流程下,首先会执行Sync类中非公平获取(nonfairTryAcquire(1))的过程.</p>

<h3>4.3 ReentrantLock.FairSync</h3>

<p>非公平锁的实现:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">final</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">FairSync</span> <span class="kd">extends</span> <span class="n">Sync</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">//见AbstractQueuedSynchronizer.java, 4.2节有</span>
</span><span class='line'>    <span class="kd">final</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">acquire</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//公平版本的tryAcquire,除非是递归调用或没有等待者或者是第一个，否则不授予访问</span>
</span><span class='line'>    <span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">tryAcquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">acquires</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">final</span> <span class="n">Thread</span> <span class="n">current</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">getState</span><span class="o">();</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="c1">//是等待队列的第一个等待者</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">isFirst</span><span class="o">(</span><span class="n">current</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
</span><span class='line'>                <span class="n">compareAndSetState</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">acquires</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="n">current</span><span class="o">);</span>   <span class="c1">//加锁成功</span>
</span><span class='line'>                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="c1">//当前线程正是线程的持有者</span>
</span><span class='line'>        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">current</span> <span class="o">==</span> <span class="n">getExclusiveOwnerThread</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">nextc</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">acquires</span><span class="o">;</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">nextc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>  <span class="c1">//溢出</span>
</span><span class='line'>                <span class="k">throw</span> <span class="k">new</span> <span class="nf">Error</span><span class="o">(</span><span class="s">&quot;Maximum lock count exceeded&quot;</span><span class="o">);</span>
</span><span class='line'>            <span class="n">setState</span><span class="o">(</span><span class="n">nextc</span><span class="o">);</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>isFirst的实现,即等待队列为空或者当前线程为等待队列的第一个元素:</p>

<pre><code>final boolean isFirst(Thread current) {
    Node h, s;
    return ((h = head) == null ||
            ((s = h.next) != null &amp;&amp; s.thread == current) ||
            fullIsFirst(current));
}
</code></pre>

<h3>4.4 lock() VS lockInterruptibly()</h3>

<p>先说线程请求锁的几个方法:</p>

<pre><code>lock():拿不到lock就不罢休，不然线程就一直block;
tryLock():马上返回，拿到lock就返回true，不然返回false;
带时间限制的tryLock():拿不到lock，就等一段时间，超时返回false;
</code></pre>

<p>先说说线程的打扰机制，每个线程都有一个 打扰 标志。这里分两种情况:</p>

<pre><code>1. 线程在sleep或wait,join， 此时如果别的进程调用此进程的 interrupt（）方法，此线程会被唤醒并被要求处理InterruptedException；
2. 此线程在运行中，则不会收到提醒。但是 此线程的 “打扰标志”会被设置， 可以通过isInterrupted()查看并作出处理。
</code></pre>

<p>lockInterruptibly()和上面的第一种情况是一样的，线程在请求lock并被阻塞时，如果被interrupt，则“此线程会被唤醒并被要求处理InterruptedException”。</p>

<h1>5.读写锁</h1>

<p>假设你的程序中涉及到对一些共享资源的读和写操作，且写操作没有读操作那么频繁。在没有写操作的时候，两个线程同时读一个资源没有任何问题，所以应该允许多个线程能在同时读取共享资源;但是如果有一个线程想去写这些共享资源，就不应该再有其它线程对该资源进行读或写（也就是说：读-读能共存，读-写不能共存，写-写不能共存）,这就需要一个读/写锁来解决这个问题。</p>

<h3>5.1 读/写锁的Java实现</h3>

<p>如果某个线程想要读取资源，只要没有线程正在对该资源进行写操作且没有线程请求对该资源的写操作即可。我们假设对写操作的请求比对读操作的请求更重要，即需要提升写请求的优先级;</p>

<p>此外，如果读操作发生的比较频繁，我们又没有提升写操作的优先级，那么就会产生“饥饿”现象,请求写操作的线程会一直阻塞，直到所有的读线程都从ReadWriteLock上解锁了(因为多个读可以共存),如果一直保证新线程的读操作权限，那么等待写操作的线程就会一直阻塞下去，结果就是发生“饥饿”;</p>

<p>因此，只有当没有线程正在锁住ReadWriteLock进行写操作，且没有线程请求该锁准备执行写操作时，才能保证读操作继续.</p>

<p>根据上面的描述,我们可以对读写访问资源的条件做个概述:</p>

<pre><code>读:没有线程正在做写操作，且没有线程在请求写操作
写:没有线程正在做读写操作
</code></pre>

<p>按照上面的叙述，简单的实现出一个读/写锁，代码如下:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReadWriteLock</span><span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">readers</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>        <span class="c1">//在读线程数</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">writers</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>        <span class="c1">//在写线程数目</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">writeRequests</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">//请求写线程数目</span>
</span><span class='line'>    <span class="c1">//尝试读加锁,有写或者有写请求时候,等待</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">lockRead</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">{</span>
</span><span class='line'>        <span class="k">while</span><span class="o">(</span><span class="n">writers</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">writeRequests</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
</span><span class='line'>            <span class="n">wait</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">readers</span><span class="o">++;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="c1">//读解锁</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">unlockRead</span><span class="o">(){</span>
</span><span class='line'>        <span class="n">readers</span><span class="o">--;</span>
</span><span class='line'>        <span class="n">notifyAll</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="c1">//尝试写加锁</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">lockWrite</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">{</span>
</span><span class='line'>        <span class="n">writeRequests</span><span class="o">++;</span>
</span><span class='line'>        <span class="c1">//有在读或者在在写的线程</span>
</span><span class='line'>        <span class="k">while</span><span class="o">(</span><span class="n">readers</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">writers</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
</span><span class='line'>            <span class="n">wait</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">writeRequests</span><span class="o">--;</span>
</span><span class='line'>        <span class="n">writers</span><span class="o">++;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="c1">//写解锁</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">unlockWrite</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">{</span>
</span><span class='line'>        <span class="n">writers</span><span class="o">--;</span>
</span><span class='line'>        <span class="n">notifyAll</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在两个释放锁的方法（unlockRead，unlockWrite）中，都调用了notifyAll方法，而不是notify。要解释这个原因，我们可以想象下面一种情形：</p>

<p>如果有线程在等待获取读锁，同时又有线程在等待获取写锁。如果这时其中一个等待读锁的线程被notify方法唤醒，但因为此时仍有请求写锁的线程存在（writeRequests>0），所以被唤醒的线程会再次进入阻塞状态。然而，等待写锁的线程一个也没被唤醒，就像什么也没发生过一样（出现了所谓的信号丢失现象）。如果用的是notifyAll方法，所有的线程都会被唤醒，然后判断能否获得其请求的锁。</p>

<p>用notifyAll还有一个好处。如果有多个读线程在等待读锁且没有线程在等待写锁时，调用unlockWrite()后，所有等待读锁的线程都能立马成功获取读锁(共享读锁),而不是一次只允许一个。</p>

<h3>5.2 读/写锁的重入</h3>

<p>上面实现的读/写锁(ReadWriteLock) 是不可重入的，当一个已经持有写锁的线程再次请求写锁时，就会被阻塞。原因是已经有一个写线程了(就是它自己)。此外，考虑下面的例子：</p>

<pre><code>Thread 1 获得了读锁
Thread 2 请求写锁，但因为Thread 1 持有了读锁，所以写锁请求被阻塞。
Thread 1 再想请求一次读锁，但因为Thread 2处于请求写锁的状态，所以想再次获取读锁也会被阻塞。
</code></pre>

<p>上面这种情形使用前面的ReadWriteLock就会被锁定,即一种类似于死锁的情形。导致不会再有线程能够成功获取读锁或写锁了。</p>

<p>为了让ReadWriteLock可重入，需要对它做一些改进,下面会分别处理读锁的重入和写锁的重入。</p>

<h3>5.3 读锁重入</h3>

<p>了让ReadWriteLock的读锁可重入，我们要先为读锁重入建立规则：</p>

<pre><code>要保证某个线程中的读锁可重入，要么满足获取读锁的条件(没有写或写请求)，要么已经持有读锁(不管是否有写请求).
</code></pre>

<p>要确定一个线程是否已经持有读锁，可以用一个map来存储已经持有读锁的线程以及对应线程获取读锁的次数,即Map&lt;thread, count>，当需要判断某个线程能否获得读锁时，就利用map中存储的数据进行判断。下面是方法lockRead和unlockRead修改后的的代码(省略了写锁代码)：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReadWriteLock</span><span class="o">{</span>
</span><span class='line'>    <span class="c1">//读锁计数器,记录当前持有读锁的线程以及加锁次数</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Thread</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">readingThreads</span> <span class="o">=</span>
</span><span class='line'>        <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Thread</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;();</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">writers</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">writeRequests</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">lockRead</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">{</span>
</span><span class='line'>        <span class="n">Thread</span> <span class="n">callingThread</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
</span><span class='line'>        <span class="k">while</span><span class="o">(!</span><span class="n">canGrantReadAccess</span><span class="o">(</span><span class="n">callingThread</span><span class="o">)){</span>
</span><span class='line'>            <span class="n">wait</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">readingThreads</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">callingThread</span><span class="o">,</span> <span class="o">(</span><span class="n">getAccessCount</span><span class="o">(</span><span class="n">callingThread</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">));</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">unlockRead</span><span class="o">(){</span>
</span><span class='line'>        <span class="n">Thread</span> <span class="n">callingThread</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">accessCount</span> <span class="o">=</span> <span class="n">getAccessCount</span><span class="o">(</span><span class="n">callingThread</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">accessCount</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>  <span class="c1">//加锁次数为0了</span>
</span><span class='line'>            <span class="n">readingThreads</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">callingThread</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">readingThreads</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">callingThread</span><span class="o">,</span> <span class="o">(</span><span class="n">accessCount</span> <span class="o">-</span><span class="mi">1</span><span class="o">));</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">notifyAll</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="c1">//判断当前线程能否获得读锁</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">canGrantReadAccess</span><span class="o">(</span><span class="n">Thread</span> <span class="n">callingThread</span><span class="o">){</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">writers</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">isReader</span><span class="o">(</span><span class="n">callingThread</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">writeRequests</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="c1">//获取这个读锁目前的加锁次数</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">getReadAccessCount</span><span class="o">(</span><span class="n">Thread</span> <span class="n">callingThread</span><span class="o">){</span>
</span><span class='line'>        <span class="n">Integer</span> <span class="n">accessCount</span> <span class="o">=</span> <span class="n">readingThreads</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">callingThread</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">accessCount</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">accessCount</span><span class="o">.</span><span class="na">intValue</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="c1">//当前线程是否为已加锁的读锁</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isReader</span><span class="o">(</span><span class="n">Thread</span> <span class="n">callingThread</span><span class="o">){</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">readingThreads</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">callingThread</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>代码中我们可以看到(canGrantReadAccess函数)，只有在没有线程拥有写锁的情况下才允许读锁的重入,此外，重入的读锁比写锁请求优先级高。</p>

<h3>5.4 写锁重入</h3>

<p>因为写锁是排他锁,写锁的可重入规则比较简单:</p>

<pre><code>仅当一个线程已经持有写锁，才允许写锁重入（再次获得写锁）。
</code></pre>

<p>下面是方法lockWrite和unlockWrite修改后的的代码(省略了写锁的代码):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReadWriteLock</span><span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Thread</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">readingThreads</span> <span class="o">=</span>
</span><span class='line'>        <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Thread</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;();</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">writeAccesses</span>    <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">writeRequests</span>    <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Thread</span> <span class="n">writingThread</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>    <span class="c1">//当前的写锁线程</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">lockWrite</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">{</span>
</span><span class='line'>        <span class="n">writeRequests</span><span class="o">++;</span>
</span><span class='line'>        <span class="n">Thread</span> <span class="n">callingThread</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
</span><span class='line'>        <span class="k">while</span><span class="o">(!</span><span class="n">canGrantWriteAccess</span><span class="o">(</span><span class="n">callingThread</span><span class="o">)){</span>
</span><span class='line'>            <span class="n">wait</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">writeRequests</span><span class="o">--;</span>
</span><span class='line'>        <span class="n">writeAccesses</span><span class="o">++;</span>
</span><span class='line'>        <span class="n">writingThread</span> <span class="o">=</span> <span class="n">callingThread</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">unlockWrite</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">{</span>
</span><span class='line'>        <span class="n">writeAccesses</span><span class="o">--;</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">writeAccesses</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
</span><span class='line'>            <span class="n">writingThread</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">notifyAll</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="c1">//判断能否加写锁</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">canGrantWriteAccess</span><span class="o">(</span><span class="n">Thread</span> <span class="n">callingThread</span><span class="o">){</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">hasReaders</span><span class="o">())</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">writingThread</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(!</span><span class="n">isWriter</span><span class="o">(</span><span class="n">callingThread</span><span class="o">))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="c1">//有线程正持有读锁</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">hasReaders</span><span class="o">(){</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">readingThreads</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="c1">//请求线程是否为当前已加写锁的线程</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isWriter</span><span class="o">(</span><span class="n">Thread</span> <span class="n">callingThread</span><span class="o">){</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">writingThread</span> <span class="o">==</span> <span class="n">callingThread</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>5.5 读锁升级到写锁</h3>

<p>有时，我们希望一个拥有读锁的线程，也能获得写锁。想要允许这样的操作，要求这个线程是唯一一个拥有读锁的线程(因为写锁是排他锁)。writeLock()需要做点改动来达到这个目的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReadWriteLock</span><span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Thread</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">readingThreads</span> <span class="o">=</span>
</span><span class='line'>        <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Thread</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;();</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">writeAccesses</span>    <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">writeRequests</span>    <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Thread</span> <span class="n">writingThread</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">lockWrite</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">{</span>
</span><span class='line'>        <span class="n">writeRequests</span><span class="o">++;</span>
</span><span class='line'>        <span class="n">Thread</span> <span class="n">callingThread</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
</span><span class='line'>        <span class="k">while</span><span class="o">(!</span><span class="n">canGrantWriteAccess</span><span class="o">(</span><span class="n">callingThread</span><span class="o">)){</span>
</span><span class='line'>            <span class="n">wait</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">writeRequests</span><span class="o">--;</span>
</span><span class='line'>        <span class="n">writeAccesses</span><span class="o">++;</span>
</span><span class='line'>        <span class="n">writingThread</span> <span class="o">=</span> <span class="n">callingThread</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">unlockWrite</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">{</span>
</span><span class='line'>        <span class="n">writeAccesses</span><span class="o">--;</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">writeAccesses</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
</span><span class='line'>            <span class="n">writingThread</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">notifyAll</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="c1">//能否获得写锁,如果是当前唯一的一个读锁,则可以升级获得写锁</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">canGrantWriteAccess</span><span class="o">(</span><span class="n">Thread</span> <span class="n">callingThread</span><span class="o">){</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">isOnlyReader</span><span class="o">(</span><span class="n">callingThread</span><span class="o">))</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">hasReaders</span><span class="o">())</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">writingThread</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(!</span><span class="n">isWriter</span><span class="o">(</span><span class="n">callingThread</span><span class="o">))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">hasReaders</span><span class="o">(){</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">readingThreads</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isWriter</span><span class="o">(</span><span class="n">Thread</span> <span class="n">callingThread</span><span class="o">){</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">writingThread</span> <span class="o">==</span> <span class="n">callingThread</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="c1">//当前持有锁的线程是否为唯一的读锁线程</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isOnlyReader</span><span class="o">(</span><span class="n">Thread</span> <span class="n">callingThread</span><span class="o">){</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">readers</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">readingThreads</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">callingThread</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>5.6 写锁降级到读锁</h3>

<p>有时拥有写锁的线程也希望得到读锁。如果一个线程拥有了写锁，那么自然其它线程是不可能拥有读锁或写锁了。所以对于一个拥有写锁的线程，再获得读锁，是不会有什么危险的。</p>

<p>我们仅仅需要对上面canGrantReadAccess方法进行简单地修改：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReadWriteLock</span><span class="o">{</span>
</span><span class='line'>    <span class="c1">//能否获得读锁,当当前持有的线程为一个写锁线程,则可以</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">canGrantReadAccess</span><span class="o">(</span><span class="n">Thread</span> <span class="n">callingThread</span><span class="o">){</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">isWriter</span><span class="o">(</span><span class="n">callingThread</span><span class="o">))</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">writingThread</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">isReader</span><span class="o">(</span><span class="n">callingThread</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">writeRequests</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>5.7 可重入的ReadWriteLock的完整实现</h3>

<p>下面是完整的ReadWriteLock实现:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReadWriteLock</span><span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Thread</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">readingThreads</span> <span class="o">=</span>
</span><span class='line'>        <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Thread</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;();</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">writeAccesses</span>    <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">writeRequests</span>    <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Thread</span> <span class="n">writingThread</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">lockRead</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">{</span>
</span><span class='line'>        <span class="n">Thread</span> <span class="n">callingThread</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
</span><span class='line'>        <span class="k">while</span><span class="o">(!</span><span class="n">canGrantReadAccess</span><span class="o">(</span><span class="n">callingThread</span><span class="o">)){</span>
</span><span class='line'>            <span class="n">wait</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">readingThreads</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">callingThread</span><span class="o">,</span>
</span><span class='line'>            <span class="o">(</span><span class="n">getReadAccessCount</span><span class="o">(</span><span class="n">callingThread</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">));</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">canGrantReadAccess</span><span class="o">(</span><span class="n">Thread</span> <span class="n">callingThread</span><span class="o">){</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">isWriter</span><span class="o">(</span><span class="n">callingThread</span><span class="o">))</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">hasWriter</span><span class="o">())</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">isReader</span><span class="o">(</span><span class="n">callingThread</span><span class="o">))</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">hasWriteRequests</span><span class="o">())</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">unlockRead</span><span class="o">(){</span>
</span><span class='line'>        <span class="n">Thread</span> <span class="n">callingThread</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(!</span><span class="n">isReader</span><span class="o">(</span><span class="n">callingThread</span><span class="o">)){</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalMonitorStateException</span><span class="o">(</span>
</span><span class='line'>                <span class="s">&quot;Calling Thread does not&quot;</span> <span class="o">+</span>
</span><span class='line'>                <span class="s">&quot; hold a read lock on this ReadWriteLock&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">accessCount</span> <span class="o">=</span> <span class="n">getReadAccessCount</span><span class="o">(</span><span class="n">callingThread</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">accessCount</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
</span><span class='line'>            <span class="n">readingThreads</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">callingThread</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">readingThreads</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">callingThread</span><span class="o">,</span> <span class="o">(</span><span class="n">accessCount</span> <span class="o">-</span><span class="mi">1</span><span class="o">));</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">notifyAll</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">lockWrite</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">{</span>
</span><span class='line'>        <span class="n">writeRequests</span><span class="o">++;</span>
</span><span class='line'>        <span class="n">Thread</span> <span class="n">callingThread</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
</span><span class='line'>        <span class="k">while</span><span class="o">(!</span><span class="n">canGrantWriteAccess</span><span class="o">(</span><span class="n">callingThread</span><span class="o">)){</span>
</span><span class='line'>            <span class="n">wait</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">writeRequests</span><span class="o">--;</span>
</span><span class='line'>        <span class="n">writeAccesses</span><span class="o">++;</span>
</span><span class='line'>        <span class="n">writingThread</span> <span class="o">=</span> <span class="n">callingThread</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">unlockWrite</span><span class="o">()</span>
</span><span class='line'>        <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">{</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(!</span><span class="n">isWriter</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">()){</span>
</span><span class='line'>        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalMonitorStateException</span><span class="o">(</span>
</span><span class='line'>            <span class="s">&quot;Calling Thread does not&quot;</span> <span class="o">+</span>
</span><span class='line'>            <span class="s">&quot; hold the write lock on this ReadWriteLock&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">writeAccesses</span><span class="o">--;</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">writeAccesses</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
</span><span class='line'>            <span class="n">writingThread</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">notifyAll</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">canGrantWriteAccess</span><span class="o">(</span><span class="n">Thread</span> <span class="n">callingThread</span><span class="o">){</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">isOnlyReader</span><span class="o">(</span><span class="n">callingThread</span><span class="o">))</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">hasReaders</span><span class="o">())</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">writingThread</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(!</span><span class="n">isWriter</span><span class="o">(</span><span class="n">callingThread</span><span class="o">))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">getReadAccessCount</span><span class="o">(</span><span class="n">Thread</span> <span class="n">callingThread</span><span class="o">){</span>
</span><span class='line'>        <span class="n">Integer</span> <span class="n">accessCount</span> <span class="o">=</span> <span class="n">readingThreads</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">callingThread</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">accessCount</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">accessCount</span><span class="o">.</span><span class="na">intValue</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">hasReaders</span><span class="o">(){</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">readingThreads</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isReader</span><span class="o">(</span><span class="n">Thread</span> <span class="n">callingThread</span><span class="o">){</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">readingThreads</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">callingThread</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isOnlyReader</span><span class="o">(</span><span class="n">Thread</span> <span class="n">callingThread</span><span class="o">){</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">readingThreads</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
</span><span class='line'>            <span class="n">readingThreads</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">callingThread</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">hasWriter</span><span class="o">(){</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">writingThread</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isWriter</span><span class="o">(</span><span class="n">Thread</span> <span class="n">callingThread</span><span class="o">){</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">writingThread</span> <span class="o">==</span> <span class="n">callingThread</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">hasWriteRequests</span><span class="o">(){</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">writeRequests</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在利用ReadWriteLock来保护临界区时，如果临界区可能抛出异常，在finally块中调用readUnlock()和writeUnlock()就显得很重要了。这样做是为了保证ReadWriteLock能被成功解锁，然后其它线程可以请求到该锁:</p>

<pre><code>lock.lockWrite();
try{
    //do critical section code, which may throw exception
} finally {
    lock.unlockWrite();
}
</code></pre>

<h1>6.ReentrantReadWriteLock源码</h1>

<p>ReentrantLock 实现了标准的互斥操作，也就是一次只能有一个线程持有锁，也即所谓独占锁的概念。前面的章节中一直在强调这个特点。显然这个特点在一定程度上面减低了吞吐量，实际上独占锁是一种保守的锁策略，在这种情况下任何“读/读”，“写/读”，“写/写”操作都不能同时发生。</p>

<p>读写锁使用的场合是一个共享资源被大量读取操作，而只有少量的写操作（修改数据）.</p>

<p>ReentrantReadWriteLock是java中可重入读写锁的一个实现.包含五个内部类:Sync,NonfairSync,FairSync,ReadLock,WriteLock.其中Sync,NonfairSync,FairSync用上公平锁和非公平锁的实现,ReadLock和WriteLock分别用于实现读锁和写锁.</p>

<p>ReentrantReadWriteLock的一些特性:</p>

<pre><code>(1).写线程获取写入锁后可以获取读取锁，然后释放写入锁，这样就从写入锁变成了读取锁，从而实现锁降级的特性;读取锁是不能直接升级为写入锁的;
(2).读取锁和写入锁的数量最大分别只能是65535;
</code></pre>

<h3>6.1 ReentrantReadWriteLock一些关键的方法:</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReentrantReadWriteLock</span> <span class="kd">implements</span> <span class="n">ReadWriteLock</span><span class="o">,</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">Serializable</span>  <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="n">ReentrantReadWriteLock</span><span class="o">.</span><span class="na">ReadLock</span> <span class="n">readerLock</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="n">ReentrantReadWriteLock</span><span class="o">.</span><span class="na">WriteLock</span> <span class="n">writerLock</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Sync</span> <span class="n">sync</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//默认实现是非公平的</span>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">ReentrantReadWriteLock</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">ReentrantReadWriteLock</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">fair</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">sync</span> <span class="o">=</span> <span class="o">(</span><span class="n">fair</span><span class="o">)?</span> <span class="k">new</span> <span class="nf">FairSync</span><span class="o">()</span> <span class="o">:</span> <span class="k">new</span> <span class="nf">NonfairSync</span><span class="o">();</span>
</span><span class='line'>        <span class="n">readerLock</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ReadLock</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span><span class='line'>        <span class="n">writerLock</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">WriteLock</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getReadLockCount</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">getReadLockCount</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isWriteLocked</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">isWriteLocked</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="c1">//是否由当前线程持有写锁</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isWriteLockedByCurrentThread</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">isHeldExclusively</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="c1">//读锁等待队列</span>
</span><span class='line'>    <span class="kd">protected</span> <span class="n">Collection</span><span class="o">&lt;</span><span class="n">Thread</span><span class="o">&gt;</span> <span class="nf">getQueuedWriterThreads</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">getExclusiveQueuedThreads</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="c1">//写锁等待队列</span>
</span><span class='line'>    <span class="kd">protected</span> <span class="n">Collection</span><span class="o">&lt;</span><span class="n">Thread</span><span class="o">&gt;</span> <span class="nf">getQueuedReaderThreads</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">getSharedQueuedThreads</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>6.2 读锁实现:</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">ReadLock</span> <span class="kd">implements</span> <span class="n">Lock</span><span class="o">,</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">Serializable</span>  <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Sync</span> <span class="n">sync</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//加锁(共享锁)</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">sync</span><span class="o">.</span><span class="na">acquireShared</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span>  <span class="kt">boolean</span> <span class="nf">tryLock</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">tryReadLock</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">tryLock</span><span class="o">(</span><span class="kt">long</span> <span class="n">timeout</span><span class="o">,</span> <span class="n">TimeUnit</span> <span class="n">unit</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">tryAcquireSharedNanos</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">unit</span><span class="o">.</span><span class="na">toNanos</span><span class="o">(</span><span class="n">timeout</span><span class="o">));</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="c1">//解锁</span>
</span><span class='line'>    <span class="kd">public</span>  <span class="kt">void</span> <span class="nf">unlock</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">sync</span><span class="o">.</span><span class="na">releaseShared</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>6.3 写锁实现:</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">WriteLock</span> <span class="kd">implements</span> <span class="n">Lock</span><span class="o">,</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">Serializable</span>  <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Sync</span> <span class="n">sync</span><span class="o">;</span>
</span><span class='line'>    <span class="c1">//排他锁</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">sync</span><span class="o">.</span><span class="na">acquire</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">tryLock</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">tryWriteLock</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">tryLock</span><span class="o">(</span><span class="kt">long</span> <span class="n">timeout</span><span class="o">,</span> <span class="n">TimeUnit</span> <span class="n">unit</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">tryAcquireNanos</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">unit</span><span class="o">.</span><span class="na">toNanos</span><span class="o">(</span><span class="n">timeout</span><span class="o">));</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">unlock</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">sync</span><span class="o">.</span><span class="na">release</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="c1">//是否有当前线程持有</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isHeldByCurrentThread</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">isHeldExclusively</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="c1">//加锁次数</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getHoldCount</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">getWriteHoldCount</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>6.4 state</h3>

<p>ReentrantLock和ReentrantReadWriteLock的实现很多细节都是由借由AbstractQueuedSynchronizer实现.</p>

<p>AQS中有一个state字段（int类型，32位）用来描述有多少线程获持有锁。在独占锁的时代这个值通常是0或者1（如果是重入的就是重入的次数），在共享锁的时代就是持有锁的数量。</p>

<p>ReentrantLock的锁是排他锁,因此只用来表示重入数.</p>

<p>ReentrantReadWriteLock的读、写锁是相关但是又不一致的，所以需要两个数来描述读锁（共享锁）和写锁（独占锁）的数量。显然现在一个state就不够用了。于是在ReentrantReadWrilteLock里面将这个字段一分为二，高位16位表示共享锁的数量，低位16位表示独占锁的数量（或者重入数量）,这就是上节中提到的为什么共享锁和独占锁的数量(包括重入次数)最大只能是65535的原因了.</p>

<p>我们可以借此分析写入锁获取片段:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">tryAcquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">acquires</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">Thread</span> <span class="n">current</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">getState</span><span class="o">();</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">exclusiveCount</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">//有读锁或者写锁持有者不是当前线程</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">w</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">current</span> <span class="o">!=</span> <span class="n">getExclusiveOwnerThread</span><span class="o">())</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">w</span> <span class="o">+</span> <span class="n">exclusiveCount</span><span class="o">(</span><span class="n">acquires</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">MAX_COUNT</span><span class="o">)</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">Error</span><span class="o">(</span><span class="s">&quot;Maximum lock count exceeded&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">((</span><span class="n">w</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">writerShouldBlock</span><span class="o">(</span><span class="n">current</span><span class="o">))</span> <span class="o">||</span>
</span><span class='line'>        <span class="o">!</span><span class="n">compareAndSetState</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">c</span> <span class="o">+</span> <span class="n">acquires</span><span class="o">))</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>    <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="n">current</span><span class="o">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>exclusiveCount&copy;的实现很简单,就是用掩码去掉高16位(c &amp; EXCLUSIVE_MASK).</p>

<p>writerShouldBlock的实现分为公平锁和非公平锁两个实现,不公平锁的实现</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">writerShouldBlock</span><span class="o">(</span><span class="n">Thread</span> <span class="n">current</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>即在非公平锁中写锁优先级高.</p>

<p>writerShouldBlock公平锁的实现:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">writerShouldBlock</span><span class="o">(</span><span class="n">Thread</span> <span class="n">current</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">// only proceed if queue is empty or current thread at head</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">!</span><span class="n">isFirst</span><span class="o">(</span><span class="n">current</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>即请求写锁的线程不是等待队列的第一个就会被阻塞,即读锁和写锁是公平排队的.</p>

<p>读锁的获取:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">protected</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">tryAcquireShared</span><span class="o">(</span><span class="kt">int</span> <span class="n">unused</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">Thread</span> <span class="n">current</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">getState</span><span class="o">();</span>
</span><span class='line'>    <span class="c1">//有写锁并且写锁持有者不是当前线程(考虑写锁可以降级到读锁)</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">exclusiveCount</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">getExclusiveOwnerThread</span><span class="o">()</span> <span class="o">!=</span> <span class="n">current</span><span class="o">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">sharedCount</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">==</span> <span class="n">MAX_COUNT</span><span class="o">)</span>
</span><span class='line'>        <span class="k">throw</span> <span class="k">new</span> <span class="nf">Error</span><span class="o">(</span><span class="s">&quot;Maximum lock count exceeded&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(!</span><span class="n">readerShouldBlock</span><span class="o">(</span><span class="n">current</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">compareAndSetState</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">c</span> <span class="o">+</span> <span class="n">SHARED_UNIT</span><span class="o">)){</span>
</span><span class='line'>        <span class="n">HoldCounter</span> <span class="n">rh</span> <span class="o">=</span> <span class="n">cachedHoldCounter</span><span class="o">;</span> <span class="c1">//首先访问缓存</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">rh</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">rh</span><span class="o">.</span><span class="na">tid</span> <span class="o">!=</span> <span class="n">current</span><span class="o">.</span><span class="na">getId</span><span class="o">())</span>
</span><span class='line'>            <span class="n">cachedHoldCounter</span> <span class="o">=</span> <span class="n">rh</span> <span class="o">=</span> <span class="n">readHolds</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
</span><span class='line'>        <span class="n">rh</span><span class="o">.</span><span class="na">count</span><span class="o">++;</span>
</span><span class='line'>        <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="nf">fullTryAcquireShared</span><span class="o">(</span><span class="n">current</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里注意到在读锁的获取和释放都用到了一个HoldCounter类,下面会介绍.</p>

<h3>6.5 HoldCounter</h3>

<p>在ReentrantReadWriteLock.Sync中有包含几个内部类:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * 每个线程特定的 read 持有计数。存放在ThreadLocal</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">HoldCounter</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>
</span><span class='line'>    <span class="c1">// 用id而不是引用是为了避免保留垃圾</span>
</span><span class='line'>    <span class="kd">final</span> <span class="kt">long</span> <span class="n">tid</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getId</span><span class="o">();</span>
</span><span class='line'>    <span class="cm">/** Decrement if positive; return previous value */</span>
</span><span class='line'>    <span class="kt">int</span> <span class="nf">tryDecrement</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">count</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
</span><span class='line'>            <span class="n">count</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">c</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * ThreadLocal subclass. Easiest to explicitly define for sake</span>
</span><span class='line'><span class="cm"> * of deserialization mechanics.</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">ThreadLocalHoldCounter</span> <span class="kd">extends</span> <span class="n">ThreadLocal</span><span class="o">&lt;</span><span class="n">HoldCounter</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">HoldCounter</span> <span class="nf">initialValue</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">new</span> <span class="nf">HoldCounter</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">static</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Sync</span> <span class="kd">extends</span> <span class="n">AbstractQueuedSynchronizer</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">//当前线程持有读锁的数目</span>
</span><span class='line'>    <span class="kd">transient</span> <span class="n">ThreadLocalHoldCounter</span> <span class="n">readHolds</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 最近一个成功获取读锁的线程的计数。</span>
</span><span class='line'><span class="cm">     * 通常情况,下一个要释放的线程是最后一个获取线程</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">transient</span> <span class="n">HoldCounter</span> <span class="n">cachedHoldCounter</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到这里使用ThreadLocal将HoldCounter绑定到当前线程上，同时HoldCounter也持有线程Id，这样在释放锁的时候才能知道ReadWriteLock里面缓存的上一个读取线程（cachedHoldCounter）是否是当前线程。这样做的好处是可以减少ThreadLocal.get()的次数，因为这也是一个耗时操作。</p>

<p>需要说明的是这样HoldCounter绑定线程id而不绑定线程对象的原因是避免HoldCounter和ThreadLocal互相绑定而GC难以释放它们,所以其实这样做只是为了帮助GC快速回收对象而已。</p>

<h1>7.参考</h1>

<p><a href="http://tutorials.jenkov.com/java-concurrency/locks.html">http://tutorials.jenkov.com/java-concurrency/locks.html</a>
<a href="http://tutorials.jenkov.com/java-concurrency/starvation-and-fairness.html">http://tutorials.jenkov.com/java-concurrency/starvation-and-fairness.html</a>
<a href="http://ifeve.com/java-concurrency-thread-directory/">http://ifeve.com/java-concurrency-thread-directory/</a>
<a href="http://coderbee.net/index.php/concurrent/20131209/618">http://coderbee.net/index.php/concurrent/20131209/618</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/11/java-atomic/">Java Atomic</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-11-11T18:02:41+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>11</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>6:02 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在多线程环境下,Java里面的++i或者&ndash;i操作不是线程安全的，因为它其实包含了三个操作:获取当前值,++或者&ndash;,写回.
在没有额外资源可以利用的情况下，只能使用加锁才能保证三个操作时“原子性”的.</p>

<p>在Java中，协调对线程间共享字段的访问的传统方法是使用同步，确保完成对共享字段的所有访问，同时具有适当的锁定。带来的问题主要是锁定竞争太厉害（线程常常在其他线程具有锁定时要求获得该锁定那么该线程将被阻塞，直到该锁定可用），会损害吞吐量，因为竞争的同步非常昂贵,另外还存在死锁等问题。对于现代 JVM 而言，无竞争的同步现在非常便宜。</p>

<p>java.util.concurrent.atomic包就是提供原子操作的类的小工具包，支持在单个变量上不用锁定(Lock-Free)的线程安全编程。</p>

<h1>1.Atomic整体介绍</h1>

<h3>1.1 Boolean,Integer,Long和Reference的Atomic版本:</h3>

<pre><code>AtomicBoolean
AtomicInteger
AtomicLong
AtomicReference
</code></pre>

<h3>1.2 Integer,Long,Reference的数组版本:</h3>

<pre><code>AtomicIntegerArray
AtomicLongArray
AtomicReferenceArray
</code></pre>

<h3>1.3 基于反射的原子更新字段操作:</h3>

<pre><code>AtomicIntegerFieldUpdater
AtomicLongFieldUpdater
AtomicReferenceFieldUpdater
</code></pre>

<p>约束:</p>

<pre><code>1. 字段必须是volatile类型的;
2. 字段的描述类型（修饰符public/protected/default/private）是与调用者与操作对象字段的关系一致。也就是说调用者能够直接操作对象字段，那么就可以反射进行原子操作。但是对于父类的字段，子类是不能直接操作的，尽管子类可以访问父类的字段;
3. 只能是实例变量，不能是类变量(static变量);
4. 只能是可修改变量，不能使final变量，因为final的语义就是不可修改,实际上final的语义和volatile是有冲突的，这两个关键字不能同时存在;
5. 对于AtomicIntegerFieldUpdater和AtomicLongFieldUpdater只能修改int/long类型的字段，不能修改其包装类型（Integer/Long）,如果要修改包装类型就需要使用AtomicReferenceFieldUpdater;
</code></pre>

<h3>1.4 AtomicMarkableReference与AtomicStampedReference</h3>

<pre><code>AtomicMarkableReference
AtomicStampedReference
</code></pre>

<p>AtomicMarkableReference类描述的一个&lt;Object,Boolean>的对，可以原子的修改Object或者Boolean的值，这种数据结构在一些缓存或者状态描述中比较有用。这种结构在单个或者同时修改Object/Boolean的时候能够有效的提高吞吐量。</p>

<p>AtomicStampedReference类维护带有整数“标志”的对象引用，可以用原子方式对其进行更新。对比AtomicMarkableReference 类的&lt;Object,Boolean>，AtomicStampedReference 维护的是一种类似&lt;Object,int>的数据结构，其实就是对对象（引用）的一个并发计数。但是与AtomicInteger 不同的是，此数据结构可以携带一个对象引用（Object），并且能够对此对象和计数同时进行原子操作。</p>

<p>在后面的章节中会提到“ABA问题”，而AtomicMarkableReference/AtomicStampedReference 在解决“ABA问题”上很有用。</p>

<h1>2.AtomicInteger实现</h1>

<p>其内部实现不是简单的使用synchronized，而是一个更为高效的方式CAS (compare and swap) + volatile和native方法，从而避免了synchronized的高开销，执行效率大为提升。</p>

<p>native的意思是使用Unsafe类,Unsafe类的功能函数是native的.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AtomicInteger</span> <span class="kd">extends</span> <span class="n">Number</span> <span class="kd">implements</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">Serializable</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Unsafe</span> <span class="n">unsafe</span> <span class="o">=</span> <span class="n">Unsafe</span><span class="o">.</span><span class="na">getUnsafe</span><span class="o">();</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">valueOffset</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">static</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">valueOffset</span> <span class="o">=</span> <span class="n">unsafe</span><span class="o">.</span><span class="na">objectFieldOffset</span>
</span><span class='line'>            <span class="o">(</span><span class="n">AtomicInteger</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">&quot;value&quot;</span><span class="o">));</span>
</span><span class='line'>      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">Error</span><span class="o">(</span><span class="n">ex</span><span class="o">);</span> <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>内部使用unsafe实现,value存真正的int值,valueOffset存value在AtomicInteger对象内的内存偏移地址.</p>

<h3>2.1 volatile语义</h3>

<p>volatile相当于synchronized的弱实现，也就是说volatile实现了类似synchronized的语义，却又没有锁机制.它确保对volatile字段的更新以可预见的方式告知其他的线程.</p>

<p>volatile包含以下语义：</p>

<pre><code>(1).Java存储模型不会对valatile指令的操作进行重排,这个保证对volatile变量的操作时按照指令的出现顺序执行的.
(2).volatile变量不会被缓存在寄存器中（只有拥有线程可见）或者其他对CPU不可见的地方，每次总是从主存中读取volatile变量的结果.也就是说对于volatile变量的修改，其它线程总是可见的，并且不是使用自己线程栈内部的变量。也就是在happens-before法则中，对一个valatile变量的写操作后，其后的任何读操作理解可见此写操作的结果.
</code></pre>

<p>尽管volatile变量的特性不错，但是volatile并不能保证线程安全的，也就是说volatile字段的操作不是原子性的，volatile变量只能保证可见性（一个线程修改后其它线程能够理解看到此变化后的结果）.</p>

<h3>2.2 常用函数</h3>

<p>getAndIncrement()相当于i++</p>

<p>incrementAndGet()相当于++i</p>

<p>getAndDecrement()相当于i&ndash;</p>

<p>decrementAndGet()相当于&ndash;i</p>

<h3>2.3 特殊函数</h3>

<p><strong>2.3.1 set() VS lazySet</strong></p>

<p>set设置为给定值，直接修改原始值；</p>

<p>lazySet延时设置变量值，这个等价于set()方法，但是由于value是volatile类型的，因此此字段的修改会比普通字段(非volatile字段)有稍微的性能延时(尽管可以忽略)，所以如果不是想立即读取设置的新值，允许在“后台”修改值，那么此方法就很有用.</p>

<p><strong>2.3.2 compareAndSet() VS weakCompareAndSet</strong></p>

<p>接受2个参数，一个是期望数据(expected)，一个是新数据(new)；如果atomic里面的数据和期望数据一 致，则将新数据设定给atomic的数据，返回true，表明成功；否则就不设定，并返回false。</p>

<p>按照JSR规范,调用weakCompareAndSet时并不能保证不存在happen- before的发生（也就是可能存在指令重排序导致此操作失败）.</p>

<p>实际实现中,compareAndSet()和weakCompareAndSet没有区别:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">compareAndSet</span><span class="o">(</span><span class="kt">int</span> <span class="n">expect</span><span class="o">,</span> <span class="kt">int</span> <span class="n">update</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">unsafe</span><span class="o">.</span><span class="na">compareAndSwapInt</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">valueOffset</span><span class="o">,</span> <span class="n">expect</span><span class="o">,</span> <span class="n">update</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">weakCompareAndSet</span><span class="o">(</span><span class="kt">int</span> <span class="n">expect</span><span class="o">,</span> <span class="kt">int</span> <span class="n">update</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">unsafe</span><span class="o">.</span><span class="na">compareAndSwapInt</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">valueOffset</span><span class="o">,</span> <span class="n">expect</span><span class="o">,</span> <span class="n">update</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h1>3.CAS操作</h1>

<p>在JDK 5之前Java语言是靠synchronized关键字保证同步的，这会导致有锁.</p>

<p>锁机制存在以下问题：</p>

<pre><code>(1)在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。
(2)一个线程持有锁会导致其它所有需要此锁的线程挂起。
(3)如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。
</code></pre>

<p>volatile是不错的机制，但是volatile不能保证原子性。因此对于同步最终还是要回到锁机制上来。</p>

<h3>3.1 悲观锁和乐观锁</h3>

<p>独占锁是一种悲观锁，synchronized就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁;</p>

<p>而另一个更加有效的锁就是乐观锁。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。</p>

<h3>3.2 比较并交换</h3>

<p>上面的乐观锁用到的机制就是比较并交换(CAS，Compare and Swap).</p>

<p>CAS 操作包含三个操作数:内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。通常将 CAS 用于同步的方式是从地址 V 读取值 A，执行多步计算来获得新值 B，然后使用 CAS 将 V 的值从 A 改为 B。如果 V 处的值尚未同时更改，则 CAS 操作成功。</p>

<p>类似于 CAS 的指令允许算法执行读-修改-写操作，而无需害怕其他线程同时修改变量，因为如果其他线程修改变量，那么 CAS 会检测它（并失败），算法可以对该操作重新计算。</p>

<h3>3.3 硬件同步原语</h3>

<p>大多数现代处理器都包含对多处理的支持。当然这种支持包括多处理器可以共享外部设备和主内存，同时它通常还包括对指令系统的增加来支持多处理的特殊要求。特别是，几乎每个现代处理器都有通过可以检测或阻止其他处理器的并发访问的方式来更新共享变量的指令.</p>

<p>拿出AtomicInteger来研究在没有锁的情况下是如何做到数据正确性的。</p>

<p>首先毫无以为，在没有锁的机制下可能需要借助volatile原语，保证线程间的数据是可见的（共享的）。这样才获取变量的值的时候才能直接读取。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>
</span><span class='line'><span class="o">...</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后来看看++i是怎么做到的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">incrementAndGet</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>  <span class="c1">//重试</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">current</span> <span class="o">=</span> <span class="n">get</span><span class="o">();</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">next</span> <span class="o">=</span> <span class="n">current</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSet</span><span class="o">(</span><span class="n">current</span><span class="o">,</span> <span class="n">next</span><span class="o">))</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">next</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这里采用了CAS操作，每次从内存中读取数据然后将此数据和+1后的结果进行CAS操作，如果成功就返回结果，否则重试直到成功为止。</p>

<p>而compareAndSet利用JNI来完成CPU指令的操作。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">compareAndSet</span><span class="o">(</span><span class="kt">int</span> <span class="n">expect</span><span class="o">,</span> <span class="kt">int</span> <span class="n">update</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">unsafe</span><span class="o">.</span><span class="na">compareAndSwapInt</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">valueOffset</span><span class="o">,</span> <span class="n">expect</span><span class="o">,</span> <span class="n">update</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>整体的过程就是这样子的，利用CPU的CAS指令，同时借助JNI来完成Java的非阻塞算法。</p>

<h1>4.指令重排</h1>

<p>Java语言规范规定了JVM线程内部维持顺序化语义，也就是说只要程序的最终结果等同于它在严格的顺序化环境下的结果，那么指令的执行顺序就可能与代码的顺序不一致,这个过程通过叫做指令的重排序。</p>

<p>指令重排序存在的意义在于：JVM能够根据处理器的特性（CPU的多级缓存系统、多核处理器等）适当的重新排序机器指令，使机器指令更符合CPU的执行特点，最大限度的发挥机器的性能。</p>

<h1>5.Happen-Before</h1>

<p>Java语言中有一个“先行发生”（happen—before）的规则，它是Java内存模型中定义的两项操作之间的偏序关系，如果操作A先行发生于操作B，其意思就是说，在发生操作B之前，操作A产生的影响都能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等，它与时间上的先后发生基本没有太大关系。这个原则特别重要，它是判断数据是否存在竞争、线程是否安全的主要依据。</p>

<p>举例来说，假设存在如下三个线程，分别执行对应的操作:</p>

<pre><code>线程A中执行如下操作：i=1
线程B中执行如下操作：j=i
线程C中执行如下操作：i=2
</code></pre>

<p>假设线程A中的操作”i=1“ happen—before线程B中的操作“j=i”，那么就可以保证在线程B的操作执行后，变量j的值一定为1，即线程B观察到了线程A中操作“i=1”所产生的影响；现在，我们依然保持线程A和线程B之间的happen—before关系，同时线程C出现在了线程A和线程B的操作之间，但是C与B并没有happen—before关系，那么j的值就不确定了，线程C对变量i的影响可能会被线程B观察到，也可能不会，这时线程B就存在读取到不是最新数据的风险，不具备线程安全性。</p>

<h1>6.ABA 问题</h1>

<p>CAS操作通常存在ABA问题.</p>

<p>因为在更改 V 之前，CAS 主要询问“V 的值是否仍为 A”，所以在第一次读取 V 以及对 V 执行 CAS 操作之前，如果将值从 A 改为 B，然后再改回 A，会使基于 CAS 的算法混乱。在这种情况下，CAS 操作会成功，但是在一些情况下，结果可能不是您所预期的。这类问题称为 ABA 问题，通常通过将标记或版本编号与要进行 CAS 操作的每个值相关联，并原子地更新值和标记，来处理这类问题。AtomicStampedReference 类支持这种方法.</p>

<h1>7.参考</h1>

<p><a href="https://www.ibm.com/developerworks/cn/java/j-jtp11234/">https://www.ibm.com/developerworks/cn/java/j-jtp11234/</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/11/javabing-fa-rong-qi/">Java并发容器</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-11-11T17:55:32+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>11</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>5:55 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>这篇博客的目的是了解Java Concurrent包中几个主要的并发容器的实现原理.</p>

<p>这里将这些并发容器分为4类:</p>

<p>(1).BlockingQueue系列</p>

<pre><code>BlockingQueue
BlockingDeque
ArrayBlockingQueue
LinkedBlockingDeque
LinkedBlockingQueue
PriorityBlockingQueue
DelayQueue
</code></pre>

<p>(2).Concurrent系列</p>

<pre><code>ConcurrentHashMap
ConcurrentLinkedQueue
ConcurrentMap
ConcurrentNavigableMap
</code></pre>

<p>(3).SkipList系列</p>

<pre><code>ConcurrentSkipListMap
ConcurrentSkipListSet
</code></pre>

<p>(4).CopyOnWrite系列</p>

<pre><code>CopyOnWriteArrayList
CopyOnWriteArraySet
</code></pre>

<p>后续系列将分别介绍:</p>

<pre><code>1.Java并发容器之BlockingQueue

2.Java并发容器之Concurrent

3.Java并发容器之SkipList

4.Java并发容器之CopyOnWrite
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/08/jie-mi-sun-dot-misc-dot-unsafe/">揭秘sun.misc.Unsafe</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-11-08T00:23:47+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>8</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>12:23 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Java最初被设计为一种安全的受控环境.尽管如此,Java HotSpot还是包含了一个“后门”,它提供了一些可以直接操控内存和线程的低层次操作.这个后门类就是sun.misc.Unsafe,它被JDK广泛用于自己的包中,如java.nio和java.util.concurrent.但是丝毫不建议在生产环境中使用这个后门.因为这个API十分不安全、不轻便、而且不稳定.这个不安全的类提供了一个观察HotSpot JVM内部结构并且可以对其进行修改.</p>

<h1>1.源代码及文档</h1>

<p>源码:<a href="http://www.docjar.com/html/api/sun/misc/Unsafe.java.html">http://www.docjar.com/html/api/sun/misc/Unsafe.java.html</a></p>

<p>文档:<a href="http://www.docjar.com/docs/api/sun/misc/Unsafe.html">http://www.docjar.com/docs/api/sun/misc/Unsafe.html</a></p>

<h1>2.Unsafe身影</h1>

<p>典型的在concurrent包中的Atomic系列的实现中,比如compareAndSet等Atomic实现就是借助于Unsafe类:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AtomicInteger</span> <span class="kd">extends</span> <span class="n">Number</span> <span class="kd">implements</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">Serializable</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Unsafe</span> <span class="n">unsafe</span> <span class="o">=</span> <span class="n">Unsafe</span><span class="o">.</span><span class="na">getUnsafe</span><span class="o">();</span>    <span class="c1">//</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">valueOffset</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">static</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">valueOffset</span> <span class="o">=</span> <span class="n">unsafe</span><span class="o">.</span><span class="na">objectFieldOffset</span>
</span><span class='line'>            <span class="o">(</span><span class="n">AtomicInteger</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">&quot;value&quot;</span><span class="o">));</span>
</span><span class='line'>      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">Error</span><span class="o">(</span><span class="n">ex</span><span class="o">);</span> <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">compareAndSet</span><span class="o">(</span><span class="kt">int</span> <span class="n">expect</span><span class="o">,</span> <span class="kt">int</span> <span class="n">update</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">unsafe</span><span class="o">.</span><span class="na">compareAndSwapInt</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">valueOffset</span><span class="o">,</span> <span class="n">expect</span><span class="o">,</span> <span class="n">update</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h1>3.Unsafe初始化</h1>

<p>sun.misc.Unsafe这个类是如此地不安全,以至于JDK开发者增加了很多特殊限制来访问它.它的构造器是私有的,工厂方法getUnsafe()的调用器只能被Bootloader加载.</p>

<p>在使用Unsafe之前,我们需要创建Unsafe对象的实例.这并不像Unsafe unsafe = new Unsafe()这么简单,因为Unsafe的构造器是私有的.它也有一个静态的getUnsafe()方法,但如果你直接调用Unsafe.getUnsafe(),你可能会得到SecurityException异常.只能从受信任的代码中使用这个方法:</p>

<pre><code>public static Unsafe getUnsafe() {
    Class cc = sun.reflect.Reflection.getCallerClass(2);
    if (cc.getClassLoader() != null)
        throw new SecurityException("Unsafe");
    return theUnsafe;
}
</code></pre>

<p>Unsafe类包含一个私有的、名为theUnsafe的实例,我们可以通过Java反射窃取该变量:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Field</span> <span class="n">f</span> <span class="o">=</span> <span class="n">Unsafe</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">&quot;theUnsafe&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">f</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
</span><span class='line'><span class="n">Unsafe</span> <span class="n">unsafe</span> <span class="o">=</span> <span class="o">(</span><span class="n">Unsafe</span><span class="o">)</span> <span class="n">f</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<h1>4.Unsafe API</h1>

<p>sun.misc.Unsafe类包含105个方法.实际上,对各种实体操作有几组重要方法:</p>

<h3>4.1 Info-仅返回一些低级的内存信息</h3>

<pre><code>addressSize
pageSize
</code></pre>

<h3>4.2 Objects-提供用于操作对象及其字段的方法</h3>

<pre><code>allocateInstance
objectFieldOffset
</code></pre>

<h3>4.3 Classes-提供用于操作类及其静态字段的方法</h3>

<pre><code>staticFieldOffset
defineClass
defineAnonymousClass
ensureClassInitialized
</code></pre>

<h3>4.4 Arrays-操作数组</h3>

<pre><code>arrayBaseOffset
arrayIndexScale
</code></pre>

<h3>4.5 Synchronization-低级的同步原语</h3>

<pre><code>monitorEnter
tryMonitorEnter
monitorExit
compareAndSwapInt
putOrderedInt
</code></pre>

<h3>4.6 Memory-直接内存访问方法</h3>

<pre><code>allocateMemory
copyMemory
freeMemory
getAddress
getInt
putInt
</code></pre>

<h1>5.有趣的Case</h1>

<h3>5.1 避免初始化</h3>

<p>当你想要跳过对象初始化阶段,或绕过构造器的安全检查,或实例化一个没有任何公共构造器的类,allocateInstance方法是非常有用的.考虑以下类：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">long</span> <span class="n">a</span><span class="o">;</span> <span class="c1">// not initialized value</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//构造器</span>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">A</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// initialization</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">a</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">a</span><span class="o">;</span> <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用构造器、反射和unsafe初始化它,将得到不同的结果.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">A</span> <span class="n">o1</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">A</span><span class="o">();</span> <span class="c1">// 构造器</span>
</span><span class='line'><span class="n">o1</span><span class="o">.</span><span class="na">a</span><span class="o">();</span> <span class="c1">// prints 1</span>
</span><span class='line'>
</span><span class='line'><span class="n">A</span> <span class="n">o2</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span> <span class="c1">// 反射</span>
</span><span class='line'><span class="n">o2</span><span class="o">.</span><span class="na">a</span><span class="o">();</span> <span class="c1">// prints 1</span>
</span><span class='line'>
</span><span class='line'><span class="n">A</span> <span class="n">o3</span> <span class="o">=</span> <span class="o">(</span><span class="n">A</span><span class="o">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="na">allocateInstance</span><span class="o">(</span><span class="n">A</span><span class="o">.</span><span class="na">class</span><span class="o">);</span> <span class="c1">// unsafe</span>
</span><span class='line'><span class="n">o3</span><span class="o">.</span><span class="na">a</span><span class="o">();</span> <span class="c1">// prints 0</span>
</span></code></pre></td></tr></table></div></figure>


<p>另外一种情况,当构造器的代价十分昂贵,我们可以绕过构造器:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">class</span> <span class="nc">ClassWithExpensiveConstructor</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="nf">ClassWithExpensiveConstructor</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">value</span> <span class="o">=</span> <span class="n">doExpensiveLookup</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">doExpensiveLookup</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">2000</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getValue</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>绕过昂贵的构造器:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Test</span>
</span><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">testObjectCreation</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">ClassWithExpensiveConstructor</span> <span class="n">instance</span> <span class="o">=</span> <span class="o">(</span><span class="n">ClassWithExpensiveConstructor</span><span class="o">)</span>
</span><span class='line'>    <span class="n">unsafe</span><span class="o">.</span><span class="na">allocateInstance</span><span class="o">(</span><span class="n">ClassWithExpensiveConstructor</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>    <span class="n">assertEquals</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">instance</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>5.2 内存崩溃(Memory corruption)</h3>

<p>这对于每个C程序员来说是常见的.顺便说一下,它是绕过安全的常用技术.</p>

<p>考虑下那些用于检查“访问规则”的简单类：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">class</span> <span class="nc">Guard</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">ACCESS_ALLOWED</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">giveAccess</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="mi">42</span> <span class="o">==</span> <span class="n">ACCESS_ALLOWED</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>客户端代码是非常安全的,并且通过调用giveAccess()来检查访问规则.可惜,对于客户,它总是返回false.只有特权用户可以以某种方式改变ACCESS_ALLOWED常量的值并且得到访问,即giveAccess()方法返回true.</p>

<p>实际上,这并不是真的.演示代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Guard</span> <span class="n">guard</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Guard</span><span class="o">();</span>
</span><span class='line'><span class="n">guard</span><span class="o">.</span><span class="na">giveAccess</span><span class="o">();</span>   <span class="c1">// false, no access</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// by pass</span>
</span><span class='line'><span class="n">Unsafe</span> <span class="n">unsafe</span> <span class="o">=</span> <span class="n">getUnsafe</span><span class="o">();</span>
</span><span class='line'><span class="n">Field</span> <span class="n">f</span> <span class="o">=</span> <span class="n">guard</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">&quot;ACCESS_ALLOWED&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">unsafe</span><span class="o">.</span><span class="na">putInt</span><span class="o">(</span><span class="n">guard</span><span class="o">,</span> <span class="n">unsafe</span><span class="o">.</span><span class="na">objectFieldOffset</span><span class="o">(</span><span class="n">f</span><span class="o">),</span> <span class="mi">42</span><span class="o">);</span> <span class="c1">// memory corruption</span>
</span><span class='line'>
</span><span class='line'><span class="n">guard</span><span class="o">.</span><span class="na">giveAccess</span><span class="o">();</span> <span class="c1">// true, access granted</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在所有的客户都拥有无限制的访问权限.</p>

<p>实际上,反射可以实现相同的功能.但值得关注的是,我们可以修改任何对象,甚至没有这些对象的引用.</p>

<p>例如,有一个guard对象,所在内存中的位置紧接着在当前guard对象之后.我们可以用以下代码来修改它的ACCESS_ALLOWED字段：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">unsafe</span><span class="o">.</span><span class="na">putInt</span><span class="o">(</span><span class="n">guard</span><span class="o">,</span> <span class="mi">16</span> <span class="o">+</span> <span class="n">unsafe</span><span class="o">.</span><span class="na">objectFieldOffset</span><span class="o">(</span><span class="n">f</span><span class="o">),</span> <span class="mi">42</span><span class="o">);</span> <span class="c1">// memory corruption</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意：我们不必持有这个对象的引用.16是Guard对象在32位架构上的大小.我们可以手工计算它,或者通过使用sizeOf方法.</p>

<h3>5.2 sizeOf</h3>

<p>使用objectFieldOffset方法可以实现C-风格（C-style）的sizeof方法.这个实现返回对象的自身内存大小:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">sizeOf</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">Unsafe</span> <span class="n">u</span> <span class="o">=</span> <span class="n">getUnsafe</span><span class="o">();</span>
</span><span class='line'>    <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">Field</span><span class="o">&gt;</span> <span class="n">fields</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">Field</span><span class="o">&gt;();</span>
</span><span class='line'>    <span class="n">Class</span> <span class="n">c</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span>
</span><span class='line'>    <span class="k">while</span> <span class="o">(</span><span class="n">c</span> <span class="o">!=</span> <span class="n">Object</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="n">Field</span> <span class="n">f</span> <span class="o">:</span> <span class="n">c</span><span class="o">.</span><span class="na">getDeclaredFields</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">((</span><span class="n">f</span><span class="o">.</span><span class="na">getModifiers</span><span class="o">()</span> <span class="o">&amp;</span> <span class="n">Modifier</span><span class="o">.</span><span class="na">STATIC</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">fields</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">f</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">getSuperclass</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// get offset</span>
</span><span class='line'>    <span class="kt">long</span> <span class="n">maxSize</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="n">Field</span> <span class="n">f</span> <span class="o">:</span> <span class="n">fields</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">long</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="na">objectFieldOffset</span><span class="o">(</span><span class="n">f</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">maxSize</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">maxSize</span> <span class="o">=</span> <span class="n">offset</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="o">((</span><span class="n">maxSize</span><span class="o">/</span><span class="mi">8</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">*</span> <span class="mi">8</span><span class="o">;</span>   <span class="c1">// padding</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>算法如下：通过所有非静态字段（包含父类的）,获取每个字段的偏移量（offset）,找到偏移最大值并填充字节数(padding).</p>

<p>如果我们仅读取对象的类结构大小值,sizeOf的实现可以更简单,这位于JVM 1.7 32 bit中的偏移量12.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">sizeOf</span><span class="o">(</span><span class="n">Object</span> <span class="n">object</span><span class="o">){</span>
</span><span class='line'>    <span class="k">return</span> <span class="nf">getUnsafe</span><span class="o">().</span><span class="na">getAddress</span><span class="o">(</span>
</span><span class='line'>        <span class="n">normalize</span><span class="o">(</span><span class="n">getUnsafe</span><span class="o">().</span><span class="na">getInt</span><span class="o">(</span><span class="n">object</span><span class="o">,</span> <span class="mi">4L</span><span class="o">))</span> <span class="o">+</span> <span class="mi">12L</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>normalize是一个为了正确内存地址使用,将有符号的int类型强制转换成无符号的long类型的方法.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">normalize</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span><span class="o">(</span><span class="n">value</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">(~</span><span class="mi">0L</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">32</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">value</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>真棒,这个方法返回的结果与我们之前的sizeof方法一样.</p>

<p>实际上,对于良好、安全、准确的sizeof方法,最好使用 java.lang.instrument包,但这需要在JVM中指定agent选项.</p>

<h3>5.3 浅拷贝(Shallow copy)</h3>

<p>为了实现计算对象自身内存大小,我们可以简单地添加拷贝对象方法.标准的解决方案是使用Cloneable修改你的代码,或者在你的对象中实现自定义的拷贝方法,但它不会是多用途的方法.</p>

<p>浅拷贝：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">static</span> <span class="n">Object</span> <span class="nf">shallowCopy</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="n">sizeOf</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span><span class='line'>    <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">toAddress</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span><span class='line'>    <span class="kt">long</span> <span class="n">address</span> <span class="o">=</span> <span class="n">getUnsafe</span><span class="o">().</span><span class="na">allocateMemory</span><span class="o">(</span><span class="n">size</span><span class="o">);</span>
</span><span class='line'>    <span class="n">getUnsafe</span><span class="o">().</span><span class="na">copyMemory</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">address</span><span class="o">,</span> <span class="n">size</span><span class="o">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="nf">fromAddress</span><span class="o">(</span><span class="n">address</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>toAddress和fromAddress将对象转换为其在内存中的地址,反之亦然.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">static</span> <span class="kt">long</span> <span class="nf">toAddress</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">Object</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">[]</span> <span class="o">{</span><span class="n">obj</span><span class="o">};</span>
</span><span class='line'>    <span class="kt">long</span> <span class="n">baseOffset</span> <span class="o">=</span> <span class="n">getUnsafe</span><span class="o">().</span><span class="na">arrayBaseOffset</span><span class="o">(</span><span class="n">Object</span><span class="o">[].</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="nf">normalize</span><span class="o">(</span><span class="n">getUnsafe</span><span class="o">().</span><span class="na">getInt</span><span class="o">(</span><span class="n">array</span><span class="o">,</span> <span class="n">baseOffset</span><span class="o">));</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">static</span> <span class="n">Object</span> <span class="nf">fromAddress</span><span class="o">(</span><span class="kt">long</span> <span class="n">address</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">Object</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">[]</span> <span class="o">{</span><span class="kc">null</span><span class="o">};</span>
</span><span class='line'>    <span class="kt">long</span> <span class="n">baseOffset</span> <span class="o">=</span> <span class="n">getUnsafe</span><span class="o">().</span><span class="na">arrayBaseOffset</span><span class="o">(</span><span class="n">Object</span><span class="o">[].</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>    <span class="n">getUnsafe</span><span class="o">().</span><span class="na">putLong</span><span class="o">(</span><span class="n">array</span><span class="o">,</span> <span class="n">baseOffset</span><span class="o">,</span> <span class="n">address</span><span class="o">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">array</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个拷贝方法可以用来拷贝任何类型的对象,动态计算它的大小.注意,在拷贝后,你需要将对象转换成特定的类型.</p>

<h3>5.4 隐藏密码（Hide Password）</h3>

<p>在Unsafe中,一个更有趣的直接内存访问的用法是,从内存中删除不必要的对象.</p>

<p>检索用户密码的大多数API的签名为byte[]或char[],为什么是数组呢?</p>

<p>这完全是出于安全的考虑,因为我们可以删除不需要的数组元素.如果将用户密码检索成字符串,这可以像一个对象一样在内存中保存,而删除该对象只需执行解除引用的操作.但是,这个对象仍然在内存中,由GC决定的时间来执行清除.</p>

<p>创建具有相同大小、假的String对象,来取代在内存中原来的String对象的技巧：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">String</span> <span class="n">password</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="s">&quot;l00k@myHor$e&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">String</span> <span class="n">fake</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="n">password</span><span class="o">.</span><span class="na">replaceAll</span><span class="o">(</span><span class="s">&quot;.&quot;</span><span class="o">,</span> <span class="s">&quot;?&quot;</span><span class="o">));</span>
</span><span class='line'><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">password</span><span class="o">);</span> <span class="c1">// l00k@myHor$e</span>
</span><span class='line'><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">fake</span><span class="o">);</span> <span class="c1">// ????????????</span>
</span><span class='line'>
</span><span class='line'><span class="n">getUnsafe</span><span class="o">().</span><span class="na">copyMemory</span><span class="o">(</span>
</span><span class='line'>          <span class="n">fake</span><span class="o">,</span> <span class="mi">0L</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">toAddress</span><span class="o">(</span><span class="n">password</span><span class="o">),</span> <span class="n">sizeOf</span><span class="o">(</span><span class="n">password</span><span class="o">));</span>
</span><span class='line'>
</span><span class='line'><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">password</span><span class="o">);</span> <span class="c1">// ????????????</span>
</span><span class='line'><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">fake</span><span class="o">);</span> <span class="c1">// ????????????</span>
</span></code></pre></td></tr></table></div></figure>


<p>感觉很安全.</p>

<p>其实这并不安全.为了真正的安全,我们需要通过反射删除后台char数组：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Field</span> <span class="n">stringValue</span> <span class="o">=</span> <span class="n">String</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">&quot;value&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">stringValue</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
</span><span class='line'><span class="kt">char</span><span class="o">[]</span> <span class="n">mem</span> <span class="o">=</span> <span class="o">(</span><span class="kt">char</span><span class="o">[])</span> <span class="n">stringValue</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">password</span><span class="o">);</span>
</span><span class='line'><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mem</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">mem</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="sc">&#39;?&#39;</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>5.5 多继承(Multiple Inheritance)</h3>

<pre><code>Java中没有多继承,这是对的,除非我们可以将任意类型转换成我们想要的其他类:

long intClassAddress = normalize(getUnsafe().getInt(new Integer(0), 4L));
long strClassAddress = normalize(getUnsafe().getInt("", 4L));
getUnsafe().putAddress(intClassAddress + 36, strClassAddress);
</code></pre>

<p>这个代码片段将String类型添加到Integer超类中,因此我们可以强制转换,且没有运行时异常:</p>

<pre><code>(String) (Object) (new Integer(666))
</code></pre>

<p>有一个问题,我们必须预先强制转换对象,以欺骗编译器.</p>

<h3>5.6 动态类（Dynamic classes）</h3>

<p>我们可以在运行时创建一个类,比如从已编译的class文件中.将类内容读取为字节数组,并正确地传递给defineClass方法.</p>

<pre><code>byte[] classContents = getClassContent();
Class c = getUnsafe().defineClass(
              null, classContents, 0, classContents.length);
c.getMethod("a").invoke(c.newInstance(), null); // 1
</code></pre>

<p>从定义文件（class文件）中读取（代码）如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">getClassContent</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">File</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">File</span><span class="o">(</span><span class="s">&quot;/home/mishadoff/tmp/A.class&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="n">FileInputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">FileInputStream</span><span class="o">(</span><span class="n">f</span><span class="o">);</span>
</span><span class='line'>    <span class="kt">byte</span><span class="o">[]</span> <span class="n">content</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[(</span><span class="kt">int</span><span class="o">)</span><span class="n">f</span><span class="o">.</span><span class="na">length</span><span class="o">()];</span>
</span><span class='line'>    <span class="n">input</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">content</span><span class="o">);</span>
</span><span class='line'>    <span class="n">input</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">content</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当你必须动态创建类,而现有代码中有一些代理, 这是很有用的.</p>

<h3>5.7 抛出异常（Throw an Exception）</h3>

<p>不喜欢受检异常？没问题</p>

<pre><code>getUnsafe().throwException(new IOException());
</code></pre>

<p>该方法抛出受检异常,但你的代码不必捕捉或重新抛出它,正如运行时异常一样.</p>

<h3>5.8 大数组（Big Arrays）</h3>

<p>正如你所知,Java数组大小的最大值为Integer.MAX_VALUE.使用直接内存分配,我们创建的数组大小受限于堆大小.</p>

<p>SuperArray的实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">class</span> <span class="nc">SuperArray</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">BYTE</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">long</span> <span class="n">size</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">long</span> <span class="n">address</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">SuperArray</span><span class="o">(</span><span class="kt">long</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">size</span> <span class="o">=</span> <span class="n">size</span><span class="o">;</span>
</span><span class='line'>        <span class="n">address</span> <span class="o">=</span> <span class="n">getUnsafe</span><span class="o">().</span><span class="na">allocateMemory</span><span class="o">(</span><span class="n">size</span> <span class="o">*</span> <span class="n">BYTE</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="kt">long</span> <span class="n">i</span><span class="o">,</span> <span class="kt">byte</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">getUnsafe</span><span class="o">().</span><span class="na">putByte</span><span class="o">(</span><span class="n">address</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">BYTE</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">get</span><span class="o">(</span><span class="kt">long</span> <span class="n">idx</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="nf">getUnsafe</span><span class="o">().</span><span class="na">getByte</span><span class="o">(</span><span class="n">address</span> <span class="o">+</span> <span class="n">idx</span> <span class="o">*</span> <span class="n">BYTE</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">size</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">size</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>简单用法：</p>

<pre><code>long SUPER_SIZE = (long)Integer.MAX_VALUE * 2;
SuperArray array = new SuperArray(SUPER_SIZE);
System.out.println("Array size:" + array.size()); // 4294967294
for (int i = 0; i &lt; 100; i++) {
    array.set((long)Integer.MAX_VALUE + i, (byte)3);
    sum += array.get((long)Integer.MAX_VALUE + i);
}
System.out.println("Sum of 100 elements:" + sum);  // 300
</code></pre>

<p>实际上,这是堆外内存（off-heap memory）技术,在java.nio包中部分可用.</p>

<p>这种方式的内存分配不在堆上,且不受GC管理,所以必须小心Unsafe.freeMemory()的使用.它也不执行任何边界检查,所以任何非法访问可能会导致JVM崩溃.</p>

<p>这可用于数学计算,代码可操作大数组的数据.此外,这可引起实时程序员的兴趣,可打破GC在大数组上延迟的限制.</p>

<h3>5.9 并发（Concurrency）</h3>

<p>关于Unsafe的并发性.compareAndSwap方法是原子的,并且可用来实现高性能的、无锁的数据结构.</p>

<p>比如,考虑问题：在使用大量线程的共享对象上增长值.</p>

<p>首先,我们定义简单的Counter接口：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">interface</span> <span class="nc">Counter</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">void</span> <span class="nf">increment</span><span class="o">();</span>
</span><span class='line'>    <span class="kt">long</span> <span class="nf">getCounter</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后,我们定义使用Counter的工作线程CounterClient：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">class</span> <span class="nc">CounterClient</span> <span class="kd">implements</span> <span class="n">Runnable</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Counter</span> <span class="n">c</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">num</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">CounterClient</span><span class="o">(</span><span class="n">Counter</span> <span class="n">c</span><span class="o">,</span> <span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">;</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">num</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">c</span><span class="o">.</span><span class="na">increment</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>测试代码：</p>

<pre><code>int NUM_OF_THREADS = 1000;
int NUM_OF_INCREMENTS = 100000;
ExecutorService service = Executors.newFixedThreadPool(NUM_OF_THREADS);
Counter counter = ... // creating instance of specific counter
long before = System.currentTimeMillis();
for (int i = 0; i &lt; NUM_OF_THREADS; i++) {
    service.submit(new CounterClient(counter, NUM_OF_INCREMENTS));
}
service.shutdown();
service.awaitTermination(1, TimeUnit.MINUTES);
long after = System.currentTimeMillis();
System.out.println("Counter result: " + c.getCounter());
System.out.println("Time passed in ms:" + (after - before));
</code></pre>

<p>第一个无锁版本的计数器：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">class</span> <span class="nc">StupidCounter</span> <span class="kd">implements</span> <span class="n">Counter</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">long</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">increment</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">counter</span><span class="o">++;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">getCounter</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">counter</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出：</p>

<pre><code>Counter result: 99542945
Time passed in ms: 679
</code></pre>

<p>运行快,但没有线程管理,结果是不准确的.</p>

<p>第二次尝试,添加上最简单的java式同步：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">class</span> <span class="nc">SyncCounter</span> <span class="kd">implements</span> <span class="n">Counter</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">long</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">increment</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">counter</span><span class="o">++;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">getCounter</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">counter</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出:</p>

<pre><code>Counter result: 100000000
Time passed in ms: 10136
</code></pre>

<p>激进的同步有效,但耗时长.</p>

<p>试试ReentrantReadWriteLock：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">class</span> <span class="nc">LockCounter</span> <span class="kd">implements</span> <span class="n">Counter</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">long</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">WriteLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ReentrantReadWriteLock</span><span class="o">().</span><span class="na">writeLock</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">increment</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
</span><span class='line'>        <span class="n">counter</span><span class="o">++;</span>
</span><span class='line'>        <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">getCounter</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">counter</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出:</p>

<pre><code>Counter result: 100000000
Time passed in ms: 8065
</code></pre>

<p>仍然正确,耗时较短.</p>

<p>atomics的运行效果如何?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">class</span> <span class="nc">AtomicCounter</span> <span class="kd">implements</span> <span class="n">Counter</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">AtomicLong</span> <span class="n">counter</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">AtomicLong</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">increment</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">counter</span><span class="o">.</span><span class="na">incrementAndGet</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">getCounter</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">counter</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出:</p>

<pre><code>Counter result: 100000000
Time passed in ms: 6552
</code></pre>

<p>AtomicCounter的运行结果更好.</p>

<p>最后,试试Unsafe原始的compareAndSwapLong,看看它是否真的只有特权才能使用它?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">class</span> <span class="nc">CASCounter</span> <span class="kd">implements</span> <span class="n">Counter</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">volatile</span> <span class="kt">long</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Unsafe</span> <span class="n">unsafe</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">long</span> <span class="n">offset</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">CASCounter</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">unsafe</span> <span class="o">=</span> <span class="n">getUnsafe</span><span class="o">();</span>
</span><span class='line'>        <span class="n">offset</span> <span class="o">=</span> <span class="n">unsafe</span><span class="o">.</span><span class="na">objectFieldOffset</span><span class="o">(</span><span class="n">CASCounter</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">&quot;counter&quot;</span><span class="o">));</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">increment</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">long</span> <span class="n">before</span> <span class="o">=</span> <span class="n">counter</span><span class="o">;</span>
</span><span class='line'>        <span class="k">while</span> <span class="o">(!</span><span class="n">unsafe</span><span class="o">.</span><span class="na">compareAndSwapLong</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">offset</span><span class="o">,</span> <span class="n">before</span><span class="o">,</span> <span class="n">before</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">before</span> <span class="o">=</span> <span class="n">counter</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">getCounter</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">counter</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出:</p>

<pre><code>Counter result: 100000000
Time passed in ms: 6454
</code></pre>

<p>看起来似乎等价于atomics,实际上,atomics正是使用Unsafe实现.</p>

<p>实际上,这个例子很简单,但它展示了Unsafe的一些能力.</p>

<p>如我所说,CAS原语可以用来实现无锁的数据结构.背后的原理很简单：</p>

<pre><code>有一些状态
创建它的副本
修改它
执行CAS
如果失败,重复尝试
</code></pre>

<p>实际上,现实中比你现象的更难.存在着许多问题,如ABA问题、指令重排序等.</p>

<p>如果你真的感兴趣,可以参考<a href="https://github.com/EsotericSoftware/kryo">lock-free HashMap</a>的精彩展示.</p>

<h1>6.结论</h1>

<p>即使Unsafe对应用程序很有用,但建议不要使用它.</p>

<h1>参考</h1>

<p><a href="http://mishadoff.com/blog/java-magic-part-4-sun-dot-misc-dot-unsafe/">http://mishadoff.com/blog/java-magic-part-4-sun-dot-misc-dot-unsafe/</a>
<a href="http://java.dzone.com/articles/understanding-sunmiscunsafe">http://java.dzone.com/articles/understanding-sunmiscunsafe</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/03/memcachedwang-luo-mo-xing/">Memcached网络模型</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-11-03T18:59:33+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2014</span></span> <span class='time'>6:59 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>这篇文章的目的是学习Memcached网络模型相关的源代码.</p>

<p>Memcached采用了很典型的Master-Worker模型，采用的是多线程而不是多进程. 主线程(Master)接收连接, 然后把连接平分派给工作线程(Worker),工作线程处理业务逻辑.</p>

<p>核心的共享数据是消息队列，主线程会把收到的事件请求放入队列，随后调度程序会选择一个空闲的Worker线程来从队列中取出事件请求进行处理.</p>

<h1>1.libevent简介</h1>

<p>Memcached使用libevent实现事件循环，libevent在Linux环境下默认采用epoll作为IO多路复用方法.
用户线程使用libevent则通常按以下步骤：
    (1).用户线程通过event_init()函数创建一个event_base对象。event_base对象管理所有注册到自己内部的IO事件。多线程环境下，event_base对象不能被多个线程共享，即一个event_base对象只能对应一个线程。
    (2).然后该线程通过event_add函数，将与自己感兴趣的文件描述符相关的IO事件，注册到event_base对象，同时指定事件发生时所要调用的事件处理函数（event handler）。服务器程序通常监听套接字（socket）的可读事件。比如，服务器线程注册套接字sock1的EV_READ事件，并指定event_handler1()为该事件的回调函数。libevent将IO事件封装成struct event类型对象，事件类型用EV_READ/EV_WRITE等常量标志。
    (3).注册完事件之后，线程调用event_base_loop进入循环监听（monitor）状态。该循环内部会调用epoll等IO复用函数进入阻塞状态，直到描述符上发生自己感兴趣的事件。此时，线程会调用事先指定的回调函数处理该事件。例如，当套接字sock1发生可读事件，即sock1的内核buff中已有可读数据时，被阻塞的线程立即返回（wake up）并调用event_handler1()函数来处理该次事件。
    (4).处理完这次监听获得的事件后，线程再次进入阻塞状态并监听，直到下次事件发生。</p>

<h1>2.Memcached网络模型</h1>

<p>大致的图示如下:</p>

<p><img src="/images/memcached/memcached-libevent.jpg"></p>

<h3>2.1主要数据结构</h3>

<p>首先是CQ_ITEM, CQ_ITEM实际上是主线程accept后返回的已建立连接的fd的封装:</p>

<figure class='code'><figcaption><span>thread.c</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/* An item in the connection queue. */</span>
</span><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="n">conn_queue_item</span> <span class="n">CQ_ITEM</span><span class="p">;</span>
</span><span class='line'><span class="k">struct</span> <span class="n">conn_queue_item</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span>               <span class="n">sfd</span><span class="p">;</span>
</span><span class='line'>    <span class="k">enum</span> <span class="n">conn_states</span>  <span class="n">init_state</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span>               <span class="n">event_flags</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span>               <span class="n">read_buffer_size</span><span class="p">;</span>
</span><span class='line'>    <span class="k">enum</span> <span class="n">network_transport</span>     <span class="n">transport</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CQ_ITEM</span>          <span class="o">*</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>CQ是一个管理CQ_ITEM的单向链表:</p>

<figure class='code'><figcaption><span>thread.c</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/* A connection queue. */</span>
</span><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="n">conn_queue</span> <span class="n">CQ</span><span class="p">;</span>
</span><span class='line'><span class="k">struct</span> <span class="n">conn_queue</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CQ_ITEM</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CQ_ITEM</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">pthread_mutex_t</span> <span class="n">lock</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>LIBEVENT_THREAD是Memcached对线程结构的封装,每个线程都包含一个CQ队列，一条通知管道pipe
和一个libevent的实例event_base :</p>

<figure class='code'><figcaption><span>thread.c</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">pthread_t</span> <span class="n">thread_id</span><span class="p">;</span>        <span class="cm">/* unique ID of this thread */</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">event_base</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>    <span class="cm">/* libevent handle this thread uses */</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">event</span> <span class="n">notify_event</span><span class="p">;</span>  <span class="cm">/* listen event for notify pipe */</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">notify_receive_fd</span><span class="p">;</span>      <span class="cm">/* receiving end of notify pipe */</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">notify_send_fd</span><span class="p">;</span>         <span class="cm">/* sending end of notify pipe */</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">thread_stats</span> <span class="n">stats</span><span class="p">;</span>  <span class="cm">/* Stats generated by this thread */</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">conn_queue</span> <span class="o">*</span><span class="n">new_conn_queue</span><span class="p">;</span> <span class="cm">/* CQ队列 */</span>
</span><span class='line'>    <span class="kt">cache_t</span> <span class="o">*</span><span class="n">suffix_cache</span><span class="p">;</span>      <span class="cm">/* suffix cache */</span>
</span><span class='line'>    <span class="kt">uint8_t</span> <span class="n">item_lock_type</span><span class="p">;</span>     <span class="cm">/* use fine-grained or global item lock */</span>
</span><span class='line'><span class="p">}</span> <span class="n">LIBEVENT_THREAD</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>2.2主流程</h3>

<p>在memcached.c的main函数中展示了客户端请求处理的主流程:</p>

<p><strong>(1).对主线程的libevent做了初始化</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/* initialize main thread libevent instance */</span>
</span><span class='line'> <span class="n">main_base</span> <span class="o">=</span> <span class="n">event_init</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>(2).初始化所有的线程(包括Master和Worker线程),并启动</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/* start up worker threads if MT mode */</span>
</span><span class='line'><span class="n">thread_init</span><span class="p">(</span><span class="n">settings</span><span class="p">.</span><span class="n">num_threads</span><span class="p">,</span> <span class="n">main_base</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中settings.num_threads表示线程数目,默认是4个:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">settings</span><span class="p">.</span><span class="n">num_threads</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>         <span class="cm">/* N workers */</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面简单分析thread_init的核心代码(thread.c):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm"> * Initializes the thread subsystem, creating various worker threads.</span>
</span><span class='line'><span class="cm"> *</span>
</span><span class='line'><span class="cm"> * nthreads  Number of worker event handler threads to spawn</span>
</span><span class='line'><span class="cm"> * main_base Event base for main thread</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">thread_init</span><span class="p">(</span><span class="kt">int</span> <span class="n">nthreads</span><span class="p">,</span> <span class="k">struct</span> <span class="n">event_base</span> <span class="o">*</span><span class="n">main_base</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">...</span><span class="c1">//省略若干代码</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//threads的声明在thread.c头部,用于保存所有的线程</span>
</span><span class='line'>    <span class="n">threads</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">nthreads</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">LIBEVENT_THREAD</span><span class="p">));</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">threads</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">perror</span><span class="p">(</span><span class="s">&quot;Can&#39;t allocate thread descriptors&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">dispatcher_thread</span><span class="p">.</span><span class="n">base</span> <span class="o">=</span> <span class="n">main_base</span><span class="p">;</span>
</span><span class='line'>    <span class="n">dispatcher_thread</span><span class="p">.</span><span class="n">thread_id</span> <span class="o">=</span> <span class="n">pthread_self</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nthreads</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">fds</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">pipe</span><span class="p">(</span><span class="n">fds</span><span class="p">))</span> <span class="p">{</span>    <span class="c1">//创建管道</span>
</span><span class='line'>            <span class="n">perror</span><span class="p">(</span><span class="s">&quot;Can&#39;t create notify pipe&quot;</span><span class="p">);</span>
</span><span class='line'>            <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">notify_receive_fd</span> <span class="o">=</span> <span class="n">fds</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  <span class="c1">//读端</span>
</span><span class='line'>        <span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">notify_send_fd</span> <span class="o">=</span> <span class="n">fds</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>     <span class="c1">//写端</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//创建所有workers线程的libevent实例</span>
</span><span class='line'>        <span class="n">setup_thread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span class='line'>        <span class="cm">/* Reserve three fds for the libevent base, and two for the pipe */</span>
</span><span class='line'>        <span class="n">stats</span><span class="p">.</span><span class="n">reserved_fds</span> <span class="o">+=</span> <span class="mi">5</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//创建线程</span>
</span><span class='line'>    <span class="cm">/* Create threads after we&#39;ve done all the libevent setup. */</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nthreads</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">create_worker</span><span class="p">(</span><span class="n">worker_libevent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//等待所有线程启动起来之后,这个函数再返回</span>
</span><span class='line'>    <span class="cm">/* Wait for all the threads to set themselves up before returning. */</span>
</span><span class='line'>    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_lock</span><span class="p">);</span>
</span><span class='line'>    <span class="n">wait_for_thread_registration</span><span class="p">(</span><span class="n">nthreads</span><span class="p">);</span>
</span><span class='line'>    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_lock</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>thread_init首先malloc线程的空间，然后第一个threads作为主线程，其余都是workers线程
然后为每个线程创建一个pipe，这个pipe被用来作为主线程通知workers线程有新的连接到达.</p>

<p>其中pipe()函数用于创建管道,管道两端可分别用描述字fds[0]以及fds[1]来描述.需要注意的是，管道的两端是固定的。即一端只能用于读，由描述字fds[0]表示，称其为管道读端；另一端则只能用于写，由描述字fds[1]来表示，称其为管道写端.</p>

<p>setup_thread主要是创建所有workers线程的libevent实例（主线程的libevent实例在main函数中已经建立）,setup_thread()的代码如下:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm"> * Set up a thread&#39;s information.</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">setup_thread</span><span class="p">(</span><span class="n">LIBEVENT_THREAD</span> <span class="o">*</span><span class="n">me</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">me</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">event_init</span><span class="p">();</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Can&#39;t allocate event base</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//注意这里只有notify_receive_fd,即读端口</span>
</span><span class='line'>    <span class="cm">/* Listen for notifications from other threads */</span>
</span><span class='line'>    <span class="n">event_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">notify_event</span><span class="p">,</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">notify_receive_fd</span><span class="p">,</span>
</span><span class='line'>              <span class="n">EV_READ</span> <span class="o">|</span> <span class="n">EV_PERSIST</span><span class="p">,</span> <span class="n">thread_libevent_process</span><span class="p">,</span> <span class="n">me</span><span class="p">);</span>
</span><span class='line'>    <span class="n">event_base_set</span><span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">notify_event</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">event_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">notify_event</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Can&#39;t monitor libevent notify pipe</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">me</span><span class="o">-&gt;</span><span class="n">new_conn_queue</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">conn_queue</span><span class="p">));</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">new_conn_queue</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">perror</span><span class="p">(</span><span class="s">&quot;Failed to allocate memory for connection queue&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">cq_init</span><span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">new_conn_queue</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里会为所有worker thread线程注册与notify_event_fd描述符有关的IO事件，这里的notify_event_fd描述符是该worker thread线程与main thread线程通信的管道的接收端(读)描述符。通过注册与该描述符有关的IO事件，worker thread线程就能监听main thread线程发给自己的数据(即事件).</p>

<p>注意这里event_set中的thread_libevent_process参数,其意义在于监听Worker线程与main thread线程通信的管道上的可读事件，并指定用thread_libevent_process()函数处理该事件,即每次管道读端有数据刻度,即触发thread_libevent_process过程.</p>

<p>thread_libevent_process的代码如下,其中最重要的一个就是数据为c的,后续会详细分析这块代码.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm"> * Processes an incoming &quot;handle a new connection&quot; item. This is called when</span>
</span><span class='line'><span class="cm"> * input arrives on the libevent wakeup pipe.</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">thread_libevent_process</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">short</span> <span class="n">which</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">LIBEVENT_THREAD</span> <span class="o">*</span><span class="n">me</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CQ_ITEM</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//从管道中读数据</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">settings</span><span class="p">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Can&#39;t read from libevent pipe</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">switch</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="sc">&#39;c&#39;</span><span class="o">:</span>   <span class="c1">//c表示有新的连接请求被主线程分配到当前Worker线程</span>
</span><span class='line'>    <span class="n">item</span> <span class="o">=</span> <span class="n">cq_pop</span><span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">new_conn_queue</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">item</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">conn</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">conn_new</span><span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">sfd</span><span class="p">,</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">init_state</span><span class="p">,</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">event_flags</span><span class="p">,</span>
</span><span class='line'>                           <span class="n">item</span><span class="o">-&gt;</span><span class="n">read_buffer_size</span><span class="p">,</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">,</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">IS_UDP</span><span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Can&#39;t listen for events on UDP socket</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>                <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="n">settings</span><span class="p">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Can&#39;t listen for events on fd %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
</span><span class='line'>                        <span class="n">item</span><span class="o">-&gt;</span><span class="n">sfd</span><span class="p">);</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>                <span class="n">close</span><span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">sfd</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">c</span><span class="o">-&gt;</span><span class="kr">thread</span> <span class="o">=</span> <span class="n">me</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">cqi_free</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>        <span class="k">break</span><span class="p">;</span>
</span><span class='line'>    <span class="cm">/* we were told to flip the lock type and report in */</span>
</span><span class='line'>    <span class="k">case</span> <span class="sc">&#39;l&#39;</span><span class="o">:</span>
</span><span class='line'>        <span class="p">...</span>
</span><span class='line'>    <span class="k">case</span> <span class="sc">&#39;g&#39;</span><span class="o">:</span>
</span><span class='line'>        <span class="p">...</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>thread_init函数中create_worker实际上就是真正启动了线程, create_worker的代码如下:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm"> * Creates a worker thread.</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">create_worker</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">pthread_t</span>       <span class="kr">thread</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">pthread_attr_t</span>  <span class="n">attr</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span>             <span class="n">ret</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">pthread_attr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="kr">thread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">arg</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Can&#39;t create thread: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
</span><span class='line'>                <span class="n">strerror</span><span class="p">(</span><span class="n">ret</span><span class="p">));</span>
</span><span class='line'>        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>pthread_create是创建线程函数,第三个参数是线程运行函数的起始地址,这里即worker_libevent函数,该方法执行event_base_loop启动该线程的libevent.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm"> * Worker thread: main event loop</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">worker_libevent</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">LIBEVENT_THREAD</span> <span class="o">*</span><span class="n">me</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/* Any per-thread setup can happen here; thread_init() will block until</span>
</span><span class='line'><span class="cm">     * all threads have finished initializing.</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/* set an indexable thread-specific memory item for the lock type.</span>
</span><span class='line'><span class="cm">     * this could be unnecessary if we pass the conn *c struct through</span>
</span><span class='line'><span class="cm">     * all item_lock calls...</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="n">me</span><span class="o">-&gt;</span><span class="n">item_lock_type</span> <span class="o">=</span> <span class="n">ITEM_LOCK_GRANULAR</span><span class="p">;</span>
</span><span class='line'>    <span class="n">pthread_setspecific</span><span class="p">(</span><span class="n">item_lock_type_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">item_lock_type</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">register_thread_initialized</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">event_base_loop</span><span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里我们需要记住每个workers线程目前只在自己线程的管道的读端有数据时可读时触发，并调用
thread_libevent_process方法.</p>

<p><strong>(3).主线程调用</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/* create the listening socket, bind it, and init */</span>
</span><span class='line'><span class="n">server_sockets</span><span class="p">(</span><span class="n">settings</span><span class="p">.</span><span class="n">port</span><span class="p">,</span> <span class="n">tcp_transport</span><span class="p">,</span> <span class="n">portnumber_file</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>在worker thread线程启动后，main thread线程就要创建监听套接字（listening socket）来等待客户端连接请求。这个方法主要是封装了创建监听socket，绑定地址，设置非阻塞模式并注册监听socket的libevent 读事件等一系列操作.</p>

<p>套接字被封装成conn对象，表示与客户端的连接,定义十分庞大(见memcached.h).</p>

<p>端口号默认是11211:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">settings</span><span class="p">.</span><span class="n">port</span> <span class="o">=</span> <span class="mi">11211</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>server_sockets函数主要调用server_socket()函数:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * Create a socket and bind it to a specific port number</span>
</span><span class='line'><span class="cm"> * @param interface the interface to bind to</span>
</span><span class='line'><span class="cm"> * @param port the port number to bind to</span>
</span><span class='line'><span class="cm"> * @param transport the transport protocol (TCP / UDP)</span>
</span><span class='line'><span class="cm"> * @param portnumber_file A filepointer to write the port numbers to</span>
</span><span class='line'><span class="cm"> *        when they are successfully added to the list of ports we</span>
</span><span class='line'><span class="cm"> *        listen on.</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="k">static</span> <span class="kt">int</span> <span class="nf">server_socket</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">interface</span><span class="p">,</span>
</span><span class='line'>                         <span class="kt">int</span> <span class="n">port</span><span class="p">,</span>
</span><span class='line'>                         <span class="k">enum</span> <span class="n">network_transport</span> <span class="n">transport</span><span class="p">,</span>
</span><span class='line'>                         <span class="kt">FILE</span> <span class="o">*</span><span class="n">portnumber_file</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">...</span><span class="c1">//省略若干代码</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//主机名到地址解析,结果存在ai中,为addrinfo的链表</span>
</span><span class='line'>    <span class="n">error</span><span class="o">=</span> <span class="n">getaddrinfo</span><span class="p">(</span><span class="n">interface</span><span class="p">,</span> <span class="n">port_buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hints</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ai</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="n">EAI_SYSTEM</span><span class="p">)</span>
</span><span class='line'>          <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;getaddrinfo(): %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">gai_strerror</span><span class="p">(</span><span class="n">error</span><span class="p">));</span>
</span><span class='line'>        <span class="k">else</span>
</span><span class='line'>          <span class="n">perror</span><span class="p">(</span><span class="s">&quot;getaddrinfo()&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">next</span><span class="o">=</span> <span class="n">ai</span><span class="p">;</span> <span class="n">next</span><span class="p">;</span> <span class="n">next</span><span class="o">=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">ai_next</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">conn</span> <span class="o">*</span><span class="n">listen_conn_add</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">((</span><span class="n">sfd</span> <span class="o">=</span> <span class="n">new_socket</span><span class="p">(</span><span class="n">next</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>   <span class="c1">//创建socket</span>
</span><span class='line'>            <span class="cm">/* getaddrinfo can return &quot;junk&quot; addresses,</span>
</span><span class='line'><span class="cm">             * we make sure at least one works before erroring.</span>
</span><span class='line'><span class="cm">             */</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EMFILE</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="cm">/* ...unless we&#39;re out of fds */</span>
</span><span class='line'>                <span class="n">perror</span><span class="p">(</span><span class="s">&quot;server_socket&quot;</span><span class="p">);</span>
</span><span class='line'>                <span class="n">exit</span><span class="p">(</span><span class="n">EX_OSERR</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="k">continue</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="c1">//IPV4地址,设置socket选项</span>
</span><span class='line'>        <span class="n">setsockopt</span><span class="p">(</span><span class="n">sfd</span><span class="p">,</span> <span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">flags</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">flags</span><span class="p">));</span>
</span><span class='line'>        <span class="p">...</span><span class="c1">//省略若干代码</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//socket和地址绑定</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">bind</span><span class="p">(</span><span class="n">sfd</span><span class="p">,</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">ai_addr</span><span class="p">,</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">ai_addrlen</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">EADDRINUSE</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">perror</span><span class="p">(</span><span class="s">&quot;bind()&quot;</span><span class="p">);</span>
</span><span class='line'>                <span class="n">close</span><span class="p">(</span><span class="n">sfd</span><span class="p">);</span>
</span><span class='line'>                <span class="n">freeaddrinfo</span><span class="p">(</span><span class="n">ai</span><span class="p">);</span>
</span><span class='line'>                <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="n">close</span><span class="p">(</span><span class="n">sfd</span><span class="p">);</span>
</span><span class='line'>            <span class="k">continue</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">success</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>            <span class="p">...</span><span class="c1">//省略若干代码</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">IS_UDP</span><span class="p">(</span><span class="n">transport</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>            <span class="p">...</span><span class="c1">//省略若干代码</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">listen_conn_add</span> <span class="o">=</span> <span class="n">conn_new</span><span class="p">(</span><span class="n">sfd</span><span class="p">,</span> <span class="n">conn_listening</span><span class="p">,</span>
</span><span class='line'>                                             <span class="n">EV_READ</span> <span class="o">|</span> <span class="n">EV_PERSIST</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
</span><span class='line'>                                             <span class="n">transport</span><span class="p">,</span> <span class="n">main_base</span><span class="p">)))</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;failed to create listening connection</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>                <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="n">listen_conn_add</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">listen_conn</span><span class="p">;</span>
</span><span class='line'>            <span class="n">listen_conn</span> <span class="o">=</span> <span class="n">listen_conn_add</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">freeaddrinfo</span><span class="p">(</span><span class="n">ai</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/* Return zero iff we detected no errors in starting up connections */</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">success</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>conn_new()是这里的最关键的一个函数,此函数负责将原始套接字封装成为一个conn对象，同时会注册与该conn对象相关的IO事件，并指定该连接（conn）的初始状态。这里要注意的是listening socket的conn对象被初始化为conn_listening状态.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">conn</span> <span class="o">*</span><span class="nf">conn_new</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">sfd</span><span class="p">,</span> <span class="k">enum</span> <span class="n">conn_states</span> <span class="n">init_state</span><span class="p">,</span>
</span><span class='line'>                <span class="k">const</span> <span class="kt">int</span> <span class="n">event_flags</span><span class="p">,</span>
</span><span class='line'>                <span class="k">const</span> <span class="kt">int</span> <span class="n">read_buffer_size</span><span class="p">,</span> <span class="k">enum</span> <span class="n">network_transport</span> <span class="n">transport</span><span class="p">,</span>
</span><span class='line'>                <span class="k">struct</span> <span class="n">event_base</span> <span class="o">*</span><span class="n">base</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">...</span><span class="c1">//省略若干代码</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//设置fd和初始状态</span>
</span><span class='line'>    <span class="n">c</span><span class="o">-&gt;</span><span class="n">sfd</span> <span class="o">=</span> <span class="n">sfd</span><span class="p">;</span>
</span><span class='line'>    <span class="n">c</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">init_state</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//注册与该连接有关的IO事件</span>
</span><span class='line'>    <span class="n">event_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">,</span> <span class="n">sfd</span><span class="p">,</span> <span class="n">event_flags</span><span class="p">,</span> <span class="n">event_handler</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">c</span><span class="p">);</span>
</span><span class='line'>    <span class="n">event_base_set</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">);</span>
</span><span class='line'>    <span class="n">c</span><span class="o">-&gt;</span><span class="n">ev_flags</span> <span class="o">=</span> <span class="n">event_flags</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">event_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">perror</span><span class="p">(</span><span class="s">&quot;event_add&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">...</span><span class="c1">//</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>所有conn对象IO事件相关的处理函数都是event_handler()函数,这个函数主要是调用drive_machine()函数:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="nf">event_handler</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">short</span> <span class="n">which</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">conn</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>    <span class="n">drive_machine</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>drive_machine这个函数就全权负责处理与客户连接相关的事件:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">drive_machine</span><span class="p">(</span><span class="n">conn</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>    <span class="n">assert</span><span class="p">(</span><span class="n">c</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">switch</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">case</span> <span class="nl">conn_listening</span><span class="p">:</span>
</span><span class='line'>            <span class="n">addrlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
</span><span class='line'>            <span class="n">sfd</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">sfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addrlen</span><span class="p">);</span>
</span><span class='line'>            <span class="p">...</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">settings</span><span class="p">.</span><span class="n">maxconns_fast</span> <span class="o">&amp;&amp;</span>
</span><span class='line'>                <span class="p">...</span>
</span><span class='line'>            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">dispatch_conn_new</span><span class="p">(</span><span class="n">sfd</span><span class="p">,</span> <span class="n">conn_new_cmd</span><span class="p">,</span> <span class="n">EV_READ</span> <span class="o">|</span> <span class="n">EV_PERSIST</span><span class="p">,</span>
</span><span class='line'>                                     <span class="n">DATA_BUFFER_SIZE</span><span class="p">,</span> <span class="n">tcp_transport</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">stop</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span><span class='line'>            <span class="k">break</span><span class="p">;</span>
</span><span class='line'>        <span class="k">case</span> <span class="nl">conn_waiting</span><span class="p">:</span>
</span><span class='line'>        <span class="p">...</span>
</span><span class='line'>        <span class="k">case</span> <span class="nl">conn_read</span><span class="p">:</span>
</span><span class='line'>        <span class="p">...</span>
</span><span class='line'>        <span class="k">case</span> <span class="nl">conn_parse_cmd</span><span class="p">:</span>
</span><span class='line'>        <span class="p">...</span>
</span><span class='line'>        <span class="k">case</span> <span class="nl">conn_new_cmd</span><span class="p">:</span>
</span><span class='line'>        <span class="p">...</span>
</span><span class='line'>        <span class="k">case</span> <span class="nl">conn_nread</span><span class="p">:</span>
</span><span class='line'>        <span class="p">...</span>
</span><span class='line'>        <span class="k">case</span> <span class="nl">conn_swallow</span><span class="p">:</span>
</span><span class='line'>        <span class="p">...</span>
</span><span class='line'>        <span class="k">case</span> <span class="nl">conn_write</span><span class="p">:</span>
</span><span class='line'>        <span class="p">...</span>
</span><span class='line'>        <span class="k">case</span> <span class="nl">conn_mwrite</span><span class="p">:</span>
</span><span class='line'>        <span class="p">...</span>
</span><span class='line'>        <span class="k">case</span> <span class="nl">conn_closing</span><span class="p">:</span>
</span><span class='line'>        <span class="p">...</span>
</span><span class='line'>        <span class="k">case</span> <span class="nl">conn_closed</span><span class="p">:</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>drive_machine中就是conn对象的state字段发挥作用的地方了,drive_machine()函数是一个巨大的switch语句，它根据conn对象的当前状态，即state字段的值选择执行不同的分支，因为listening socket的conn对象被初始化为conn_listening状态，所以drive_machine()函数会执行switch语句中case conn_listenning的分支，即接受客户端连接并通过dispatch_conn_new()函数将连接分派给Worker线程.</p>

<p>dispatch_conn_new代码如下(thread.c):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm"> * Dispatches a new connection to another thread. This is only ever called</span>
</span><span class='line'><span class="cm"> * from the main thread, either during initialization (for UDP) or because</span>
</span><span class='line'><span class="cm"> * of an incoming connection.</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">dispatch_conn_new</span><span class="p">(</span><span class="kt">int</span> <span class="n">sfd</span><span class="p">,</span> <span class="k">enum</span> <span class="n">conn_states</span> <span class="n">init_state</span><span class="p">,</span> <span class="kt">int</span> <span class="n">event_flags</span><span class="p">,</span>
</span><span class='line'>                       <span class="kt">int</span> <span class="n">read_buffer_size</span><span class="p">,</span> <span class="k">enum</span> <span class="n">network_transport</span> <span class="n">transport</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CQ_ITEM</span> <span class="o">*</span><span class="n">item</span> <span class="o">=</span> <span class="n">cqi_new</span><span class="p">();</span>  <span class="c1">//新申请一个CQ_ITEM</span>
</span><span class='line'>    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">item</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">close</span><span class="p">(</span><span class="n">sfd</span><span class="p">);</span>
</span><span class='line'>        <span class="cm">/* given that malloc failed this may also fail, but let&#39;s try */</span>
</span><span class='line'>        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Failed to allocate memory for connection object</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//分发给Worker线程</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">tid</span> <span class="o">=</span> <span class="p">(</span><span class="n">last_thread</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">settings</span><span class="p">.</span><span class="n">num_threads</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">LIBEVENT_THREAD</span> <span class="o">*</span><span class="kr">thread</span> <span class="o">=</span> <span class="n">threads</span> <span class="o">+</span> <span class="n">tid</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">last_thread</span> <span class="o">=</span> <span class="n">tid</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">item</span><span class="o">-&gt;</span><span class="n">sfd</span> <span class="o">=</span> <span class="n">sfd</span><span class="p">;</span>
</span><span class='line'>    <span class="n">item</span><span class="o">-&gt;</span><span class="n">init_state</span> <span class="o">=</span> <span class="n">init_state</span><span class="p">;</span>  <span class="c1">//注意这里的状态为conn_new_cmd</span>
</span><span class='line'>    <span class="n">item</span><span class="o">-&gt;</span><span class="n">event_flags</span> <span class="o">=</span> <span class="n">event_flags</span><span class="p">;</span>
</span><span class='line'>    <span class="n">item</span><span class="o">-&gt;</span><span class="n">read_buffer_size</span> <span class="o">=</span> <span class="n">read_buffer_size</span><span class="p">;</span>
</span><span class='line'>    <span class="n">item</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">=</span> <span class="n">transport</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//把新申请的CQ_ITEM放到被分配的Worker线程的队列中</span>
</span><span class='line'>    <span class="n">cq_push</span><span class="p">(</span><span class="kr">thread</span><span class="o">-&gt;</span><span class="n">new_conn_queue</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">MEMCACHED_CONN_DISPATCH</span><span class="p">(</span><span class="n">sfd</span><span class="p">,</span> <span class="kr">thread</span><span class="o">-&gt;</span><span class="n">thread_id</span><span class="p">);</span>
</span><span class='line'>    <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;c&#39;</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">//向worker thread线程的管道写入一字节的数据</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="kr">thread</span><span class="o">-&gt;</span><span class="n">notify_send_fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">perror</span><span class="p">(</span><span class="s">&quot;Writing to thread notify pipe&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>向Worker线程写一个字符的意义在于触发Worker线程管道的读端，即notify_receive_fd描述符的可读事件.</p>

<p>主线程在新连接到来的时候是如何选择处理副线程的呢?很简单,有一个计数器last_thread, 每次将last_thread加一,再模线程数来选择线程ID.</p>

<p>通过之前的分析,我们知道,Worker线程的管道有读时间触发的时候,会调用thread_libevent_process来处理,这里详细分析一下:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm"> * Processes an incoming &quot;handle a new connection&quot; item. This is called when</span>
</span><span class='line'><span class="cm"> * input arrives on the libevent wakeup pipe.</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">thread_libevent_process</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">short</span> <span class="n">which</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">LIBEVENT_THREAD</span> <span class="o">*</span><span class="n">me</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CQ_ITEM</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//从管道中读数据</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">settings</span><span class="p">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Can&#39;t read from libevent pipe</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">switch</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="sc">&#39;c&#39;</span><span class="o">:</span>   <span class="c1">//c表示有新的连接请求被主线程分配到当前Worker线程</span>
</span><span class='line'>    <span class="c1">//从当前Worker线程的连接请求队列中弹出一个请求</span>
</span><span class='line'>    <span class="c1">//此对象即先前main thread线程推入new_conn_queue队列的对象</span>
</span><span class='line'>    <span class="n">item</span> <span class="o">=</span> <span class="n">cq_pop</span><span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">new_conn_queue</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">item</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">//根据这个CQ_ITEM对象，创建并初始化conn对象</span>
</span><span class='line'>        <span class="c1">//该对象负责客户端与该worker thread线程之间的通信</span>
</span><span class='line'>        <span class="n">conn</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">conn_new</span><span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">sfd</span><span class="p">,</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">init_state</span><span class="p">,</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">event_flags</span><span class="p">,</span>
</span><span class='line'>                           <span class="n">item</span><span class="o">-&gt;</span><span class="n">read_buffer_size</span><span class="p">,</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">,</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">IS_UDP</span><span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Can&#39;t listen for events on UDP socket</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>                <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="n">settings</span><span class="p">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Can&#39;t listen for events on fd %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
</span><span class='line'>                        <span class="n">item</span><span class="o">-&gt;</span><span class="n">sfd</span><span class="p">);</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>                <span class="n">close</span><span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">sfd</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">c</span><span class="o">-&gt;</span><span class="kr">thread</span> <span class="o">=</span> <span class="n">me</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">cqi_free</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>        <span class="k">break</span><span class="p">;</span>
</span><span class='line'>    <span class="cm">/* we were told to flip the lock type and report in */</span>
</span><span class='line'>    <span class="k">case</span> <span class="sc">&#39;l&#39;</span><span class="o">:</span>
</span><span class='line'>        <span class="p">...</span>
</span><span class='line'>    <span class="k">case</span> <span class="sc">&#39;g&#39;</span><span class="o">:</span>
</span><span class='line'>        <span class="p">...</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>到这里,Worker线程就建立了和客户端的连接.</p>

<p>conn_new的一个值得注意的地方就是会设置线程的事件处理函数:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">conn</span> <span class="o">*</span><span class="nf">conn_new</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">sfd</span><span class="p">,</span> <span class="k">enum</span> <span class="n">conn_states</span> <span class="n">init_state</span><span class="p">,</span>
</span><span class='line'>                <span class="k">const</span> <span class="kt">int</span> <span class="n">event_flags</span><span class="p">,</span>
</span><span class='line'>                <span class="k">const</span> <span class="kt">int</span> <span class="n">read_buffer_size</span><span class="p">,</span> <span class="k">enum</span> <span class="n">network_transport</span> <span class="n">transport</span><span class="p">,</span>
</span><span class='line'>                <span class="k">struct</span> <span class="n">event_base</span> <span class="o">*</span><span class="n">base</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>    <span class="n">event_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">,</span> <span class="n">sfd</span><span class="p">,</span> <span class="n">event_flags</span><span class="p">,</span> <span class="n">event_handler</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">c</span><span class="p">);</span>
</span><span class='line'>        <span class="n">event_base_set</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">);</span>
</span><span class='line'>        <span class="n">c</span><span class="o">-&gt;</span><span class="n">ev_flags</span> <span class="o">=</span> <span class="n">event_flags</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">event_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">perror</span><span class="p">(</span><span class="s">&quot;event_add&quot;</span><span class="p">);</span>
</span><span class='line'>            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们可以看到,Worker线程也是使用event_handler函数来处理客户端请求过来的数据,根当前请求连接的状态来处理.</p>

<p><strong>(4).事件循环</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/* enter the event loop */</span>
</span><span class='line'><span class="n">event_base_loop</span><span class="p">(</span><span class="n">main_base</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>这时主线程启动开始通过libevent来接受外部连接请求，整个启动过程完毕.</p>

<h1>3.总结</h1>

<p>Memcached中采用的就是所谓的半同步-半异步模式,最早应该是由ACE的作者提出,原文在<a href="http://www.cs.wustl.edu/~schmidt/PDF/HS-HA.pdf">这里</a>.</p>

<p>简单示意图如下:</p>

<p><img src="/images/memcached/half-sync-half-async.jpg"></p>

<h3>3.1半同步-半异步模式</h3>

<p>几个模块的之间的交互为:</p>

<pre><code>(1).异步模块接收可能会异步到来的各种事件(I/O,信号等),然后将它们放入队列中;
(2).同步模块一般只有一种动作,就是不停的从队列中取出消息进行处理;
</code></pre>

<p>半同步-半异步模式的出现是为了给服务器的功能进行划分,尽可能将的可能阻塞的操作放在同步模块中,这样不会影响到异步模块的处理.</p>

<p>举个例子说明:</p>

<p>假设现在有一个服务器,在接收完客户端请求之后会去数据库查询,这个查询可能会很慢.这时,如果还是采用的把接收客户端的连接和处理客户端的请求(在这里这个处理就是查询数据库)放在一个模块中来处理,很可能将会有很多连接的处理响应非常慢.</p>

<p>此时,考虑使用半同步半异步的模式,开一个进程,使用多路复用IO(如epoll/select)等监听客户端的连接,接收到新的连接请求之后就将这些请求存放到通过某种IPC方式实现的消息队列中,同时,还有N个处理进程,它们所做的工作就是不停的从消息队列中取出消息进行处理.这样的划分,将接收客户端请求和处理客户端请求划分为不同的模块,相互之间的通过IPC进行通讯,将对彼此功能的影响限制到最小.</p>

<p><strong>优点</strong></p>

<pre><code>(1).接收操作只在主循环中处理,因此不会出现惊群现象;
(2).主副线程分工明确, 主线程仅负责I/O, 副线程负责业务逻辑处理;
(3).多个副线程之间不会有影响,因为大家都有各自独立的连接队列;
</code></pre>

<p><strong>缺点</strong></p>

<p>假如业务逻辑是类似于web服务器之类的, 那么一个简单的请求也需要这个比较繁琐的操作的话(最重要的是,很可能一个进程就能处理完的事情,非得从一个线程接收再到另一个线程去处理), 那么显然代价是不值得的.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/10/16/xmemcached-client/">XMemcached Client</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-10-16T22:51:01+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>16</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>10:51 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>1.XMemcached是什么</h1>

<p>XMemcached是众多Memcached Client中的后起之秀,而且还是一个Chinese主导的.写这篇Blog的目的就是研究下这个Memcached Client的代码,顺便研究下传说中的一致性Hash.</p>

<p>XMemcached项目:<a href="https://code.google.com/p/xmemcached/">https://code.google.com/p/xmemcached/</a></p>

<p>源代码:<a href="https://github.com/killme2008/xmemcached">https://github.com/killme2008/xmemcached</a></p>

<p>使用文档:<a href="http://blog.sina.com.cn/s/blog_6094008a0102v6gj.html">http://blog.sina.com.cn/s/blog_6094008a0102v6gj.html</a></p>

<p>特点:</p>

<pre><code>(1).支持所有的Memcached文本协议(text based protocols)和二进制协议(二进制协议从1.2.0开始支持);
(2).支持分布式的Memcached,包括标准Hash和一致性哈希策略;
(3).支持JMX,从而允许使用者监控和控制XMemcached Client的行为;同时可以修改优化参数,动态添加或者删除服务器;
(4).支持待权重的服务器配置;
(5).支持连接池,使用Java的nio,对同一个Memcached服务器使用者能够创建更多的连接;
(6).支持故障模式和备用节点;
(7).支持和Spring框架和hibernate-memcached的整合;
(8).高性能;
(9).支持和kestrel(一个Scala实现的MQ)和TokyoTyrant的对话;
</code></pre>

<h1>2.XMemcached的类图</h1>

<p>XMemcached的类图(几个主要的类):</p>

<p><img src="/images/xmemcached/xmemcached-classes.jpg"></p>

<h1>3.XMemcached的示例</h1>

<p>源代码中自带了例子,我们分析一个SimpleExample.java:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SimpleExample</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">args</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Useage:java SimpleExample [servers]&quot;</span><span class="o">);</span>
</span><span class='line'>            <span class="n">System</span><span class="o">.</span><span class="na">exit</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">MemcachedClient</span> <span class="n">memcachedClient</span> <span class="o">=</span> <span class="n">getMemcachedClient</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">memcachedClient</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">(</span><span class="s">&quot;Null MemcachedClient,please check memcached has been started&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>            <span class="c1">// add a,b,c</span>
</span><span class='line'>            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Add a,b,c&quot;</span><span class="o">);</span>
</span><span class='line'>            <span class="n">memcachedClient</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="s">&quot;Hello,xmemcached&quot;</span><span class="o">);</span>
</span><span class='line'>            <span class="n">memcachedClient</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="s">&quot;b&quot;</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="s">&quot;Hello,xmemcached&quot;</span><span class="o">);</span>
</span><span class='line'>            <span class="n">memcachedClient</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="s">&quot;c&quot;</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="s">&quot;Hello,xmemcached&quot;</span><span class="o">);</span>
</span><span class='line'>            <span class="c1">// get a</span>
</span><span class='line'>            <span class="n">String</span> <span class="n">value</span> <span class="o">=</span> <span class="n">memcachedClient</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">);</span>
</span><span class='line'>            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;get a=&quot;</span> <span class="o">+</span> <span class="n">value</span><span class="o">);</span>
</span><span class='line'>            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;delete a&quot;</span><span class="o">);</span>
</span><span class='line'>            <span class="c1">// delete a</span>
</span><span class='line'>            <span class="n">memcachedClient</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">);</span>
</span><span class='line'>            <span class="c1">// reget a</span>
</span><span class='line'>            <span class="n">value</span> <span class="o">=</span> <span class="n">memcachedClient</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">);</span>
</span><span class='line'>            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;after delete,a=&quot;</span> <span class="o">+</span> <span class="n">value</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Iterate all keys...&quot;</span><span class="o">);</span>
</span><span class='line'>            <span class="c1">// iterate all keys</span>
</span><span class='line'>            <span class="n">KeyIterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">memcachedClient</span><span class="o">.</span><span class="na">getKeyIterator</span><span class="o">(</span><span class="n">AddrUtil</span><span class="o">.</span><span class="na">getOneAddress</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]));</span>
</span><span class='line'>            <span class="k">while</span> <span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="na">next</span><span class="o">());</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">memcachedClient</span><span class="o">.</span><span class="na">touch</span><span class="o">(</span><span class="s">&quot;b&quot;</span><span class="o">,</span> <span class="mi">1000</span><span class="o">));</span>
</span><span class='line'>
</span><span class='line'>        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">MemcachedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;MemcachedClient operation fail&quot;</span><span class="o">);</span>
</span><span class='line'>            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">TimeoutException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;MemcachedClient operation timeout&quot;</span><span class="o">);</span>
</span><span class='line'>            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="c1">// ignore</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">memcachedClient</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Shutdown MemcachedClient fail&quot;</span><span class="o">);</span>
</span><span class='line'>            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="n">MemcachedClient</span> <span class="nf">getMemcachedClient</span><span class="o">(</span><span class="n">String</span> <span class="n">servers</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>            <span class="c1">//默认是Text协议</span>
</span><span class='line'>            <span class="n">MemcachedClientBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">XMemcachedClientBuilder</span><span class="o">(</span><span class="n">AddrUtil</span><span class="o">.</span><span class="na">getAddresses</span><span class="o">(</span><span class="n">servers</span><span class="o">));</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">builder</span><span class="o">.</span><span class="na">build</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Create MemcachedClient fail&quot;</span><span class="o">);</span>
</span><span class='line'>            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>本地先起来两个Memcached实例:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">memcached</span> <span class="o">-</span><span class="n">m</span> <span class="mi">256</span> <span class="o">-</span><span class="n">p</span> <span class="mi">11211</span> <span class="o">-</span><span class="n">u</span> <span class="n">memcache</span> <span class="o">-</span><span class="n">l</span> <span class="mf">127.0</span><span class="o">.</span><span class="mf">0.1</span> <span class="o">-</span><span class="n">d</span>
</span><span class='line'><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">memcached</span> <span class="o">-</span><span class="n">m</span> <span class="mi">256</span> <span class="o">-</span><span class="n">p</span> <span class="mi">11222</span> <span class="o">-</span><span class="n">u</span> <span class="n">memcache</span> <span class="o">-</span><span class="n">l</span> <span class="mf">127.0</span><span class="o">.</span><span class="mf">0.1</span> <span class="o">-</span><span class="n">d</span>
</span></code></pre></td></tr></table></div></figure>


<p>在IDEA下运行,配上运行参数,即Memcached服务器的IP和端口,格式如下(解析代码见AddrUtil.java):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="mf">127.0</span><span class="o">.</span><span class="mf">0.1</span><span class="o">:</span><span class="mi">11211</span> <span class="mf">127.0</span><span class="o">.</span><span class="mf">0.1</span><span class="o">:</span><span class="mi">11222</span>
</span></code></pre></td></tr></table></div></figure>


<p>Debug代码,可以发现其运行过程,下面是get的一个运行序列图:</p>

<p><img src="/images/xmemcached/xmemcached-get.jpg"></p>

<h1>4.XMemcached的分布式实现</h1>

<p>memcached虽然称为“分布式”缓存服务器,但服务器端并没有"&ldquo;分布式”功能.至于memcached的分布式,则是完全由客户端程序库实现的.</p>

<h3>4.1 Memcached的分布式是什么意思</h3>

<p>这里多次使用了“分布式”这个词,但并未做详细解释.现在开始简单地介绍一下其原理,各个客户端的实现基本相同.</p>

<p>下面假设memcached服务器有node1～node3三台, 应用程序要保存键名为“tokyo”“kanagawa”“chiba”“saitama”“gunma” 的数据.</p>

<p><img src="/images/memcached/memcached-distribute-1.png"></p>

<p>首先向memcached中添加“tokyo”.将“tokyo”传给客户端程序库后, 客户端实现的算法就会根据“键”来决定保存数据的memcached服务器. 服务器选定后,即命令它保存“tokyo”及其值.</p>

<p><img src="/images/memcached/memcached-distribute-2.png"></p>

<p>同样,“kanagawa”“chiba”“saitama”“gunma”都是先选择服务器再保存.</p>

<p>接下来获取保存的数据.获取时也要将要获取的键“tokyo”传递给函数库. 函数库通过与数据保存时相同的算法,根据“键”选择服务器. 使用的算法相同,就能选中与保存时相同的服务器,然后发送get命令. 只要数据没有因为某些原因被删除,就能获得保存的值.</p>

<p><img src="/images/memcached/memcached-distribute-3.png"></p>

<p>这样,将不同的键保存到不同的服务器上,就实现了memcached的分布式. memcached服务器增多后,键就会分散,即使一台memcached服务器发生故障
无法连接,也不会影响其他的缓存,系统依然能继续运行.</p>

<h3>4.2 余数哈希</h3>

<p>XMemcached默认使用的是Native Hash,见ArrayMemcachedSessionLocator.java:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">final</span> <span class="kt">long</span> <span class="nf">getHash</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">,</span> <span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">long</span> <span class="n">hash</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">hashAlgorighm</span><span class="o">.</span><span class="na">hash</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">hash</span> <span class="o">%</span> <span class="n">size</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>ArrayMemcachedSessionLocator中使用的hashAlgorighm是HashAlgorithm.NATIVE_HASH,而HashAlgorithm.NATIVE_HASH的hash()函数的实现:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kt">long</span> <span class="nf">hash</span><span class="o">(</span><span class="kd">final</span> <span class="n">String</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">long</span> <span class="n">rv</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>    <span class="k">switch</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="nl">NATIVE_HASH:</span>
</span><span class='line'>        <span class="n">rv</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="na">hashCode</span><span class="o">();</span>
</span><span class='line'>        <span class="k">break</span><span class="o">;</span>
</span><span class='line'>    <span class="o">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>即XMemcached的Native Hash就是通常的余数哈希:首先求得字符串的hash值,根据该值除以服务器节点数目得到的余数决定服务器.</p>

<p>根据这种hash方式,上门这几个key分布的服务器如下(三台服务器分别为 0 1 2):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">tokyo</span> <span class="o">--&gt;</span> <span class="mi">2</span>
</span><span class='line'><span class="n">kanagawa</span> <span class="o">--&gt;</span> <span class="mi">1</span>
</span><span class='line'><span class="n">chiba</span> <span class="o">--&gt;</span> <span class="mi">2</span>
</span><span class='line'><span class="n">saitama</span> <span class="o">--&gt;</span> <span class="mi">1</span>
</span><span class='line'><span class="n">gunma</span> <span class="o">--&gt;</span> <span class="mi">2</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>优点</strong>
简单高效:计算简单,数据的分散性也相当优秀</p>

<p><strong>缺点</strong>
当添加或移除服务器时,缓存重组的代价相当巨大. 添加服务器后,余数就会产生巨变,这样就无法获取与保存时相同的服务器, 从而影响缓存的命中率.</p>

<p>下面简单验证这个:首先在3台服务器的情况下将“a”到“z”的键保存到memcached并访问的情况;接下来增加一台memcached服务器;计算缓存命中率;</p>

<p>简单测试代码(忍不住吐槽下java真是一门罗嗦的语言):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Hash</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 默认的Hash算法</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="n">HashAlgorithm</span> <span class="n">hashAlgorithm</span> <span class="o">=</span> <span class="n">HashAlgorithm</span><span class="o">.</span><span class="na">NATIVE_HASH</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Memcached服务器数目</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">SERVER_SIZE</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">// 初始化</span>
</span><span class='line'>        <span class="n">Map</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">itemMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;();</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SERVER_SIZE</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">itemMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;());</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">char</span> <span class="n">letters</span><span class="o">[]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="mi">27</span><span class="o">];</span>
</span><span class='line'>        <span class="n">letters</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="sc">&#39;a&#39;</span><span class="o">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">letters</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">char</span><span class="o">)</span> <span class="o">(</span><span class="n">letters</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
</span><span class='line'>            <span class="kt">long</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">getHash</span><span class="o">(</span><span class="n">SERVER_SIZE</span><span class="o">,</span> <span class="n">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">letters</span><span class="o">[</span><span class="n">i</span><span class="o">]));</span>
</span><span class='line'>            <span class="n">itemMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">hash</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">letters</span><span class="o">[</span><span class="n">i</span><span class="o">]));</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">e</span> <span class="o">:</span> <span class="n">itemMap</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getKey</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot; : &quot;</span> <span class="o">+</span> <span class="n">join</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getValue</span><span class="o">()));</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">getHash</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">,</span> <span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">long</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">hashAlgorithm</span><span class="o">.</span><span class="na">hash</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">hash</span> <span class="o">%</span> <span class="n">size</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">join</span><span class="o">(</span><span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">StringBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">StringBuilder</span><span class="o">();</span>
</span><span class='line'>        <span class="k">for</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">builder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">s</span> <span class="o">+</span> <span class="sc">&#39; &#39;</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="n">builder</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们得到3台服务器(分别为0,1,2)的时候,26个字母的分布如下:</p>

<pre><code>0 : c f i l o r u x 
1 : a d g j m p s v y 
2 : b e h k n q t w z 
</code></pre>

<p>4台服务器(分别为0,1,2,3)的时候,26个字母的分布如下:</p>

<pre><code>0 : d h l p t x 
1 : a e i m q u y 
2 : b f j n r v z 
3 : c g k o s w
</code></pre>

<p>根据这两份数据,我们可以得到,加拉一台服务器之后,26个字母只有8个命中了.像这样,添加节点后键分散到的服务器会发生巨大变化.</p>

<p>同样,减少服务器(比如某一台服务器down机),也会导致大量的Miss,基本失去了缓存的作用.</p>

<p>带来的问题就是,在Web应用程序中使用memcached时, 在添加memcached服务器的瞬间缓存效率会大幅度下降,有可能会发生无法提供正常服务的情况.</p>

<h3>4.3 一致性哈希(Consistent Hashing)</h3>

<p>一致性哈希能够很大程度上(注意不是完全解决)解决余数哈希的增加服务器导致缓存失效的问题.</p>

<p><strong>4.3.1 一致性哈希原理</strong>
Consistent Hashing如下所示：首先求出memcached服务器（节点）的哈希值,
并将其配置到0～2SUP(32)的圆（continuum）上. 然后用同样的方法求出存储数据的键的哈希值,并映射到圆上. 然后从数据映射到的位置开始顺时针查找,将数据保存到找到的第一个服务器上. 如果超过2SUP(32)仍然找不到服务器,就会保存到第一台memcached服务器上.</p>

<p><img src="/images/memcached/memcached-consistent-hash1.png"></p>

<p>从上图的状态中添加一台memcached服务器.余数分布式算法由于保存键的服务器会发生巨大变化 而影响缓存的命中率,但Consistent Hashing中,只有在continuum上增加服务器的地点逆时针方向的 第一台服务器上的键会受到影响.</p>

<p><img src="/images/memcached/memcached-consistent-hash2.png"></p>

<p>因此,Consistent Hashing最大限度地抑制了键的重新分布. 而且,有的Consistent Hashing的实现方法还采用了虚拟节点的思想. 使用一般的hash函数的话,服务器的映射地点的分布非常不均匀. 因此,使用虚拟节点的思想,为每个物理节点（服务器） 在continuum上分配100～200个点.这样就能抑制分布不均匀, 最大限度地减小服务器增减时的缓存重新分布.</p>

<p><strong>4.3.2 虚拟节点</strong>
 一致性哈希算法在服务节点太少时,容易因为节点分部不均匀而造成数据倾斜问题.例如我们的系统中有两台 server,其环分布如下：</p>

<p> <img src="/images/xmemcached/virtual-node-why.png"></p>

<p> 此时必然造成大量数据集中到Server 1上,而只有极少量会定位到Server 2上.为了解决这种数据倾斜问题,一致性哈希算法引入了虚拟节点机制.</p>

<p>虚拟节点(virtual node)是实际节点(服务器)在 hash 空间的复制品,一个实际节点(服务器)对应了若干个虚拟节点,这个对应个数也称为为复制个数,虚拟节点在 hash 环中以hash值排列.</p>

<p>例如为上面的每台服务器设置三个虚拟节点:</p>

<p><img src="/images/xmemcached/virtual-node.png"></p>

<p>在实际应用中,一个物理节点对应多少的虚拟节点才能达到比较好的均衡效果,有一个效果图:</p>

<p><img src="/images/xmemcached/virtual-node-count.png"></p>

<p>纵轴为物理服务器的数目,横轴为虚拟节点的数目,可以看出,当物理服务器的数量很小时,需要更大的虚拟节点,反之则需要更少的节点,从图上可以看出,在物理服务器有10台时,差不多需要为每台服务器增加100~200个虚拟节点效果比较好.</p>

<h3>4.4 XMemcached一致性哈希的实现</h3>

<p>XMemcached Client中实现了一致性哈希,见KetamaMemcachedSessionLocator.java,使用的Hash算法是KETAMA HASH算法.</p>

<p>下面主要分析一下KetamaMemcachedSessionLocator.java代码,去掉了一些无关的代码:</p>

<p><strong>4.4.1 根据服务器列表生成Hash环</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">buildMap</span><span class="o">(</span><span class="n">Collection</span><span class="o">&lt;</span><span class="n">Session</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="n">HashAlgorithm</span> <span class="n">alg</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">TreeMap</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Session</span><span class="o">&gt;&gt;</span> <span class="n">sessionMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeMap</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Session</span><span class="o">&gt;&gt;();</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="n">Session</span> <span class="n">session</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>  <span class="c1">//遍历每个服务器</span>
</span><span class='line'>        <span class="n">String</span> <span class="n">sockStr</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>  <span class="c1">//根据服务器地址得到的字符串,用于hash</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">cwNginxUpstreamConsistent</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="o">...</span> <span class="c1">//生成sockStr</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>            <span class="o">...</span> <span class="c1">//生成sockStr</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="cm">/**</span>
</span><span class='line'><span class="cm">         * Duplicate 160 X weight references</span>
</span><span class='line'><span class="cm">         */</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">numReps</span> <span class="o">=</span> <span class="n">NUM_REPS</span><span class="o">;</span> <span class="c1">//虚拟节点数目, 默认160</span>
</span><span class='line'>        <span class="c1">//考虑权重,权重小的服务器最终生成的虚拟节点就少,数据打到这个服务器的概率就小</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">session</span> <span class="k">instanceof</span> <span class="n">MemcachedTCPSession</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">numReps</span> <span class="o">*=</span> <span class="o">((</span><span class="n">MemcachedSession</span><span class="o">)</span> <span class="n">session</span><span class="o">).</span><span class="na">getWeight</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">alg</span> <span class="o">==</span> <span class="n">HashAlgorithm</span><span class="o">.</span><span class="na">KETAMA_HASH</span><span class="o">)</span> <span class="o">{</span>     <span class="c1">//一致性Hash</span>
</span><span class='line'>            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numReps</span> <span class="o">/</span> <span class="mi">4</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>                <span class="c1">//计算Hash值,将虚拟节点映射到当前session代表的服务器</span>
</span><span class='line'>                <span class="kt">byte</span><span class="o">[]</span> <span class="n">digest</span> <span class="o">=</span> <span class="n">HashAlgorithm</span><span class="o">.</span><span class="na">computeMd5</span><span class="o">(</span><span class="n">sockStr</span> <span class="o">+</span> <span class="s">&quot;-&quot;</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>
</span><span class='line'>                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">;</span> <span class="n">h</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>                    <span class="kt">long</span> <span class="n">k</span> <span class="o">=</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span> <span class="o">(</span><span class="n">digest</span><span class="o">[</span><span class="mi">3</span> <span class="o">+</span> <span class="n">h</span> <span class="o">*</span> <span class="mi">4</span><span class="o">]</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="o">)</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span> <span class="o">|</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span> <span class="o">(</span><span class="n">digest</span><span class="o">[</span><span class="mi">2</span> <span class="o">+</span> <span class="n">h</span> <span class="o">*</span> <span class="mi">4</span><span class="o">]</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="o">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span>
</span><span class='line'>                            <span class="o">|</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span> <span class="o">(</span><span class="n">digest</span><span class="o">[</span><span class="mi">1</span> <span class="o">+</span> <span class="n">h</span> <span class="o">*</span> <span class="mi">4</span><span class="o">]</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="o">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span> <span class="n">digest</span><span class="o">[</span><span class="n">h</span> <span class="o">*</span> <span class="mi">4</span><span class="o">]</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="o">;</span>
</span><span class='line'>                    <span class="k">this</span><span class="o">.</span><span class="na">getSessionList</span><span class="o">(</span><span class="n">sessionMap</span><span class="o">,</span> <span class="n">k</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="n">session</span><span class="o">);</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>            <span class="o">...</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">this</span><span class="o">.</span><span class="na">ketamaSessions</span> <span class="o">=</span> <span class="n">sessionMap</span><span class="o">;</span>
</span><span class='line'>    <span class="k">this</span><span class="o">.</span><span class="na">maxTries</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Session</span><span class="o">&gt;</span> <span class="nf">getSessionList</span><span class="o">(</span><span class="n">TreeMap</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Session</span><span class="o">&gt;&gt;</span> <span class="n">sessionMap</span><span class="o">,</span> <span class="kt">long</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">List</span><span class="o">&lt;</span><span class="n">Session</span><span class="o">&gt;</span> <span class="n">sessionList</span> <span class="o">=</span> <span class="n">sessionMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">k</span><span class="o">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">sessionList</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">sessionList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Session</span><span class="o">&gt;();</span>
</span><span class='line'>        <span class="n">sessionMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">sessionList</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">sessionList</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>buildMap的结果就是在0-2<sup>32</sup>这个圈上生成一些列的虚拟节点,每个虚拟节点都指向一个真实服务器.</p>

<p>例如本机只开一个服务器情况下,没有设置权重,会生成160个虚拟节点,每个虚拟节点都指向中一台服务器:</p>

<p><img src="/images/xmemcached/xmemcached-ketama-buildmap.png">
<strong>4.4.2 对Key做Hash</strong></p>

<p>做get或者set的时候,首先都会通过key找到服务器:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="n">Session</span> <span class="nf">getSessionByKey</span><span class="o">(</span><span class="kd">final</span> <span class="n">String</span> <span class="n">key</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>其实现代码如下:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">//通过key找真实到服务器</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">final</span> <span class="n">Session</span> <span class="nf">getSessionByKey</span><span class="o">(</span><span class="kd">final</span> <span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">ketamaSessions</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="k">this</span><span class="o">.</span><span class="na">ketamaSessions</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="kt">long</span> <span class="n">hash</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">hashAlg</span><span class="o">.</span><span class="na">hash</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>         <span class="c1">//计算key的Hash值</span>
</span><span class='line'>    <span class="n">Session</span> <span class="n">rv</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">getSessionByHash</span><span class="o">(</span><span class="n">hash</span><span class="o">);</span>   <span class="c1">//通过Hash值找服务器</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">tries</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>    <span class="k">while</span> <span class="o">(!</span><span class="k">this</span><span class="o">.</span><span class="na">failureMode</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">rv</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">rv</span><span class="o">.</span><span class="na">isClosed</span><span class="o">())</span>
</span><span class='line'>            <span class="o">&amp;&amp;</span> <span class="n">tries</span><span class="o">++</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">.</span><span class="na">maxTries</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">hash</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">nextHash</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">tries</span><span class="o">);</span>
</span><span class='line'>        <span class="n">rv</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">getSessionByHash</span><span class="o">(</span><span class="n">hash</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">rv</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">final</span> <span class="n">Session</span> <span class="nf">getSessionByHash</span><span class="o">(</span><span class="kd">final</span> <span class="kt">long</span> <span class="n">hash</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">TreeMap</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Session</span><span class="o">&gt;&gt;</span> <span class="n">sessionMap</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">ketamaSessions</span><span class="o">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">sessionMap</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="n">Long</span> <span class="n">resultHash</span> <span class="o">=</span> <span class="n">hash</span><span class="o">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(!</span><span class="n">sessionMap</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">hash</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">//下面的逻辑是找到大于hash值的第一个虚拟节点(即ceiling)</span>
</span><span class='line'>        <span class="c1">//Java 1.6使用ceilingKey可以实现,为兼容jdk5,使用tailMap,tailMap为所有大于hash值的虚拟节点</span>
</span><span class='line'>        <span class="n">SortedMap</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Session</span><span class="o">&gt;&gt;</span> <span class="n">tailMap</span> <span class="o">=</span> <span class="n">sessionMap</span><span class="o">.</span><span class="na">tailMap</span><span class="o">(</span><span class="n">hash</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">tailMap</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span><span class="c1">//没有比hash值大的节点,则取第一个虚拟节点</span>
</span><span class='line'>            <span class="n">resultHash</span> <span class="o">=</span> <span class="n">sessionMap</span><span class="o">.</span><span class="na">firstKey</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">resultHash</span> <span class="o">=</span> <span class="n">tailMap</span><span class="o">.</span><span class="na">firstKey</span><span class="o">();</span><span class="c1">//取tailMap第一个,即最大于hash值最小节点</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">List</span><span class="o">&lt;</span><span class="n">Session</span><span class="o">&gt;</span> <span class="n">sessionList</span> <span class="o">=</span> <span class="n">sessionMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">resultHash</span><span class="o">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">sessionList</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">sessionList</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">sessionList</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">sessionList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="n">size</span><span class="o">));</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里调试时候key是'a',其Hash值是3111502092:</p>

<p><img src="/images/xmemcached/xmemcached-ketama-key.png">
getSessionByHash的逻辑其实就是在Hash环上找第一个大于key对应hash值的虚拟节点,通过虚拟节点找到真实服务器.</p>

<p>这里的tailMap即为大于3111502092的虚拟节点,如下:</p>

<p><img src="/images/xmemcached/xmemcached-ketama-tailMap.png"></p>

<p>因此我们要找的虚拟节点就是3164521287对应的虚拟节点,其服务器指向的是127.0.0.1:11211.因此当前key(这里为'a')的请求被打到这台服务器上.</p>

<h3>4.5 使用XMemcached的一致性哈希</h3>

<p>默认情况下XMemcached使用的是余数哈希,如下使用一致性哈希:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">MemcachedClientBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">XMemcachedClientBuilder</span><span class="o">(</span><span class="n">AddrUtil</span><span class="o">.</span><span class="na">getAddresses</span><span class="o">(</span><span class="n">servers</span><span class="o">));</span>
</span><span class='line'><span class="c1">// 设置使用一致性hash</span>
</span><span class='line'><span class="n">builder</span><span class="o">.</span><span class="na">setSessionLocator</span><span class="o">(</span><span class="k">new</span> <span class="nf">KetamaMemcachedSessionLocator</span><span class="o">());</span>
</span><span class='line'><span class="k">return</span> <span class="n">builder</span><span class="o">.</span><span class="na">build</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/10/15/memcachednei-cun-cun-chu/">Memcached内存存储</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-10-15T18:13:49+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>15</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>6:13 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>早就听说过Memcached独特的内存管理方式,写着篇文章的目的就是了解Memcached的内存管理,学习其源代码.</p>

<h1>1.什么是Slab Allocator</h1>

<p>memcached默认情况下采用了名为Slab Allocator的机制分配、管理内存，Slab Allocator的基本原理是按照预先规定的大小，将分配的内存分割成特定长度的块，以期望完全解决内存碎片问题。而且，slab allocator还有重复使用已分配的内存的目的。 也就是说，分配到的内存不会释放，而是重复利用。</p>

<p><img src="/images/memcached/memcached-slab.png"></p>

<h1>2.Slab Allocation的主要术语</h1>

<pre><code>Page        分配给Slab的内存空间,默认是1MB,分配给Slab之后根据slab的大小切分成chunk
Chunk       用于缓存记录的内存空间
Slab Class  特定大小的chunk的组
</code></pre>

<p><img src="/images/memcached/memcached-slab-page.png"></p>

<h1>3.Slab初始化</h1>

<p>在Memcached启动时候会调用slab的初始化代码(详见memcached.c中main函数调用slabs_init函数).</p>

<p>slabs_init函数声明:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/** Init the subsystem. 1st argument is the limit on no. of bytes to allocate,</span>
</span><span class='line'><span class="cm">    0 if no limit. 2nd argument is the growth factor; each slab will use a chunk</span>
</span><span class='line'><span class="cm">    size equal to the previous slab&#39;s chunk size times this factor.</span>
</span><span class='line'><span class="cm">    3rd argument specifies if the slab allocator should allocate all memory</span>
</span><span class='line'><span class="cm">    up front (if true), or allocate memory in chunks as it is needed (if false)</span>
</span><span class='line'><span class="cm">*/</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">slabs_init</span><span class="p">(</span><span class="k">const</span> <span class="kt">size_t</span> <span class="n">limit</span><span class="p">,</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">factor</span><span class="p">,</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">prealloc</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中limit表示memcached最大使用内存;factor表示slab中chunk size的增长因子,slab中chunk size的大小等于前一个slab的chunk size乘以factor;</p>

<p>memcached.c中main函数调用slabs_init函数:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">slabs_init</span><span class="p">(</span><span class="n">settings</span><span class="p">.</span><span class="n">maxbytes</span><span class="p">,</span> <span class="n">settings</span><span class="p">.</span><span class="n">factor</span><span class="p">,</span> <span class="n">preallocate</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中settings.maxbytes默认值为64M,启动memcached使用选项-m设置;settings.factor默认为1.25,启动memcached时候使用-f设置;preallocate指的是启动memcached的时候默认为每种类型slab预先分配一个page的内存,默认是false;</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">settings</span><span class="p">.</span><span class="n">maxbytes</span> <span class="o">=</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span> <span class="cm">/* default is 64MB */</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="n">settings</span><span class="p">.</span><span class="n">factor</span> <span class="o">=</span> <span class="mf">1.25</span><span class="p">;</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="n">preallocate</span> <span class="o">=</span> <span class="nb">false</span>
</span></code></pre></td></tr></table></div></figure>


<p>slabs_init函数实现:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * Determines the chunk sizes and initializes the slab class descriptors</span>
</span><span class='line'><span class="cm"> * accordingly.</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">slabs_init</span><span class="p">(</span><span class="k">const</span> <span class="kt">size_t</span> <span class="n">limit</span><span class="p">,</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">factor</span><span class="p">,</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">prealloc</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">POWER_SMALLEST</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">//真实占用大小=对象大小+48</span>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">+</span> <span class="n">settings</span><span class="p">.</span><span class="n">chunk_size</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">mem_limit</span> <span class="o">=</span> <span class="n">limit</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//开启预分配,则首先将limit大小(默认64M)的内存全部申请</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">prealloc</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="cm">/* Allocate everything in a big chunk with malloc */</span>
</span><span class='line'>        <span class="n">mem_base</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">mem_limit</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">mem_base</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">mem_current</span> <span class="o">=</span> <span class="n">mem_base</span><span class="p">;</span>
</span><span class='line'>            <span class="n">mem_avail</span> <span class="o">=</span> <span class="n">mem_limit</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Warning: Failed to allocate requested memory in&quot;</span>
</span><span class='line'>                    <span class="s">&quot; one large chunk.</span><span class="se">\n</span><span class="s">Will allocate in smaller chunks</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//清空所有的slab</span>
</span><span class='line'>    <span class="n">memset</span><span class="p">(</span><span class="n">slabclass</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">slabclass</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">POWER_LARGEST</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">&lt;=</span> <span class="n">settings</span><span class="p">.</span><span class="n">item_size_max</span> <span class="o">/</span> <span class="n">factor</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="cm">/* Make sure items are always n-byte aligned */</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">%</span> <span class="n">CHUNK_ALIGN_BYTES</span><span class="p">)</span>
</span><span class='line'>            <span class="n">size</span> <span class="o">+=</span> <span class="n">CHUNK_ALIGN_BYTES</span> <span class="o">-</span> <span class="p">(</span><span class="n">size</span> <span class="o">%</span> <span class="n">CHUNK_ALIGN_BYTES</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">slabclass</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
</span><span class='line'>        <span class="n">slabclass</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">perslab</span> <span class="o">=</span> <span class="n">settings</span><span class="p">.</span><span class="n">item_size_max</span> <span class="o">/</span> <span class="n">slabclass</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>
</span><span class='line'>        <span class="n">size</span> <span class="o">*=</span> <span class="n">factor</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">settings</span><span class="p">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;slab class %3d: chunk size %9u perslab %7u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
</span><span class='line'>                    <span class="n">i</span><span class="p">,</span> <span class="n">slabclass</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">,</span> <span class="n">slabclass</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">perslab</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//最大chunksize的一个slab,chunksize为settings.item_size_max(默认1M)</span>
</span><span class='line'>    <span class="n">power_largest</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>    <span class="n">slabclass</span><span class="p">[</span><span class="n">power_largest</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">settings</span><span class="p">.</span><span class="n">item_size_max</span><span class="p">;</span>
</span><span class='line'>    <span class="n">slabclass</span><span class="p">[</span><span class="n">power_largest</span><span class="p">].</span><span class="n">perslab</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">settings</span><span class="p">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;slab class %3d: chunk size %9u perslab %7u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
</span><span class='line'>                <span class="n">i</span><span class="p">,</span> <span class="n">slabclass</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">,</span> <span class="n">slabclass</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">perslab</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//记录已分配的空间大小</span>
</span><span class='line'>    <span class="cm">/* for the test suite:  faking of how much we&#39;ve already malloc&#39;d */</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="kt">char</span> <span class="o">*</span><span class="n">t_initial_malloc</span> <span class="o">=</span> <span class="n">getenv</span><span class="p">(</span><span class="s">&quot;T_MEMD_INITIAL_MALLOC&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">t_initial_malloc</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">mem_malloced</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">atol</span><span class="p">(</span><span class="n">t_initial_malloc</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//开启了预分配,则为每种slab都分配一个page的空间</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">prealloc</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">slabs_preallocate</span><span class="p">(</span><span class="n">power_largest</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中settings.chunk_size默认为48:</p>

<pre><code>settings.chunk_size = 48;         /* space for a modest key and value */
</code></pre>

<p>POWER_LARGEST指slab种类的最大值,默认只为200,在memcached.c中设置</p>

<pre><code>#define POWER_LARGEST  200
</code></pre>

<p>settings.item_size_max就是每个page的大小,默认1M,在memcached.c中初始化:</p>

<pre><code>settings.item_size_max = 1024 * 1024; /* The famous 1MB upper limit. */
</code></pre>

<p>默认不开启预分配,因为很多时候Memcached只存储一种类型的数据(即其大小相对比较固定),这时候其他类型的预分配的slab空间就会浪费.</p>

<p>预分配的逻辑就是从最小的slab开始,为每类slab分配一个Page大小的空间(空间不足时停止分配):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">slabs_preallocate</span> <span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">maxslabs</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">prealloc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/* pre-allocate a 1MB slab in every size class so people don&#39;t get</span>
</span><span class='line'><span class="cm">       confused by non-intuitive &quot;SERVER_ERROR out of memory&quot;</span>
</span><span class='line'><span class="cm">       messages.  this is the most common question on the mailing</span>
</span><span class='line'><span class="cm">       list.  if you really don&#39;t want this, you can rebuild without</span>
</span><span class='line'><span class="cm">       these three lines.  */</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">POWER_SMALLEST</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">POWER_LARGEST</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">prealloc</span> <span class="o">&gt;</span> <span class="n">maxslabs</span><span class="p">)</span>
</span><span class='line'>            <span class="k">return</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">do_slabs_newslab</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Error while preallocating slab memory!</span><span class="se">\n</span><span class="s">&quot;</span>
</span><span class='line'>                <span class="s">&quot;If using -L or other prealloc options, max memory must be &quot;</span>
</span><span class='line'>                <span class="s">&quot;at least %d megabytes.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">power_largest</span><span class="p">);</span>
</span><span class='line'>            <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>do_slabs_newslab的工作就是为某一个slab分配空间,并将空间划分乘固定大小的chunk:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="kt">int</span> <span class="nf">do_slabs_newslab</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">slabclass_t</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">slabclass</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">settings</span><span class="p">.</span><span class="n">slab_reassign</span> <span class="o">?</span> <span class="n">settings</span><span class="p">.</span><span class="nl">item_size_max</span>
</span><span class='line'>        <span class="p">:</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">*</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">perslab</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">((</span><span class="n">mem_limit</span> <span class="o">&amp;&amp;</span> <span class="n">mem_malloced</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">mem_limit</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">slabs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
</span><span class='line'>        <span class="p">(</span><span class="n">grow_slab_list</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
</span><span class='line'>        <span class="p">((</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">memory_allocate</span><span class="p">((</span><span class="kt">size_t</span><span class="p">)</span><span class="n">len</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>  <span class="c1">//申请内存</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">MEMCACHED_SLABS_SLABCLASS_ALLOCATE_FAILED</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">memset</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">len</span><span class="p">);</span>
</span><span class='line'>    <span class="c1">//将内存划分乘chunk</span>
</span><span class='line'>    <span class="n">split_slab_page_into_freelist</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//维护slab链表</span>
</span><span class='line'>    <span class="n">p</span><span class="o">-&gt;</span><span class="n">slab_list</span><span class="p">[</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">slabs</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
</span><span class='line'>    <span class="n">mem_malloced</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
</span><span class='line'>    <span class="n">MEMCACHED_SLABS_SLABCLASS_ALLOCATE</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>split_slab_page_into_freelist的主要控制就是Page划分乘chunk并清空:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">split_slab_page_into_freelist</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">slabclass_t</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">slabclass</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">perslab</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">do_slabs_free</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
</span><span class='line'>        <span class="n">ptr</span> <span class="o">+=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>memcached的内存分配策略就是：按slab需求分配page,各slab按需使用chunk存储.</p>

<p>按需分配的意思就是某一类slab没有对象可存,就不会分配(非preallocate模式),某类slab存储对象很多,就会分配多个slab形成链表.</p>

<p>这里有几个特点要注意:</p>

<pre><code>1.Memcached分配出去的page不会被回收或者重新分配;
2.Memcached申请的内存不会被释放;
3.slab空闲的chunk不会借给任何其他slab使用(新版本memcached有slab_reassign,slab_automove的功能);
</code></pre>

<p>slab内存结构图,二维数组链表:</p>

<p><img src="/images/memcached/memcached_slab_alloct.jpg"></p>

<h1>4.往Slab中缓存记录</h1>

<p>memcached根据收到的数据的大小,选择最适合数据大小的slab.
memcached中保存着slab内空闲chunk的列表,根据该列表选择chunk,
然后将数据缓存于其中.</p>

<p><img src="/images/memcached/memcached-slab-save.png"></p>

<p>代码如下:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm"> * Figures out which slab class (chunk size) is required to store an item of</span>
</span><span class='line'><span class="cm"> * a given size.</span>
</span><span class='line'><span class="cm"> *</span>
</span><span class='line'><span class="cm"> * Given object size, return id to use when allocating/freeing memory for object</span>
</span><span class='line'><span class="cm"> * 0 means error: can&#39;t store such a large object</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">slabs_clsid</span><span class="p">(</span><span class="k">const</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">POWER_SMALLEST</span><span class="p">;</span>   <span class="c1">//最小slab编号</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">slabclass</span><span class="p">[</span><span class="n">res</span><span class="p">].</span><span class="n">size</span><span class="p">)</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">++</span> <span class="o">==</span> <span class="n">power_largest</span><span class="p">)</span>     <span class="cm">/* won&#39;t fit in the biggest slab */</span>
</span><span class='line'>            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>参数是待存储对象的大小,根据这个大小,从最小的Chunk Size开始查找,找到第一个(即最小的)能放下size大小的对象的Chunk.找不到(size大于最大的Chunk Size)返回0(这就是为什么slab class从1开始而不是从0开始).</p>

<p>如果某个Slab没有剩余的Chunk了，系统便会给这个Slab分配一个新的Page以供使用，如果没有Page可用，系统就会触发LRU机制，通过删除冷数据来为新数据腾出空间，这里有一点需要注意的是：LRU不是全局的，而是针对Slab而言的.</p>

<p>slab内存分配示例:</p>

<p><img src="/images/memcached/memcached_slab_ins.jpg"></p>

<h1>5.Slab Allocator的缺点</h1>

<p>由于Slab Allocator分配的是特定长度的内存，因此无法有效利用分配的内存。 例如，将100字节的数据缓存到128字节的chunk中，剩余的28字节就浪费了。</p>

<p><img src="/images/memcached/memcached-slab-disadvantage.png"></p>

<h1>6.Memcached减少内存浪费</h1>

<h3>4.1:调整growth factor</h3>

<pre><code>(1).估算我们item的大小
key键长＋suffix+value值长＋结构大小(48字节)
(2).逐步调整growth factor,使得某个slab的大小和我们的item大小接近(必须大于我们item的大小)
</code></pre>

<h1>7.过期数据</h1>

<pre><code>(1).LRU过期策略;
(2).在slab级别上执行LRU策略;
(3).查看是否过去是在get的时候,即懒惰(lazy)检查;
</code></pre>

<h1>8.memcached-tool脚本</h1>

<p>memcached-tool脚本可以方便地获得slab的使用情况 （它将memcached的返回值整理成容易阅读的格式）,可以从下面的地址获得脚本:
<a href="http://www.netingcn.com/demo/memcached-tool.zip">http://www.netingcn.com/demo/memcached-tool.zip</a></p>

<p>使用方法也极其简单：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">perl</span> <span class="n">memcached</span><span class="o">-</span><span class="n">tool</span> <span class="nl">server_ip</span><span class="p">:</span><span class="n">prot</span> <span class="n">option</span>
</span></code></pre></td></tr></table></div></figure>


<p>比如:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">perl</span> <span class="n">memcached</span><span class="o">-</span><span class="n">tool</span> <span class="mf">10.0.0.5</span><span class="o">:</span><span class="mi">11211</span> <span class="n">display</span>    <span class="err">#</span> <span class="n">shows</span> <span class="n">slabs</span>
</span><span class='line'><span class="n">perl</span> <span class="n">memcached</span><span class="o">-</span><span class="n">tool</span> <span class="mf">10.0.0.5</span><span class="o">:</span><span class="mi">11211</span>            <span class="err">#</span> <span class="n">same</span><span class="p">.</span>  <span class="p">(</span><span class="k">default</span> <span class="n">is</span> <span class="n">display</span><span class="p">)</span>
</span><span class='line'><span class="n">perl</span> <span class="n">memcached</span><span class="o">-</span><span class="n">tool</span> <span class="mf">10.0.0.5</span><span class="o">:</span><span class="mi">11211</span> <span class="n">stats</span>      <span class="err">#</span> <span class="n">shows</span> <span class="n">general</span> <span class="n">stats</span>
</span><span class='line'><span class="n">perl</span> <span class="n">memcached</span><span class="o">-</span><span class="n">tool</span> <span class="mf">10.0.0.5</span><span class="o">:</span><span class="mi">11211</span> <span class="n">move</span> <span class="mi">7</span> <span class="mi">9</span>   <span class="err">#</span> <span class="n">takes</span> <span class="mi">1</span><span class="n">MB</span> <span class="n">slab</span> <span class="n">from</span> <span class="n">class</span> <span class="err">#</span><span class="mi">7</span>
</span><span class='line'>                                              <span class="cp"># to class #9.</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出示例:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#  Item_Size   Max_age  1MB_pages Count   Full?</span>
</span><span class='line'> <span class="mi">1</span>     <span class="mi">104</span> <span class="n">B</span>  <span class="mi">1394292</span> <span class="n">s</span>    <span class="mi">1215</span> <span class="mi">12249628</span>    <span class="n">yes</span>
</span><span class='line'> <span class="mi">2</span>     <span class="mi">136</span> <span class="n">B</span>  <span class="mi">1456795</span> <span class="n">s</span>      <span class="mi">52</span>  <span class="mi">400919</span>     <span class="n">yes</span>
</span><span class='line'> <span class="p">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>各列的含义为：</p>

<pre><code>#           slab class编号
Item_Size   Chunk大小
Max_age     LRU内最旧的记录的生存时间
1MB_pages   分配给Slab的页数
Count       Slab内的记录数
Full?       Slab内是否含有空闲chunk
</code></pre>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/8">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/6">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <div class="panel-heading">
    <h1 class="panel-title">最新文章</h3>
  </div>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/11/19/memcachedxian-zhi-fang-wen-ip/">Memcached限制访问IP</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/18/libphonenumber/">Libphonenumber</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/09/lunecezheng-ti-jia-gou/">Lunece整体架构</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/03/luceneru-men/">Lucene入门</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/03/mysql-join/">Mysql Join</a>
      </li>
    
  </ul>
</section>
<section class="panel panel-default">
  <div  class="panel-heading">
    <h1 class="panel-title">文章分类</h1>
  </div>
  <div id="categories_list_div" class="list-group">
    <li><a class='list-group-item' href='/blog/categories/algorithm/'>algorithm (4)</a></li>
<li><a class='list-group-item' href='/blog/categories/druid/'>druid (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/dubbo/'>dubbo (2)</a></li>
<li><a class='list-group-item' href='/blog/categories/guava/'>guava (2)</a></li>
<li><a class='list-group-item' href='/blog/categories/java/'>java (23)</a></li>
<li><a class='list-group-item' href='/blog/categories/library/'>library (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/linux/'>linux (12)</a></li>
<li><a class='list-group-item' href='/blog/categories/maven/'>maven (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/memcached/'>memcached (5)</a></li>
<li><a class='list-group-item' href='/blog/categories/mybatis/'>mybatis (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/mysql/'>mysql (11)</a></li>
<li><a class='list-group-item' href='/blog/categories/octopress/'>octopress (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/postgresql/'>postgresql (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/qa/'>qa (2)</a></li>
<li><a class='list-group-item' href='/blog/categories/reading/'>reading (7)</a></li>
<li><a class='list-group-item' href='/blog/categories/search/'>search (8)</a></li>
<li><a class='list-group-item' href='/blog/categories/spring/'>spring (3)</a></li>
<li><a class='list-group-item' href='/blog/categories/squid/'>squid (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/structure/'>structure (3)</a></li>
<li><a class='list-group-item' href='/blog/categories/tomcat/'>tomcat (3)</a></li>
<li><a class='list-group-item' href='/blog/categories/tools/'>tools (8)</a></li>
<li><a class='list-group-item' href='/blog/categories/web/'>web (1)</a></li>
 
  </div>
</section>
<section class="panel panel-default">
  <div  class="panel-heading">
    <h1 class="panel-title">其他博客</h3>
  </div>
  <div id="categories_list_div" class="list-group">
    <a class='list-group-item' href='http://www.baidu.com/p/Nicker_2010'>百度空间</a>
  </div>
</section>

  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - xiaobaoqiu -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
