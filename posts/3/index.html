
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>xiaobaoqiu Blog</title>
  <meta name="author" content="xiaobaoqiu">

  
  <meta name="description" content="最近项目中遇到一个问题，无意中发现Spring SpEL语法，Spring的Cache正是基于此实现的，感觉很强大，学习一下。 1.简介 SpEL官网：http://docs.spring.io/spring/docs/current/spring-framework-reference/html &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://xiaobaoqiu.github.io/posts/3/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  

  <link href="/atom.xml" rel="alternate" title="xiaobaoqiu Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">xiaobaoqiu Blog</a></h1>
  
    <h2>Keep Runnnnnnnnnning...</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss email">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
    <li><a href="xiaobaoqiu@163.com" rel="subscribe-email" title="subscribe via email">Email</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="xiaobaoqiu.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">所有博文</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/04/09/spring-spelyu-fa/">Spring SpEL语法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-09T07:25:44+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>9</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>7:25 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近项目中遇到一个问题，无意中发现Spring SpEL语法，Spring的Cache正是基于此实现的，感觉很强大，学习一下。</p>

<h1>1.简介</h1>

<p>SpEL官网：<a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html">http://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html</a></p>

<p>Spring表达式语言全称为Spring Expression Language(缩写为SpEL)，能在运行时构建复杂表达式、存取对象图属性、对象方法调用等等，并且能与Spring功能完美整合，如能用来配置Bean定义。
表达式语言给静态Java语言增加了动态功能。</p>

<p>SpEL是单独模块，只依赖于core模块，不依赖于其他模块，可以单独使用。</p>

<p>SpEL支持以下功能:</p>

<pre><code>1.文本表达式(Literal expressions)
2.布尔操作和关系操作(Boolean and relational operators)
3.正则表达式(Regular expressions)
4.类表达式(Class expressions)
5.访问属性,数组,list和map(Accessing properties, arrays, lists, maps)
6.方法调用(Method invocation)
7.关系操作符(Relational operators)
8.赋值(Assignment)
9.调用构造器(Calling constructors)
10.Bean引用(Bean references)
11.数组构造(Array construction)
12.内脸list(Inline lists)
13.内联Map(Inline maps)
14.三元运算符(Ternary operator)
15.变量(Variables)
16.自定义函数(User defined functions)
17.集合投影(Collection projection)
18.集合筛选(Collection selection)
19.模板表达式(Templated expressions)
</code></pre>

<h1>2.SpEL使用</h1>

<p>下面通过一些简单的case来示范SpEL的使用.</p>

<h3>2.1 第一个SpEL</h3>

<p>SpEL表达式可以直接使用ExpressionParser解析,主要是调用ExpressionParser的parseExpression()方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_1(){
</span><span class='line'>    Expression expression = parser.parseExpression("'Testing Spring Expression Framework'");
</span><span class='line'>    String message = (String) expression.getValue();
</span><span class='line'>    System.out.println("Message is " + message);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.2 字面量表达式</h3>

<p>SpEL支持的字面量包括字符串、数字类型（int、long、float、double）、bool类型、null类型,注意字符串必须要单引号括起来:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_2(){
</span><span class='line'>    // evals to "Hello World"
</span><span class='line'>    String helloWorld = (String) parser.parseExpression("'Hello World'").getValue();
</span><span class='line'>    double avogadrosNumber = (Double) parser.parseExpression("6.0221415E+23").getValue();
</span><span class='line'>
</span><span class='line'>    // evals to 2147483647
</span><span class='line'>    int maxValue = (Integer) parser.parseExpression("0x7FFFFFFF").getValue();
</span><span class='line'>    boolean trueValue = (Boolean) parser.parseExpression("true").getValue();
</span><span class='line'>    Object nullValue = parser.parseExpression("null").getValue();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.3 算数运算表达式</h3>

<p>SpEL支持加(+)、减(-)、乘(*)、除(/)、求余（%）、幂（^）运算,SpEL还提供求余（MOD）和除（DIV）而外两个运算符，与"%&ldquo;和&rdquo;/&ldquo;等价，不区分大小写:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_3(){
</span><span class='line'>    int result1 = parser.parseExpression("1+2-3*4/2").getValue(Integer.class);
</span><span class='line'>    int result2 = parser.parseExpression("4%3").getValue(Integer.class);
</span><span class='line'>    int result3 = parser.parseExpression("2^3").getValue(Integer.class);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.4 关系表达式</h3>

<p>等于（==）、不等于(!=)、大于(>)、大于等于(>=)、小于(&lt;)、小于等于(&lt;=)，区间（between）运算:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_4(){
</span><span class='line'>    boolean result1 = parser.parseExpression("1&gt;2").getValue(boolean.class);
</span><span class='line'>    boolean result2 = parser.parseExpression("1 between {1, 2}").getValue(boolean.class);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>between运算符右边操作数必须是列表类型，且只能包含2个元素。第一个元素为开始，第二个元素为结束，区间运算是包含边界值的。</p>

<p>SpEL同样提供了等价的"EQ" 、"NE"、 &ldquo;GT"、"GE"、 "LT&rdquo; 、"LE"来表示等于、不等于、大于、大于等于、小于、小于等于，不区分大小写。</p>

<h3>2.5 逻辑表达式</h3>

<p>且（and）、或(or)、非(!或NOT),注意,逻辑运算符不支持 Java中的 &amp;&amp; 和 ||:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_5() {
</span><span class='line'>    String expression1 = "2&gt;1 and (!true or !false)";
</span><span class='line'>    boolean result1 = parser.parseExpression(expression1).getValue(boolean.class);
</span><span class='line'>
</span><span class='line'>    String expression2 = "2&gt;1 and (NOT true or NOT false)";
</span><span class='line'>    boolean result2 = parser.parseExpression(expression2).getValue(boolean.class);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.6 字符串连接及截取表达式</h3>

<p>使用"+&ldquo;进行字符串连接，使用&rdquo;&lsquo;String&rsquo;[0] [index]&ldquo;来截取一个字符，目前只支持截取一个，如&rdquo;&lsquo;Hello &rsquo; + &lsquo;World!&rsquo;&ldquo;得到"Hello World!"；而&rdquo;&lsquo;Hello World!&rsquo;[0]&ldquo;将返回"H"。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_6() {
</span><span class='line'>//    String expression1 = "'Hello Spring SpEL'[0] [5]";
</span><span class='line'>//    String result1 = parser.parseExpression(expression1).getValue(String.class);
</span><span class='line'>//    System.out.println("result1=" + result1);
</span><span class='line'>
</span><span class='line'>    String expression2 = "'Hello' + 'Spring' + 'SpEL.'";
</span><span class='line'>    String result2 = parser.parseExpression(expression2).getValue(String.class);
</span><span class='line'>//    System.out.println("result1=" + result1);
</span><span class='line'>    System.out.println("result2=" + result2);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.7 三目运算</h3>

<p>三目运算符 &ldquo;表达式1?表达式2:表达式3"用于构造三目运算表达式，如"2>1?true:false"将返回true；</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_7() {
</span><span class='line'>    boolean result1 = parser.parseExpression("2&gt;1?true:false").getValue(boolean.class);
</span><span class='line'>    System.out.println("result1=" + result1);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.8 正则表达式</h3>

<p>可以正则,格式为:str matches regex</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_8() {
</span><span class='line'>    boolean result1 = parser.parseExpression("'123' matches '\\d{3}'").getValue(boolean.class);
</span><span class='line'>    System.out.println("result1=" + result1);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.9 括号优先级表达式</h3>

<p>使用"(表达式)&ldquo;构造，括号里的具有高优先级</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_9() {
</span><span class='line'>    int result1 = parser.parseExpression("1+2-3*4/2").getValue(Integer.class);
</span><span class='line'>    int result2 = parser.parseExpression("1+(2-3)*4/2").getValue(Integer.class);
</span><span class='line'>    System.out.println("result1=" + result1);
</span><span class='line'>    System.out.println("result2=" + result2);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.10 类类型表达式</h3>

<p>使用"T(Type)&ldquo;来表示java.lang.Class实例，"Type"必须是类全限定名，"java.lang"包除外，即该包下的类可以不指定包名；使用类类型表达式还可以进行访问类静态方法及类静态字段。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_10() {
</span><span class='line'>    //java.lang包类访问
</span><span class='line'>    Class&lt;String&gt; result1 = parser.parseExpression("T(String)").getValue(Class.class);
</span><span class='line'>    System.out.println("result1=" + result1);
</span><span class='line'>    //其他包类访问
</span><span class='line'>    String expression2 = "T(com.qunar.scm.spel.SpelParser)";
</span><span class='line'>    Class&lt;String&gt; result2 = parser.parseExpression(expression2).getValue(Class.class);
</span><span class='line'>    System.out.println("result2=" + result2);
</span><span class='line'>    //类静态字段访问
</span><span class='line'>    int result3=parser.parseExpression("T(Integer).MAX_VALUE").getValue(int.class);
</span><span class='line'>    System.out.println("result3=" + result3);
</span><span class='line'>    //类静态方法调用
</span><span class='line'>    int result4 = parser.parseExpression("T(Integer).parseInt('1')").getValue(int.class);
</span><span class='line'>    System.out.println("result4=" + result4);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.11 类实例化</h3>

<p>类实例化同样使用java关键字"new"，类名必须是全限定名，但java.lang包内的类型除外，如String、Integer.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_11() {
</span><span class='line'>    String result1 = parser.parseExpression("new String('Spring SpEL')").getValue(String.class);
</span><span class='line'>    System.out.println("result1=" + result1);
</span><span class='line'>
</span><span class='line'>    Date result2 = parser.parseExpression("new java.util.Date()").getValue(Date.class);
</span><span class='line'>    System.out.println("result2=" + result2);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.12 instanceof表达式</h3>

<p>SpEL支持instanceof运算符，跟Java内使用同义:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_12() {
</span><span class='line'>    boolean result1 = parser.parseExpression("'Spring SpEL' instanceof T(String)").getValue(Boolean.class);
</span><span class='line'>    System.out.println("result1=" + result1);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.13 变量定义及引用</h3>

<p>变量定义通过EvaluationContext接口的setVariable(variableName, value)方法定义；在表达式中使用"#variableName"引用；</p>

<p>除了引用自定义变量，SpE还允许引用根对象及当前上下文对象，使用"#root"引用根对象，使用"#this"引用当前上下文对象；</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_13() {
</span><span class='line'>    EvaluationContext context = new StandardEvaluationContext();
</span><span class='line'>    context.setVariable("variable", "Spring SpEL");
</span><span class='line'>    String result1 = parser.parseExpression("#variable").getValue(context, String.class);
</span><span class='line'>    System.out.println("result1=" + result1);   //Spring SpEL
</span><span class='line'>
</span><span class='line'>    context = new StandardEvaluationContext("Spring SpEL");
</span><span class='line'>    String result2 = parser.parseExpression("#root").getValue(context, String.class);
</span><span class='line'>    System.out.println("result2=" + result2);   //Spring SpEL
</span><span class='line'>    String result3 = parser.parseExpression("#this").getValue(context, String.class);
</span><span class='line'>    System.out.println("result3=" + result3);   //Spring SpEL
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.14 自定义函数</h3>

<p>学习编写自定义的函数并将其注册,这样这个函数就可以在SpEL表达式中使用.</p>

<p>首先是两个工具类的代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class CollectionUtils {
</span><span class='line'>    /**
</span><span class='line'>     * 集合中的最大元素
</span><span class='line'>     * @param collection
</span><span class='line'>     * @return
</span><span class='line'>     */
</span><span class='line'>    public static Integer maxElement(Collection&lt;Integer&gt; collection) {
</span><span class='line'>        Integer maxElement = null;
</span><span class='line'>        Iterator iterator = collection.iterator();
</span><span class='line'>        while (iterator.hasNext()) {
</span><span class='line'>
</span><span class='line'>            Integer integer = (Integer) iterator.next();
</span><span class='line'>
</span><span class='line'>            if (maxElement == null) {
</span><span class='line'>                maxElement = integer;
</span><span class='line'>            } else {
</span><span class='line'>                if (integer.intValue() &gt; maxElement.intValue()) {
</span><span class='line'>                    maxElement = integer;
</span><span class='line'>                }
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>        return maxElement;
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public class MathUtils {
</span><span class='line'>    /**
</span><span class='line'>     * 测试一个数字是否为素数
</span><span class='line'>     * @param number
</span><span class='line'>     * @return
</span><span class='line'>     */
</span><span class='line'>    public static boolean isPrime(Integer number) {
</span><span class='line'>
</span><span class='line'>        if (number == 0) {
</span><span class='line'>            return false;
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        for (int index = 2; index &lt; number; index++) {
</span><span class='line'>            if (number % index == 0) {
</span><span class='line'>                return false;
</span><span class='line'>            } else {
</span><span class='line'>                continue;
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>        return true;
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>下面,我们首先初始化一个EvaluationContext,具体类是StandardEvaluationContext.</p>

<p>一个context evaluation object能用来存储任意多个对象,这些对象会在在随后的表达式解析中使用.
另外evaluation context也能用来注册用户自定义的方法.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void main(String[] args) throws Exception {
</span><span class='line'>        ExpressionParser parser = new SpelExpressionParser();
</span><span class='line'>
</span><span class='line'>        StandardEvaluationContext context = new StandardEvaluationContext();
</span><span class='line'>        Method method = null;
</span><span class='line'>        Expression expression = null;
</span><span class='line'>        Boolean value = null;
</span><span class='line'>
</span><span class='line'>        // 注册方法 isPrime() 为 prime
</span><span class='line'>        method = MathUtils.class.getMethod("isPrime", Integer.class);
</span><span class='line'>        context.registerFunction("prime", method);
</span><span class='line'>
</span><span class='line'>        expression = parser.parseExpression("#prime(10)");
</span><span class='line'>        value = expression.getValue(context, Boolean.class);
</span><span class='line'>        System.out.println("Number 10 is prime: " + value);
</span><span class='line'>
</span><span class='line'>        expression = parser.parseExpression("#prime(37)");
</span><span class='line'>        value = expression.getValue(context, Boolean.class);
</span><span class='line'>        System.out.println("Number 37 is prime: " + value);
</span><span class='line'>
</span><span class='line'>        // 注册方法 maxElement() 为 max
</span><span class='line'>        method = CollectionUtils.class.getMethod("maxElement", Collection.class);
</span><span class='line'>        context.registerFunction("max", method);
</span><span class='line'>
</span><span class='line'>        // Collection为参数maxElement()
</span><span class='line'>        expression = parser.parseExpression("#max({10, 43, 45, 98, 32, 1})");
</span><span class='line'>        Integer maxElement = expression.getValue(context, Integer.class);
</span><span class='line'>        System.out.println("Max element in the list is : " + maxElement);
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>注：EvaluationContext开销较大，所以多用于数据变化较少的情况。如果数据变化频繁，我们可以考虑直接引用对象（比如上例中的simple）以减小开销。</p>

<h3>2.15 赋值表达式</h3>

<p>SpEL即允许给自定义变量赋值，也允许给跟对象赋值，直接使用"#variableName=value"即可赋值：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_15() {
</span><span class='line'>    EvaluationContext context = new StandardEvaluationContext();
</span><span class='line'>    //1.给自定义变量赋值
</span><span class='line'>    context.setVariable("variable", "Spring SpEL");
</span><span class='line'>    String result1 = parser.parseExpression("#variable").getValue(context, String.class);
</span><span class='line'>    System.out.println("result1=" + result1);
</span><span class='line'>
</span><span class='line'>    //修改
</span><span class='line'>    String result2 = parser.parseExpression("#variable='ABC'").getValue(context, String.class);
</span><span class='line'>    System.out.println("result2=" + result2);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.16 对象属性存取及安全导航表达式</h3>

<p>对象属性获取非常简单，即使用如"a.property.property"这种点缀式获取，SpEL对于属性名首字母是不区分大小写的；修改对象属性值则可以通过赋值表达式或Expression接口的setValue方法修改。</p>

<p>对于当前上下文对象属性及方法访问，可以直接使用属性或方法名访问，注意此处属性名首字母不区分大小写。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_16() {
</span><span class='line'>    ExpressionParser parser = new SpelExpressionParser();
</span><span class='line'>    // 1.访问root对象属性
</span><span class='line'>    Date date = new Date();
</span><span class='line'>    System.out.println("date=" + date);
</span><span class='line'>    StandardEvaluationContext context = new StandardEvaluationContext(date);
</span><span class='line'>    int result1 = parser.parseExpression("Month").getValue(context, int.class);
</span><span class='line'>    System.out.println("result1=" + result1);
</span><span class='line'>    int result2 = parser.parseExpression("month").getValue(context, int.class);
</span><span class='line'>    System.out.println("result2=" + result2);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>SpEL还引入了Groovy语言中的安全导航运算符"(对象|属性)?.属性"，用来避免但"?.&ldquo;前边的表达式为null时抛出空指针异常，而是返回null；</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_16() {
</span><span class='line'>    ExpressionParser parser = new SpelExpressionParser();
</span><span class='line'>    // 2.安全访问
</span><span class='line'>    context.setRootObject(null);
</span><span class='line'>    Object result3 = parser.parseExpression("#root?.year").getValue(context, Object.class);
</span><span class='line'>    System.out.println("result3=" + result3);   //null
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.17 对象方法调用</h3>

<p>对象方法调用更简单，跟Java语法一样；如"&lsquo;Spring&rsquo;.substring(2,4)&ldquo;将返回"ri"；而对于根对象可以直接调用方法；</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_17() {
</span><span class='line'>    String result1 = parser.parseExpression("'Spring SpEL'.substring(2,4)").getValue(String.class);
</span><span class='line'>    System.out.println("result1=" + result1);
</span><span class='line'>
</span><span class='line'>    //root对象date方法"getYear"可以直接调用
</span><span class='line'>    Date date = new Date();
</span><span class='line'>    StandardEvaluationContext context = new StandardEvaluationContext(date);
</span><span class='line'>    int result2 = parser.parseExpression("getMonth()").getValue(context, int.class);
</span><span class='line'>    System.out.println("result2=" + result2);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.18 Bean引用</h3>

<p>SpEL支持使用"@&ldquo;符号来引用Bean，在引用Bean时需要使用BeanResolver接口实现来查找Bean，Spring提供BeanFactoryResolver实现；</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_18() {
</span><span class='line'>    ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext();
</span><span class='line'>    ctx.refresh();
</span><span class='line'>    ExpressionParser parser = new SpelExpressionParser();
</span><span class='line'>    StandardEvaluationContext context = new StandardEvaluationContext();
</span><span class='line'>    context.setBeanResolver(new BeanFactoryResolver(ctx));
</span><span class='line'>    Properties result1 = parser.parseExpression("@systemProperties").getValue(context, Properties.class);
</span><span class='line'>    System.out.println("result1=" + result1);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在示例中我们首先初始化了一个IoC容器，ClassPathXmlApplicationContext实现默认会把"System.getProperties()&ldquo;注册为"systemProperties"Bean，因此我们使用 &rdquo;@systemProperties"来引用该Bean。</p>

<h3>2.19 内联List</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_19() {
</span><span class='line'>    // 将返回不可修改的空List
</span><span class='line'>    List&lt;Integer&gt; result0 = parser.parseExpression("{}").getValue(List.class);
</span><span class='line'>    System.out.println("result0=" + result0);   //[]
</span><span class='line'>
</span><span class='line'>    //对于字面量列表也将返回不可修改的List
</span><span class='line'>    List&lt;Integer&gt; result1 = parser.parseExpression("{1,2,3}").getValue(List.class);
</span><span class='line'>    System.out.println("result1=" + result1);   //[1, 2, 3]
</span><span class='line'>    Assert.assertEquals(new Integer(1), result1.get(0));
</span><span class='line'>    try {
</span><span class='line'>        result1.set(0, 2);
</span><span class='line'>        //不可能执行到这，对于字面量列表不可修改
</span><span class='line'>    } catch (Exception e) {
</span><span class='line'>        e.printStackTrace();
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //对于列表中只要有一个不是字面量表达式，将只返回原始List， 会进行不可修改处理
</span><span class='line'>    String expression3 = "\{\{1+2,2+4\},\{3,4+4\}\}";
</span><span class='line'>    List&lt;List&lt;Integer&gt;&gt; result2 = parser.parseExpression(expression3).getValue(List.class);
</span><span class='line'>    System.out.println("result2=" + result2);   //[[3, 6], [3, 8]]
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.20 内联数组</h3>

<p>和Java 数组定义类似，只是在定义时进行多维数组初始化</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_20() {
</span><span class='line'>    //定义一维数组并初始化
</span><span class='line'>    int[] result1 = parser.parseExpression("new int[1]{8}").getValue(int[].class);
</span><span class='line'>    System.out.println("result1.length=" + result1.length + ",result1=" + result1);
</span><span class='line'>
</span><span class='line'>    // 定义多维数组但不初始化, 多维数组不能初始化
</span><span class='line'>    String expression1 = "new int[1][2]";
</span><span class='line'>    //String expression2 = "new int[1][2]\{\{1}\{2\}\}"; //多维数组不能初始化
</span><span class='line'>    int[][] result2 = parser.parseExpression(expression1).getValue(int[][].class);
</span><span class='line'>    System.out.println("result2.length=" + result2.length + ",result2=" + result2);
</span><span class='line'>
</span><span class='line'>    //解析到多维数据
</span><span class='line'>    String expression3 = "\{\{3,4\},\{5,6\}\}";
</span><span class='line'>    int[][] result3 = parser.parseExpression(expression3).getValue(int[][].class);
</span><span class='line'>    System.out.println("result3=" + result3);   //[[3, 6], [3, 8]]
</span><span class='line'>    for (int[] row : result3) {
</span><span class='line'>        for(int data : row) {
</span><span class='line'>            System.out.print(data + "   ");
</span><span class='line'>        }
</span><span class='line'>        System.out.println();
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.21 集合，字典元素访问</h3>

<p>SpEL目前支持所有集合类型和字典类型的元素访问，使用"集合[索引]&ldquo;访问集合元素，使用"map[key]"访问字典元素；</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_21() {
</span><span class='line'>    // SpEL内联List访问
</span><span class='line'>    int result1 = parser.parseExpression("{1,2,3}[0]").getValue(int.class);
</span><span class='line'>    System.out.println("result1=" + result1);   //1
</span><span class='line'>
</span><span class='line'>    EvaluationContext context = new StandardEvaluationContext();
</span><span class='line'>
</span><span class='line'>    //SpEL目前支持所有集合类型的访问
</span><span class='line'>    Collection&lt;Integer&gt; collection = new HashSet&lt;Integer&gt;();
</span><span class='line'>    collection.add(1);
</span><span class='line'>    collection.add(2);
</span><span class='line'>    context.setVariable("collection", collection);
</span><span class='line'>    int result2 = parser.parseExpression("#collection[1]").getValue(context, int.class);
</span><span class='line'>    System.out.println("result2=" + result2);   //2
</span><span class='line'>
</span><span class='line'>    //SpEL对Map字典元素访问的支持
</span><span class='line'>    Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();
</span><span class='line'>    map.put("A", 3);
</span><span class='line'>    context.setVariable("map", map);
</span><span class='line'>    int result3 = parser.parseExpression("#map['A']").getValue(context, int.class);
</span><span class='line'>    System.out.println("result3=" + result3);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.22 列表，字典，数组元素修改</h3>

<p>可以使用赋值表达式或Expression接口的setValue方法修改</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_22() {
</span><span class='line'>    EvaluationContext context = new StandardEvaluationContext();
</span><span class='line'>
</span><span class='line'>    //1.修改数组元素值
</span><span class='line'>    int[] array = new int[] {1, 2};
</span><span class='line'>    context.setVariable("array", array);
</span><span class='line'>    int result1 = parser.parseExpression("#array[1] = 3").getValue(context, int.class);
</span><span class='line'>    System.out.println("result1=" + result1);   //3
</span><span class='line'>
</span><span class='line'>    //2.修改集合值
</span><span class='line'>    Collection&lt;Integer&gt; collection = new ArrayList&lt;Integer&gt;();
</span><span class='line'>    collection.add(1);
</span><span class='line'>    collection.add(2);
</span><span class='line'>    context.setVariable("collection", collection);
</span><span class='line'>    int result2 = parser.parseExpression("#collection[1] = 4").getValue(context, int.class);
</span><span class='line'>    System.out.println("result2=" + result2);   //4
</span><span class='line'>    parser.parseExpression("#collection[1]").setValue(context, 5);
</span><span class='line'>    int result3 = parser.parseExpression("#collection[1]").getValue(context, int.class);
</span><span class='line'>    System.out.println("result3=" + result3);   //5
</span><span class='line'>
</span><span class='line'>    //3.修改map元素值
</span><span class='line'>    Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();
</span><span class='line'>    map.put("A", 1);
</span><span class='line'>    context.setVariable("map", map);
</span><span class='line'>    int result4 = parser.parseExpression("#map['A'] = 6").getValue(context, int.class);
</span><span class='line'>    System.out.println("result4=" + result4);   //6
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.23 集合投影</h3>

<p>在SQL中投影指从表中选择出列，而在SpEL指根据集合中的元素中通过选择来构造另一个集合，该集合和原集合具有相同数量的元素；SpEL使用"（list|map）.![投影表达式]&ldquo;来进行投影运算.</p>

<p>对于集合或数组使用如上表达式进行投影运算，其中投影表达式中"#this"代表每个集合或数组元素，可以使用比如"#this.property"来获取集合元素的属性，其中"#this"可以省略。</p>

<p>SpEL投影运算还支持Map投影，但Map投影最终只能得到List结果，如上所示，对于投影表达式中的"#this"将是Map.Entry，所以可以使用"value"来获取值，使用"key"来获取键。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_23() {
</span><span class='line'>    EvaluationContext context = new StandardEvaluationContext();
</span><span class='line'>
</span><span class='line'>    //1.首先准备测试数据
</span><span class='line'>    Collection&lt;Integer&gt; collection = new ArrayList&lt;Integer&gt;();
</span><span class='line'>    collection.add(4);
</span><span class='line'>    collection.add(5);
</span><span class='line'>
</span><span class='line'>    Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();
</span><span class='line'>    map.put("A", 1);
</span><span class='line'>    map.put("B", 2);
</span><span class='line'>
</span><span class='line'>    //2.collection中每个值加1
</span><span class='line'>    context.setVariable("collection", collection);
</span><span class='line'>    Collection&lt;Integer&gt; result1 = parser.parseExpression("#collection.![#this+1]").getValue(context,
</span><span class='line'>            Collection.class);
</span><span class='line'>    System.out.println("result1.size()=" + result1.size() + ", result1=" + result1);//result1.size()=2, result1=[5, 6]
</span><span class='line'>
</span><span class='line'>    //3.测试map
</span><span class='line'>    context.setVariable("map", map);
</span><span class='line'>    List&lt;Integer&gt; result2 = parser.parseExpression("#map.![value+1]").getValue(context, List.class);
</span><span class='line'>    System.out.println("result2.size()=" + result2.size() + ", result2=" + result2);    //result2.size()=2, result2=[2, 3]
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.24 集合选择</h3>

<p>在SQL中指使用select进行选择行数据，而在SpEL指根据原集合通过条件表达式选择出满足条件的元素并构造为新的集合，SpEL使用"(list|map).?[选择表达式]&ldquo;，其中选择表达式结果必须是boolean类型，如果true则选择的元素将添加到新集合中，false将不添加到新集合中。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void test2_24() {
</span><span class='line'>    EvaluationContext context = new StandardEvaluationContext();
</span><span class='line'>
</span><span class='line'>    // 1.首先准备测试数据
</span><span class='line'>    Collection&lt;Integer&gt; collection = new ArrayList&lt;Integer&gt;();
</span><span class='line'>    collection.add(4);
</span><span class='line'>    collection.add(5);
</span><span class='line'>
</span><span class='line'>    Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();
</span><span class='line'>    map.put("A", 1);
</span><span class='line'>    map.put("B", 2);
</span><span class='line'>
</span><span class='line'>    // 2.集合或数组测试:出集合元素值大于4的所有元素
</span><span class='line'>    context.setVariable("collection", collection);
</span><span class='line'>    Collection&lt;Integer&gt; result1 = parser.parseExpression("#collection.?[#this&gt;4]").getValue(context,
</span><span class='line'>            Collection.class);
</span><span class='line'>    System.out.println("result1.size()=" + result1.size() + ", result1=" + result1); // result1.size()=1, result1=[5]
</span><span class='line'>
</span><span class='line'>    // 3.字典测试:选择键值不等于"A"的,注意map选择表达式中"#this"是Map.Entry类型
</span><span class='line'>    context.setVariable("map", map);
</span><span class='line'>    Map&lt;String, Integer&gt; result2 = parser.parseExpression("#map.?[#this.key != 'A']").getValue(context, Map.class);
</span><span class='line'>    System.out.println("result2=" + result2); // result2={B=2}
</span><span class='line'>
</span><span class='line'>    List&lt;Integer&gt; result3 = parser.parseExpression("#map.?[key != 'A'].![value+1]").getValue(context, List.class);
</span><span class='line'>    System.out.println("result3.size()=" + result3.size() + ", result3=" + result3); // result3.size()=1,
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.25 表达式模板</h3>

<h1>3.Spring Cache</h1>

<p>Spring 3.1引入了激动人心的基于注释(annotation)的缓存(cache)技术，它本质上不是一个具体的缓存实现方案(例如 EHCache等)，而是一个对缓存使用的抽象,通过在既有代码中添加少量它定义的各种 annotation,即能够达到缓存方法的返回对象的效果。</p>

<p>Spring Cache是使用SpEL表达式的一个地方.将会另起一篇单独介绍Sping Cache.</p>

<h1>4.参考</h1>

<p><a href="http://sishuok.com/forum/blogPost/list/2463.html">http://sishuok.com/forum/blogPost/list/2463.html</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/04/09/maven-compiler-plugin/">Maven-compiler-plugin</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-09T07:04:59+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>9</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>7:04 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>今天项目发布的出现一个异常：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Unsupported major.minor version 51.0 (unable to load class XXX)</span></code></pre></td></tr></table></div></figure>


<p>一看到这个51.0,直觉想起了JDK 1.7。追查问题发现是新定义了maven-compiler-plugin，并且指定了版本为1.7,但是线上应用机器上的JDK版本是1.6,导致编译产生的1.7版本的class文件在1.6(version为50)上无法执行。</p>

<p>maven-compiler-plugin用来指定编译时候的JDK版本</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;plugin&gt;
</span><span class='line'>    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
</span><span class='line'>    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
</span><span class='line'>    &lt;version&gt;3.1&lt;/version&gt;
</span><span class='line'>    &lt;configuration&gt;
</span><span class='line'>        &lt;source&gt;1.7&lt;/source&gt; &lt;!-- 源代码使用的开发版本 --&gt;
</span><span class='line'>        &lt;target&gt;1.7&lt;/target&gt; &lt;!-- 需要生成的目标class文件的编译版本 --&gt;
</span><span class='line'>        &lt;!-- 一般而言，target与source是保持一致的，但是，有时候为了让程序能在其他版本的jdk中运行(对于低版本目标jdk，源代码中需要没有使用低版本jdk中不支持的语法)，会存在target不同于source的情况 --&gt;
</span><span class='line'>     
</span><span class='line'>        &lt;!-- 这下面的是可选项 --&gt;
</span><span class='line'>        &lt;meminitial&gt;128m&lt;/meminitial&gt;
</span><span class='line'>        &lt;maxmem&gt;512m&lt;/maxmem&gt;
</span><span class='line'>        &lt;fork&gt;true&lt;/fork&gt; &lt;!-- fork is enable,用于明确表示编译版本配置的可用 --&gt; 
</span><span class='line'>        &lt;compilerVersion&gt;1.3&lt;/compilerVersion&gt;
</span><span class='line'>         
</span><span class='line'>        &lt;!-- 这个选项用来传递编译器自身不包含但是却支持的参数选项 --&gt;
</span><span class='line'>        &lt;compilerArgument&gt;-verbose -bootclasspath ${java.home}\lib\rt.jar&lt;/compilerArgument&gt;
</span><span class='line'>         
</span><span class='line'>    &lt;/configuration&gt;
</span><span class='line'>&lt;/plugin&gt;</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/04/08/mysql-utf8mb4/">Mysql Utf8mb4</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-08T04:50:24+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>8</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>4:50 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>MYSQL 5.5 之前， UTF8 编码只支持1-3个字节，只支持BMP这部分的unicode编码区， BMP是从哪到哪，到
<a href="http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters">http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters</a>
这里看，基本就是0000～FFFF这一区。 从MYSQL5.5开始，可支持4个字节UTF编码utf8mb4，一个字符最多能有4字节，所以能支持更多的字符集。</p>

<p>utf8mb4兼容utf8，且比utf8能表示更多的字符。</p>

<p>在做移动应用时，会遇到ios用户会在文本的区域输入emoji表情，emoji就是表情符号，在手机短信里面已经是很流行使用的一种表情。</p>

<p>因为utf8mb4是utf8的超集，理论上即使client修改字符集为utf8mb4，也会不会对已有的utf8编码读取产生任何问题。</p>

<h1>1.问题</h1>

<pre><code>1.MySQL在处理utf8mb4数据时,要比utf8慢;
2.存储字符数量,utf8mb4要比utf8少;
3.TIMESTAMP NOT NULL DEFAULT 类型的字段，当我们在程序中传入NULL时，Mysql 5.5会自动填充默认值，而5.6不会自动填充，这就违反了非空约束，会报错;
4.在mysql 5.6版本, utf8的表和utf8mb4的表join查询会导致索引失效;
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/04/03/mysqljia-gou/">Mysql架构</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-03T04:07:44+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2015</span></span> <span class='time'>4:07 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>这里想总结一下使用Mysql的一些架构，注意不是Mysql源码的架构。</p>

<h1>1.单点</h1>

<p>数据量不大，业务简单的情况下，直接单点的mysql instance足够。</p>

<p><img src="/images/mysql/one_instance.PNG"></p>

<h3>1.1 优点</h3>

<pre><code>1.简单，不存在数据一致性等问题;
</code></pre>

<h3>1.2 缺点瓶颈</h3>

<pre><code>1.单机存储数据量有限;
2.数据索引单机内存可能放不下,导致和只能加载部分索引，印象性能;
3.单机访问速度有极限;
4.读写混合，不正当的写操作导致的锁表等问题，可能导致读操作也失败，进而拖死整个系统;
5.无法容灾;
</code></pre>

<p>很多业务场景简单的，单表可以一般足够，比如对于用户信息这类表 （3个索引），16G内存能放下大概2000W行数据的索引，简单的读和写混合访问量3000/s左右没有问题。</p>

<h1>2.垂直拆分</h1>

<p>当单表遇到瓶颈的时候，最简单的想法是垂直拆分，从业务角度来看，将关联性不强的数据拆分到不同的instance上，从而达到消除瓶颈的目标。</p>

<p>另外，绝大部分的业务常见读写复合2-8原则，即80%的数据库操作会是读操作，因此对于重复读类型比较多的场景，我们还可以加一层cache，来减少对DB的压力。</p>

<p><img src="/images/mysql/v_multi_instance.PNG"></p>

<h3>2.1 优点</h3>

<pre><code>1.业务隔离，互不影响;
</code></pre>

<h3>2.2 缺点瓶颈</h3>

<pre><code>1.读写混合的问题依然存在;
</code></pre>

<h1>3.Master-Slave</h1>

<p>基于业务的读写2-8原则，我们将读写分离，即读和写打到不同的数据库服务器，通常读服务器会有多台，这即典型的Master-Slave结构，主库(Master)抗写压力，通过从库(Slave)来分担读压力。MS结构非常适合读多写少的应用场景，比如博客类网站等。</p>

<p><img src="/images/mysql/master_slave.PNG"></p>

<p>Slave通过binlog来同步Master的数据变更：
<img src="/images/mysql/master-salve.jpg"></p>

<p>主从机器的硬件配置和MySQL版本、各种参数配置最好都要一样，这样才能保证出问题时应用程 序能够平滑地从主库切换到备库上。</p>

<h3>3.1 优点</h3>

<pre><code>1.读写分离，减少相互影响;
2.实时备份;
</code></pre>

<h3>3.2 缺点瓶颈</h3>

<pre><code>1.数据一致性难以保障;
2.主从切换麻烦，而且切换所带来的麻烦会随着备库的增多而逐步上升;
</code></pre>

<h1>4.Proxy</h1>

<p>在Application和DB中间加以层Proxy，Proxy来解析sql协议，按sharding key 来寻找cluster, 判断是读操作还是写操作来请求主服务器或者从服务器，这一切内部的细节都由proxy来屏蔽。</p>

<p>Proxy做的工作包括：</p>

<pre><code>1.SQL解析
2.SQL改写
3.查询Dispatch
4.读写分离、主从切换逻辑
5.缓冲区控制
6.归并+排序
</code></pre>

<h1>5.Heartbeat+DRBD</h1>

<h3>5.1 Heartbeat介绍</h3>

<p>heartbeat可以资源(VIP地址及程序服务)从一台有故障的服务器快速的转移到另一台正常的服务器提供服务，heartbeat和keepalived相似，heartbeat可以实现failover功能，但不能实现对后端的健康检查。</p>

<p><a href="http://linux-ha.org/wiki/Main_Page">http://linux-ha.org/wiki/Main_Page</a></p>

<h3>5.2 DRBD介绍</h3>

<p>DRBD(Distributed Replicated Block Device)是一个基于块设备级别在远程服务器直接同步和镜像数据的软件，用软件实现的、无共享的、服务器之间镜像块设备内容的存储复制解决方案。</p>

<p>它可以实现在网络中两台服务器之间基于块设备级别的实时镜像或同步复制(两台服务器都写入成功)/异步复制(本地服务器写入成功)，相当于网络的RAID1，由于是基于块设备(磁盘，LVM逻辑卷)，在文件系统的底层，所以数据复制要比cp命令更快。DRBD已经被MySQL官方写入文档手册作为推荐的高可用的方案之一。</p>

<p>官方站点：<a href="http://www.drbd.org/">http://www.drbd.org/</a></p>

<h3>5.3 Heartbeat+DRBD</h3>

<p>适用于数据库访问量不太大，短期内访问量增长不会太快，对数据库可用性要求非常高的场景。</p>

<h1>6.MMM</h1>

<p>主从切换是Master-Slave结构的一个硬伤，如果备库只是用来实时备份数据和承担小部分读压力，那么MM结构将会是取代MS结构的不二之选。MM(Master-Master)就是主主结构,任意一个时刻，只有一个实际意义上的Master，另外一个作为Slave，只有当前的Master出现故障或者问题的使用，两台Master的角色切换，即原始的Master变为Slave，而原始的Slave切换为Master。</p>

<p>MMM(Master-Master replication manager for MySQ)是一套支持双主故障切换和双主日常管理的脚本程序。MMM使用Perl语言开发，主要用来监控和管理MySQL Master-Master复制。</p>

<p>MMM项目来自 Google：<a href="http://code.google.com/p/mysql-master-master">http://code.google.com/p/mysql-master-master</a></p>

<p>官方网站为：<a href="http://mysql-mmm.org">http://mysql-mmm.org</a></p>

<p>虽然叫做双主复制，但是业务上同一时刻只允许对一个主进行写入，另一台备选主上提供部分读服务，以加速在主主切换时刻备选主的预热，可以说MMM这套脚本程序一方面实现了故障切换的功能，另一方面其内部附加的工具脚本也可以实现多个slave的read负载均衡。</p>

<h3>6.1 MMM两种典型的使用</h3>

<p>典型的MM结构，即只有两台数据库Master服务器：
<img src="/images/mysql/MMM-usage1.png"></p>

<p>MM+Slaves结构，即两台数据库Master服务器加多台Slave服务器：
<img src="/images/mysql/MMM-usage2.png"></p>

<h3>6.2 Master切换的原理</h3>

<p>MMM主要的功能通过下面三个脚本来实现：</p>

<pre><code>mmm_mond： 负责所有的监控工作的监控守护进程，决定节点的活动;
mmm_agentd：运行在mysql服务器上的代理守护进程，通过远程服务提供给监控节点;
mmm_control：通过命令行管理mmm_mond进程;
</code></pre>

<p>mysql-mmm的监管端会提供多个虚拟IP(VIP)，包括一个可写VIP，多个可读VIP，通过监管端每十秒种(默认间隔)轮询一次MySQL节点来检查其状态，仅其中的一台服务器接收到写入器角色(写的VIP，Master的某一个)，其他的可以拥有阅读器角色(读VIP，包括一个备份的Master),当写库不可用(比如宕机等)，MMM会自动将写VIP给另外一台Master。</p>

<p>Mysql需要创建一个mmm_monitor和多个mmm_agent账户并授权。</p>

<h3>6.3 优点</h3>

<pre><code>1.克服了MS结构主从切换困难的问题;
2.是一种HA(高可用)架构(Easy Failover)
</code></pre>

<h3>6.4 缺点瓶颈</h3>

<pre><code>1.MMM不适用于对数据一致性要求很高的环境,某种情况下存在双写的问题
</code></pre>

<p>其他问题参考：</p>

<pre><code>1.[What's wrong with MMM?](http://www.xaprb.com/blog/2011/05/04/whats-wrong-with-mmm/)
2.[Problems with MMM for MySQL](http://code.openark.org/blog/mysql/problems-with-mmm-for-mysql)
</code></pre>

<p>最近我们系统遇到过一次MMM导致的问题：</p>

<pre><code>1.在当前的主Master(称之为Master-A)上有读写请求，从T1时刻开始，由于大量的慢查询，且这台机器善有多个Mysql Instance，导致在业务高峰期，当前的主Master对Monitor(Master-A)没有响应，因此Monitor认为这个Master(Master-A)宕机了，因此在T2时刻将读和写的VIP都漂移到另外一台备份Master(Master-B)上，这种情况下，Master-A和Master-B之间的双写复制中断，但是实际上Master-A上的写操作还在进行，即在T2之后的一段时间内，Master-A和Master-B上都存在写操作，并且不存在双写复制，当Master-A机器恢复，读VIP漂移到Master-A上，开始执行双写复制，发现存在冲突，因此双写导致数据存在冲突(比如自增ID)。
</code></pre>

<h1>7.PXC</h1>

<h3>7.1 优点</h3>

<h3>7.2 缺点瓶颈</h3>

<p><a href="http://www.infoq.com/cn/news/2013/03/MySQL-Reference-Architectures">http://www.infoq.com/cn/news/2013/03/MySQL-Reference-Architectures</a>
<a href="http://www.admin10000.com/document/4539.html">http://www.admin10000.com/document/4539.html</a>
<a href="http://www.open-open.com/lib/view/open1341302877043.html">http://www.open-open.com/lib/view/open1341302877043.html</a>
<a href="http://mysql-mmm.org/mysql-mmm.html">http://mysql-mmm.org/mysql-mmm.html</a>
<a href="http://www.cnblogs.com/gomysql/p/3671896.html">http://www.cnblogs.com/gomysql/p/3671896.html</a>
<a href="http://www.luocs.com/archives/849.http">http://www.luocs.com/archives/849.http</a>
html://wiki.corp.qunar.com/download/attachments/63242976/%E5%91%A8%E5%BD%A6%E4%BC%9F%E3%80%8AMySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98%E4%B9%8B%E8%B7%AF_%E4%BB%8EMMM%E5%88%B0PXC%E3%80%8B.pdf?version=1&amp;modificationDate=1418272276416</p>

<p><a href="http://www.cnblogs.com/bamboos/p/3543309.html">http://www.cnblogs.com/bamboos/p/3543309.html</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/04/02/xu-ni-iphe-ippiao-yi/">虚拟IP和IP漂移</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-02T22:39:14+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>2</span><span class='date-suffix'>nd</span>, <span class='date-year'>2015</span></span> <span class='time'>10:39 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>学习一下虚拟IP和IP漂移的概念。</p>

<h1>1.虚拟IP</h1>

<p>在 TCP/IP 的架构下，所有想上网的电脑，不论是用何种方式连上网路，都必须要有一个唯一的 IP-address。事实上IP地址是主机硬件地址的一种抽象，简单的说，MAC地址是物理地址，IP地址是逻辑地址。</p>

<p>虚拟IP，就是一个未分配给真实主机的IP，也就是说对外提供服务器的主机除了有一个真实IP外还有一个虚IP，使用这两个IP中的任意一个都可以连接到这台主机。</p>

<p>虚拟IP一般用作达到HA(High Availability)的目的,比如让所有项目中数据库链接一项配置的都是这个虚IP，当主服务器发生故障无法对外提供服务时，动态将这个虚IP切换到备用服务器。</p>

<h1>2.虚拟IP原理</h1>

<p>ARP是地址解析协议，它的作用很简单，将一个IP地址转换为MAC地址，然后给传输层使用。</p>

<p>每台主机中都有一个ARP高速缓存，存储同一个网络内的IP地址与MAC地址的对应关 系，以太网中的主机发送数据时会先从这个缓存中查询目标IP对应的MAC地址，会向这个MAC地址发送数据。操作系统会自动维护这个缓存。</p>

<p>在Linux下可以使用arp命令操作ARP高速缓存。</p>

<p>比如存在物理机A(IP是192.168.192.54 )和物理机器B(IP是192.168.192.40)，A作为对外服务的主服务器(比如数据库主库)，B作为备份机器，两台服务器之间的通信是通过Heartbeat，即主服务器会定时的给备份服务器发送数据包，告知主服务器服务正常，当备份服务器在规定时间内没有收到主服务器的Heartbeat，就会认为主服务器宕机，则备份服务器就会升级为主服务器。假设物理机A的ARP缓存如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>地址                     类型    硬件地址            标志  Mask            接口
</span><span class='line'>192.168.192.54           ether   ec:f4:bb:49:xx:xx   C                     eth0
</span><span class='line'>192.168.192.237          ether   ec:f4:bb:49:xx:xx   C                     eth0
</span><span class='line'>192.168.192.40           ether   28:e3:47:c0:xx:xx   C                     eth0
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>另外物理机器B(IP是192.168.192.40)的ARP缓存如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>地址                     类型    硬件地址            标志  Mask            接口
</span><span class='line'>192.168.192.54           ether   ec:f4:bb:49:xx:xx   C                     eth0
</span><span class='line'>192.168.192.237          ether   ec:f4:bb:49:xx:xx   C                     eth0
</span><span class='line'>192.168.192.40           ether   ec:f4:bb:49:xx:xx   C                     eth0
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>当机器B通过BeatHeart得知机器A对外服务质量低于预期的时候(比如发生故障，服务无响应)，会将自己的ARP缓存发送出去，让路由器修改路由表，告知虚拟地址应该指向我(物理机器B,192.168.192.40),这时候，外界再次访问虚拟IP的时候，机器B会变成主服务器，而A降级为备份服务器。这就完成了主从机器的自动切换，这一切对外界是透明的。</p>

<h1>3.IP漂移</h1>

<p>上面的VIP自动切换的过程就称之为IP漂移。</p>

<p>我们可以通过Keepalived来实现这个过程。 Keepalived是一个基于VRRP协议(Virtual Router Redundancy Protocol,即虚拟路由冗余协议)来实现的LVS(负载均衡器)服务高可用方案，可以利用其来避免单点故障。一个LVS服务会有2台服务器运行Keepalived，一台为主服务器（MASTER），一台为备份服务器（BACKUP），但是对外表现为一个虚拟IP，主服务器会发送特定的消息给备份服务器，当备份服务器收不到这个消息的时候，即主服务器宕机的时候， 备份服务器就会接管虚拟IP，继续提供服务，从而保证了高可用性。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/04/02/dubbo-thread-pool-exhausted/">Dubbo Thread Pool Exhausted</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-02T20:13:22+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>2</span><span class='date-suffix'>nd</span>, <span class='date-year'>2015</span></span> <span class='time'>8:13 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>今天出现一次dubbo的Thread pool exhausted导致服务不可用。根本原因是Mysql的慢查询。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Caused by: java.util.concurrent.RejectedExecutionException: Thread pool is EXHAUSTED! Thread Name...</span></code></pre></td></tr></table></div></figure>


<p>RejectedExecutionException表示线程池已经达到最大值，并且没有空闲连，拒绝执行了一些任务。
Thread pool exhausted通常是min和max不一样大时，表示当前已创建的连接用完，进行了一次扩充，创建了新线程，但不影响运行。</p>

<p>原因可能是连接池不够用，可以在provider的配置文件中设置threads参数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;dubbo:provider port="20920" timeout="20000" threads="200"/&gt;</span></code></pre></td></tr></table></div></figure>


<p>如果线程池已经有200，还不够，通常是业务处理占用线程时间过长，
需优化业务，可通过jstack查看进程的状态，分析当前大多数线程都在干什么，从而分析出哪个地方是瓶颈，
比如，如果大部分线程都在处理SQL，可能是数据库连接不够，或数据源配置错误，或SQL没走索引等。</p>

<p>参考：
<a href="http://alibaba.github.io/dubbo-doc-static/FAQ-focusedCommentId=9633823.htm#FAQ-9.%E5%87%BA%E7%8E%B0java.util.concurrent.RejectedExecutionException%E6%88%96%E8%80%85Threadpoolexhausted%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F">http://alibaba.github.io/dubbo-doc-static/FAQ-focusedCommentId=9633823.htm#FAQ-9.%E5%87%BA%E7%8E%B0java.util.concurrent.RejectedExecutionException%E6%88%96%E8%80%85Threadpoolexhausted%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/04/01/enumfan-xu-lie-hua-wen-ti/">Enum反序列化问题</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-01T23:01:25+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2015</span></span> <span class='time'>11:01 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>1.Enum原理</h1>

<p>定义一个Enum，通过编译之后的字节码，我们可以发现其实现原理：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public enum FruitEnum {  
</span><span class='line'>    APPLE, ORAGE  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>编译器是在为我们创建一个类，这个类继承自 java.lang.Enum，有两个公共的、静态的、被声明成final的属性，它们的类型就是我们定义的FruitEnum。</p>

<p>编译器还生成了一个静态初始话器，就是字节码中static{};这一行下面的代码，其中的字节码创建了两个FruitEnum对象，同时分别赋值给APPLE和ORANGE这两个属性，调用的构造函数是定义在java.lang.Enum中的protected Enum(String name, int ordinal)方法。</p>

<p>在创建完成两个FruitEnum对象并且分别赋值给APPLE和ORIGIN之后，还创建了一个名叫ENUM$VALUES的数组，然后把APPLE和ORIGIN按照定义的顺序放如这个数组中。</p>

<p>除了这个静态初始化器之外，编译器还为我们生成了两个静态方法，values()和 valueOf(java.lang.String)方法。其中values()方法将ENUM$VALUES数组拷贝一份然后返回，而valueOf(java.lang.String)方法则会调用java.lang.Enum类中的valueOf方法，其作用是根据参数名找到对应的具体的枚举对象，如果找不到的话会抛出一个IllegalArgumentException异常。</p>

<h1>2.Enum序列化反序列化原理及问题</h1>

<h3>2.1原理</h3>

<p>序列化的时候Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过java.lang.Enum的valueOf方法来根据名字查找枚举对象。</p>

<p>同时，编译器是不允许任何对这种序列化机制的定制的，因此禁用了writeObject、readObject、readObjectNoData、writeReplace和readResolve等方法。</p>

<h3>2.2问题</h3>

<p>在系统或者类库升级时，对其中定义的枚举类型多加注意，为了保持代码上的兼容性，如果我们定义的枚举类型有可能会被序列化保存(放到文件中、保存到数据库中，进入分布式内存缓存中)，那么我们是不能够删除原来枚举类型中定义的任何枚举对象的，否则程序在运行过程中，JVM就会抱怨找不到与某个名字对应的枚举对象了。</p>

<p>另外，在远程方法调用过程中，如果我们发布的客户端接口返回值中使用了枚举类型，那么服务端在升级过程中就需要特别注意。如果在接口的返回结果的枚举类型中添加了新的枚举值，那就会导致仍然在使用老的客户端的那些应用出现调用失败的情况。</p>

<h1>3.Enum序列化反序列化问题解决</h1>

<p>使用class代替Enum,原来的枚举使用static对象替换，valueOf()方法使用一个Map实现，示例代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public final class FruitEnum implements Serializable {
</span><span class='line'>
</span><span class='line'>    private static final long serialVersionUID = -7230925342774763449L;
</span><span class='line'>
</span><span class='line'>    private static final Map&lt;Integer, FruitEnum&gt; MAP = new HashMap&lt;Integer, FruitEnum&gt;();
</span><span class='line'>
</span><span class='line'>    public static final FruitEnum APPLE = new FruitEnum("Apple", 0);
</span><span class='line'>    public static final FruitEnum ORAGE = new FruitEnum("Orige", 1);
</span><span class='line'>
</span><span class='line'>    private String text;
</span><span class='line'>    private int code;
</span><span class='line'>
</span><span class='line'>    private FruitEnum(String text, int code) {
</span><span class='line'>        this.text = text;
</span><span class='line'>        this.code = code;
</span><span class='line'>
</span><span class='line'>        MAP.put(code, this);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public String getText() {
</span><span class='line'>        return text;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public void setText(String text) {
</span><span class='line'>        this.text = text;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    public int getCode() {
</span><span class='line'>        return code;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 根据code获取FruitEnum
</span><span class='line'>     *
</span><span class='line'>     * @param code
</span><span class='line'>     * @return
</span><span class='line'>     */
</span><span class='line'>    public static FruitEnum valueOf(int code) {
</span><span class='line'>        return MAP.get(code);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>参考：<a href="http://mysun.iteye.com/blog/1581119">http://mysun.iteye.com/blog/1581119</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/03/18/tomcatjia-gou/">Tomcat架构</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-03-18T19:03:09+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>18</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>7:03 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>主要整理Tomcat的整体架构.分析各个主要模块的功能.</p>

<h1>1.整体结构</h1>

<p>Tomcat基本结构图如下所示:</p>

<p><img src="/images/tomcat/struct.gif"></p>

<p>简单介绍:</p>

<pre><code>1.一个serve包括多个service;
2.一个service包含两个核心部件:一个容器(Container)和多个连接器(Connector),Connector主要负责对外交流,Container主要处理Connector接受的请求,主要是处理内部事务;
3.Tomcat基于JMX(Java Management Extensions,即Java管理扩展,是一个为应用程序、设备、系统等植入管理功能的框架)管理这些组件,另外实现以上接口的组件也实现了代表生存期的接口Lifecycle,使其组件履行固定的生存期,在其整个生存期的过程中通过事件侦听LifecycleEvent实现扩展;
</code></pre>

<h1>2.核心部件</h1>

<p>Tomcat的核心类图如下所示：</p>

<p><img src="/images/tomcat/classes.jpg"></p>

<p>其中Container是一个接口,定义一些容器的行为, 比如addChild(),getPipeline()等.每个Container都有一个Pipeline,其中包含一系列的表示请求处理器的Valve,注意Pipeline不是通过server.xml配置产生的,是必须有的,在pipeline上配置不同的valve,当需要调用此容器实现逻辑时,就会按照顺序将此pipeline上的所有valve调用一遍,类似于责任链模式.Engine,Host,Context和Wrapper都是实现了Container这个接口.Container还包含用来处理安全里授权与认证Realm等组件.</p>

<p>Tomcat(Container)的容器分成4个等级,如下：</p>

<p><img src="/images/tomcat/tomcat_containner.jpg"></p>

<p>假设访问的URL是
<a href="http://www.mydomain.com/app/index.html">http://www.mydomain.com/app/index.html</a>
各个容器处理的详细情况如图所示:</p>

<p><img src="/images/tomcat/tomcat_path.jpg"></p>

<p>Wrapper封装了具体的访问资源,例如 index.html
Context 封装了各个wrapper资源的集合,例如 app
Host 封装了各个context资源的集合,例如 www.mydomain.com</p>

<p>下面简单介绍一下各个类:</p>

<h3>2.1 Bootstrap</h3>

<p>Bootstrap简单说就是Tomcat的启动类,它只负责创建Catalina实例并将输入参数传递给Catalina实例;</p>

<h3>2.2 Catalina</h3>

<p>Catalina是Tomcat实际的入口,执行Tomcat的初始化,启动,停止等关键逻辑;
(1).初始化的逻辑中初始化一个解析配置文件的Digester,这个Digester使用SAX方式解析xml文件,它获取解析conf目录下的server.xml这个配置文件并会生成Server等实例;并执行Server的初始化;Server会顺序往后执行Service,Connector,Containner等的初始化.
(2).启动逻辑就是调用Server的启动;
(3).停止逻辑就是调用Server的停止;</p>

<h3>2.3 Server</h3>

<p>Server(参考StandardServer类)是整个Tomcat组件的容器,包含一个或多个Service.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void addService(Service service);</span></code></pre></td></tr></table></div></figure>


<h3>2.4 Service</h3>

<p>Service(参考StandardService类)是包含Connector和Container的集合,Service用适当的Connector接收用户的请求,再发给相应的Container来处理.</p>

<h3>2.5 Connector</h3>

<p>Connector是网络socket相关接口模块,默认实现HTTP、AJP等协议的.connector主要作用包括:</p>

<pre><code>(1).接收socket
(2).从socket获取数据包,并解析成HttpServletRequest对象
(3).从engine容器开始走调用流程,经过各层valve,最后调用servlet完成业务逻辑
(4).返回response,关闭socket
</code></pre>

<p>connector配置举例为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;Connector port="80" URIEncoding="UTF-8" protocol="HTTP/1.1"
</span><span class='line'>               connectionTimeout="20000"
</span><span class='line'>               redirectPort="7443" /&gt;</span></code></pre></td></tr></table></div></figure>


<p>其中protocol的选择包括
    (1).BIO实现:
    org.apache.coyote.http11.Http11Protocol
    (2).NIO实现
    org.apache.coyote.http11.Http11NioProtocol</p>

<p>以Http11Protocol举例解析connector结构:</p>

<p><img src="/images/tomcat/connector.jpg"></p>

<p>Http11ConnectionHandler对象维护了一个Http11Processor对象池, 完成http request的解析和分派.</p>

<p>JIoEndpoint维护了两个线程池,Acceptor及Worker
Acceptor是接收socket,然后从Worker线程池中找出空闲的线程处理socket,如果worker线程池没有空闲线程,则Acceptor将阻塞;Worker是典型的线程池实现.Worker线程拿到socket后,就从Http11Processor对象池中获取Http11Processor对象;</p>

<p>Mapper维护了一个从Host到Wrapper的各级容器的快照.它主要是为了,当http request被解析后,能够将http request绑定到相应的servlet进行业务处理.</p>

<p>CoyoteAdapter将http request解析成HttpServletRequest对象,之后绑定相应的容器,然后从engine开始逐层调用.</p>

<h3>2.6 Engine</h3>

<p>Engine(参考StandardEngine类)</p>

<h3>2.7 Host</h3>

<p>Host(参考StandardHost类)就是我们所理解的虚拟主机.</p>

<h3>2.8 Context</h3>

<p>Context(参考StandardContext类)就是我们所部属的具体Web应用的上下文,每个请求都在是相应的上下文里处理的.</p>

<h3>2.9 Wrapper</h3>

<p>Wrapper(参考StandardWrapper类)Wrapper是针对每个Servlet的Container,每个Servlet都有相应的Wrapper来管理.</p>

<p>它封装的处理资源的每个具体的servlet,除了上面提到的Pipeline和Valve之外,还包含我们熟悉的servlet对象.</p>

<p>wrapper主要包括三大类</p>

<pre><code>(1).处理静态资源的一个wrapper：例如html, jpg.对应wrapper为org.apache.catalina.servlets.DefaultServlet
(2).处理jsp文件,对应wrapper为org.apache.jasper.servlet.JspServlet
(3).自定义的servlet对象. 在web.xml中定义的serlvet
</code></pre>

<h3>2.10 Pipeline和Valve</h3>

<p>Pipeline(参考StandardPipeline类),Pipeline就是一串Valve.请求到达当前容器,则从前往后执行每个Valve的逻辑.</p>

<p>Valve实现具体业务逻辑单元.可以定制化valve（实现特定接口）,然后配置在server.xml里.对其包含的所有host里的应用有效.定制化的valve是可选的,但是每个容器有一个缺省的valve,例如engine的StandardEngineValve,是在StandardEngine里自带的,它主要实现了对其子host对象的StandardHostValve的调用,以此类推.</p>

<p>缺省的valve的Valve实在Pipeline的最后面.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/03/14/mysqlyou-hua/">Mysql优化</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-03-14T05:02:34+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>14</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>5:02 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近项目组遇到的慢查询比较多，大家的慢查询意识逐渐有了，同事做的工作中使用到的优化慢查询的方法分享，这里简单总结一些，便于以后使用。</p>

<p>通常这些优化方式是组合使用的。</p>

<h1>1.合理使用索引</h1>

<h3>1.1 一个表只会使用一个索引</h3>

<p>假设customer表有两个索引：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  KEY `idx_create_time` (`create_time`) USING BTREE,
</span><span class='line'>  KEY `idx_city` (`city`)</span></code></pre></td></tr></table></div></figure>


<p>sql语句的where条件包含create_time和city</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>explain select * from customer where city = 'beijing' and create_time &gt; '2015-01-01';</span></code></pre></td></tr></table></div></figure>


<p>这个sql语句只会走一个索引。</p>

<h3>1.2 索引区分度越大越好</h3>

<p>索引的区分读越大越好，可以使用show index from table看表的索引情况。</p>

<h3>1.3 行数越少越好</h3>

<p>执行计划中sql搜索的行数(rows)越小越好。</p>

<h3>1.4 查询条件字段不要套函数，无法使用索引</h3>

<p>比如下面这个sql是不走索引的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>explain select * from customer where left(city, 2) = 'be';</span></code></pre></td></tr></table></div></figure>


<h1>2.不要复合条件查询</h1>

<p>将复合条件根据规则转换为单个条件，避免多个字段去or。</p>

<p>比如我们在city上面建立了索引，但是我们没有在name上建立索引，下面这个sql会走全表而不走索引</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>explain select * from customer where city = 'beijing' or name = 'beijing';</span></code></pre></td></tr></table></div></figure>


<h1>3.减少join</h1>

<p>利用Mybatis的动态SQL，保证同一时刻JOIN的表最少。即满足某一个条件的时候才join。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>select * from customer
</span><span class='line'>&lt;if test="conditions.name != null and conditions.name != ''"&gt;
</span><span class='line'>    join user on user.id = customer.user_id
</span><span class='line'>&lt;/if&gt;</span></code></pre></td></tr></table></div></figure>


<h1>4.分步查询</h1>

<p>比如一个sql需要大量的join，并且每个join表的数据量都很大，这时候，尝试将单独的sql拆分成多个sql。</p>

<p>我们可以从搜索条件入手，不包含搜索条件的表一定可以拆分成单独的sql。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>select *
</span><span class='line'>from A
</span><span class='line'>join B on ...
</span><span class='line'>join C on ...
</span><span class='line'>join D on ...
</span><span class='line'>join E on ...
</span><span class='line'>where
</span><span class='line'>A.name = ...
</span><span class='line'>and B.city = ...</span></code></pre></td></tr></table></div></figure>


<p>这是可以考虑对C，D，E表的查询单独拆分出来。</p>

<h1>5.合理使用Cache</h1>

<p>通常根据条件Count比较耗时，可以将Count数Cache，比如list接口的count通常成千上万，count数只是用来展示页数，这时候可以考虑缓存下来，但是需要考虑好缓存策略。</p>

<h1>6.业务逻辑上优化</h1>

<p>当我们使用上述步骤无法优化时，可以考虑从逻辑上优化。</p>

<p>比如join很多个表查询的时候，我们需要确认应用方所有的字段都需要，通常减少字段能让我们少join表。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/03/13/tomcatjian-jie/">Tomcat简介</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-03-13T04:34:51+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>13</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>4:34 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近会重新看一下Tomcat的源代码，整理一些东西，包括但不限于：</p>

<pre><code>1.Tomcat架构
2.Tomcat启动过程
3.请求在Tomcat中的流转
4.Tomcat目录结构与配置
</code></pre>

<p>这里会首先简单介绍一些Tomcat的知识。后面会逐渐详细介绍。</p>

<p>Tomcat是由Apache软件基金会下属的Jakarta项目开发的一个Servlet容器，按照Sun Microsystems提供的技术规范，实现了对Servlet和JavaServer Page(JSP)的支持，并提供了作为Web服务器的一些特有功能,如Tomcat管理和控制平台、安全域管理和Tomcat阀等。由于Tomcat本身也内含了一个HTTP服务器，它也可以被视作一个单独的Web服务器。</p>

<p>由于有了Sun的参与和支持，最新的Servlet和Jsp规范总能在Tomcat中得到体现。而进来因为Tomcat 技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。</p>

<p>官方网站：<a href="http://tomcat.apache.org/">http://tomcat.apache.org/</a></p>

<p>Tomcat wiki：<a href="http://wiki.apache.org/tomcat/FrontPage">http://wiki.apache.org/tomcat/FrontPage</a></p>

<h1>1.JSP和Servlet</h1>

<p>Jsp（JavaServer Page）是在普通Html中嵌入了Java代码的一个脚本，在这一点上，它与其它的脚本语言（如Php）一样，但它与其它语言不同的是：其它脚本语言由服务器直接解释这个脚本，而Jsp则由Jsp容器（如Tomcat）首先将其转化为Servlet，然后再调用Javac将Servlet编译为Class文件。</p>

<p>Servlet其实是一个特殊的Java类，Servlet类一般从HttpServlet类继承而来，在这个类中至少要实现doGet或者doPost函数，在这两个函数中处理来自客户的请求，然后将结果返回。</p>

<h1>2.Servlet容器</h1>

<p>负责处理客户请求、把请求传送给Servlet并把结果返回给客户。不同程序的容器实际实现可能有所变化，但容器与Servlet之间的接口是由Servlet API定义好的，这个接口定义了Servlet容器在Servlet上要调用的方法及传递给Servlet的对象类。</p>

<h1>3.Servlet生命周期</h1>

<pre><code>1.Servlet容器创建Servlet的一个实例
2.容器调用该实例的init()方法
3.如果容器对该Servlet有请求，则调用此实例的service()方法
4.容器在销毁本实例前调用它的destroy()方法
5.销毁并标记该实例以供作为垃圾收集
</code></pre>

<h1>4.Tomcat简介</h1>

<p>Tomcat中的Servlet容器称之为Catalina。</p>

<p>Tomcat中的应用程序是一个WAR（Web Archive）文件。WAR是Sun提出的一种Web应用程序格式，与JAR类似，也是许多文件的一个压缩包。这个包中的文件按一定目录结构来组织：通常其根目录下包含有Html和Jsp文件或者包含这两种文件的目录，另外还会有一个WEB-INF目录，这个目录很重要。通常在WEB-INF目录下有一个web.xml文件和一个classes目录，web.xml是这个应用的配置文件，而classes目录下则包含编译好的Servlet类和Jsp或Servlet所依赖的其它类（如JavaBean）。</p>

<p>在Tomcat中，应用程序的部署很简单，你只需将你的WAR放到Tomcat的webapp目录下，Tomcat会自动检测到这个文件，并将其解压。你在浏览器中访问这个应用的Jsp时，通常第一次会很慢，因为Tomcat要将Jsp转化为Servlet文件，然后编译。编译以后，访问将会很快。另外Tomcat也提供了一个应用：manager，访问这个应用需要用户名和密码，用户名和密码存储在一个xml文件中。通过这个应用，你可以在远程通过Web部署和撤销应用。</p>

<h1>5.Tomcat各个版本</h1>

<p><a href="http://wiki.apache.org/tomcat/TomcatVersions">http://wiki.apache.org/tomcat/TomcatVersions</a></p>

<h1>6.参考：</h1>

<p><a href="http://zh.wikipedia.org/wiki/Apache_Tomcat">http://zh.wikipedia.org/wiki/Apache_Tomcat</a></p>

<p><a href="http://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/">http://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/</a></p>

<p><a href="http://gearever.iteye.com/category/223001">http://gearever.iteye.com/category/223001</a></p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/4">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/2">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <div class="panel-heading">
    <h1 class="panel-title">最新文章</h3>
  </div>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/08/03/fan-she-de-xiao-lu/">反射的效率</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/03/fan-she-de-xiao-lu/">Fan She De Xiao Lu</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/01/mycli/">Mycli</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/17/fen-ci/">分词</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/16/cratefu-wu-loadbiao-gao/">Crate服务load飙高</a>
      </li>
    
  </ul>
</section>
<section class="panel panel-default">
  <div  class="panel-heading">
    <h1 class="panel-title">文章分类</h1>
  </div>
  <div id="categories_list_div" class="list-group">
    <li><a class='list-group-item' href='/blog/categories/algorithm/'>algorithm (4)</a></li>
<li><a class='list-group-item' href='/blog/categories/dubbo/'>dubbo (2)</a></li>
<li><a class='list-group-item' href='/blog/categories/guava/'>guava (2)</a></li>
<li><a class='list-group-item' href='/blog/categories/java/'>java (22)</a></li>
<li><a class='list-group-item' href='/blog/categories/linux/'>linux (11)</a></li>
<li><a class='list-group-item' href='/blog/categories/maven/'>maven (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/memcached/'>memcached (4)</a></li>
<li><a class='list-group-item' href='/blog/categories/mysql/'>mysql (9)</a></li>
<li><a class='list-group-item' href='/blog/categories/octopress/'>octopress (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/postgresql/'>postgresql (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/qa/'>qa (2)</a></li>
<li><a class='list-group-item' href='/blog/categories/reading/'>reading (7)</a></li>
<li><a class='list-group-item' href='/blog/categories/search/'>search (6)</a></li>
<li><a class='list-group-item' href='/blog/categories/spring/'>spring (3)</a></li>
<li><a class='list-group-item' href='/blog/categories/squid/'>squid (1)</a></li>
<li><a class='list-group-item' href='/blog/categories/structure/'>structure (3)</a></li>
<li><a class='list-group-item' href='/blog/categories/tomcat/'>tomcat (3)</a></li>
<li><a class='list-group-item' href='/blog/categories/tools/'>tools (8)</a></li>
<li><a class='list-group-item' href='/blog/categories/web/'>web (1)</a></li>
 
  </div>
</section>
<section class="panel panel-default">
  <div  class="panel-heading">
    <h1 class="panel-title">其他博客</h3>
  </div>
  <div id="categories_list_div" class="list-group">
    <a class='list-group-item' href='http://www.baidu.com/p/Nicker_2010'>百度空间</a>
  </div>
</section>

  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - xiaobaoqiu -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
